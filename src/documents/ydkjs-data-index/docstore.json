[["0",{"pageContent":"Up & Going \n\n\nKyle Simpson \n\n\nBeijing • Cambridge • Farnham • Koln • Sebastopol • Tokyo \n\n\nO'REILLY \n\n\n\n\n\nTable of Contents \n\n\nForeword. v \n\nPreface.vii \n\n1. Into Programming. 1 \n\nCode 2 \n\nExpressions 3 \n\nTry It Yourself 4 \n\nOperators 8 \n\nValues & Types 10 \n\nCode Comments 12 \n\nVariables 14 \n\nBlocks 17 \n\nConditionals 18 \n\nLoops 20 \n\nFunctions 22 \n\nPractice 26 \n\nReview 28 \n\n2. Into JavaScript. 29 \n\nValues & Types 30 \n\nVariables 40 \n\nConditionals 43 \n\nStrict Mode 45 \n\nFunctions as Values 47 \n\nthis Identifier 52 \n\nPrototypes 53 \n\n\niii \n\n\n\n\n\n\n\n\nOld & New \n\n55 \n\nNon-JavaScript \n\n58 \n\nReview \n\n59 \n\n3. IntoYDKJS. \n\n.61 \n\nScope & Closures \n\n61 \n\nthis & Object Prototypes \n\n62 \n\nTypes & Grammar \n\n63 \n\nAsync & Performance \n\n64 \n\nES6 & Beyond \n\n65 \n\nReview \n\n67 \n\n\niv | Table of Contents \n\n\n\n\nForeword \n\n\nWhat was the last new thing you learned?","metadata":{"loc":{"lines":{"from":1,"to":126}}}}],["1",{"pageContent":"this & Object Prototypes \n\n62 \n\nTypes & Grammar \n\n63 \n\nAsync & Performance \n\n64 \n\nES6 & Beyond \n\n65 \n\nReview \n\n67 \n\n\niv | Table of Contents \n\n\n\n\nForeword \n\n\nWhat was the last new thing you learned? \n\nPerhaps it was a foreign language, like Italian or German. Or maybe \nit was a graphics editor, like Photoshop. Or a cooking technique or \nwoodworking or an exercise routine. I want you to remember that \nfeeling when you finally got it: the lightbulb moment. When things \nwent from blurry to crystal clear, as you mastered the table saw or \nunderstood the difference between masculine and feminine nouns \nin French. How did it feel? Pretty amazing, right?","metadata":{"loc":{"lines":{"from":126,"to":163}}}}],["2",{"pageContent":"Now I want you to travel back a little bit further in your memory to \nright before you learned your new skill. How did that feel? Probably \nslightly intimidating and maybe a little bit frustrating, right? At one \npoint, we all did not know the things that we know now, and that’s \ntotally OK; we all start somewhere. Learning new material is an \nexciting adventure, especially if you are looking to learn the subject \nefficiently. \n\nI teach a lot of beginner coding classes. The students who take my \nclasses have often tried teaching themselves subjects like HTML or \nJavaScript by reading blog posts or copying and pasting code, but \nthey haven’t been able to truly master the material that will allow \nthem to code their desired outcome. And because they don’t truly \ngrasp the ins and outs of certain coding topics, they can’t write pow¬ \nerful code or debug their own work because they don’t really under¬ \nstand what is happening.","metadata":{"loc":{"lines":{"from":165,"to":180}}}}],["3",{"pageContent":"I always believe in teaching my classes the proper way, meaning I \nteach web standards, semantic markup, well-commented code, and \nother best practices. I cover the subject in a thorough manner to \nexplain the hows and whys, without just tossing out code to copy \n\n\n\n\nand paste. When you strive to comprehend your code, you create \nbetter work and become better at what you do. The code isn’t just \nyour job anymore, it’s your craft. This is why I love Up & Going. Kyle \ntakes us on a deep dive through syntax and terminology to give a \ngreat introduction to JavaScript without cutting corners. This book \ndoesn’t skim over the surface but really allows us to genuinely \nunderstand the concepts.","metadata":{"loc":{"lines":{"from":182,"to":196}}}}],["4",{"pageContent":"Because it’s not enough to be able to duplicate jQuery snippets into \nyour website, the same way it’s not enough to learn how to open, \nclose, and save a document in Photoshop. Sure, once I learned a few \nbasics about the program, I could create and share a design I made. \nBut without legitimately knowing the tools and what is behind \nthem, how can I define a grid, or craft a legible type system, or opti¬ \nmize graphics for web use. The same goes for JavaScript. Without \nknowing how loops work, or how to define variables, or what scope \nis, we won’t be writing the best code we can. We don’t want to settle \nfor anything less—this is, after all, our craft.","metadata":{"loc":{"lines":{"from":198,"to":207}}}}],["5",{"pageContent":"The more you are exposed to JavaScript, the clearer it becomes. \nWords like closures, objects, and methods might seem out of reach \nto you now, but this book will help those terms come into clarity. I \nwant you to keep those two feelings of before and after you learn \nsomething in mind as you begin this book. It might seem daunting, \nbut you’ve picked up this book because you are starting an awesome \njourney to hone your knowledge. Up & Going is the start of our path \nto understanding programming. Enjoy the lightbulb moments! \n\n—Jenn Lukas (http://jennlukas.com, @jennlukas), \n\nFrontend consultant \n\n\nvi | Foreword \n\n\n\nPreface \n\n\nI’m sure you noticed, but “JS” in the series title is not an abbrevia¬ \ntion for words used to curse about JavaScript, though cursing at the \nlanguage’s quirks is something we can probably all identify with!","metadata":{"loc":{"lines":{"from":209,"to":232}}}}],["6",{"pageContent":"From the earliest days of the Web, JavaScript has been a founda¬ \ntional technology that drives interactive experience around the con¬ \ntent we consume. While flickering mouse trails and annoying pop¬ \nup prompts may be where JavaScript started, nearly two decades \nlater, the technology and capability of JavaScript has grown many \norders of magnitude, and few doubt its importance at the heart of \nthe world’s most widely available software platform: the Web. \n\nBut as a language, it has perpetually been a target for a great deal of \ncriticism, owing partly to its heritage but even more to its design \nphilosophy. Even the name evokes, as Brendan Eich once put it, \n“dumb kid brother” status next to its more mature older brother, \nJava. But the name is merely an accident of politics and marketing. \nThe two languages are vastly different in many important ways. \n“JavaScript” is as related to “Java” as “Carnival” is to “Car.”","metadata":{"loc":{"lines":{"from":234,"to":248}}}}],["7",{"pageContent":"Because JavaScript borrows concepts and syntax idioms from sev¬ \neral languages, including proud C-style procedural roots as well as \nsubtle, less obvious Scheme/Lisp-style functional roots, it is exceed¬ \ningly approachable to a broad audience of developers, even those \nwith little to no programming experience. The “Hello World” of \nJavaScript is so simple that the language is inviting and easy to get \ncomfortable with in early exposure. \n\nWhile JavaScript is perhaps one of the easiest languages to get up \nand running with, its eccentricities make solid mastery of the lan¬ \nguage a vastly less common occurrence than in many other lan- \n\n\nVII \n\n\n\n\nguages. Where it takes a pretty in-depth knowledge of a language \nlike C or C++ to write a full-scale program, full-scale production \nJavaScript can, and often does, barely scratch the surface of what the \nlanguage can do.","metadata":{"loc":{"lines":{"from":250,"to":271}}}}],["8",{"pageContent":"Sophisticated concepts that are deeply rooted into the language tend \ninstead to surface themselves in seemingly simplistic ways, such as \npassing around functions as callbacks, which encourages the Java¬ \nScript developer to just use the language as is and not worry too \nmuch about what’s going on under the hood. \n\nIt is simultaneously a simple, easy-to-use language that has broad \nappeal, and a complex and nuanced collection of language mechan¬ \nics that without careful study will elude true understanding even for \nthe most seasoned of JavaScript developers. \n\nTherein lies the paradox of JavaScript, the Achilles’ heel of the lan¬ \nguage, the challenge we are presently addressing. Because JavaScript \ncan be used without understanding, the understanding of the lan¬ \nguage is often never attained. \n\nMission","metadata":{"loc":{"lines":{"from":273,"to":289}}}}],["9",{"pageContent":"Mission \n\nIf at every point that you encounter a surprise or frustration in Java¬ \nScript, your response is to add it to the blacklist (as some are accus¬ \ntomed to doing), you soon will be relegated to a hollow shell of the \nrichness of JavaScript. \n\nWhile this subset has been famously dubbed “The Good Parts,” I \nwould implore you, dear reader, to instead consider it the “The Easy \nParts,” “The Safe Parts,” or even “The Incomplete Parts.” \n\nThis You Don’t Know JS series offers a contrary challenge: learn and \ndeeply understand all of JavaScript, even and especially “The Tough \nParts.” \n\nHere, we address head-on the tendency of JS developers to learn just \nenough to get by, without ever forcing themselves to learn exactly \nhow and why the language behaves the way it does. Furthermore, we \neschew the common advice to retreat when the road gets rough. \n\n\nviii | Preface","metadata":{"loc":{"lines":{"from":289,"to":310}}}}],["10",{"pageContent":"viii | Preface \n\n\n\n\nI am not content, nor should you be, at stopping once something \njust works and not really knowing why. I gently challenge you to \njourney down that bumpy “road less traveled” and embrace all that \nJavaScript is and can do. With that knowledge, no technique, no \nframework, and no popular buzzword acronym of the week will be \nbeyond your understanding. \n\nThese books each take on specific core parts of the language that are \nmost commonly misunderstood or under-understood, and dive \ndeep and exhaustively into them. You should come away from read¬ \ning with a firm confidence in your understanding, not just of the \ntheoretical, but the practical “what you need to know” bits.","metadata":{"loc":{"lines":{"from":310,"to":326}}}}],["11",{"pageContent":"The JavaScript you know right now is probably parts handed down \nto you by others who’ve been burned by incomplete understanding. \n7 hat JavaScript is but a shadow of the true language. You don’t really \nknow JavaScript yet, but if you dig into this series, you will. Read on, \nmy friends. JavaScript awaits you. \n\nReview \n\nJavaScript is awesome. It’s easy to learn partially, and much harder to \nlearn completely (or even sufficiently). When developers encounter \nconfusion, they usually blame the language instead of their lack of \nunderstanding. These books aim to fix that, inspiring a strong \nappreciation for the language you can now, and should, deeply know. \n\n\n\nMany of the examples in this book assume \nmodern (and future-reaching) JavaScript engine \nenvironments, such as ES6. Some code may not \nwork as described if run in older (pre-ES6) \nengines. \n\n\nConventions Used in This Book \n\nThe following typographical conventions are used in this book: \n\nItalic","metadata":{"loc":{"lines":{"from":328,"to":355}}}}],["12",{"pageContent":"Conventions Used in This Book \n\nThe following typographical conventions are used in this book: \n\nItalic \n\nIndicates new terms, URLs, email addresses, filenames, and file \nextensions. \n\n\nPreface | ix \n\n\n\n\n\n\nConstant width \n\nUsed for program listings, as well as within paragraphs to refer \nto program elements such as variable or function names, data¬ \nbases, data types, environment variables, statements, and key¬ \nwords. \n\nConstant width bold \n\nShows commands or other text that should be typed literally by \nthe user. \n\n\nConstant width italic \n\nShows text that should be replaced with user-supplied values or \nby values determined by context. \n\n\n\nThis element signifies a tip or suggestion. \n\n\n\nThis element signifies a general note. \n\n\nThis element indicates a warning or caution. \n\n\nUsing Code Examples \n\nSupplemental material (code examples, exercises, etc.) is available \nfor download at http://bit.ly/ydkjs-up-going-code.","metadata":{"loc":{"lines":{"from":355,"to":405}}}}],["13",{"pageContent":"This element indicates a warning or caution. \n\n\nUsing Code Examples \n\nSupplemental material (code examples, exercises, etc.) is available \nfor download at http://bit.ly/ydkjs-up-going-code. \n\nThis book is here to help you get your job done. In general, if exam¬ \nple code is offered with this book, you may use it in your programs \nand documentation. You do not need to contact us for permission \nunless you’re reproducing a significant portion of the code. For \nexample, writing a program that uses several chunks of code from \nthis book does not require permission. Selling or distributing a CD- \nROM of examples from O’Reilly books does require permission. \nAnswering a question by citing this book and quoting example code \n\n\nx | Preface \n\n\n\n\n\n\n\n\ndoes not require permission. Incorporating a significant amount of \nexample code from this book into your product’s documentation \ndoes require permission.","metadata":{"loc":{"lines":{"from":405,"to":434}}}}],["14",{"pageContent":"x | Preface \n\n\n\n\n\n\n\n\ndoes not require permission. Incorporating a significant amount of \nexample code from this book into your product’s documentation \ndoes require permission. \n\nWe appreciate, but do not require, attribution. An attribution usu¬ \nally includes the title, author, publisher, and ISBN. For example: \n“You Don’t Know JavaScript: Up & Going by Kyle Simpson (O’Reilly). \nCopyright 2015 Getify Solutions, Inc., 978-1-491-92446-4.” \n\nIf you feel your use of code examples falls outside fair use or the per¬ \nmission given above, feel free to contact us at permis- \nsions@oreilly.com. \n\nSafari® Books Online \n\n\nill Safari \n\n\nSafari Books Online is an on-demand digital \nlibrary that delivers expert content in both \nbook and video form from the world’s lead¬ \ning authors in technology and business.","metadata":{"loc":{"lines":{"from":434,"to":465}}}}],["15",{"pageContent":"ill Safari \n\n\nSafari Books Online is an on-demand digital \nlibrary that delivers expert content in both \nbook and video form from the world’s lead¬ \ning authors in technology and business. \n\n\nTechnology professionals, software developers, web designers, and \nbusiness and creative professionals use Safari Books Online as their \nprimary resource for research, problem solving, learning, and certif¬ \nication training. \n\nSafari Books Online offers a range of plans and pricing for enter¬ \nprise, government, education, and individuals.","metadata":{"loc":{"lines":{"from":465,"to":480}}}}],["16",{"pageContent":"Safari Books Online offers a range of plans and pricing for enter¬ \nprise, government, education, and individuals. \n\nMembers have access to thousands of books, training videos, and \nprepublication manuscripts in one fully searchable database from \npublishers like O’Reilly Media, Prentice Hall Professional, Addison- \nWesley Professional, Microsoft Press, Sams, Que, Peachpit Press, \nFocal Press, Cisco Press, John Wiley & Sons, Syngress, Morgan \nKaufmann, IBM Redbooks, Packt, Adobe Press, FT Press, Apress, \nManning, New Riders, McGraw-Hill, Jones & Bartlett, Course Tech¬ \nnology, and hundreds more. For more information about Safari \nBooks Online, please visit us online. \n\n\nPreface | xi \n\n\n\nHow to Contact Us \n\nPlease address comments and questions concerning this book to the \npublisher: \n\nO’Reilly Media, Inc. \n\n1005 Gravenstein Highway North \nSebastopol, CA 95472 \n\n800-998-9938 (in the United States or Canada) \n\n707-829-0515 (international or local) \n\n707-829-0104 (fax)","metadata":{"loc":{"lines":{"from":480,"to":512}}}}],["17",{"pageContent":"O’Reilly Media, Inc. \n\n1005 Gravenstein Highway North \nSebastopol, CA 95472 \n\n800-998-9938 (in the United States or Canada) \n\n707-829-0515 (international or local) \n\n707-829-0104 (fax) \n\nWe have a web page for this book, where we list errata, examples, \nand any additional information. You can access this page at http:// \nbit.ly/ydkjs_up-and-going. \n\nTo comment or ask technical questions about this book, send email \nto bookquestions@oreilly.com. \n\nFor more information about our books, courses, conferences, and \nnews, see our website at http://www.oreilly.com. \n\nFind us on Facebook: http://facebook.com/oreilly \n\nFollow us on Twitter: http://twitter.com/oreillymedia \n\nWatch us on YouTube: http://www.youtube.com/oreillymedia \n\n\nxii | Preface \n\n\n\nCHAPTER 1 \n\n\nInto Programming \n\n\nWelcome to the You Don’t Know JS ( YDKJS ) series.","metadata":{"loc":{"lines":{"from":512,"to":550}}}}],["18",{"pageContent":"Watch us on YouTube: http://www.youtube.com/oreillymedia \n\n\nxii | Preface \n\n\n\nCHAPTER 1 \n\n\nInto Programming \n\n\nWelcome to the You Don’t Know JS ( YDKJS ) series. \n\nUp & Going is an introduction to several basic concepts of program¬ \nming—of course we lean toward JavaScript (often abbreviated JS) \nspecifically—and how to approach and understand the rest of the \ntitles in this series. Especially if you’re just getting into programming \nand/or JavaScript, this book will briefly explore what you need to get \nup and going. \n\nThis book starts off explaining the basic principles of programming \nat a very high level. It’s mostly intended if you are starting YDKJS \nwith little to no prior programming experience, and are looking to \nthese books to help get you started along a path to understanding \nprogramming through the lens of JavaScript.","metadata":{"loc":{"lines":{"from":550,"to":576}}}}],["19",{"pageContent":"Chapter 1 should be approached as a quick overview of the things \nyou’ll want to learn more about and practice to get into program¬ \nming. There are also many other fantastic programming introduc¬ \ntion resources that can help you dig into these topics further, and I \nencourage you to learn from them in addition to this chapter. \n\nOnce you feel comfortable with general programming basics, Chap¬ \nter 2 will help guide you to a familiarity with JavaScript’s flavor of \nprogramming. Chapter 2 introduces what JavaScript is about, but \nagain, it’s not a comprehensive guide—that’s what the rest of the \nYDKJS books are for! \n\n\n1 \n\n\n\n\n\nIf you’re already fairly comfortable with JavaScript, first check out \nChapter 3 as a brief glimpse of what to expect from YDKJS, then \njump right in! \n\nCode \n\nLet’s start from the beginning.","metadata":{"loc":{"lines":{"from":578,"to":603}}}}],["20",{"pageContent":"If you’re already fairly comfortable with JavaScript, first check out \nChapter 3 as a brief glimpse of what to expect from YDKJS, then \njump right in! \n\nCode \n\nLet’s start from the beginning. \n\nA program, often referred to as source code or just code, is a set of \nspecial instructions to tell the computer what tasks to perform. Usu¬ \nally code is saved in a text file, although with JavaScript you can also \ntype code directly into a developer console in a browser, which we’ll \ncover shortly. \n\nThe rules for valid format and combinations of instructions is called \na computer language, sometimes referred to as its syntax, much the \nsame as English tells you how to spell words and how to create valid \nsentences using words and punctuation. \n\nStatements \n\nIn a computer language, a group of words, numbers, and operators \nthat performs a specific task is a statement. In JavaScript, a statement \nmight look as follows: \n\na = b * 2;","metadata":{"loc":{"lines":{"from":603,"to":628}}}}],["21",{"pageContent":"Statements \n\nIn a computer language, a group of words, numbers, and operators \nthat performs a specific task is a statement. In JavaScript, a statement \nmight look as follows: \n\na = b * 2; \n\nThe characters a and b are called variables (see “Variables” on page \n14), which are like simple boxes you can store any of your stuff in. \nIn programs, variables hold values (like the number 42) to be used \nby the program. Think of them as symbolic placeholders for the val¬ \nues themselves. \n\nBy contrast, the 2 is just a value itself, called a literal value, because it \nstands alone without being stored in a variable. \n\nThe = and * characters are operators (see “Operators” on page 8) — \nthey perform actions with the values and variables such as assign¬ \nment and mathematic multiplication. \n\nMost statements in JavaScript conclude with a semicolon (;) at the \nend.","metadata":{"loc":{"lines":{"from":628,"to":650}}}}],["22",{"pageContent":"Most statements in JavaScript conclude with a semicolon (;) at the \nend. \n\nThe statement a = b * 2; tells the computer, roughly, to get the \ncurrent value stored in the variable b, multiply that value by 2, then \nstore the result back into another variable we call a. \n\n\n2 | Chapter 1: Into Programming \n\n\n\nPrograms are just collections of many such statements, which \ntogether describe all the steps that it takes to perform your pro¬ \ngram’s purpose. \n\nExpressions \n\nStatements are made up of one or more expressions. An expression is \nany reference to a variable or value, or a set of variable(s) and \nvalue(s) combined with operators. \n\nFor example: \n\na = b * 2; \n\nThis statement has four expressions in it: \n\n• 2 is a literal value expression. \n\n• b is a variable expression, which means to retrieve its current \nvalue. \n\n• b * 2 is an arithmetic expression, which means to do the multi¬ \nplication.","metadata":{"loc":{"lines":{"from":650,"to":684}}}}],["23",{"pageContent":"• 2 is a literal value expression. \n\n• b is a variable expression, which means to retrieve its current \nvalue. \n\n• b * 2 is an arithmetic expression, which means to do the multi¬ \nplication. \n\n• a = b * 2 is an assignment expression, which means to assign \nthe result of the b * 2 expression to the variable a (more on \nassignments later). \n\nA general expression that stands alone is also called an expression \nstatement, such as the following: \n\nb * 2; \n\nThis flavor of expression statement is not very common or useful, as \ngenerally it wouldn’t have any effect on the running of the program \n—it would retrieve the value of b and multiply it by 2, but then \nwouldn’t do anything with that result. \n\nA more common expression statement is a call expression statement \n(see “Functions” on page 22), as the entire statement is the function \ncall expression itself: \n\nalert( a ); \n\n\nExpressions | 3 \n\n\n\nExecuting a Program","metadata":{"loc":{"lines":{"from":684,"to":717}}}}],["24",{"pageContent":"alert( a ); \n\n\nExpressions | 3 \n\n\n\nExecuting a Program \n\nHow do those collections of programming statements tell the com¬ \nputer what to do? The program needs to be executed, also referred to \nas running the program. \n\nStatements like a = b * 2 are helpful for developers when reading \nand writing, but are not actually in a form the computer can directly \nunderstand. So a special utility on the computer (either an inter¬ \npreter or a compiler ) is used to translate the code you write into com¬ \nmands a computer can understand. \n\nFor some computer languages, this translation of commands is typi¬ \ncally done from top to bottom, line by line, every time the program \nis run, which is usually called interpreting the code. \n\nFor other languages, the translation is done ahead of time, called \ncompiling the code, so when the program runs later, what’s running \nis actually the already compiled computer instructions ready to go.","metadata":{"loc":{"lines":{"from":717,"to":742}}}}],["25",{"pageContent":"It’s typically asserted that JavaScript is interpreted, because your Java¬ \nScript source code is processed each time it’s run. But that’s not \nentirely accurate. The JavaScript engine actually compiles the pro¬ \ngram on the fly and then immediately runs the compiled code. \n\n\n\nFor more information on JavaScript compiling, \nsee the first two chapters of the Scope & Closures \ntitle of this series. \n\n\nTry It Yourself \n\nThis chapter is going to introduce each programming concept with \nsimple snippets of code, all written in JavaScript (obviously!). \n\nIt cannot be emphasized enough: while you go through this chapter \n—and you may need to spend the time to go over it several times— \nyou should practice each of these concepts by typing the code your¬ \nself. The easiest way to do that is to open up the developer tools con¬ \nsole in your nearest browser (Firefox, Chrome, IE, etc.). \n\n\n4 | Chapter 1: Into Programming","metadata":{"loc":{"lines":{"from":744,"to":768}}}}],["26",{"pageContent":"4 | Chapter 1: Into Programming \n\n\n\n\n\nTypically, you can launch the developer console \nwith a keyboard shortcut or from a menu item. \n\nFor more detailed information about launching \nk and using the console in your favorite browser, \nsee “Mastering The Developer Tools Console”. \n\nTo type multiple lines into the console at once, \nuse <shift> + <enter> to move to the next \nnew line. Once you hit <enter> by itself, the \nconsole will run everything you’ve just typed. \n\nLet’s get familiar with the process of running code in the console. \nFirst, I suggest opening up an empty tab in your browser. I prefer to \ndo this by typing about: blank into the address bar. Then, make sure \nyour developer console is open, as we just mentioned. \n\nNow, type this code and see how it runs: \n\na = 21 ; \n\nb = a * 2; \n\nconsole.log ( b ); \n\nTyping the preceding code into the console in Chrome should pro¬ \nduce something like the following: \n\n\n\n0 Elements Network Sources » >— $ x","metadata":{"loc":{"lines":{"from":768,"to":804}}}}],["27",{"pageContent":"a = 21 ; \n\nb = a * 2; \n\nconsole.log ( b ); \n\nTyping the preceding code into the console in Chrome should pro¬ \nduce something like the following: \n\n\n\n0 Elements Network Sources » >— $ x \n\nQ V <top frame> ▼ □ Preserve log \n\n> a = 21; \n\nb = a * 2; \n\nconsole.log! b ); \n\n42 VM855:6 \n\n<• undefined \n\n> I \n\n\nGo on, try it. The best way to learn programming is to start coding! \n\n\nTry It Yourself | 5 \n\n\n\n\n\n\n\nOutput \n\nIn the previous code snippet, we used console.log( ..). Briefly, let’s \nlook at what that line of code is all about. \n\nYou may have guessed, but that’s exactly how we print text (aka out¬ \nput to the user) in the developer console. There are two characteris¬ \ntics of that statement that we should explain. \n\nFirst, the log( b ) part is referred to as a function call (see “Func¬ \ntions” on page 22). What’s happening is we’re handing the b variable \nto that function, which asks it to take the value of b and print it to \nthe console.","metadata":{"loc":{"lines":{"from":804,"to":855}}}}],["28",{"pageContent":"Second, the console, part is an object reference where the log(.. ) \nfunction is located. We cover objects and their properties in more \ndetail in Chapter 2. \n\nAnother way of creating output that you can see is to run an \nalert(. .) statement. For example: \n\nalert( b ); \n\nIf you run that, you’ll notice that instead of printing the output to \nthe console, it shows a pop-up “OK” box with the contents of the b \nvariable. However, using console.log(.. ) is generally going to \nmake learning about coding and running your programs in the con¬ \nsole easier than using alert( ..) because you can output many val¬ \nues at once without interrupting the browser interface. \n\nFor this book, we’ll use console. log(..) for output. \n\nInput \n\nWhile we’re discussing output, you may also wonder about input \n(i.e., receiving information from the user).","metadata":{"loc":{"lines":{"from":857,"to":878}}}}],["29",{"pageContent":"For this book, we’ll use console. log(..) for output. \n\nInput \n\nWhile we’re discussing output, you may also wonder about input \n(i.e., receiving information from the user). \n\nThe most common way that happens is for the HTML page to show \nform elements (like text boxes) to a user that she can type into, and \nthen use JS to read those values into your program’s variables. \n\nBut there’s an easier way to get input for simple learning and dem¬ \nonstration purposes such as what you’ll be doing throughout this \nbook. Use the prompt( ..) function: \n\n\n6 | Chapter 1: Into Programming \n\n\n\n\nage = prompt( \"Please tell me your age:\" ); \n\n\nconsole.log ( age ); \n\nAs you may have guessed, the message you pass to prompt( ..) — in \nthis case, \"Please tell me your age:\"— is printed into the pop \nup. \n\nThis should look similar to the following: \n\n\nQ. \n\n□ \n\nElements Network Sources » >!= $ * \n\n<S> \n\nV \n\n<top frame> ▼ □ Preserve log \n\n> \n\nage = \n\nprompt! \"Please tell me your age:\" );","metadata":{"loc":{"lines":{"from":878,"to":927}}}}],["30",{"pageContent":"This should look similar to the following: \n\n\nQ. \n\n□ \n\nElements Network Sources » >!= $ * \n\n<S> \n\nV \n\n<top frame> ▼ □ Preserve log \n\n> \n\nage = \n\nprompt! \"Please tell me your age:\" ); \n\n\nconsole.log( age ); \n\n\n\nOnce you submit the input text by clicking “OK,” you’ll observe that \nthe value you typed is stored in the age variable, which we then out¬ \nput with console.log(..): \n\n\nQ. \n\n0 \n\nElements Network Sources » >E $ x \n\n0 \n\n^7 \n\n<top frame> ▼ □ Preserve log \n\n\n> age = prompt! \"Please tell me your age:\" ); \nconsole.log( age ); \n\n35 VM848:4 \n\n<• undefined \n\n> I \n\n\nTo keep things simple while were learning basic programming con¬ \ncepts, the examples in this book will not require input. But now that \nyou’ve seen how to use prompt (..), if you want to challenge your¬ \nself, you can try to use input in your explorations of the examples. \n\n\nTry It Yourself | 7 \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nOperators","metadata":{"loc":{"lines":{"from":927,"to":1005}}}}],["31",{"pageContent":"Try It Yourself | 7 \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nOperators \n\nOperators are how we perform actions on variables and values. \nWe’ve already seen two JavaScript operators, the = and the *. \n\nThe * operator performs mathematic multiplication. Simple enough, \nright? \n\nThe = equals operator is used for assignment —we first calculate the \nvalue on the right-hand side (source value) of the = and then put it \ninto the variable that we specify on the left-hand side (target vari¬ \nable). \n\n\n\nThis may seem like a strange reverse order to \nspecify assignment. Instead of a = 42, some \nmight prefer to flip the order so the source value \nis on the left and the target variable is on the \nright, like 42 -> a (this is not valid JavaScript!). \nUnfortunately, the a = 42 ordered form, and \nsimilar variations, is quite prevalent in modern \nprogramming languages. If it feels unnatural, \njust spend some time rehearsing that order in \nyour mind to get accustomed to it. \n\n\nConsider: \n\na = 2; \nb = a + 1 ;","metadata":{"loc":{"lines":{"from":1005,"to":1053}}}}],["32",{"pageContent":"Consider: \n\na = 2; \nb = a + 1 ; \n\nHere, we assign the 2 value to the a variable. Then, we get the value \nof the a variable (still 2), add 1 to it resulting in the value 3, then \nstore that value in the b variable. \n\nWhile not technically an operator, you’ll need the keyword var in \nevery program, as it’s the primary way you declare (aka create) \nvariables (see “Variables” on page 14). \n\nYou should always declare the variable by name before you use it. \nBut you only need to declare a variable once for each scope (see \n“Scope” on page 24); it can be used as many times after that as \nneeded. For example: \n\nvar a = 20; \n\na = a + 1 ; \na = a * 2; \n\n\n8 [ Chapter 1: Into Programming \n\n\n\n\n\nconsole.log ( a ); // 42 \n\nHere are some of the most common operators in JavaScript: \n\nAssignment \n\n=, as in a = 2. \n\nMath \n\n+ (addition), - (subtraction), * (multiplication), and / (divi¬ \nsion), as in a * 3. \n\nCompound assignment","metadata":{"loc":{"lines":{"from":1053,"to":1096}}}}],["33",{"pageContent":"Assignment \n\n=, as in a = 2. \n\nMath \n\n+ (addition), - (subtraction), * (multiplication), and / (divi¬ \nsion), as in a * 3. \n\nCompound assignment \n\n+=, - =, *=, and / = are compound operators that combine a math \noperation with assignment, as in a += 2 (same as a = a + 2). \n\nIncrement/decrement \n\n++ (increment), -- (decrement), as in a++ (similar to a = a + \n1). \n\nObject property access \n\n. as in console.log(). \n\nObjects are values that hold other values at specific named loca¬ \ntions called properties, ob j. a means an object value called ob j \nwith a property of the name a. Properties can alternatively be \naccessed as ob j [\" a\" ]. See Chapter 2. \n\nEquality \n\n== (loose-equals), === (strict-equals), != (loose not-equals), !== \n(strict not-equals), as in a == b. \n\nSee “Values & Types” on page 10 and Chapter 2. \n\nComparison \n\n< (less than), > (greater than), <= (less than or loose-equals), >= \n(greater than or loose-equals), as in a <= b.","metadata":{"loc":{"lines":{"from":1096,"to":1134}}}}],["34",{"pageContent":"See “Values & Types” on page 10 and Chapter 2. \n\nComparison \n\n< (less than), > (greater than), <= (less than or loose-equals), >= \n(greater than or loose-equals), as in a <= b. \n\nSee “Values & Types” on page 10 and Chapter 2. \n\nLogical \n\n&& (and), | | (or), as in a | | b that selects either a or b. \n\nThese operators are used to express compound conditionals \n(see “Conditionals” on page 18), like if either a or b is true. \n\n\nOperators | 9 \n\n\n\n\ns \n\n\nFor much more detail, and coverage of operators \nnot mentioned here, see the Mozilla Developer \nNetwork (MDN)’s “Expressions and Operators”. \n\n\nValues & Types \n\n\nIf you ask an employee at a phone store how much a certain phone \ncosts, and he says “ninety-nine, ninety-nine” (i.e., $99.99), he’s giv¬ \ning you an actual numeric dollar figure that represents what you’ll \nneed to pay (plus taxes) to buy it. If you want to buy two of those \nphones, you can easily do the mental math to double that value to \nget $199.98 for your base cost.","metadata":{"loc":{"lines":{"from":1134,"to":1172}}}}],["35",{"pageContent":"If that same employee picks up another similar phone but says it’s \n“free” (perhaps with air quotes), he’s not giving you a number, but \ninstead another kind of representation of your expected cost ($0.00) \n—the word “free.” \n\nWhen you later ask if the phone includes a charger, the answer can \nonly be “yes” or “no.” \n\nIn very similar ways, when you express values in a programs, you \nchoose different representations for those values based on what you \nplan to do with them. \n\nThese different representations for values are called types in pro¬ \ngramming terminology. JavaScript has built-in types for each of \nthese so-called primitive values: \n\n• When you need to do math, you want a number. \n\n• When you need to print a value on the screen, you need a \nstring (one or more characters, words, or sentences). \n\n• When you need to make a decision in your program, you need a \nboolean (true or false).","metadata":{"loc":{"lines":{"from":1174,"to":1196}}}}],["36",{"pageContent":"• When you need to make a decision in your program, you need a \nboolean (true or false). \n\nValues that are included directly in the source code are called liter¬ \nals. string literals are surrounded by double quotes (\"...\") or sin¬ \ngle quotes ('...')—the only difference is stylistic preference, \nnumber and boolean literals are just presented as is (e.g., 42, true, \netc.). \n\n\n10 | Chapter 1: Into Programming \n\n\n\n\n\n\n\nConsider: \n\n\"I am a string\"; \n\n'I am also a string' ; \n\n42; \n\ntrue; \n\nfalse; \n\nBeyond strlng/number/boolean value types, it’s common for pro¬ \ngramming languages to provide arrays, objects, functions, and more. \nWe’ll cover much more about values and types throughout this \nchapter and the next. \n\nConverting Between Types","metadata":{"loc":{"lines":{"from":1196,"to":1231}}}}],["37",{"pageContent":"Converting Between Types \n\nIf you have a number but need to print it on the screen, you need to \nconvert the value to a string, and in JavaScript this conversion is \ncalled “coercion.” Similarly, if someone enters a series of numeric \ncharacters into a form on an ecommerce page, that’s a string, but if \nyou need to then use that value to do math operations, you need to \ncoerce it to a number. \n\nJavaScript provides several different facilities for forcibly coercing \nbetween types. For example: \n\nvar a = \"42\"; \n\nvar b = Number( a ); \n\nconsole.log ( a ); // \" 42 \" \n\nconsole.log ( b ); // 42 \n\nUsing Number (..) (a built-in function) as shown is an explicit coer¬ \ncion from any other type to the number type. That should be pretty \nstraightforward. \n\nBut a controversial topic is what happens when you try to compare \ntwo values that are not already of the same type, which would \nrequire implicit coercion.","metadata":{"loc":{"lines":{"from":1231,"to":1257}}}}],["38",{"pageContent":"But a controversial topic is what happens when you try to compare \ntwo values that are not already of the same type, which would \nrequire implicit coercion. \n\nWhen comparing the string \"99.99\" to the number 99.99, most \npeople would agree they are equivalent. But they’re not exactly the \nsame, are they? It’s the same value in two different representations, \ntwo different types. You could say they’re “loosely equal,” couldn’t \nyou? \n\n\nValues & Types | 11 \n\n\n\n\nTo help you out in these common situations, JavaScript will some¬ \ntimes kick in and implicitly coerce values to the matching types. \n\nSo if you use the == loose-equals operator to make the comparison \n\"99.99\" == 99.99, JavaScript will convert the left-hand side \n\n\"99.99\" to its number equivalent 99.99. The comparison then \nbecomes 99.99 == 99.99, which is of course true.","metadata":{"loc":{"lines":{"from":1257,"to":1280}}}}],["39",{"pageContent":"\"99.99\" to its number equivalent 99.99. The comparison then \nbecomes 99.99 == 99.99, which is of course true. \n\nWhile designed to help you, implicit coercion can create confusion \nif you haven’t taken the time to learn the rules that govern its behav¬ \nior. Most JS developers never have, so the common feeling is that \nimplicit coercion is confusing and harms programs with unexpected \nbugs, and should thus be avoided. It’s even sometimes called a flaw \nin the design of the language. \n\nHowever, implicit coercion is a mechanism that can be learned, and \nmoreover should be learned by anyone wishing to take JavaScript \nprogramming seriously. Not only is it not confusing once you learn \nthe rules, it can actually make your programs better! The effort is \nwell worth it. \n\n\n\nFor more information on coercion, see Chap¬ \nter 2 of this title and Chapter 4 of the Types & \nGrammar title of this series. \n\n\nCode Comments","metadata":{"loc":{"lines":{"from":1280,"to":1303}}}}],["40",{"pageContent":"For more information on coercion, see Chap¬ \nter 2 of this title and Chapter 4 of the Types & \nGrammar title of this series. \n\n\nCode Comments \n\nThe phone store employee might jot down some notes on the fea¬ \ntures of a newly released phone or on the new plans her company \noffers. These notes are only for the employee—they’re not for cus¬ \ntomers to read. Nevertheless, these notes help the employee do her \njob better by documenting the hows and whys of what she should \ntell customers. \n\nOne of the most important lessons you can learn about writing code \nis that it’s not just for the computer. Code is every bit as much, if not \nmore, for the developer as it is for the compiler. \n\nYour computer only cares about machine code, a series of binary Os \nand Is, that comes from compilation. There’s a nearly infinite num¬ \nber of programs you could write that yield the same series of Os and \nIs. The choices you make about how to write your program matter \n\n\n12 | Chapter 1: Into Programming","metadata":{"loc":{"lines":{"from":1303,"to":1327}}}}],["41",{"pageContent":"12 | Chapter 1: Into Programming \n\n\n\n\n\n\n—not only to you, but to your other team members and even to \nyour future self. \n\nYou should strive not just to write programs that work correctly, but \nprograms that make sense when examined. You can go a long way in \nthat effort by choosing good names for your variables (see “Vari¬ \nables” on page 14) and functions (see “Functions” on page 22). \n\nBut another important part is code comments. These are bits of text \nin your program that are inserted purely to explain things to a \nhuman. The interpreter/compiler will always ignore these com¬ \nments. \n\nThere are lots of opinions on what makes well-commented code; we \ncan’t really define absolute universal rules. But some observations \nand guidelines are quite useful: \n\n• Code without comments is suboptimal. \n\n• Too many comments (one per line, for example) is probably a \nsign of poorly written code.","metadata":{"loc":{"lines":{"from":1327,"to":1354}}}}],["42",{"pageContent":"• Code without comments is suboptimal. \n\n• Too many comments (one per line, for example) is probably a \nsign of poorly written code. \n\n• Comments should explain why, not what. They can optionally \nexplain how if what’s written is particularly confusing. \n\nIn JavaScript, there are two types of comments possible: a single-line \ncomment and a multiline comment. \n\nConsider: \n\n// This is a single-line comment \n\n/* But this is \n\na multiline \n\ncomment. \n\nV \n\nThe // single-line comment is appropriate if you’re going to put a \ncomment right above a single statement, or even at the end of a line. \nEverything on the line after the //is treated as the comment (and \nthus ignored by the compiler), all the way to the end of the line. \nThere’s no restriction to what can appear inside a single-line com¬ \nment. \n\nConsider: \n\nvar a = 42; // 42 is the meaning of life \n\n\nCode Comments | 13","metadata":{"loc":{"lines":{"from":1354,"to":1389}}}}],["43",{"pageContent":"Consider: \n\nvar a = 42; // 42 is the meaning of life \n\n\nCode Comments | 13 \n\n\n\n\nThe /* .. */ multiline comment is appropriate if you have several \nlines worth of explanation to make in your comment. \n\nHere’s a common usage of multiline comments: \n\n/* The following value is used because \nit has been shown that it answers \nevery question in the universe. */ \nvar a = 42; \n\nIt can also appear anywhere on a line, even in the middle of a line, \nbecause the */ ends it. For example: \n\nvar a = /* arbitrary value */ 42; \nconsole.log ( a ); // 42 \n\nThe only thing that cannot appear inside a multiline comment is a \n*/, because that would be interpreted to end the comment. \n\nYou will definitely want to begin your learning of programming by \nstarting off with the habit of commenting code. Throughout the rest \nof this chapter, you’ll see I use comments to explain things, so do the \nsame in your own practice. Trust me, everyone who reads your code \nwill thank you! \n\nVariables","metadata":{"loc":{"lines":{"from":1389,"to":1424}}}}],["44",{"pageContent":"Variables \n\nMost useful programs need to track a value as it changes over the \ncourse of the program, undergoing different operations as called for \nby your program’s intended tasks. \n\nThe easiest way to go about that in your program is to assign a value \nto a symbolic container, called a variable —so called because the \nvalue in this container can vary over time as needed. \n\nIn some programming languages, you declare a variable (container) \nto hold a specific type of value, such as number or string. Static typ¬ \ning, otherwise known as type enforcement, is typically cited as a ben¬ \nefit for program correctness by preventing unintended value \nconversions. \n\nOther languages emphasize types for values instead of variables. \nWeak typing, otherwise known as dynamic typing, allows a variable \nto hold any type of value at any time. It’s typically cited as a benefit \nfor program flexibility by allowing a single variable to represent a \n\n\n14 | Chapter 1: Into Programming","metadata":{"loc":{"lines":{"from":1424,"to":1446}}}}],["45",{"pageContent":"14 | Chapter 1: Into Programming \n\n\n\nvalue no matter what type form that value may take at any given \nmoment in the program’s logic flow. \n\nJavaScript uses the latter approach, dynamic typing, meaning vari¬ \nables can hold values of any type without any type enforcement. \n\nAs mentioned earlier, we declare a variable using the var statement \n—notice there’s no other type information in the declaration. Con¬ \nsider this simple program: \n\nvar amount = 99.99; \n\namount = amount * 2; \n\nconsole.log( amount ); // 199.98 \n\n// convert 'anount' to a string, and \n// add \"$\" on the beginning \namount = \"$\" + String( amount ); \n\nconsole.log( amount ); // \"$199.98\" \n\nThe amount variable starts out holding the number 99.99, and then \nholds the number result of amount * 2, which is 199.98. \n\nThe first console.log (..) command has to implicitly coerce that \nnumber value to a string to print it out.","metadata":{"loc":{"lines":{"from":1446,"to":1476}}}}],["46",{"pageContent":"The first console.log (..) command has to implicitly coerce that \nnumber value to a string to print it out. \n\nThen the statement amount = \"$\" + String(amount) explicitly \ncoerces the 199.98 value to a string and adds a \"$\" character to the \nbeginning. At this point, amount now holds the string value \n\"$199.98\", so the second console.log(..) statement doesn’t need \nto do any coercion to print it out. \n\nJavaScript developers will note the flexibility of using the amount \nvariable for each of the 99.99, 199.98, and the \"$199.98\" values. \nStatic-typing enthusiasts would prefer a separate variable like \namountStr to hold the final \"$199.98\" representation of the value, \nbecause it’s a different type. \n\nEither way, you’ll note that amount holds a running value that \nchanges over the course of the program, illustrating the primary \npurpose of variables: managing program state. \n\nIn other words, state is tracking the changes to values as your pro¬ \ngram runs. \n\n\nVariables | 15","metadata":{"loc":{"lines":{"from":1476,"to":1499}}}}],["47",{"pageContent":"In other words, state is tracking the changes to values as your pro¬ \ngram runs. \n\n\nVariables | 15 \n\n\n\n\nAnother common usage of variables is for centralizing value setting. \nThis is more typically called constants, when you declare a variable \nwith a value and intend for that value to not change throughout the \nprogram. \n\nYou declare these constants, often at the top of a program, so that it’s \nconvenient for you to have one place to go to alter a value if you \nneed to. By convention, JavaScript variables as constants are usually \ncapitalized, with underscores _ between multiple words. \n\nHere’s a silly example: \n\nvar TAX_RATE = 0.08; // 8% sales tax \n\nvar amount = 99.99; \n\namount = amount * 2; \n\namount = amount + (amount * TAX_RATE); \n\nconsole.log( amount ); // 215.9784 \n\nconsole.log ( amount.toFixed( 2 ) ); // \"215.98\"","metadata":{"loc":{"lines":{"from":1499,"to":1530}}}}],["48",{"pageContent":"var amount = 99.99; \n\namount = amount * 2; \n\namount = amount + (amount * TAX_RATE); \n\nconsole.log( amount ); // 215.9784 \n\nconsole.log ( amount.toFixed( 2 ) ); // \"215.98\" \n\n\n\nSimilar to how console.log( ..) is a function \nlog(. .) accessed as an object property on the \nconsole value, toFixed(. .) here is a function \nthat can be accessed on number values. JavaScript \nnumbers aren’t automatically formatted for dol¬ \nlars—the engine doesn’t know what your intent \nis, and there’s no type for currency. toFixed(..) \nlets us specify how many decimal places we’d \nlike the number rounded to, and it produces the \nstring as necessary.","metadata":{"loc":{"lines":{"from":1530,"to":1551}}}}],["49",{"pageContent":"The TAX_RATE variable is only constant by convention—there’s noth¬ \ning special in this program that prevents it from being changed. But \nif the city raises the sales tax rate to 9%, we can still easily update our \nprogram by setting the TAX_RATE assigned value to 0.09 in one \nplace, instead of finding many occurrences of the value 0.08 strewn \nthroughout the program and updating all of them. \n\nThe newest version of JavaScript at the time of this writing (com¬ \nmonly called “ES6”) includes a new way to declare constants, by \nusing const instead of var: \n\n\n16 | Chapter 1: Into Programming \n\n\n\n\n\n// as of ES6: \n\nconst TAX_RATE = 0.08; \n\nvar amount = 99.99; \n\n//","metadata":{"loc":{"lines":{"from":1554,"to":1578}}}}],["50",{"pageContent":"16 | Chapter 1: Into Programming \n\n\n\n\n\n// as of ES6: \n\nconst TAX_RATE = 0.08; \n\nvar amount = 99.99; \n\n// \n\nConstants are useful just like variables with unchanged values, \nexcept that constants also prevent accidentally changing value some¬ \nwhere else after the initial setting. If you tried to assign any different \nvalue to TAX_RATE after that first declaration, your program would \nreject the change (and in strict mode, fail with an error—see “Strict \nMode” on page 45 in Chapter 2). \n\nBy the way, that kind of “protection” against mistakes is similar to \nthe static-typing type enforcement, so you can see why static types \nin other languages can be attractive! \n\n\n\nFor more information about how different val¬ \nues in variables can be used in your programs, \nsee the Types & Grammar title of this series. \n\n\nBlocks \n\nThe phone store employee must go through a series of steps to com¬ \nplete the checkout as you buy your new phone.","metadata":{"loc":{"lines":{"from":1578,"to":1613}}}}],["51",{"pageContent":"Blocks \n\nThe phone store employee must go through a series of steps to com¬ \nplete the checkout as you buy your new phone. \n\nSimilarly, in code we often need to group a series of statements \ntogether, which we often call a block. In JavaScript, a block is defined \nby wrapping one or more statements inside a curly-brace pair \n{ .. }. Consider: \n\nvar amount = 99.99; \n\n// a general block \n\nI \n\namount = amount * 2; \n\nconsole.log( amount ); // 199.98 \n\n} \n\nThis kind of standalone { .. } general block is valid, but isn’t as \ncommonly seen in JS programs. Typically, blocks are attached to \nsome other control statement, such as an if statement (see “Condi¬ \ntionals” on page 18) or a loop (see “Loops” on page 20). For exam¬ \nple: \n\n\nBlocks | 17 \n\n\n\n\n\n\nvar amount = 99.99; \n\n\n//is amount big enough? \n\nif (amount > 10) { // <-- block attached to 'if' \n\namount = amount * 2; \nconsole.log( amount ); // 199.98 \n\n}","metadata":{"loc":{"lines":{"from":1613,"to":1659}}}}],["52",{"pageContent":"Blocks | 17 \n\n\n\n\n\n\nvar amount = 99.99; \n\n\n//is amount big enough? \n\nif (amount > 10) { // <-- block attached to 'if' \n\namount = amount * 2; \nconsole.log( amount ); // 199.98 \n\n} \n\nWe’ll explain if statements in the next section, but as you can see, \nthe { .. } block with its two statements is attached to if (amount \n> 10); the statements inside the block will only be processed if the \nconditional passes. \n\n\n\nUnlike most other statements like con \nsole.log(amount);, a block statement does not \nneed a semicolon (;) to conclude it. \n\n\nConditionals \n\n“Do you want to add on the extra screen protectors to your pur¬ \nchase, for $9.99?” The helpful phone store employee has asked you \nto make a decision. And you may need to first consult the current \nstate of your wallet or bank account to answer that question. But \nobviously, this is just a simple “yes or no” question. \n\nThere are quite a few ways we can express conditionals (aka deci¬ \nsions) in our programs.","metadata":{"loc":{"lines":{"from":1659,"to":1699}}}}],["53",{"pageContent":"There are quite a few ways we can express conditionals (aka deci¬ \nsions) in our programs. \n\nThe most common one is the if statement. Essentially, you’re say¬ \ning, “If this condition is true, do the following...”. For example: \n\nvar bank_balance = 302.13; \nvar amount = 99.99; \n\nif (amount < bank_balance) { \n\nconsole.log( \"I want to buy this phone!\" ); \n\n} \n\nThe if statement requires an expression in between the parentheses \n( ) that can be treated as either true or false. In this program, we \nprovided the expression amount < bank_balance, which indeed will \neither evaluate to true or false, depending on the amount in the \nbank balance variable. \n\n\n18 | Chapter 1: Into Programming \n\n\n\n\n\nYou can even provide an alternative if the condition isn’t true, called \nan else clause. Consider: \n\nconst ACCESSORY_PRICE = 9.99; \n\nvar bank_balance = 302.13; \nvar amount = 99.99; \n\namount = amount * 2; \n\n// can we afford the extra purchase? \nif ( amount < bank_balance ) {","metadata":{"loc":{"lines":{"from":1699,"to":1738}}}}],["54",{"pageContent":"const ACCESSORY_PRICE = 9.99; \n\nvar bank_balance = 302.13; \nvar amount = 99.99; \n\namount = amount * 2; \n\n// can we afford the extra purchase? \nif ( amount < bank_balance ) { \n\nconsole.log( \"I'll take the accessory!\" ); \namount = amount + ACCESSORY_PRICE; \n\n} \n\n// otherwise: \n\nelse { \n\nconsole.log( \"No, thanks.\" ); \n\n} \n\nHere, if amount < bank_balance is true, we’ll print out \"I' ll take \nthe accessory!\" and add the 9.99 to our amount variable. Other¬ \nwise, the else clause says we’ll just politely respond with \"No, \nthanks.\" and leave amount unchanged. \n\nAs we discussed in “Values & Types” on page 10, values that aren’t \nalready of an expected type are often coerced to that type. The if \nstatement expects a boolean, but if you pass it something that’s not \nalready boolean, coercion will occur.","metadata":{"loc":{"lines":{"from":1738,"to":1769}}}}],["55",{"pageContent":"JavaScript defines a list of specific values that are considered “falsy” \nbecause when coerced to a boolean, they become false—these \ninclude values like 0 and \"\". Any other value not on the “falsy” list is \nautomatically “truthy”—when coerced to a boolean they become \ntrue. Truthy values include things like 99.99 and \"free\". See “Tru¬ \nthy & falsy” on page 36 in Chapter 2 for more information. \n\nConditionals exist in other forms besides the if. For example, the \nswitch statement can be used as a shorthand for a series of \nif. .else statements (see Chapter 2). Loops (see “Loops” on page \n20) use a conditional to determine if the loop should keep going or \nstop. \n\n\nConditionals | 19 \n\n\n\n\ns \n\n\nFor deeper information about the coercions that \ncan occur implicitly in the test expressions of \nconditionals, see Chapter 4 of the Types & Gram¬ \nmar title of this series. \n\n\nLoops","metadata":{"loc":{"lines":{"from":1771,"to":1799}}}}],["56",{"pageContent":"s \n\n\nFor deeper information about the coercions that \ncan occur implicitly in the test expressions of \nconditionals, see Chapter 4 of the Types & Gram¬ \nmar title of this series. \n\n\nLoops \n\n\nDuring busy times, there’s a waiting list for customers who need to \nspeak to the phone store employee. While there’s still people on that \nlist, she just needs to keep serving the next customer. \n\nRepeating a set of actions until a certain condition fails—in other \nwords, repeating only while the condition holds—is the job of pro¬ \ngramming loops; loops can take different forms, but they all satisfy \nthis basic behavior. \n\nA loop includes the test condition as well as a block (typically as \n{ .. }). Each time the loop block executes, that’s called an iteration. \n\nFor example, the while loop and the do. .while loop forms illustrate \nthe concept of repeating a block of statements until a condition no \nlonger evaluates to true: \n\nwhile (numOfCustomers > 0) {","metadata":{"loc":{"lines":{"from":1799,"to":1827}}}}],["57",{"pageContent":"For example, the while loop and the do. .while loop forms illustrate \nthe concept of repeating a block of statements until a condition no \nlonger evaluates to true: \n\nwhile (numOfCustomers > 0) { \n\nconsole.log( \"How nay I help you?\" ); \n\n// help the customer... \n\n\nnumOfCustomers = numOfCustomers - 1; \n\n\n1 \n\n\n// versus: \n\ndo { \n\nconsole.log( \"How may I help you?\" ); \n\n// help the customer... \n\nnumOfCustomers = numOfCustomers - 1; \n\n} while (numOfCustomers > 0); \n\nThe only practical difference between these loops is whether the \nconditional is tested before the first iteration (while) or after the \nfirst iteration (do. .while). \n\n\n20 | Chapter 1: Into Programming \n\n\n\n\n\n\n\nIn either form, if the conditional tests as false, the next iteration \nwill not run. That means if the condition is initially false, a while \nloop will never run, but a do.. while loop will run just the first time.","metadata":{"loc":{"lines":{"from":1827,"to":1871}}}}],["58",{"pageContent":"Sometimes you are looping for the intended purpose of counting a \ncertain set of numbers, like from 0 to 9 (10 numbers). You can do \nthat by setting a loop iteration variable like l at value 0 and incre¬ \nmenting it by 1 each iteration. \n\n\n\nFor a variety of historical reasons, programming \nlanguages almost always count things in a zero- \nbased fashion, meaning starting with 0 instead \nof 1. If you’re not familiar with that mode of \nthinking, it can be quite confusing at first. Take \nsome time to practice counting starting with 0 to \nbecome more comfortable with it! \n\n\nThe conditional is tested on each iteration, much as if there is an \nimplied If statement inside the loop. \n\nWe can use JavaScript’s break statement to stop a loop. Also, we can \nobserve that it’s awfully easy to create a loop that would otherwise \nrun forever without a breaking mechanism. \n\nLet’s illustrate: \n\nvar 1=0; \n\n// a 'while..true' loop would run forever, right? \nwhile (true) { \n\n// keep the loop going?","metadata":{"loc":{"lines":{"from":1873,"to":1903}}}}],["59",{"pageContent":"Let’s illustrate: \n\nvar 1=0; \n\n// a 'while..true' loop would run forever, right? \nwhile (true) { \n\n// keep the loop going? \n\nIf (1 <= 9) { \n\nconsole.log( 1 ); \n\n1 = 1 + 1 ; \n\n} \n\n// tine to stop the loop! \n\nelse { \n\nbreak; \n\n} \n\n} \n\n// 0123456789 \n\n\n\nThis is not necessarily a practical form you’d \nwant to use for your loops. It’s presented here for \nillustration purposes only. \n\n\nLoops | 21 \n\n\n\n\n\nWhile a while (or do. .while) can accomplish the task manually, \nthere’s another syntactic form called a for loop for just that purpose: \n\nfor (var i = 0; i <= 9; i = 1 + 1) { \nconsole.log( i ); \n\n} \n\n// 0123456789 \n\nAs you can see, in both cases the conditional i <= 9 is true for the \nfirst 10 iterations (i of values 0 through 9) of either loop form, but \nbecomes false once i is value 10.","metadata":{"loc":{"lines":{"from":1903,"to":1957}}}}],["60",{"pageContent":"} \n\n// 0123456789 \n\nAs you can see, in both cases the conditional i <= 9 is true for the \nfirst 10 iterations (i of values 0 through 9) of either loop form, but \nbecomes false once i is value 10. \n\nThe for loop has three clauses: the initialization clause (var i=0), \nthe conditional test clause (i <= 9), and the update clause (i = i + \n1). So if you’re going to do counting with your loop iterations, for is \na more compact and often easier form to understand and write. \n\nThere are other specialized loop forms that are intended to iterate \nover specific values, such as the properties of an object (see Chap¬ \nter 2) where the implied conditional test is just whether all the prop¬ \nerties have been processed. The “loop until a condition fails” \nconcept holds no matter what the form of the loop. \n\nFunctions","metadata":{"loc":{"lines":{"from":1957,"to":1976}}}}],["61",{"pageContent":"Functions \n\nThe phone store employee probably doesn’t carry around a calcula¬ \ntor to figure out the taxes and final purchase amount. That’s a task \nshe needs to define once and reuse over and over again. Odds are, \nthe company has a checkout register (computer, tablet, etc.) with \nthose “functions” built in. \n\nSimilarly, your program will almost certainly want to break up the \ncode’s tasks into reusable pieces, instead of repeatedly repeating \nyourself repetitiously (pun intended!). The way to do this is to \ndefine a function. \n\nA function is generally a named section of code that can be “called” \nby name, and the code inside it will be run each time. Consider: \n\nfunction prlntAmount( ) { \n\nconsole.log( amount.toFixed( 2 ) ); \n\n} \n\nvar amount = 99.99; \nprlntAmount( ); // \"99.99\" \n\n\n22 | Chapter 1: Into Programming \n\n\n\n\namount = amount * 2; \n\n\nprlntAmount( ); // \"199.98\"","metadata":{"loc":{"lines":{"from":1976,"to":2010}}}}],["62",{"pageContent":"console.log( amount.toFixed( 2 ) ); \n\n} \n\nvar amount = 99.99; \nprlntAmount( ); // \"99.99\" \n\n\n22 | Chapter 1: Into Programming \n\n\n\n\namount = amount * 2; \n\n\nprlntAmount( ); // \"199.98\" \n\nFunctions can optionally take arguments (aka parameters)—values \nyou pass in. And they can also optionally return a value back: \n\nfunction prlntAmount(amt) { \n\nconsole.log( amt.toFixed( 2 ) ); \n\n} \n\nfunction formatAmount( ) { \n\nreturn \"$\" + amount.toFixed( 2 ); \n\n} \n\nvar amount = 99.99; \n\nprintAmount( amount * 2 ); // \"199.98\" \n\namount = formatAmount( ); \n\nconsole.log ( amount ); // \"$99.99\" \n\nThe function printAmount(. .) takes a parameter that we call amt. \nThe function formatAmount() returns a value. Of course, you can \nalso combine those two techniques in the same function. \n\nFunctions are often used for code that you plan to call multiple \ntimes, but they can also be useful just to organize related bits of code \ninto named collections, even if you only plan to call them once. \n\nConsider:","metadata":{"loc":{"lines":{"from":2010,"to":2059}}}}],["63",{"pageContent":"Consider: \n\nconst TAX_RATE = 0.08; \n\nfunction calculateFinalPurchaseAmount(amt) { \n\n// calculate the new amount with the tax \namt = amt + (amt * TAX_RATE); \n\n// return the new amount \n\nreturn amt; \n\n} \n\nvar amount = 99.99; \n\namount = calculateFinalPurchaseAmount( amount ); \nconsole.log( amount.toFixed( 2 ) ); // \"107.99\" \n\nAlthough calculateFinalPurchaseAmount(..) is only called once, \norganizing its behavior into a separate named function makes the \ncode that uses its logic (the amount = calculateFinal... State- \n\n\nFunctions | 23 \n\n\n\nment) cleaner. If the function had more statements in it, the benefits \nwould be even more pronounced. \n\nScope \n\nIf you ask the phone store employee for a phone model that her \nstore doesn’t carry, she will not be able to sell you the phone you \nwant. She only has access to the phones in her stores inventory. \nYou’ll have to try another store to see if you can find the phone \nyou’re looking for.","metadata":{"loc":{"lines":{"from":2059,"to":2097}}}}],["64",{"pageContent":"Programming has a term for this concept: scope (technically called \nlexical scope). In JavaScript, each function gets its own scope. Scope \nis basically a collection of variables as well as the rules for how those \nvariables are accessed by name. Only code inside that function can \naccess that function’s scoped variables. \n\nA variable name has to be unique within the same scope—there \ncan’t be two different a variables sitting right next to each other. But \nthe same variable name a could appear in different scopes: \n\nfunction one() { \n\n// this 'a' only belongs to the ~one()' function \nvar a = 1; \nconsole.log( a ); \n\n} \n\nfunction two() { \n\n// this 'a' only belongs to the ~two()' function \nvar a = 2; \nconsole.log( a ); \n\n} \n\none(); // 1 \n\ntwo (); // 2","metadata":{"loc":{"lines":{"from":2099,"to":2127}}}}],["65",{"pageContent":"} \n\nfunction two() { \n\n// this 'a' only belongs to the ~two()' function \nvar a = 2; \nconsole.log( a ); \n\n} \n\none(); // 1 \n\ntwo (); // 2 \n\nAlso, a scope can be nested inside another scope, just like if a clown \nat a birthday party blows up one balloon inside another balloon. If \none scope is nested inside another, code inside the innermost scope \ncan access variables from either scope. \n\nConsider: \n\n\n24 | Chapter 1: Into Programming \n\n\n\nfunction outerQ { \nvar a = 1; \n\nfunction inner() { \nvar b = 2; \n\n\n// we can access both 'a' and 'b' here \nconsole.log( a + b ); // 3 \n\n\ninner( ); \n\n\n// we can only access 'a' here \nconsole.log( a ); // 1 \n\n\nouterQ; \n\nLexical scope rules say that code in one scope can access variables of \neither that scope or any scope outside of it. \n\nSo, code inside the innerQ function has access to both variables a \nand b, but code only in outerQ has access only to a—it cannot \naccess b because that variable is only inside innerQ.","metadata":{"loc":{"lines":{"from":2127,"to":2178}}}}],["66",{"pageContent":"So, code inside the innerQ function has access to both variables a \nand b, but code only in outerQ has access only to a—it cannot \naccess b because that variable is only inside innerQ. \n\nRecall this code snippet from earlier: \n\nconst TAX_RATE = 0.08; \n\n\nfunction calculateFinalPurchaseAmount(amt) { \n// calculate the new anount with the tax \nant = ant + (ant * TAX_RATE); \n\n\n// return the new anount \n\nreturn ant; \n\n} \n\nThe TAX_RATE constant (variable) is accessible from inside the calcu \nlateFinalPurchaseAnount(..) function, even though we didn’t \npass it in, because of lexical scope. \n\n\n\nFor more information about lexical scope, see \nthe first three chapters of the Scope & Closures \ntitle of this series. \n\n\nFunctions | 25 \n\n\n\n\n\nPractice \n\nThere is absolutely no substitute for practice in learning program¬ \nming. No amount of articulate writing on my part is alone going to \nmake you a programmer.","metadata":{"loc":{"lines":{"from":2178,"to":2219}}}}],["67",{"pageContent":"Functions | 25 \n\n\n\n\n\nPractice \n\nThere is absolutely no substitute for practice in learning program¬ \nming. No amount of articulate writing on my part is alone going to \nmake you a programmer. \n\nWith that in mind, let’s try practicing some of the concepts we \nlearned here in this chapter. I’ll give the “requirements,” and you try \nit first. Then consult the code listing below to see how I approached \nit: \n\n\n• Write a program to calculate the total price of your phone pur¬ \nchase. You will keep purchasing phones (hint: loop!) until you \nrun out of money in your bank account. You’ll also buy accesso¬ \nries for each phone as long as your purchase amount is below \nyour mental spending threshold. \n\n• After you’ve calculated your purchase amount, add in the tax, \nthen print out the calculated purchase amount, properly for¬ \nmatted. \n\n• Finally, check the amount against your bank account balance to \nsee if you can afford it or not.","metadata":{"loc":{"lines":{"from":2219,"to":2248}}}}],["68",{"pageContent":"• Finally, check the amount against your bank account balance to \nsee if you can afford it or not. \n\n• You should set up some constants for the “tax rate,” “phone \nprice,” “accessory price,” and “spending threshold,” as well as a \nvariable for your “bank account balance.” \n\n• You should define functions for calculating the tax and for for¬ \nmatting the price with a “$” and rounding to two decimal \nplaces. \n\n• Bonus Challenge: Try to incorporate input into this program, \nperhaps with the prompt(..) covered in “Input” on page 6. You \nmay prompt the user for their bank account balance, for exam¬ \nple. Have fun and be creative! \n\nOK, go ahead. Try it. Don’t peek at my code listing until you’ve given \nit a shot yourself! \n\n\n\nBecause this is a JavaScript book, I’m obviously \ngoing to solve the practice exercise in JavaScript. \nBut you can do it in another language for now if \nyou feel more comfortable. \n\n\n26 | Chapter 1: Into Programming","metadata":{"loc":{"lines":{"from":2248,"to":2275}}}}],["69",{"pageContent":"26 | Chapter 1: Into Programming \n\n\n\n\n\nHere’s my JavaScript solution for this exercise: \n\nconst SPENDING_THRESHOLD = 200; \nconst TAX_RATE = 0.08; \nconst PHONE_PRICE = 99.99; \nconst ACCESSORY_PRICE = 9.99; \n\nvar bank_batance = 303.91; \nvar amount = 0; \n\nfunction catculateTax(amount) { \nreturn amount * TAX_RATE; \n\n} \n\nfunction formatAmount(amount) { \n\nreturn \"$\" + amount.toFixed( 2 ); \n\n} \n\n// keep buying phones while you still have money \nwhile (amount < bank_balance) { \n\n// buy a new phone! \n\namount = amount + PHONE_PRICE; \n\n// can we afford the accessory? \nif (amount < SPENDING_THRESHOLD) { \n\namount = amount + ACCESSORY_PRICE; \n\n} \n\n} \n\n// don't forget to pay the government, too \namount = amount + calculateTax( amount ); \n\n\nconsole.log ( \n\n\"Your purchase: \" + formatAmount( amount ) \n\n); \n\n// Your purchase: $334.76 \n\n// can you actually afford this purchase? \nif (amount > bank_balance) { \nconsole.log( \n\n\"You can't afford this purchase. :(\" \n\n); \n\n}","metadata":{"loc":{"lines":{"from":2275,"to":2338}}}}],["70",{"pageContent":"); \n\n// Your purchase: $334.76 \n\n// can you actually afford this purchase? \nif (amount > bank_balance) { \nconsole.log( \n\n\"You can't afford this purchase. :(\" \n\n); \n\n} \n\n// You can't afford this purchase. :( \n\n\n\nThe simplest way to run this JavaScript program \nis to type it into the developer console of your \nnearest browser. \n\n\nPractice | 27 \n\n\n\n\nHow did you do? It wouldn’t hurt to try it again now that you’ve \nseen my code. And play around with changing some of the con¬ \nstants to see how the program runs with different values. \n\nReview \n\nLearning programming doesn’t have to be a complex and over¬ \nwhelming process. There are just a few basic concepts you need to \nwrap your head around. \n\nThese act like building blocks. To build a tall tower, you start first by \nputting block on top of block on top of block. The same goes with \nprogramming. Here are some of the essential programming building \nblocks: \n\n• You need operators to perform actions on.","metadata":{"loc":{"lines":{"from":2338,"to":2381}}}}],["71",{"pageContent":"• You need operators to perform actions on. \n\n• You need values and types to perform different kinds of actions \nlike math on numbers or output with strings. \n\n• You need variables to store data (aka state) during your pro¬ \ngram’s execution. \n\n• You need conditionals like if statements to make decisions. \n\n• You need loops to repeat tasks until a condition stops being true. \n\n• You need functions to organize your code into logical and reusa¬ \nble chunks. \n\nCode comments are one effective way to write more readable code, \nwhich makes your program easier to understand, maintain, and fix \nlater if there are problems. \n\nFinally, don’t neglect the power of practice. The best way to learn \nhow to write code is to write code.","metadata":{"loc":{"lines":{"from":2381,"to":2401}}}}],["72",{"pageContent":"Finally, don’t neglect the power of practice. The best way to learn \nhow to write code is to write code. \n\nI’m excited you’re well on your way to learning how to code, now! \nKeep it up. Don’t forget to check out other beginner programming \nresources (books, blogs, online training, etc.). This chapter and this \nbook are a great start, but they’re just a brief introduction. \n\nThe next chapter will review many of the concepts from this chapter, \nbut from a more JavaScript-specific perspective, which will highlight \nmost of the major topics that are addressed in deeper detail \nthroughout the rest of the series. \n\n\n28 | Chapter 1: Into Programming \n\n\n\n\nCHAPTER 2 \n\n\nInto JavaScript","metadata":{"loc":{"lines":{"from":2401,"to":2423}}}}],["73",{"pageContent":"28 | Chapter 1: Into Programming \n\n\n\n\nCHAPTER 2 \n\n\nInto JavaScript \n\n\nIn the previous chapter, I introduced the basic building blocks of \nprogramming, such as variables, loops, conditionals, and functions. \nOf course, all the code shown has been in JavaScript. But in this \nchapter, we want to focus specifically on things you need to know \nabout JavaScript to get up and going as a JS developer. \n\nWe will introduce quite a few concepts in this chapter that will not \nbe fully explored until subsequent YDKJS books. You can think of \nthis chapter as an overview of the topics covered in detail through¬ \nout the rest of this series. \n\nEspecially if you’re new to JavaScript, you should expect to spend \nquite a bit of time reviewing the concepts and code examples here \nmultiple times. Any good foundation is laid brick by brick, so don’t \nexpect that you’ll immediately understand it all the first pass \nthrough. \n\nYour journey to deeply learn JavaScript starts here. \n\n\n29","metadata":{"loc":{"lines":{"from":2423,"to":2454}}}}],["74",{"pageContent":"Your journey to deeply learn JavaScript starts here. \n\n\n29 \n\n\n\n\n\nAs I said in Chapter 1, you should definitely try \nall this code yourself as you read and work \nthrough this chapter. Be aware that some of the \ncode here assumes capabilities introduced in the \nnewest version of JavaScript at the time of this \nwriting (commonly referred to as “ES6” for the \n6th edition of ECMAScript—the official name of \nthe JS specification). If you happen to be using \nan older, pre-ES6 browser, the code may not \nwork. A recent update of a modern browser (like \nChrome, Firefox, or IE) should be used. \n\n\nValues & Types \n\nAs we asserted in Chapter 1, JavaScript has typed values, not typed \nvariables. The following built-in types are available: \n\n• string \n\n• number \n\n• boolean \n\n• null and undefined \n\n• object \n\n• symbol (new to ES6) \n\nJavaScript provides a typeof operator that can examine a value and \ntell you what type it is: \n\nvar a; \n\n\ntypeof a; \n\n// \n\n\"undefined\" \n\na = \"hello world\"; \ntypeof a;","metadata":{"loc":{"lines":{"from":2454,"to":2506}}}}],["75",{"pageContent":"• symbol (new to ES6) \n\nJavaScript provides a typeof operator that can examine a value and \ntell you what type it is: \n\nvar a; \n\n\ntypeof a; \n\n// \n\n\"undefined\" \n\na = \"hello world\"; \ntypeof a; \n\n// \n\n\"string\" \n\na = 42; \n\ntypeof a; \n\n// \n\n\"nunber\" \n\na = true; \n\n\n\ntypeof a; \n\n// \n\n\"boolean\" \n\na = null; \ntypeof a; \n\n// \n\n\"object\"■ -weird, bug \n\na = undefined; \ntypeof a; \n\n// \n\n\"undefined\" \n\n\n30 | Chapter 2: Into JavaScript \n\n\n\n\n\n\n\na = { b: \"c\" }; \n\ntypeof a; // \"object\" \n\nThe return value from the typeof operator is always one of six \n(seven as of ES6!) string values. That is, typeof \"abc\" returns \n\"string\", not string. \n\nNotice how in this snippet the a variable holds every different type \nof value, and that despite appearances, typeof a is not asking for \nthe “type of a,” but rather for the “type of the value currently in a.” \nOnly values have types in JavaScript; variables are just simple con¬ \ntainers for those values.","metadata":{"loc":{"lines":{"from":2506,"to":2580}}}}],["76",{"pageContent":"typeof null is an interesting case because it errantly returns \n\"object\" when youd expect it to return \"null\". \n\n\n\nThis is a long-standing bug in JS, but one that is \nlikely never going to be fixed. Too much code on \nthe Web relies on the bug, and thus fixing it \nwould cause a lot more bugs! \n\n\nAlso, note a = undefined. We’re explicitly setting a to the unde \nfined value, but that is behaviorally no different from a variable that \nhas no value set yet, like with the var a; line at the top of the snip¬ \npet. A variable can get to this “undefined” value state in several dif¬ \nferent ways, including functions that return no values and usage of \nthe void operator. \n\nObjects \n\nThe object type refers to a compound value where you can set \nproperties (named locations) that each hold their own values of any \ntype. This is perhaps one of the most useful value types in all of Java¬ \nScript: \n\nvar obj = { \n\na: \"hello world\" , \nb: 42, \nc: true \n\n}; \n\nobj. a; // \"hello world\" \n\nobj . b; // 42","metadata":{"loc":{"lines":{"from":2582,"to":2617}}}}],["77",{"pageContent":"var obj = { \n\na: \"hello world\" , \nb: 42, \nc: true \n\n}; \n\nobj. a; // \"hello world\" \n\nobj . b; // 42 \n\nobj.c; // true \n\n\nValues & Types | 31 \n\n\n\n\nobj [ \"a\" ] \nobj[\"b\" ] \nobj [ \"c\"] \n\n\n// \"hello world' \n// 42 \n// true \n\n\nIt may be helpful to think of this obj value visually: \n\n\nobj \n\n\na: \"hello world\" \n\n\nk: 42 \n\n\nc: true \n\n\nProperties can either be accessed with dot notation (i.e., obj. a) or \nbracket notation (i.e., obj [\"a\"]). Dot notation is shorter and gener¬ \nally easier to read, and is thus preferred when possible. \n\nBracket notation is useful if you have a property name that has spe¬ \ncial characters in it, like obj [\"hello world! \"]—such properties are \noften referred to as keys when accessed via bracket notation. The [ ] \nnotation requires either a variable (explained next) or a string lit¬ \neral (which needs to be wrapped in \" .. \" or ' .. ').","metadata":{"loc":{"lines":{"from":2617,"to":2670}}}}],["78",{"pageContent":"Of course, bracket notation is also useful if you want to access a \nproperty/key but the name is stored in another variable, such as: \n\nvar obj = { \n\na: \"hello world\", \nb: 42 \n\n}; \n\n\nvar b = \"a\"; \n\n\nobj[b ]; // \"hello world\" \n\nobj [ \"b\" ]; // 42 \n\n\n\nFor more information on JavaScript objects, see \nthe this & Object Prototypes title of this series, \nspecifically Chapter 3. \n\n\nThere are a couple of other value types that you will commonly \ninteract with in JavaScript programs: array and function. But rather \nthan being proper built-in types, these should be thought of more \nlike subtypes—specialized versions of the object type. \n\n\n32 | Chapter 2: Into JavaScript \n\n\n\n\n\n\n\n\n\n\nArrays \n\nAn array is an object that holds values (of any type) not particularly \nin named properties/keys, but rather in numerically indexed posi¬ \ntions. For example: \n\nvar arr = [ \n\n\"hetlo world\", \n\n42, \n\ntrue \n\n]; \n\narr[0] ; \narr[l]; \narr[2] ; \narr.length; \n\ntypeof arr;","metadata":{"loc":{"lines":{"from":2672,"to":2735}}}}],["79",{"pageContent":"var arr = [ \n\n\"hetlo world\", \n\n42, \n\ntrue \n\n]; \n\narr[0] ; \narr[l]; \narr[2] ; \narr.length; \n\ntypeof arr; \n\n\nLanguages that start counting at zero, like JS \ndoes, use 0 as the index of the first element in \nthe array. \n\n\n\n// \"hello world\" \n// 42 \n// true \n// 3 \n\n// \"object\" \n\n\nIt may be helpful to think of arr visually: \n\n\narr \n\n\n\"hello world\" \n\n\n42 \n\n\n2: true \n\n\nBecause arrays are special objects (as typeof implies), they can also \nhave properties, including the automatically updated length prop¬ \nerty. \n\nYou theoretically could use an array as a normal object with your \nown named properties, or you could use an object but only give it \nnumeric properties (0, 1, etc.) similar to an array. However, this \nwould generally be considered improper usage of the respective \ntypes. \n\nThe best and most natural approach is to use arrays for numerically \npositioned values and use objects for named properties. \n\n\nValues & Types | 33 \n\n\n\n\n\n\n\n\n\nFunctions","metadata":{"loc":{"lines":{"from":2735,"to":2806}}}}],["80",{"pageContent":"The best and most natural approach is to use arrays for numerically \npositioned values and use objects for named properties. \n\n\nValues & Types | 33 \n\n\n\n\n\n\n\n\n\nFunctions \n\nThe other object subtype you’ll use all over your JS programs is a \nfunction: \n\nfunction foo() { \nreturn 42; \n\n} \n\nfoo.bar = \"hello world\"; \n\ntypeof foo; // \"function\" \n\ntypeof foo(); // \"number\" \n\ntypeof foo.bar; // \"string\" \n\nAgain, functions are a subtype of objects—typeof returns \"func \n\ntion\", which implies that a function is a main type—and can thus \nhave properties, but you typically will only use function object prop¬ \nerties (like foo.bar) in limited cases. \n\n\n\nFor more information on JS values and their \ntypes, see the first two chapters of the Types & \nGrammar title of this series. \n\n\nBuilt-In Type Methods \n\nThe built-in types and subtypes we’ve just discussed have behaviors \nexposed as properties and methods that are quite powerful and use¬ \nful. \n\nFor example: \n\nvar a = \"hello world\"; \nvar b = 3.14159;","metadata":{"loc":{"lines":{"from":2806,"to":2860}}}}],["81",{"pageContent":"For example: \n\nvar a = \"hello world\"; \nvar b = 3.14159; \n\na.length; // 11 \n\na. toUpperCase(); // \"HELLO WORLD\" \n\nb. toFlxed(4); // \"3.1416\" \n\nThe “how” behind being able to call a. tollpperCase( ) is more com¬ \nplicated than just that method existing on the value. \n\nBriefly, there is a String (capital S) object wrapper form, typically \ncalled a “native,” that pairs with the primitive string type; it’s this \nobject wrapper that defines the toUpperCasef ) method on its proto¬ \ntype. \n\n\n34 | Chapter 2: Into JavaScript \n\n\n\n\n\nWhen you use a primitive value like \"hello world\" as an object by \nreferencing a property or method (e.g., a. toUpperCase() in the pre¬ \nvious snippet), JS automatically “boxes” the value to its object wrap¬ \nper counterpart (hidden under the covers).","metadata":{"loc":{"lines":{"from":2860,"to":2889}}}}],["82",{"pageContent":"A string value can be wrapped by a String object, a number can be \nwrapped by a Number object, and a boolean can be wrapped by a \nBoolean object. For the most part, you don’t need to worry about or \ndirectly use these object wrapper forms of the values—prefer the \nprimitive value forms in practically all cases and JavaScript will take \ncare of the rest for you. \n\n\n\nFor more information on JS natives and “box¬ \ning,” see Chapter 3 of the Types & Grammar title \nof this series. To better understand the prototype \nof an object, see Chapter 5 of the this & Object \nPrototypes title of this series. \n\n\nComparing Values \n\nThere are two main types of value comparison that you will need to \nmake in your JS programs: equality and inequality. The result of any \ncomparison is a strictly boolean value (true or false), regardless of \nwhat value types are compared. \n\nCoercion \n\nWe talked briefly about coercion in Chapter 1, but let’s revisit it here.","metadata":{"loc":{"lines":{"from":2891,"to":2916}}}}],["83",{"pageContent":"Coercion \n\nWe talked briefly about coercion in Chapter 1, but let’s revisit it here. \n\nCoercion comes in two forms in JavaScript: explicit and implicit. \nExplicit coercion is simply that you can see from the code that a \nconversion from one type to another will occur, whereas implicit \ncoercion is when the type conversion can happen as more of a non- \nobvious side effect of some other operation. \n\nYou’ve probably heard sentiments like “coercion is evil” drawn from \nthe fact that there are clearly places where coercion can produce \nsome surprising results. Perhaps nothing evokes frustration from \ndevelopers more than when the language surprises them. \n\nCoercion is not evil, nor does it have to be surprising. In fact, the \nmajority of cases you can construct with type coercion are quite \nsensible and understandable, and can even be used to improve the \nreadability of your code. But we won’t go much further into that \n\n\nValues & Types | 35","metadata":{"loc":{"lines":{"from":2916,"to":2937}}}}],["84",{"pageContent":"Values & Types | 35 \n\n\n\n\ndebate—Chapter 4 of the Types & Grammar title of this series covers \nall sides. \n\nHere’s an example of explicit coercion: \n\nvar a = \"42\"; \n\nvar b = Number( a ); \n\na; // \"42\" \n\nb; // 42--the number! \n\nAnd here’s an example of implicit coercion: \n\n\nvar a = \"42\"; \n\n\n\n\nvar b = a * 1; \n\n// \n\n\"42' \n\n' implicitly coerced to 42 here \n\na; \n\n// \n\n\"42' \n\n\nb; \n\n// 42-- \n\nthe number! \n\n\nTruthy&falsy \n\nIn Chapter 1, we briefly mentioned the “truthy” and “falsy” nature of \nvalues: when a non-boolean value is coerced to a boolean, does it \nbecome true or false, respectively? \n\nThe specific list of “falsy” values in JavaScript is as follows: \n\n• \"\" (empty string) \n\n• 0, -0, NaN (invalid number) \n\n• null, undefined \n\n• false \n\nAny value that’s not on this “falsy” list is “truthy.” Here are some \nexamples of those: \n\n• \"hello\" \n\n• 42 \n\n• true \n\n• [ ], [ 1, \"2\", 3 ] (arrays) \n\n• { }, { a: 42 } (objects) \n\n• function foo() { .. } (functions) \n\n\n36 | Chapter 2: Into JavaScript","metadata":{"loc":{"lines":{"from":2937,"to":3017}}}}],["85",{"pageContent":"• \"hello\" \n\n• 42 \n\n• true \n\n• [ ], [ 1, \"2\", 3 ] (arrays) \n\n• { }, { a: 42 } (objects) \n\n• function foo() { .. } (functions) \n\n\n36 | Chapter 2: Into JavaScript \n\n\n\n\nIt’s important to remember that a non-boolean value only follows \nthis “truthy”/“falsy” coercion if it’s actually coerced to a boolean. It’s \nnot all that difficult to confuse yourself with a situation that seems \nlike it’s coercing a value to a boolean when it’s not. \n\nEquality \n\nThere are four equality operators: ==, ===, ! =, and ! ==. The ! forms \nare of course the symmetric “not equal” versions of their counter¬ \nparts; non-equality should not be confused with inequality.","metadata":{"loc":{"lines":{"from":3017,"to":3044}}}}],["86",{"pageContent":"The difference between == and === is usually characterized that == \nchecks for value equality and === checks for both value and type \nequality. However, this is inaccurate. The proper way to characterize \nthem is that == checks for value equality with coercion allowed, and \n=== checks for value equality without allowing coercion; === is often \ncalled “strict equality” for this reason. \n\nConsider the implicit coercion that’s allowed by the == loose- \nequality comparison and not allowed with the === strict-equality: \n\nvar a = \"42\"; \nvar b = 42; \n\na == b; // true \n\na === b; // false \n\nIn the a == b comparison, JS notices that the types do not match, so \nit goes through an ordered series of steps to coerce one or both val¬ \nues to a different type until the types match, where then a simple \nvalue equality can be checked.","metadata":{"loc":{"lines":{"from":3046,"to":3066}}}}],["87",{"pageContent":"If you think about it, there’s two possible ways a == b could give \ntrue via coercion. Either the comparison could end up as 42 == 42 \nor it could be \" 42\" == \" 42\". So which is it? \n\nThe answer: \"42\" becomes 42, to make the comparison 42 == 42. In \nsuch a simple example, it doesn’t really seem to matter which way \nthat process goes, as the end result is the same. There are more com¬ \nplex cases where it matters not just what the end result of the com¬ \nparison is, but how you get there. \n\nThe a === b produces false, because the coercion is not allowed, \nso the simple value comparison obviously fails. Many developers feel \nthat === is more predictable, so they advocate always using that form \nand staying away from ==. I think this view is very shortsighted. I \n\n\nValues & Types | 37 \n\n\n\nbelieve == is a powerful tool that helps your program, if you take the \ntime to learn how it works.","metadata":{"loc":{"lines":{"from":3068,"to":3089}}}}],["88",{"pageContent":"Values & Types | 37 \n\n\n\nbelieve == is a powerful tool that helps your program, if you take the \ntime to learn how it works. \n\nWe’re not going to cover all the nitty-gritty details of how the coer¬ \ncion in == comparisons works here. Much of it is pretty sensible, but \nthere are some important corner cases to be careful of. You can read \nsection 11.9.3 of the ES5 specification to see the exact rules, and \nyou’ll be surprised at just how straightforward this mechanism is, \ncompared to all the negative hype surrounding it. \n\nTo boil down a whole lot of details to a few simple takeaways, and \nhelp you know whether to use == or === in various situations, here \nare my simple rules: \n\n• If either value (aka side) in a comparison could be the true or \nfalse value, avoid == and use ===. \n\n• If either value in a comparison could be of these specific values \n(0, \"\", or []—empty array), avoid == and use ===.","metadata":{"loc":{"lines":{"from":3089,"to":3111}}}}],["89",{"pageContent":"• If either value in a comparison could be of these specific values \n(0, \"\", or []—empty array), avoid == and use ===. \n\n• In all other cases, you’re safe to use ==. Not only is it safe, but in \nmany cases it simplifies your code in a way that improves read¬ \nability. \n\nWhat these rules boil down to is requiring you to think critically \nabout your code and about what kinds of values can come through \nvariables that get compared for equality. If you can be certain about \nthe values, and == is safe, use it! If you can’t be certain about the val¬ \nues, use ===. It’s that simple. \n\nThe ! = non-equality form pairs with ==, and the ! == form pairs with \n===. All the rules and observations we just discussed hold symmetri¬ \ncally for these non-equality comparisons.","metadata":{"loc":{"lines":{"from":3111,"to":3126}}}}],["90",{"pageContent":"The ! = non-equality form pairs with ==, and the ! == form pairs with \n===. All the rules and observations we just discussed hold symmetri¬ \ncally for these non-equality comparisons. \n\nYou should take special note of the == and === comparison rules if \nyou’re comparing two non-primitive values, like objects (including \nfunction and array). Because those values are actually held by ref¬ \nerence, both == and === comparisons will simply check whether the \nreferences match, not anything about the underlying values. \n\nFor example, arrays are by default coerced to strings by simply \njoining all the values with commas (,) in between. You might think \nthat two arrays with the same contents would be == equal, but \nthey’re not: \n\n\n38 | Chapter 2: Into JavaScript \n\n\n\n\nvar a = [1,2,3]; \nvar b = [1,2,3]; \nvar c = \"1,2,3\"; \n\n\na == c; // true \nb == c; // true \na == b; // false","metadata":{"loc":{"lines":{"from":3126,"to":3154}}}}],["91",{"pageContent":"38 | Chapter 2: Into JavaScript \n\n\n\n\nvar a = [1,2,3]; \nvar b = [1,2,3]; \nvar c = \"1,2,3\"; \n\n\na == c; // true \nb == c; // true \na == b; // false \n\n\n\nFor more information about the == equality \ncomparison rules, see the ES5 specification (sec¬ \ntion 11.9.3) and also consult Chapter 4 of the \nTypes & Grammar title of this series; see Chapter \n2 for more information about values versus ref¬ \nerences. \n\n\nInequality \n\nThe <, >, <=, and >= operators are used for inequality, referred to in \nthe specification as “relational comparison.” Typically they will be \nused with ordinally comparable values like numbers. It’s easy to \nunderstand that 3 < 4. \n\nBut JavaScript string values can also be compared for inequality, \nusing typical alphabetic rules (\"bar\" < \"foo\").","metadata":{"loc":{"lines":{"from":3154,"to":3186}}}}],["92",{"pageContent":"But JavaScript string values can also be compared for inequality, \nusing typical alphabetic rules (\"bar\" < \"foo\"). \n\nWhat about coercion? Similar rules as == comparison (though not \nexactly identical!) apply to the inequality operators. Notably, there \nare no “strict inequality” operators that would disallow coercion the \nsame way === “strict equality” does. \n\nConsider: \n\nvar a = 41; \nvar b = \"42\"; \nvar c = \"43\"; \n\na < b; // true \n\nb < c; // true \n\nWhat happens here? In section 11.8.5 of the ES5 specification, it says \nthat if both values in the < comparison are strings, as it is with b < \nc, the comparison is made lexicographically (aka alphabetically like \na dictionary). But if one or both is not a string, as it is with a < b, \nthen both values are coerced to be numbers, and a typical numeric \ncomparison occurs. \n\n\nValues & Types | 39","metadata":{"loc":{"lines":{"from":3186,"to":3212}}}}],["93",{"pageContent":"Values & Types | 39 \n\n\n\n\n\n\n\nThe biggest gotcha you may run into here with comparisons \nbetween potentially different value types—remember, there are no \n“strict inequality” forms to use—is when one of the values cannot be \nmade into a valid number, such as: \n\nvar a = 42; \nvar b = \"foo\"; \n\na < b; // false \n\na > b; // false \n\na == b; // false \n\nWait, how can all three of those comparisons be false? Because the \nb value is being coerced to the “invalid number value” NaN in the < \nand > comparisons, and the specification says that NaN is neither \ngreater than nor less than any other value. \n\nThe == comparison fails for a different reason, a == b could fail if \nit’s interpreted either as 42 == NaN or \"42\" == \"foo\"—as we \nexplained earlier, the former is the case. \n\n\n\nFor more information about the inequality com¬ \nparison rules, see section 11.8.5 of the ES5 speci¬ \nfication and also consult Chapter 4 of the Types \n& Grammar title of this series. \n\n\nVariables","metadata":{"loc":{"lines":{"from":3212,"to":3251}}}}],["94",{"pageContent":"For more information about the inequality com¬ \nparison rules, see section 11.8.5 of the ES5 speci¬ \nfication and also consult Chapter 4 of the Types \n& Grammar title of this series. \n\n\nVariables \n\nIn JavaScript, variable names (including function names) must be \nvalid identifiers. The strict and complete rules for valid characters in \nidentifiers are a little complex when you consider nontraditional \ncharacters such as Unicode. If you only consider typical ASCII \nalphanumeric characters, though, the rules are simple. \n\nAn identifier must start with a-z, A-Z, $, or _. It can then contain any \nof those characters plus the numerals 0-9. \n\nGenerally, the same rules apply to a property name as to a variable \nidentifier. However, certain words cannot be used as variables, but \nare OK as property names. These words are called “reserved words,” \nand include the JS keywords (for, in, if, etc.) as well as null, true, \nand false. \n\n\n40 | Chapter 2: Into JavaScript","metadata":{"loc":{"lines":{"from":3251,"to":3275}}}}],["95",{"pageContent":"40 | Chapter 2: Into JavaScript \n\n\n\n\n\n\n\n\nFor more information about reserved words, see \nAppendix A of the Types & Grammar title of this \nseries. \n\n\nFunction Scopes \n\nYou use the var keyword to declare a variable that will belong to the \ncurrent function scope, or the global scope if at the top level outside \nof any function. \n\n\nHoisting \n\nWherever a var appears inside a scope, that declaration is taken to \nbelong to the entire scope and accessible everywhere throughout. \n\nMetaphorically, this behavior is called hoisting, when a var declara¬ \ntion is conceptually “moved” to the top of its enclosing scope. Tech¬ \nnically, this process is more accurately explained by how code is \ncompiled, but we can skip over those details for now. \n\nConsider: \n\nvar a = 2; \n\n\nfoo(); // works because 'foo()' \n\n// declaration is \"hoisted\" \n\nfunction foo() { \na = 3; \n\n\nconsole.log( a ); // 3 \n\n\nvar a; \n\n\n} \n\n\n// declaration is \"hoisted\" \n// to the top of 'foo()' \n\n\nconsole.log ( a ); // 2","metadata":{"loc":{"lines":{"from":3275,"to":3332}}}}],["96",{"pageContent":"// declaration is \"hoisted\" \n\nfunction foo() { \na = 3; \n\n\nconsole.log( a ); // 3 \n\n\nvar a; \n\n\n} \n\n\n// declaration is \"hoisted\" \n// to the top of 'foo()' \n\n\nconsole.log ( a ); // 2 \n\n\n\nIt’s not common or a good idea to rely on vari¬ \nable hoisting to use a variable earlier in its scope \nthan its var declaration appears; it can be quite \nconfusing. It’s much more common and \naccepted to use hoisted function declarations, as \nwe do with the foo() call appearing before its \nformal declaration. \n\n\nVariables | 41 \n\n\n\n\n\n\n\n\nNested scopes \n\nWhen you declare a variable, it is available anywhere in that scope, \nas well as any lower/inner scopes. For example: \n\nfunction foo() { \nvar a = 1; \n\nfunction bar() { \nvar b = 2; \n\nfunction baz() { \nvar c = 3; \n\nconsole.log ( a, b , c );// 1 2 3 \n\n} \n\nbaz(); \n\nconsole. log( a, b ); // 1 2 \n\n} \n\nbar(); \n\nconsole.log( a ); // 1 \n\n} \n\nfoo( );","metadata":{"loc":{"lines":{"from":3332,"to":3403}}}}],["97",{"pageContent":"function bar() { \nvar b = 2; \n\nfunction baz() { \nvar c = 3; \n\nconsole.log ( a, b , c );// 1 2 3 \n\n} \n\nbaz(); \n\nconsole. log( a, b ); // 1 2 \n\n} \n\nbar(); \n\nconsole.log( a ); // 1 \n\n} \n\nfoo( ); \n\nNotice that c is not available inside of bar(), because it’s declared \nonly inside the inner baz() scope, and that b is not available to \nf oo () for the same reason. \n\nIf you try to access a variables value in a scope where it’s not avail¬ \nable, you’ll get a ReferenceError thrown. If you try to set a variable \nthat hasn’t been declared, you’ll either end up creating a variable in \nthe top-level global scope (bad!) or getting an error, depending on \n“strict mode” (see “Strict Mode” on page 45). Let’s take a look: \n\nfunction foo() { \n\na = 1; // 'a' not formally declared \n\n} \n\nfoo( ); \n\na; // l--oops, auto global variable :( \n\nThis is a very bad practice. Don’t do it! Always formally declare your \nvariables.","metadata":{"loc":{"lines":{"from":3403,"to":3448}}}}],["98",{"pageContent":"function foo() { \n\na = 1; // 'a' not formally declared \n\n} \n\nfoo( ); \n\na; // l--oops, auto global variable :( \n\nThis is a very bad practice. Don’t do it! Always formally declare your \nvariables. \n\nIn addition to creating declarations for variables at the function \nlevel, ES6 lets you declare variables to belong to individual blocks \n(pairs of { .. }), using the let keyword. Besides some nuanced \n\n\n42 | Chapter 2: Into JavaScript \n\n\n\ndetails, the scoping rules will behave roughly the same as we just saw \nwith functions: \n\nfunction foo() { \nvar a = 1; \n\nif (a >= 1) { \nlet b = 2; \n\nwhile (b < 5) { \nlet c = b * 2; \nb++; \n\nconsole.log( a + c ); \n\n1 \n\n1 \n\n1 \n\nf°°( ); \n\n// 5 7 9","metadata":{"loc":{"lines":{"from":3448,"to":3493}}}}],["99",{"pageContent":"function foo() { \nvar a = 1; \n\nif (a >= 1) { \nlet b = 2; \n\nwhile (b < 5) { \nlet c = b * 2; \nb++; \n\nconsole.log( a + c ); \n\n1 \n\n1 \n\n1 \n\nf°°( ); \n\n// 5 7 9 \n\nBecause of using let instead of var, b will belong only to the if \nstatement and thus not to the whole foo() functions scope. Simi¬ \nlarly, c belongs only to the while loop. Block scoping is very useful \nfor managing your variable scopes in a more fine-grained fashion, \nwhich can make your code much easier to maintain over time. \n\n\n\nFor more information about scope, see the Scope \n& Closures title of this series. See the ES6 & \nBeyond title of this series for more information \nabout let block scoping. \n\n\nConditionals \n\nIn addition to the if statement we introduced briefly in Chapter 1, \nJavaScript provides a few other conditionals mechanisms that we \nshould take a look at. \n\nSometimes you may find yourself writing a series of if. .else, .if \nstatements like this: \n\n\nIf (a - 2) { \n\n// do something \n\n1 \n\nelse If (a == 10) {","metadata":{"loc":{"lines":{"from":3493,"to":3545}}}}],["100",{"pageContent":"Sometimes you may find yourself writing a series of if. .else, .if \nstatements like this: \n\n\nIf (a - 2) { \n\n// do something \n\n1 \n\nelse If (a == 10) { \n\n// do another thing \n\n1 \n\n\nConditionals | 43 \n\n\n\n\n\n\nelse if (a == 42) { \n\n// do yet another thing \n\n} \n\nelse { \n\n// fallback to here \n\n} \n\nThis structure works, but it’s a little verbose because you need to \nspecify the a test for each case. Here’s another option, the switch \nstatement: \n\nswitch (a) { \ncase 2: \n\n// do something \n\nbreak; \ncase 10: \n\n// do another thing \n\nbreak; \ncase 42: \n\n// do yet another thing \n\nbreak; \n\ndefault: \n\n// fallback to here \n\n} \n\nThe break is important if you want only the statement(s) in one \ncase to run. If you omit break from a case, and that case matches \nor runs, execution will continue with the next case’s statements \nregardless of that case matching. This so called “fall through” is \nsometimes useful/desired: \n\nswitch (a) { \ncase 2: \ncase 10: \n\n// some cool stuff \n\nbreak; \ncase 42:","metadata":{"loc":{"lines":{"from":3545,"to":3621}}}}],["101",{"pageContent":"switch (a) { \ncase 2: \ncase 10: \n\n// some cool stuff \n\nbreak; \ncase 42: \n\n// other stuff \n\nbreak; \n\ndefault: \n\n// fallback \n\n} \n\nHere, if a is either 2 or 10, it will execute the “some cool stuff” code \nstatements. \n\nAnother form of conditional in JavaScript is the “conditional opera¬ \ntor,” often called the “ternary operator.” It’s like a more concise form \nof a single if. .else statement, such as: \n\n\n44 | Chapter 2: Into JavaScript \n\n\n\n\nvar a = 42; \n\n\nvar b = (a > 41) ? \"hello\" : \"world\"; \n\n// sinilar to: \n\n// if (a > 41) { \n\n// b = \"hello\"; \n\n// } \n\n// else { \n\n// b = \"world\"; \n\n// } \n\nIf the test expression (a > 41 here) evaluates as true, the first clause \n(\"hello\") results; otherwise, the second clause (\"world\") results, \nand whatever the result is then gets assigned to b. \n\nThe conditional operator doesn’t have to be used in an assignment, \nbut that’s definitely the most common usage.","metadata":{"loc":{"lines":{"from":3621,"to":3677}}}}],["102",{"pageContent":"The conditional operator doesn’t have to be used in an assignment, \nbut that’s definitely the most common usage. \n\n\n\nFor more information about testing conditions \nand other patterns for switch and ? :, see the \nTypes & Grammar title of this series. \n\n\nStrict Mode \n\nES5 added a “strict mode” to the language, which tightens the rules \nfor certain behaviors. Generally, these restrictions are seen as keep¬ \ning the code to a safer and more appropriate set of guidelines. Also, \nadhering to strict mode makes your code generally more optimiza- \nble by the engine. Strict mode is a big win for code, and you should \nuse it for all your programs. \n\nYou can opt in to strict mode for an individual function, or an entire \nfile, depending on where you put the strict mode pragma: \n\nfunction foo() { \n\n\"use strict\"; \n\n// this code is strict node \n\nfunction bar() { \n\n// this code is strict node \n\n} \n\n} \n\n\nStrict Mode | 45 \n\n\n\n\n\n\n\n\n// this code is not strict node \nCompare that to: \n\n\"use strict\";","metadata":{"loc":{"lines":{"from":3677,"to":3726}}}}],["103",{"pageContent":"\"use strict\"; \n\n// this code is strict node \n\nfunction bar() { \n\n// this code is strict node \n\n} \n\n} \n\n\nStrict Mode | 45 \n\n\n\n\n\n\n\n\n// this code is not strict node \nCompare that to: \n\n\"use strict\"; \n\nfunction foo() { \n\n// this code is strict node \n\nfunction bar() { \n\n// this code is strict node \n\n} \n\n} \n\n// this code is strict node \n\nOne key difference (improvement!) with strict mode is disallowing \nthe implicit auto-global variable declaration from omitting the van \n\nfunction foo() { \n\n\"use strict\"; // turn on strict node \na = 1; // 'var' nissing, ReferenceError \n\n} \n\nfooQ; \n\nIf you turn on strict mode in your code, and you get errors, or code \nstarts behaving buggy, your temptation might be to avoid strict \nmode. But that instinct would be a bad idea to indulge. If strict \nmode causes issues in your program, it’s almost certainly a sign that \nyou have things in your program you should fix.","metadata":{"loc":{"lines":{"from":3726,"to":3783}}}}],["104",{"pageContent":"Not only will strict mode keep your code to a safer path, and not \nonly will it make your code more optimizable, but it also represents \nthe future direction of the language. It’d be easier on you to get used \nto strict mode now than to keep putting it off—it’ll only get harder \nto convert later! \n\n\n\nFor more information about strict mode, see \nChapter 5 of the Types & Grammar title of this \nseries. \n\n\n46 | Chapter 2: Into JavaScript \n\n\n\n\n\nFunctions as Values \n\nSo far, we’ve discussed functions as the primary mechanism of scope \nin JavaScript. You recall typical function declaration syntax as fol¬ \nlows: \n\nfunction foo() { \n\n// \n\n} \n\nThough it may not seem obvious from that syntax, foo is basically \njust a variable in the outer enclosing scope that’s given a reference to \nthe function being declared. That is, the function itself is a value, \njust like 42 or [1,2,3] would be.","metadata":{"loc":{"lines":{"from":3785,"to":3819}}}}],["105",{"pageContent":"This may sound like a strange concept at first, so take a moment to \nponder it. Not only can you pass a value (argument) to a function, \nbut a function itself can be a value that’s assigned to variables or \npassed to or returned from other functions. \n\nAs such, a function value should be thought of as an expression, \nmuch like any other value or expression. \n\nConsider: \n\nvar foo = function() { \n\n// •• \n\n}; \n\nvar x = function bar(){ \n\n// •• \n\n}; \n\nThe first function expression assigned to the foo variable is called \nanonymous because it has no name. \n\nThe second function expression is named (bar), even as a reference \nto it is also assigned to the x variable. Named function expressions are \ngenerally more preferable, though anonymous function expressions \nare still extremely common. \n\nFor more information, see the Scope & Closures title of this series. \n\nImmediately Invoked Function Expressions (IIFEs)","metadata":{"loc":{"lines":{"from":3821,"to":3853}}}}],["106",{"pageContent":"For more information, see the Scope & Closures title of this series. \n\nImmediately Invoked Function Expressions (IIFEs) \n\nIn the previous snippet, neither of the function expressions are exe¬ \ncuted—we could if we had included foo() or x(), for instance. \n\n\nFunctions as Values | 47 \n\n\n\nThere’s another way to execute a function expression, which is typi¬ \ncally referred to as an immediately invoked function expression \n(IIFE): \n\n(function IIFE (){ \n\nconsole.log( \"Hello!\" ); \n\n})(); \n\n// \"Hello!\" \n\nThe outer ( .. ) that surrounds the (function 11 FE() { .. }) \nfunction expression is just a nuance of JS grammar needed to pre¬ \nvent it from being treated as a normal function declaration. \n\nThe final () on the end of the expression—the }) (); line—is what \nactually executes the function expression referenced immediately \nbefore it. \n\nThat may seem strange, but it’s not as foreign as first glance. Con¬ \nsider the similarities between foo and IIFE here: \n\nfunction foo() { .. }","metadata":{"loc":{"lines":{"from":3853,"to":3888}}}}],["107",{"pageContent":"That may seem strange, but it’s not as foreign as first glance. Con¬ \nsider the similarities between foo and IIFE here: \n\nfunction foo() { .. } \n\n// 'foo' function reference expression, \n\n// then '()' executes it \nfoo(); \n\n// 'IIFE' function expression, \n\n// then '()' executes i t \n\n(function IIFE (){ .. })(); \n\nAs you can see, listing the (function IIFE(){ .. }) before its exe¬ \ncuting () is essentially the same as including foo before its execut¬ \ning (); in both cases, the function reference is executed with () \nimmediately after it. \n\nBecause an IIFE is just a function, and functions create variable \nscope, using an IIFE in this fashion is often used to declare variables \nthat won’t affect the surrounding code outside the IIFE: \n\nvar a = 42; \n\n(function IIFE(){ \nvar a = 10; \n\nconsole.log( a ); // 10 \n\n})(); \n\nconsole.log ( a ); // 42 \n\nIIFEs can also have return values: \n\n\n48 | Chapter 2: Into JavaScript \n\n\n\n\nvar x = (function IIFE(){ \nreturn 42; \n\n})(); \n\nx; // 42","metadata":{"loc":{"lines":{"from":3888,"to":3937}}}}],["108",{"pageContent":"console.log( a ); // 10 \n\n})(); \n\nconsole.log ( a ); // 42 \n\nIIFEs can also have return values: \n\n\n48 | Chapter 2: Into JavaScript \n\n\n\n\nvar x = (function IIFE(){ \nreturn 42; \n\n})(); \n\nx; // 42 \n\nThe 42 value gets returned from the IIFE-named function being \nexecuted, and is then assigned to x. \n\nClosure \n\nClosure is one of the most important, and often least understood, \nconcepts in JavaScript. I won’t cover it in deep detail here, and \ninstead refer you to the Scope & Closures title of this series. But I \nwant to say a few things about it so you understand the general con¬ \ncept. It will be one of the most important techniques in your JS skill- \nset. \n\nYou can think of closure as a way to “remember” and continue to \naccess a functions scope (its variables) even once the function has \nfinished running. \n\nConsider: \n\nfunction makeAdder(x) { \n\n// parameter 'x' is an inner variable \n\n// inner function 'add()~ uses 'x', so \n//it has a \"closure\" over it \n\nfunction add(y) { \nreturn y + x;","metadata":{"loc":{"lines":{"from":3937,"to":3984}}}}],["109",{"pageContent":"Consider: \n\nfunction makeAdder(x) { \n\n// parameter 'x' is an inner variable \n\n// inner function 'add()~ uses 'x', so \n//it has a \"closure\" over it \n\nfunction add(y) { \nreturn y + x; \n\n}; \n\n\nreturn add; \n\n} \n\nThe reference to the inner add (..) function that gets returned with \neach call to the outer makeAdder(..) is able to remember whatever x \nvalue was passed in to makeAdder(..). Now, let’s use makeAd \nder(..): \n\n// 'plusOne' gets a reference to the inner ~add(..)' \n\n// function with closure over the 'x' parameter of \n// the outer 'makeAdder(..)' \nvar plusOne = makeAdder( 1 ); \n\n// 'plusTen' gets a reference to the inner 'add(..)' \n\n// function with closure over the 'x' parameter of \n// the outer 'makeAdder(..)' \n\n\nFunctions as Values | 49 \n\n\n\nvar plusTen = makeAdder( 10 ); \n\n\nplusOne( 3 ); // 4 <--1+3 \n\nplusOne( 41 ); // 42 <-- 1 + 41 \n\nplusTen( 13 ); // 23 <-- 10 + 13 \n\nMore on how this code works:","metadata":{"loc":{"lines":{"from":3984,"to":4033}}}}],["110",{"pageContent":"Functions as Values | 49 \n\n\n\nvar plusTen = makeAdder( 10 ); \n\n\nplusOne( 3 ); // 4 <--1+3 \n\nplusOne( 41 ); // 42 <-- 1 + 41 \n\nplusTen( 13 ); // 23 <-- 10 + 13 \n\nMore on how this code works: \n\n1. When we call niakeAdder(l), we get back a reference to its inner \nadd(..) that remembers x as 1. We call this function reference \nplusOne(..). \n\n2. When we call makeAdder(lO), we get back another reference to \nits inner add(..) that remembers x as 10. We call this function \nreference plusTen(..). \n\n3. When we call plus0ne(3), it adds 3 (its inner y) to the 1 \n(remembered by x), and we get 4 as the result. \n\n4. When we call plusTen(13), it adds 13 (its inner y) to the 10 \n(remembered by x), and we get 23 as the result. \n\nDon’t worry if this seems strange and confusing at first—it can be! \nIt’ll take lots of practice to understand it fully.","metadata":{"loc":{"lines":{"from":4033,"to":4063}}}}],["111",{"pageContent":"Don’t worry if this seems strange and confusing at first—it can be! \nIt’ll take lots of practice to understand it fully. \n\nBut trust me, once you do, it’s one of the most powerful and useful \ntechniques in all of programming. It’s definitely worth the effort to \nlet your brain simmer on closures for a bit. In the next section, we’ll \nget a little more practice with closure. \n\nModules \n\nThe most common usage of closure in JavaScript is the module pat¬ \ntern. Modules let you define private implementation details (vari¬ \nables, functions) that are hidden from the outside world, as well as a \npublic API that is accessible from the outside. \n\nConsider: \n\nfunction User(){ \n\nvar username, password; \n\nfunction doLogin(user,pw) { \nusername = user; \npassword = pw; \n\n// do the rest of the login work \n\n} \n\n\n50 | Chapter 2: Into JavaScript \n\n\n\n\nvar publicAPI = { \nlogin: doLogin \n\n\n}; \n\n\nreturn publicAPI; \n\n} \n\n// create a 'User' module instance \nvar fred = User();","metadata":{"loc":{"lines":{"from":4063,"to":4110}}}}],["112",{"pageContent":"} \n\n\n50 | Chapter 2: Into JavaScript \n\n\n\n\nvar publicAPI = { \nlogin: doLogin \n\n\n}; \n\n\nreturn publicAPI; \n\n} \n\n// create a 'User' module instance \nvar fred = User(); \n\nfred.login( \"fred\", \"12Battery34!\" ); \n\nThe UserQ function serves as an outer scope that holds the vari¬ \nables username and password, as well as the inner doLogin() func¬ \ntion; these are all private inner details of this User module that \ncannot be accessed from the outside world. \n\n\n\nWe are not callling new UserQ here, on pur¬ \npose, despite the fact that probably seems more \ncommon to most readers. UserQ is just a func¬ \ntion, not a class to be instantiated, so it’s just \ncalled normally. Using new would be inappropri¬ \nate and actually waste resources.","metadata":{"loc":{"lines":{"from":4110,"to":4146}}}}],["113",{"pageContent":"Executing User() creates an instance of the User module—a whole \nnew scope is created, and thus a whole new copy of each of these \ninner variables/functions. We assign this instance to fred. If we run \nUser() again, wed get a new instance entirely separate from fred. \n\nThe inner doLogin() function has a closure over username and pass \nword, meaning it will retain its access to them even after the User() \nfunction finishes running. \n\npublicAPI is an object with one property/method on it, login, \nwhich is a reference to the inner doLogin() function. When we \nreturn publicAPI from UserQ, it becomes the instance we call fred. \n\nAt this point, the outer UserQ function has finished executing. Nor¬ \nmally, youd think the inner variables like username and password \nhave gone away. But here they have not, because there’s a closure in \nthe login() function keeping them alive. \n\n\nFunctions as Values | 51","metadata":{"loc":{"lines":{"from":4149,"to":4168}}}}],["114",{"pageContent":"Functions as Values | 51 \n\n\n\n\n\nThat’s why we can call fred.login(..)—the same as calling the \ninner doLogin(..)—and it can still access username and password \ninner variables. \n\nThere’s a good chance that with just this brief glimpse at closure and \nthe module pattern, some of it is still a bit confusing. That’s OK! It \ntakes some work to wrap your brain around it. \n\nFrom here, go read the Scope & Closures title of this series for a \nmuch more in-depth exploration. \n\nthis Identifier \n\nAnother very commonly misunderstood concept in JavaScript is the \nthis keyword. Again, there’s a couple of chapters on it in the this & \nObject Prototypes title of this series, so here we’ll just briefly intro¬ \nduce the concept. \n\nWhile it may often seem that this is related to “object-oriented pat¬ \nterns,” in JS this is a different mechanism.","metadata":{"loc":{"lines":{"from":4168,"to":4193}}}}],["115",{"pageContent":"While it may often seem that this is related to “object-oriented pat¬ \nterns,” in JS this is a different mechanism. \n\nIf a function has a this reference inside it, that this reference usu¬ \nally points to an object. But which object it points to depends on \nhow the function was called. \n\nIt’s important to realize that this does not refer to the function itself, \nas is the most common misconception. \n\nHere’s a quick illustration: \n\nfunction foo() { \n\nconsole.log( this. bar ); \n\n} \n\nvar bar = \"global\"; \n\nvar objl = { \n\nbar: \"objl\", \nfoo: foo \n\n}; \n\n\nvar obj2 = { \nbar: \"obj2\" \n\n}; \n\n\n//. \n\nfoo(); // \"global \n\n\n52 | Chapter 2: Into JavaScript \n\n\n\n\n\nobjl.fooQ; // \"objl\" \n\nfoo.call ( obj2 ); // \"obj2\" \n\nnew foo(); // undefined \n\nThere are four rules for how this gets set, and they’re shown in \nthose last four lines of that snippet:","metadata":{"loc":{"lines":{"from":4193,"to":4245}}}}],["116",{"pageContent":"objl.fooQ; // \"objl\" \n\nfoo.call ( obj2 ); // \"obj2\" \n\nnew foo(); // undefined \n\nThere are four rules for how this gets set, and they’re shown in \nthose last four lines of that snippet: \n\n1. foo() ends up setting this to the global object in non-strict \nmode—in strict mode, this would be undefined and you’d get \nan error in accessing the bar property—so \"global\" is the value \nfound for this. bar. \n\n2. objl.fooQ sets this to the objl object. \n\n3. foo.call(obj2) sets this to the obj2 object. \n\n4. new foo() sets this to a brand new empty object. \n\nBottom line: to understand what this points to, you have to exam¬ \nine how the function in question was called. It will be one of those \nfour ways just shown, and that will then answer what this is. \n\n\n\nFor more information about this, see Chapters \n1 and 2 of the this & Object Prototypes title of \nthis series. \n\n\nPrototypes","metadata":{"loc":{"lines":{"from":4245,"to":4276}}}}],["117",{"pageContent":"For more information about this, see Chapters \n1 and 2 of the this & Object Prototypes title of \nthis series. \n\n\nPrototypes \n\nThe prototype mechanism in JavaScript is quite complicated. We \nwill only glance at it here. You will want to spend plenty of time \nreviewing Chapters 4-6 of the this & Object Prototypes title of this \nseries for all the details. \n\nWhen you reference a property on an object, if that property doesn’t \nexist, JavaScript will automatically use that object’s internal proto¬ \ntype reference to find another object to look for the property on. \nYou could think of this almost as a fallback if the property is miss¬ \ning. \n\nThe internal prototype reference linkage from one object to its fall¬ \nback happens at the time the object is created. The simplest way to \nillustrate it is with a built-in utility called Object .create(..). \n\n\nPrototypes | 53 \n\n\n\n\n\n\nConsider: \n\n\nvar foo = { \na: 42 \n\n\n}; \n\n\n// create 'bar' and link it to 'foo' \nvar bar = Object. create( foo );","metadata":{"loc":{"lines":{"from":4276,"to":4317}}}}],["118",{"pageContent":"Prototypes | 53 \n\n\n\n\n\n\nConsider: \n\n\nvar foo = { \na: 42 \n\n\n}; \n\n\n// create 'bar' and link it to 'foo' \nvar bar = Object. create( foo ); \n\nbar.b = \"hello world\"; \n\nbar.b; // \"hello world\" \n\nbar. a; // 42 <-- delegated to 'foo' \n\nIt may help to visualize the foo and bar objects and their relation¬ \nship: \n\n\nfoo \n\n\n\nThe a property doesn’t actually exist on the bar object, but because \nbar is prototype-linked to foo, JavaScript automatically falls back to \nlooking for a on the foo object, where it’s found. \n\nThis linkage may seem like a strange feature of the language. The \nmost common way this feature is used—and I would argue, abused \n—is to try to emulate/fake a “class” mechanism with “inheritance.” \n\nBut a more natural way of applying prototypes is a pattern called \n“behavior delegation,” where you intentionally design your linked \nobjects to be able to delegate from one to the other for parts of the \nneeded behavior.","metadata":{"loc":{"lines":{"from":4317,"to":4362}}}}],["119",{"pageContent":"For more information about prototypes and \nbehavior delegation, see Chapters 4-6 of the this \n& Object Prototypes title of this series. \n\n\n54 | Chapter 2: Into JavaScript \n\n\n\n\n\n\n\n\n\n\nOld & New \n\nSome of the JS features we’ve already covered, and certainly many of \nthe features covered in the rest of this series, are newer additions \nand will not necessarily be available in older browsers. In fact, some \nof the newest features in the specification aren’t even implemented \nin any stable browsers yet. \n\nSo, what do you do with the new stuff? Do you just have to wait \naround for years or decades for all the old browsers to fade into \nobscurity? \n\nThat’s how many people think about the situation, but it’s really not \na healthy approach to JS. \n\nThere are two main techniques you can use to “bring” the newer \nJavaScript stuff to the older browsers: polyfilling and transpiling. \n\nPolyfilling","metadata":{"loc":{"lines":{"from":4366,"to":4400}}}}],["120",{"pageContent":"There are two main techniques you can use to “bring” the newer \nJavaScript stuff to the older browsers: polyfilling and transpiling. \n\nPolyfilling \n\nThe word “polyfill” is an invented term (by Remy Sharp) used to \nrefer to taking the definition of a newer feature and producing a \npiece of code that’s equivalent to the behavior, but is able to run in \nolder JS environments. \n\nFor example, ES6 defines a utility called Number.isNaN( ..) to pro¬ \nvide an accurate, non-buggy check for NaN values, deprecating the \noriginal isNaN(.. ) utility. But it’s easy to polyfill that utility so that \nyou can start using it in your code regardless of whether the end \nuser is in an ES6 browser or not. \n\nConsider: \n\nif ( INumber.isNaN) { \n\nNumber.IsNaN = function isNaN(x) { \n\nreturn x !== x; \n\n}; \n\n} \n\nThe if statement guards against applying the polyfill definition in \nES6 browsers where it will already exist. If it’s not already present, \nwe define Number. isNaN(.. ). \n\n\nOld & New | 55","metadata":{"loc":{"lines":{"from":4400,"to":4433}}}}],["121",{"pageContent":"} \n\nThe if statement guards against applying the polyfill definition in \nES6 browsers where it will already exist. If it’s not already present, \nwe define Number. isNaN(.. ). \n\n\nOld & New | 55 \n\n\n\n\n\nThe check we do here takes advantage of a quirk \nwith NaN values, which is that they’re the only \nvalue in the whole language that is not equal to \nitself. So the NaN value is the only one that would \nmake x !== x be true. \n\n\nNot all new features are fully polyfillable. Sometimes most of the \nbehavior can be polyfilled, but there are still small deviations. You \nshould be really, really careful in implementing a polyfill yourself, to \nmake sure you are adhering to the specification as strictly as possi¬ \nble. \n\nOr better yet, use an already vetted set of polyfills that you can trust, \nsuch as those provided by ES5-Shim and ES6-Shim. \n\nTranspiling","metadata":{"loc":{"lines":{"from":4433,"to":4462}}}}],["122",{"pageContent":"Or better yet, use an already vetted set of polyfills that you can trust, \nsuch as those provided by ES5-Shim and ES6-Shim. \n\nTranspiling \n\nThere’s no way to polyfill new syntax that has been added to the lan¬ \nguage. The new syntax would throw an error in the old JS engine as \nunrecognized/invalid. \n\nSo the better option is to use a tool that converts your newer code \ninto older code equivalents. This process is commonly called “tran¬ \nspiling,” a term for transforming + compiling. \n\nEssentially your source code is authored in the new syntax form, but \nwhat you deploy to the browser is the transpiled code in old syntax \nform. You typically insert the transpiler into your build process, \nsimilar to your code linter or your minifier. \n\nYou might wonder why you’d go to the trouble to write new syntax \nonly to have it transpiled away to older code—why not just write the \nolder code directly? \n\nThere are several important reasons you should care about transpi¬ \nling:","metadata":{"loc":{"lines":{"from":4462,"to":4485}}}}],["123",{"pageContent":"There are several important reasons you should care about transpi¬ \nling: \n\n\n• The new syntax added to the language is designed to make your \ncode more readable and maintainable. The older equivalents are \noften much more convoluted. You should prefer writing newer \nand cleaner syntax, not only for yourself but for all other mem¬ \nbers of the development team. \n\n• If you transpile only for older browsers, but serve the new syn¬ \ntax to the newest browsers, you get to take advantage of browser \n\n\n56 | Chapter 2: Into JavaScript \n\n\n\n\n\n\nperformance optimizations with the new syntax. This also lets \nbrowser makers have more real-world code to test their imple¬ \nmentations and optimizations on. \n\n• Using the new syntax earlier allows it to be tested more robustly \nin the real world, which provides earlier feedback to the Java¬ \nScript committee (TC39). If issues are found early enough, they \ncan be changed/fixed before those language design mistakes \nbecome permanent.","metadata":{"loc":{"lines":{"from":4485,"to":4514}}}}],["124",{"pageContent":"Here’s a quick example of transpiling. ES6 adds a feature called \n“default parameter values.” It looks like this: \n\nfunction foo(a = 2) { \nconsole.log( a ); \n\n} \n\nfoo(); // 2 \nfoo( 42 ); // 42 \n\nSimple, right? Helpful, too! But it’s new syntax that’s invalid in pre- \nES6 engines. So what will a transpiler do with that code to make it \nrun in older environments? \n\nfunction foo() { \n\nvar a = arguments[0] !== (void 0) ? arguments[0] : 2; \nconsole.log( a ); \n\n} \n\nAs you can see, it checks to see if the arguments[0] value is void 0 \n(aka undefined), and if so provides the 2 default value; otherwise, it \nassigns whatever was passed. \n\nIn addition to being able to now use the nicer syntax even in older \nbrowsers, looking at the transpiled code actually explains the \nintended behavior more clearly.","metadata":{"loc":{"lines":{"from":4516,"to":4544}}}}],["125",{"pageContent":"In addition to being able to now use the nicer syntax even in older \nbrowsers, looking at the transpiled code actually explains the \nintended behavior more clearly. \n\nYou may not have realized just from looking at the ES6 version that \nundefined is the only value that can’t get explicitly passed in for a \ndefault-value parameter, but the transpiled code makes that much \nmore clear. \n\nThe last important detail to emphasize about transpilers is that they \nshould now be thought of as a standard part of the JS development \necosystem and process. JS is going to continue to evolve, much more \nquickly than before, so every few months new syntax and new fea¬ \ntures will be added. \n\n\nOld & New | 57 \n\n\n\nIf you use a transpiler by default, you’ll always be able to make that \nswitch to newer syntax whenever you find it useful, rather than \nalways waiting for years for todays browsers to phase out.","metadata":{"loc":{"lines":{"from":4544,"to":4566}}}}],["126",{"pageContent":"If you use a transpiler by default, you’ll always be able to make that \nswitch to newer syntax whenever you find it useful, rather than \nalways waiting for years for todays browsers to phase out. \n\nThere are quite a few great transpilers for you to choose from. Here \nare some good options at the time of this writing: \n\nBabel (formerly 6to5) \n\nTranspiles ES6+ into ES5 \n\nTraceur \n\nTranspiles ES6, ES7, and beyond into ES5 \n\nNon-JavaScript \n\nSo far, the only things we’ve covered are in the JS language itself. The \nreality is that most JS is written to run in and interact with environ¬ \nments like browsers. A good chunk of the stuff that you write in \nyour code is, strictly speaking, not directly controlled by JavaScript. \nThat probably sounds a little strange. \n\nThe most common non-JavaScript JavaScript you’ll encounter is the \nDOM API. For example: \n\nvar el = document. getElenentByID( \"foo\" );","metadata":{"loc":{"lines":{"from":4566,"to":4592}}}}],["127",{"pageContent":"The most common non-JavaScript JavaScript you’ll encounter is the \nDOM API. For example: \n\nvar el = document. getElenentByID( \"foo\" ); \n\nThe document variable exists as a global variable when your code is \nrunning in a browser. It’s not provided by the JS engine, nor is it \nparticularly controlled by the JavaScript specification. It takes the \nform of something that looks an awful lot like a normal JS object, \nbut it’s not really exactly that. It’s a special object, often called a \n“host object.” \n\nMoreover, the getElementByID(..) method on document looks like \na normal JS function, but it’s just a thinly exposed interface to a \nbuilt-in method provided by the DOM from your browser. In some \n(newer-generation) browsers, this layer may also be in JS, but tradi¬ \ntionally the DOM and its behavior is implemented in something \nmore like C/C++. \n\nAnother example is with input/output (I/O).","metadata":{"loc":{"lines":{"from":4592,"to":4611}}}}],["128",{"pageContent":"Another example is with input/output (I/O). \n\nEveryone’s favorite alert(..) pops up a message box in the user’s \nbrowser window. alert(..) is provided to your JS program by the \nbrowser, not by the JS engine itself. The call you make sends the \n\n\n58 | Chapter 2: Into JavaScript \n\n\n\nmessage to the browser internals and it handles drawing and dis¬ \nplaying the message box. \n\nThe same goes with console.log( ..); your browser provides such \nmechanisms and hooks them up to the developer tools. \n\nThis book, and this whole series, focuses on JavaScript the language. \nThat’s why you don’t see any substantial coverage of these non- \nJavaScript JavaScript mechanisms. Nevertheless, you need to be \naware of them, as they’ll be in every JS program you write! \n\nReview \n\nThe first step to learning JavaScript’s flavor of programming is to get \na basic understanding of its core mechanisms like values, types, \nfunction closures, this, and prototypes.","metadata":{"loc":{"lines":{"from":4611,"to":4637}}}}],["129",{"pageContent":"Review \n\nThe first step to learning JavaScript’s flavor of programming is to get \na basic understanding of its core mechanisms like values, types, \nfunction closures, this, and prototypes. \n\nOf course, each of these topics deserves much greater coverage than \nyou’ve seen here, but that’s why they have chapters and books dedi¬ \ncated to them throughout the rest of this series. After you feel pretty \ncomfortable with the concepts and code samples in this chapter, the \nrest of the series awaits you to really dig in and get to know the lan¬ \nguage deeply. \n\nThe final chapter of this book will briefly summarize each of the \nother titles in the series and the other concepts they cover besides \nwhat we’ve already explored. \n\n\nReview | 59 \n\n\n\nCHAPTER 3 \n\n\nInto YDKJS","metadata":{"loc":{"lines":{"from":4637,"to":4662}}}}],["130",{"pageContent":"Review | 59 \n\n\n\nCHAPTER 3 \n\n\nInto YDKJS \n\n\nWhat is this series all about? Put simply, it’s about taking seriously \nthe task of learning all parts of JavaScript, not just some subset of the \nlanguage that someone called “the good parts,” and not just what¬ \never minimal amount you need to get your job done at work. \n\nSerious developers in other languages expect to put in the effort to \nlearn most or all of the language(s) they primarily write in, but JS \ndevelopers seem to stand out from the crowd in the sense of typi¬ \ncally not learning very much of the language. This is not a good \nthing, and it’s not something we should continue to allow to be the \nnorm. \n\nThe You Don’t Know JS (YDKJS) series stands in stark contrast to the \ntypical approaches to learning JS, and is unlike almost any other JS \nbooks you will read. It challenges you to go beyond your comfort \nzone and to ask the deeper “why” questions for every single behav¬ \nior you encounter. Are you up for that challenge?","metadata":{"loc":{"lines":{"from":4662,"to":4688}}}}],["131",{"pageContent":"I’m going to use this final chapter to briefly summarize what to \nexpect from the rest of the books in the series, and how to most \neffectively go about building a foundation of JS learning on top of \nYDKJS. \n\nScope & Closures \n\nPerhaps one of the most fundamental things you’ll need to quickly \ncome to terms with is how scoping of variables really works in Java¬ \nScript. It’s not enough to have anecdotal fuzzy beliefs about scope. \n\n\n61 \n\n\n\n\nThe Scope & Closures title starts by debunking the common miscon¬ \nception that JS is an “interpreted language” and therefore not com¬ \npiled. Nope. \n\nThe JS engine compiles your code right before (and sometimes dur¬ \ning!) execution. So we use some deeper understanding of the com¬ \npiler’s approach to our code to understand how it finds and deals \nwith variable and function declarations. Along the way, we see the \ntypical metaphor for JS variable scope management, “hoisting.”","metadata":{"loc":{"lines":{"from":4690,"to":4715}}}}],["132",{"pageContent":"This critical understanding of “lexical scope” is what we then base \nour exploration of closure on for the last chapter of the book. Clo¬ \nsure is perhaps the single most important concept in all of JS, but if \nyou haven’t first grasped firmly how scope works, closure will likely \nremain beyond your grasp. \n\nOne important application of closure is the module pattern, as we \nbriefly introduced in this book in Chapter 2. The module pattern is \nperhaps the most prevalent code organization pattern in all of Java¬ \nScript; deep understanding of it should be one of your highest prior¬ \nities. \n\nthis & Object Prototypes \n\nPerhaps one of the most widespread and persistent mistruths about \nJavaScript is that the this keyword refers to the function it appears \nin. Terribly mistaken. \n\nThe this keyword is dynamically bound based on how the function \nin question is executed, and it turns out there are four simple rules \nto understand and fully determine this binding.","metadata":{"loc":{"lines":{"from":4717,"to":4737}}}}],["133",{"pageContent":"The this keyword is dynamically bound based on how the function \nin question is executed, and it turns out there are four simple rules \nto understand and fully determine this binding. \n\nClosely related to the this keyword is the object prototype mecha¬ \nnism, which is a look-up chain for properties, similar to how lexical \nscope variables are found. But wrapped up in the prototypes is the \nother huge miscue about JS: the idea of emulating (fake) classes and \n(so-called “prototypal”) inheritance. \n\nUnfortunately, the desire to bring class and inheritance design pat¬ \ntern thinking to JavaScript is just about the worst thing you could \ntry to do, because while the syntax may trick you into thinking \nthere’s something like classes present, in fact the prototype mecha¬ \nnism is fundamentally opposite in its behavior. \n\n\n62 | Chapter 3: Into YDKJS","metadata":{"loc":{"lines":{"from":4737,"to":4754}}}}],["134",{"pageContent":"62 | Chapter 3: Into YDKJS \n\n\n\n\nWhat’s at issue is whether it’s better to ignore the mismatch and pre¬ \ntend that what you’re implementing is “inheritance,” or whether it’s \nmore appropriate to learn and embrace how the object prototype \nsystem actually works. The latter is more appropriately named \n“behavior delegation.” \n\nThis is more than syntactic preference. Delegation is an entirely dif¬ \nferent, and more powerful, design pattern, one that replaces the \nneed to design with classes and inheritance. But these assertions will \nabsolutely fly in the face of nearly every other blog post, book, and \nconference talk on the subject for the entirety of JavaScript’s lifetime. \n\nThe claims I make regarding delegation versus inheritance come not \nfrom a dislike of the language and its syntax, but from the desire to \nsee the true capability of the language properly leveraged and the \nendless confusion and frustration wiped away.","metadata":{"loc":{"lines":{"from":4754,"to":4774}}}}],["135",{"pageContent":"But the case I make regarding prototypes and delegation is a much \nmore involved one than what I will indulge here. If you’re ready to \nreconsider everything you think you know about JavaScript “classes” \nand “inheritance,” I offer you the chance to “take the red pill” (The \nMatrix, 1999) and check out Chapters 4-6 of the this & Object Proto¬ \ntypes title of this series. \n\nTypes & Grammar \n\nThe third title in this series primarily focuses on tackling yet another \nhighly controversial topic: type coercion. Perhaps no topic causes \nmore frustration with JS developers than when you talk about the \nconfusions surrounding implicit coercion.","metadata":{"loc":{"lines":{"from":4776,"to":4788}}}}],["136",{"pageContent":"By far, the conventional wisdom is that implicit coercion is a “bad \npart” of the language and should be avoided at all costs. In fact, \nsome have gone so far as to call it a “flaw” in the design of the lan¬ \nguage. Indeed, there are tools whose entire job is to do nothing but \nscan your code and complain if you’re doing anything even remotely \nlike coercion. \n\nBut is coercion really so confusing, so bad, so treacherous, that your \ncode is doomed from the start if you use it? \n\nI say no. After having built up an understanding of how types and \nvalues really work in Chapters 1-3, Chapter 4 takes on this debate \nand fully explains how coercion works, in all its nooks and crevices. \n\n\nTypes & Grammar | 63 \n\n\n\nWe see just what parts of coercion really are surprising and what \nparts actually make complete sense if given the time to learn.","metadata":{"loc":{"lines":{"from":4790,"to":4810}}}}],["137",{"pageContent":"Types & Grammar | 63 \n\n\n\nWe see just what parts of coercion really are surprising and what \nparts actually make complete sense if given the time to learn. \n\nBut I’m not merely suggesting that coercion is sensible and learna- \nble; I’m asserting that coercion is an incredibly useful and totally \nunderestimated tool that you should be using in your code. I’m saying \nthat coercion, when used properly, not only works, but makes your \ncode better. All the naysayers and doubters will surely scoff at such a \nposition, but I believe it’s one of the main keys to upping your JS \ngame. \n\nDo you want to just keep following what the crowd says, or are you \nwilling to set all the assumptions aside and look at coercion with a \nfresh perspective? The Types & Grammar title of this series will \ncoerce your thinking. \n\nAsync & Performance","metadata":{"loc":{"lines":{"from":4810,"to":4830}}}}],["138",{"pageContent":"Async & Performance \n\nThe first three titles of this series focus on the core mechanics of the \nlanguage, but the fourth title branches out slightly to cover patterns \non top of the language mechanics for managing asynchronous pro¬ \ngramming. Asynchrony is not only critical to the performance of \nour applications, it’s increasingly becoming the critical factor in \nwritability and maintainability. \n\nThe book starts first by clearing up a lot of terminology and concept \nconfusion around things like “async,” “parallel,” and “concurrent,” \nand explains in depth how such things do and do not apply to JS. \n\nThen we move into examining callbacks as the primary method of \nenabling asynchrony. But it’s here that we quickly see that the call¬ \nback alone is hopelessly insufficient for the modern demands of \nasynchronous programming. We identify two major deficiencies of \ncallbacks-only coding: Inversion of Control (IoC) trust loss and lack \nof linear reason-ability.","metadata":{"loc":{"lines":{"from":4830,"to":4848}}}}],["139",{"pageContent":"To address these two major deficiencies, ES6 introduces two new \nmechanisms (and indeed, patterns): promises and generators. \n\nPromises are a time-independent wrapper around a “future value,” \nwhich lets you reason about and compose them regardless of if the \nvalue is ready or not yet. Moreover, they effectively solve the IoC \ntrust issues by routing callbacks through a trustable and composable \npromise mechanism. \n\n\n64 | Chapter 3: Into YDKJS \n\n\n\n\nGenerators introduce a new mode of execution for JS functions, \nwhereby the generator can be paused at yield points and be \nresumed asynchronously later. The pause-and-resume capability \nenables synchronous, sequential-looking code in the generator to be \nprocessed asynchronously behind the scenes. By doing so, we \naddress the non-linear, non-local-jump confusions of callbacks and \nthereby make our asynchronous code sync-looking so as to be more \nreason-able.","metadata":{"loc":{"lines":{"from":4850,"to":4872}}}}],["140",{"pageContent":"But it’s the combination of promises and generators that “yields” our \nmost effective asynchronous coding pattern to date in JavaScript. In \nfact, much of the future sophistication of asynchrony coming in ES7 \nand later will certainly be built on this foundation. To be serious \nabout programming effectively in an async world, you’re going to \nneed to get really comfortable with combining promises and genera¬ \ntors. \n\nIf promises and generators are about expressing patterns that let our \nprograms run more concurrently and thus get more processing \naccomplished in a shorter period, JS has many other facets of perfor¬ \nmance optimization worth exploring.","metadata":{"loc":{"lines":{"from":4874,"to":4885}}}}],["141",{"pageContent":"Chapter 5 delves into topics like program parallelism with Web \nWorkers and data parallelism with SIMD, as well as low-level opti¬ \nmization techniques like ASM.js. Chapter 6 takes a look at perfor¬ \nmance optimization from the perspective of proper benchmarking \ntechniques, including what kinds of performance to worry about \nand what to ignore. \n\nWriting JavaScript effectively means writing code that can break the \nconstraint barriers of being run dynamically in a wide range of \nbrowsers and other environments. It requires a lot of intricate and \ndetailed planning and effort on our parts to take a program from “it \nworks” to “it works well.” \n\nThe Async & Performance title is designed to give you all the tools \nand skills you need to write reasonable and performant JavaScript \ncode. \n\nES6 & Beyond","metadata":{"loc":{"lines":{"from":4887,"to":4904}}}}],["142",{"pageContent":"The Async & Performance title is designed to give you all the tools \nand skills you need to write reasonable and performant JavaScript \ncode. \n\nES6 & Beyond \n\nNo matter how much you feel you’ve mastered JavaScript to this \npoint, the truth is that JavaScript is never going to stop evolving, and \nmoreover, the rate of evolution is increasing rapidly. This fact is \n\n\nES6 & Beyond | 65 \n\n\n\nalmost a metaphor for the spirit of this series, to embrace that we’ll \nnever fully know every part of JS, because as soon as you master it \nall, there’s going to be new stuff coming down the line that you’ll \nneed to learn. \n\nThis title is dedicated to both the short- and mid-term visions of \nwhere the language is headed, not just the known stuff like ES6 but \nthe likely stuff beyond.","metadata":{"loc":{"lines":{"from":4904,"to":4926}}}}],["143",{"pageContent":"This title is dedicated to both the short- and mid-term visions of \nwhere the language is headed, not just the known stuff like ES6 but \nthe likely stuff beyond. \n\nWhile all the titles of this series embrace the state of JavaScript at the \ntime of this writing, which is midway through ES6 adoption, the pri¬ \nmary focus in the series has been more on ES5. Now, we want to \nturn our attention to ES6, ES7, and beyond... \n\nSince ES6 is nearly complete at the time of this writing, ES6 & \nBeyond starts by dividing up the concrete stuff from the ES6 land¬ \nscape into several key categories, including new syntax, new data \nstructures (collections), and new processing capabilities and APIs. \nWe cover each of these new ES6 features, in varying levels of detail, \nincluding reviewing details that are touched on in other books of \nthis series.","metadata":{"loc":{"lines":{"from":4926,"to":4941}}}}],["144",{"pageContent":"Some exciting ES6 things to look forward to reading about: destruc¬ \nturing, default parameter values, symbols, concise methods, compu¬ \nted properties, arrow functions, block scoping, promises, generators, \niterators, modules, proxies, weakmaps, and much, much more! \nPhew, ES6 packs quite a punch! \n\nThe first part of the book is a roadmap for all the stuff you need to \nlearn to get ready for the new and improved JavaScript you’ll be \nwriting and exploring over the next couple of years. \n\nThe latter part of the book turns attention to briefly glance at things \nthat we can likely expect to see in the near future of JavaScript. The \nmost important realization here is that post-ES6, JS is likely going to \nevolve feature by feature rather than version by version, which \nmeans we can expect to see these near-future things coming much \nsooner than you might imagine. \n\nThe future for JavaScript is bright. Isn’t it time we start learning it? \n\n\n66 | Chapter 3: Into YDKJS \n\n\n\n\n\nReview","metadata":{"loc":{"lines":{"from":4943,"to":4969}}}}],["145",{"pageContent":"The future for JavaScript is bright. Isn’t it time we start learning it? \n\n\n66 | Chapter 3: Into YDKJS \n\n\n\n\n\nReview \n\nThe YDKJS series is dedicated to the proposition that all JS develop¬ \ners can and should learn all of the parts of this great language. No \nperson’s opinion, no framework’s assumptions, and no project’s \ndeadline should be the excuse for why you never learn and deeply \nunderstand JavaScript. \n\nWe take each important area of focus in the language and dedicate a \nshort but very dense book to fully explore all the parts of it that you \nperhaps thought you knew but probably didn’t fully. \n\n“You Don’t Know JS” isn’t a criticism or an insult. It’s a realization \nthat all of us, myself included, must come to terms with. Learning \nJavaScript isn’t an end goal but a process. We don’t know JavaScript, \nyet. But we will! \n\n\nReview | 67 \n\n\n\nAbout the Author","metadata":{"loc":{"lines":{"from":4969,"to":5000}}}}],["146",{"pageContent":"Review | 67 \n\n\n\nAbout the Author \n\n\nKyle Simpson is an Open Web Evangelist from Austin, TX, who’s \npassionate about all things JavaScript. He’s an author, workshop \ntrainer, tech speaker, and OSS contributor/leader. \n\n\n\n\nScope and Closures \n\n\nKyle Simpson \n\n\nBeijing • Cambridge • Farnham • Koln • Sebastopol • Tokyo \n\n\nO REILLY \n\n\n\n\n\nTable of Contents \n\n\nForeword. v \n\nPreface.vii \n\n1. What Is Scope?. 1 \n\nCompiler Theory 1 \n\nUnderstanding Scope 3 \n\nNested Scope 8 \n\nErrors 10 \n\nReview 11 \n\n2. Lexical Scope. 13 \n\nLex-time 13 \n\nCheating Lexical 16 \n\nReview 21 \n\n3. Function Versus Block Scope. 23 \n\nScope From Functions 23 \n\nHiding in Plain Scope 24 \n\nFunctions as Scopes 28 \n\nBlocks as Scopes 33 \n\nReview 39 \n\n4. Hoisting. 41 \n\nChicken or the Egg? 41 \n\nThe Compiler Strikes Again 42 \n\nFunctions First 44 \n\n\niii \n\n\n\n\n\n\n\n\n\n\n\nReview \n\n\n46 \n\n\n5. Scope Closure. 47 \n\nEnlightenment 47 \n\nNitty Gritty 48 \n\nNow I Can See 51 \n\nLoops and Closure 53 \n\nModules 56 \n\nReview 63 \n\nA. Dynamic Scope. 65","metadata":{"loc":{"lines":{"from":5000,"to":5109}}}}],["147",{"pageContent":"iii \n\n\n\n\n\n\n\n\n\n\n\nReview \n\n\n46 \n\n\n5. Scope Closure. 47 \n\nEnlightenment 47 \n\nNitty Gritty 48 \n\nNow I Can See 51 \n\nLoops and Closure 53 \n\nModules 56 \n\nReview 63 \n\nA. Dynamic Scope. 65 \n\nB. Polyfilling Block Scope. 69 \n\nC. Lexical this.75 \n\n\niv | Table of Contents \n\n\n\n\n\n\n\nForeword \n\n\nWhen I was a young child, I would often enjoy taking things apart and \nputting them back together again—old mobile phones, hi-fi stereos, \nand anything else I could get my hands on. I was too young to really \nuse these devices, but whenever one broke, I would instantly ask if I \ncould figure out how it worked.","metadata":{"loc":{"lines":{"from":5109,"to":5163}}}}],["148",{"pageContent":"I remember once looking at a circuit board for an old radio. It had this \nweird long tube with copper wire wrapped around it. I couldn’t work \nout its purpose, but I immediately went into research mode. What does \nit do? Why is it in a radio? It doesn’t look like the other parts of the \ncircuit board, why? Why does it have copper wrapped around it? What \nhappens if I remove the copper?! Now I know it was a loop antenna, \nmade by wrapping copper wire around a ferrite rod, which are often \nused in transistor radios. \n\nDid you ever become addicted to figuring out all of the answers to \nevery why question? Most children do. In fact it is probably my favorite \nthing about children—their desire to learn.","metadata":{"loc":{"lines":{"from":5165,"to":5176}}}}],["149",{"pageContent":"Did you ever become addicted to figuring out all of the answers to \nevery why question? Most children do. In fact it is probably my favorite \nthing about children—their desire to learn. \n\nUnfortunately, now I’m considered a professional and spend my days \nmaking things. When I was young, I loved the idea of one day making \nthe things that I took apart. Of course, most things I make now are \nwith JavaScript and not ferrite rods.. .but close enough! However, de¬ \nspite once loving the idea of making things, I now find myself longing \nfor the desire to figure things out. Sure, I often figure out the best way \nto solve a problem or fix a bug, but I rarely take the time to question \nmy tools. \n\nAnd that is exactly why I am so excited about this “You Don’t Know \nJS” series of books. Because it’s right. I don’t know JS. I use JavaScript","metadata":{"loc":{"lines":{"from":5176,"to":5190}}}}],["150",{"pageContent":"And that is exactly why I am so excited about this “You Don’t Know \nJS” series of books. Because it’s right. I don’t know JS. I use JavaScript \n\n\n\n\nday in, day out and have done for many years, but do I really under¬ \nstand it? No. Sure, I understand a lot of it and I often read the specs \nand the mailing lists, but no, I don’t understand as much as my inner \nsix-year-old wishes I did. \n\nScope and Closures is a brilliant start to the series. It is very well targeted \nat people like me (and hopefully you, too). It doesn’t teach JavaScript \nas if you’ve never used it, but it does make you realize how little about \nthe inner workings you probably know. It is also coming out at the \nperfect time: ES6 is finally settling down and implementation across \nbrowsers is going well. If you’ve not yet made time for learning the \nnew features (such as let and const), this book will be a great intro¬ \nduction.","metadata":{"loc":{"lines":{"from":5190,"to":5208}}}}],["151",{"pageContent":"So I hope that you enjoy this book, but moreso, that Kyle’s way of \ncritically thinking about how every tiny bit of the language works will \ncreep into your mindset and general workflow. Instead of just using \nthe antenna, figure out how and why it works. \n\n—Shane Hudson \nwww.shanehudson.net \n\n\nvi | Foreword \n\n\n\nPreface \n\n\nI’m sure you noticed, but “JS” in the book series title is not an abbre¬ \nviation for words used to curse about JavaScript, though cursing at the \nlanguage’s quirks is something we can probably all identify with! \n\nFrom the earliest days of the Web, JavaScript has been a foundational \ntechnology that drives interactive experience around the content we \nconsume. While flickering mouse trails and annoying pop-up \nprompts may be where JavaScript started, nearly two decades later, the \ntechnology and capability of JavaScript has grown many orders of \nmagnitude, and few doubt its importance at the heart of the world’s \nmost widely available software platform: the Web.","metadata":{"loc":{"lines":{"from":5210,"to":5236}}}}],["152",{"pageContent":"But as a language, it has perpetually been a target for a great deal of \ncriticism, owing partly to its heritage but even more to its design phi¬ \nlosophy. Even the name evokes, as Brendan Eich once put it, “dumb \nkid brother” status next to its more mature older brother, Java. But the \nname is merely an accident of politics and marketing. The two lan¬ \nguages are vastly different in many important ways. “JavaScript” is as \nrelated to “Java” as “Carnival” is to “Car.” \n\nBecause JavaScript borrows concepts and syntax idioms from several \nlanguages, including proud C-style procedural roots as well as subtle, \nless obvious Scheme/Lisp-style functional roots, it is exceedingly ap¬ \nproachable to a broad audience of developers, even those with just \nlittle to no programming experience. The “Hello World” of JavaScript \nis so simple that the language is inviting and easy to get comfortable \nwith in early exposure.","metadata":{"loc":{"lines":{"from":5238,"to":5252}}}}],["153",{"pageContent":"While JavaScript is perhaps one of the easiest languages to get up and \nrunning with, its eccentricities make solid mastery of the language a \n\n\nVII \n\n\n\n\nvastly less common occurrence than in many other languages. Where \nit takes a pretty in-depth knowledge of a language like C or C++ to \nwrite a full-scale program, full-scale production JavaScript can, and \noften does, barely scratch the surface of what the language can do. \n\nSophisticated concepts that are deeply rooted into the language tend \ninstead to surface themselves in seemingly simplistic ways, such as \npassing around functions as callbacks, which encourages the Java¬ \nScript developer to just use the language as-is and not worry too much \nabout what’s going on under the hood. \n\nIt is simultaneously a simple, easy-to-use language that has broad ap¬ \npeal and a complex and nuanced collection of language mechanics that \nwithout careful study will elude true understanding even for the most \nseasoned of JavaScript developers.","metadata":{"loc":{"lines":{"from":5254,"to":5277}}}}],["154",{"pageContent":"Therein lies the paradox of JavaScript, the Achilles’ heel of the lan¬ \nguage, the challenge we are presently addressing. Because JavaScript \nca n be used without understanding, the understanding of the language \nis often never attained. \n\nMission \n\nIf at every point that you encounter a surprise or frustration in Java¬ \nScript, your response is to add it to the blacklist, as some are accus¬ \ntomed to doing, you soon will be relegated to a hollow shell of the \nrichness of JavaScript. \n\nWhile this subset has been famoulsy dubbed “The Good Parts,” I would \nimplore you, dear reader, to instead consider it the “The Easy Parts,” \n“The Safe Parts,” or even “The Incomplete Parts.” \n\nThis “You Don’t Know JavaScript” book series offers a contrary chal¬ \nlenge: learn and deeply understand all of JavaScript, even and espe¬ \ncially “The Tough Parts.”","metadata":{"loc":{"lines":{"from":5279,"to":5297}}}}],["155",{"pageContent":"This “You Don’t Know JavaScript” book series offers a contrary chal¬ \nlenge: learn and deeply understand all of JavaScript, even and espe¬ \ncially “The Tough Parts.” \n\nHere, we address head on the tendency of JS developers to learn “just \nenough” to get by, without ever forcing themselves to learn exactly \nhow and why the language behaves the way it does. Furthermore, we \neschew the common advice to retreat when the road gets rough. \n\nI am not content, nor should you be, at stopping once something just \nworks, and not really knowing why. I gently challenge you to journey \ndown that bumpy “road less traveled” and embrace all that JavaScript \nis and can do. With that knowledge, no technique, no framework, no \n\n\nviii | Preface \n\n\n\npopular buzzword acronym of the week, will be beyond your under¬ \nstanding.","metadata":{"loc":{"lines":{"from":5297,"to":5317}}}}],["156",{"pageContent":"viii | Preface \n\n\n\npopular buzzword acronym of the week, will be beyond your under¬ \nstanding. \n\nThese books each take on specific core parts of the language that are \nmost commonly misunderstood or under-understood, and dive very \ndeep and exhaustively into them. You should come away from reading \nwith a firm confidence in your understanding, not just of the theo¬ \nretical, but the practical “what you need to know” bits. \n\nThe JavaScript you know right now is probably parts handed down to \nyou by others who’ve been burned by incomplete understanding. That \nJavaScript is but a shadow of the true language. You don’t really know \nJavaScript, yet, but if you dig into this series, you will. Read on, my \nfriends. JavaScript awaits you. \n\n\nReview","metadata":{"loc":{"lines":{"from":5317,"to":5337}}}}],["157",{"pageContent":"Review \n\nJavaScript is awesome. It’s easy to learn partially, but much harder to \nlearn completely (or even sufficiently). When developers encounter \nconfusion, they usually blame the language instead of their lack of \nunderstanding. These books aim to fix that, inspiring a strong appre¬ \nciation for the language you can now, and should, deeply know. \n\n\n\nMany of the examples in this book assume modern (and future- \nreaching) JavaScript engine environments, such as ECMA- \nScript version 6 (ES6). Some code may not work as described \nif run in older (pre-ES6) environments. \n\n\nConventions Used in This Book \n\nThe following typographical conventions are used in this book: \n\nItalic \n\nIndicates new terms, URLs, email addresses, filenames, and file \nextensions. \n\nConstant width \n\nUsed for program listings, as well as within paragraphs to refer to \nprogram elements such as variable or function names, databases, \ndata types, environment variables, statements, and keywords. \n\n\nPreface | ix","metadata":{"loc":{"lines":{"from":5337,"to":5369}}}}],["158",{"pageContent":"Preface | ix \n\n\n\n\n\n\nConstant width bold \n\nShows commands or other text that should be typed literally by \nthe user. \n\nConstant width italic \n\nShows text that should be replaced with user-supplied values or \nby values determined by context. \n\nThis element signifies a tip or suggestion. \n\n\n\n\nUsing Code Examples \n\nSupplemental material (code examples, exercises, etc.) is available for \ndownload at http://bit.ly/lc8HEWF.","metadata":{"loc":{"lines":{"from":5369,"to":5394}}}}],["159",{"pageContent":"This element signifies a tip or suggestion. \n\n\n\n\nUsing Code Examples \n\nSupplemental material (code examples, exercises, etc.) is available for \ndownload at http://bit.ly/lc8HEWF. \n\nThis book is here to help you get your job done. In general, if example \ncode is offered with this book, you may use it in your programs and \ndocumentation. You do not need to contact us for permission unless \nyou’re reproducing a significant portion of the code. For example, \nwriting a program that uses several chunks of code from this book \ndoes not require permission. Selling or distributing a CD-ROM of \nexamples from O’Reilly books does require permission. Answering a \nquestion by citing this book and quoting example code does not re¬ \nquire permission. Incorporating a significant amount of example code \nfrom this book into your product’s documentation does require per¬ \nmission. \n\n\nx | Preface","metadata":{"loc":{"lines":{"from":5394,"to":5417}}}}],["160",{"pageContent":"x | Preface \n\n\n\n\n\n\n\n\n\nWe appreciate, but do not require, attribution. An attribution usually \nincludes the title, author, publisher, and ISBN. For example: “Scope \nand Closures by Kyle Simpson (O’Reilly). Copyright 2014 Kyle Simp¬ \nson, 978-1-449-33558-8.” \n\nIf you feel your use of code examples falls outside fair use or the per¬ \nmission given above, feel free to contact us at permissions@oreilly.com. \n\n\nSafari* Books Online \n\n_ _ Safari Books Online is an on-demand digital li- \n\n^3 | 3 brary that delivers expert content in both book and \n\nvideo form from the world’s leading authors in \ntechnology and business. \n\n\nBooks Online \n\n\nTechnology professionals, software developers, web designers, and \nbusiness and creative professionals use Safari Books Online as their \nprimary resource for research, problem solving, learning, and certif¬ \nication training.","metadata":{"loc":{"lines":{"from":5417,"to":5452}}}}],["161",{"pageContent":"Safari Books Online offers a range of product mixes and pricing pro¬ \ngrams for organizations, government agencies, and individuals. Sub¬ \nscribers have access to thousands of books, training videos, and pre¬ \npublication manuscripts in one fully searchable database from pub¬ \nlishers like O’Reilly Media, Prentice Hall Professional, Addison- \nWesley Professional, Microsoft Press, Sams, Que, Peachpit Press, Focal \nPress, Cisco Press, John Wiley & Sons, Syngress, Morgan Kaufmann, \nIBM Redbooks, Packt, Adobe Press, FT Press, Apress, Manning, New \nRiders, McGraw-Hill, Jones & Bartlett, Course Technology, and doz¬ \nens more. For more information about Safari Books Online, please \nvisit us online. \n\n\nHow to Contact Us \n\nPlease address comments and questions concerning this book to the \npublisher: \n\nO’Reilly Media, Inc. \n\n1005 Gravenstein Highway North \nSebastopol, CA 95472 \n\n800-998-9938 (in the United States or Canada) \n\n707-829-0515 (international or local) \n\n707-829-0104 (fax)","metadata":{"loc":{"lines":{"from":5455,"to":5482}}}}],["162",{"pageContent":"O’Reilly Media, Inc. \n\n1005 Gravenstein Highway North \nSebastopol, CA 95472 \n\n800-998-9938 (in the United States or Canada) \n\n707-829-0515 (international or local) \n\n707-829-0104 (fax) \n\n\nPreface | xi \n\n\n\n\nWe have a web page for this book, where we list errata, examples, and \nany additional information. You can access this page at http://oreil.ly/ \nJS_scope_and_closures. \n\nTo comment or ask technical questions about this book, send email to \nbookquestions@oreilly.com. \n\nFor more information about our books, courses, conferences, and \nnews, see our website at http://www.oreilly.com. \n\nFind us on Facebook: http://facebook.com/oreilly \n\nFollow us on Twitter: http://twitter.com/oreillymedia \n\nWatch us on YouTube: http://www.youtube.com/oreillymedia \n\nCheck out the full You Don’t Know JS series: http://YouDont \nKnowJS.com \n\n\nxii | Preface \n\n\n\nCHAPTER 1 \n\n\nWhat Is Scope?","metadata":{"loc":{"lines":{"from":5482,"to":5526}}}}],["163",{"pageContent":"Watch us on YouTube: http://www.youtube.com/oreillymedia \n\nCheck out the full You Don’t Know JS series: http://YouDont \nKnowJS.com \n\n\nxii | Preface \n\n\n\nCHAPTER 1 \n\n\nWhat Is Scope? \n\n\nOne of the most fundamental paradigms of nearly all programming \nlanguages is the ability to store values in variables, and later retrieve \nor modify those values. In fact, the ability to store values and pull \nvalues out of variables is what gives a program state. \n\nWithout such a concept, a program could perform some tasks, but \nthey would be extremely limited and not terribly interesting. \n\nBut the inclusion of variables into our program begets the most in¬ \nteresting questions we will now address: where do those variables \nlive 7 . In other words, where are they stored? And, most important, how \ndoes our program find them when it needs them?","metadata":{"loc":{"lines":{"from":5526,"to":5553}}}}],["164",{"pageContent":"These questions speak to the need for a well-defined set of rules for \nstoring variables in some location, and for finding those variables at a \nlater time. We’ll call that set of rules: scope. \n\nBut, where and how do these scope rules get set? \n\nCompiler Theory \n\nIt may be self-evident, or it may be surprising, depending on your level \nof interaction with various languages, but despite the fact that Java¬ \nScript falls under the general category of “dynamic” or “interpreted” \nlanguages, it is in fact a compiled language. It is not compiled well in \nadvance, as are many traditionally compiled languages, nor are the \nresults of compilation portable among various distributed systems. \n\n\n1 \n\n\n\n\n\nBut, nevertheless, the JavaScript engine performs many of the same \nsteps, albeit in more sophisticated ways than we may commonly be \naware, of any traditional language compiler.","metadata":{"loc":{"lines":{"from":5555,"to":5579}}}}],["165",{"pageContent":"1 \n\n\n\n\n\nBut, nevertheless, the JavaScript engine performs many of the same \nsteps, albeit in more sophisticated ways than we may commonly be \naware, of any traditional language compiler. \n\nIn traditional compiled-language process, a chunk of source code, \nyour program, will undergo typically three steps before it is executed, \nroughly called “compilation”: \n\nTokenizi ng/Lexi ng \n\nBreaking up a string of characters into meaningful (to the lan¬ \nguage) chunks, called tokens. For instance, consider the program \nvar a = 2;. This program would likely be broken up into the \nfollowing tokens: var, a, =, 2, and ;. Whitespace may or may not \nbe persisted as a token, depending on whether its meaningful or \nnot.","metadata":{"loc":{"lines":{"from":5579,"to":5600}}}}],["166",{"pageContent":"The difference between tokenizing and lexing is subtle and \nacademic, but it centers on whether or not these tokens \nare identified in a stateless or stateful way. Put simply, if \nthe tokenizer were to invoke stateful parsing rules to fig¬ \nure out whether a should be considered a distinct token \nor just part of another token, that would be lexing. \n\n\nParsing \n\ntaking a stream (array) of tokens and turning it into a tree of nested \nelements, which collectively represent the grammatical structure \nof the program. This tree is called an “AST” (abstract syntax tree). \n\nThe tree for va r a = 2; might start with a top-level node called \nVariableDeclaration, with a child node called Identifier \n(whose value is a), and another child called AssignmentExpres \nsion, which itself has a child called Nume ricLite ral (whose value \nis 2). \n\nCode-Generation","metadata":{"loc":{"lines":{"from":5604,"to":5624}}}}],["167",{"pageContent":"Code-Generation \n\nThe process of taking an AST and turning it into executable code. \nThis part varies greatly depending on the language, the platform \nit’s targeting, and so on. \n\nSo, rather than get mired in details, we’ll just handwave and say \nthat there’s a way to take our previously described AST for var a \n= 2; and turn it into a set of machine instructions to actually create \n\n\n2 | Chapter 1: What Is Scope? \n\n\n\n\n\n\na variable called a (including reserving memory, etc.), and then \nstore a value into a. \n\n\n\nThe details of how the engine manages system resources \nare deeper than we will dig, so we’ll just take it for gran¬ \nted that the engine is able to create and store variables as \nneeded.","metadata":{"loc":{"lines":{"from":5624,"to":5650}}}}],["168",{"pageContent":"The details of how the engine manages system resources \nare deeper than we will dig, so we’ll just take it for gran¬ \nted that the engine is able to create and store variables as \nneeded. \n\n\nThe JavaScript engine is vastly more complex than just those three \nsteps, as are most other language compilers. For instance, in the \nprocess of parsing and code-generation, there are certainly steps to \noptimize the performance of the execution, including collapsing re¬ \ndundant elements, etc. \n\nSo, I’m painting only with broad strokes here. But I think you’ll see \nshortly why these details we do cover, even at a high level, are relevant. \n\nFor one thing, JavaScript engines don’t get the luxury (like other lan¬ \nguage compilers) of having plenty of time to optimize, because Java¬ \nScript compilation doesn’t happen in a build step ahead of time, as \nwith other languages.","metadata":{"loc":{"lines":{"from":5650,"to":5668}}}}],["169",{"pageContent":"For JavaScript, the compilation that occurs happens, in many cases, \nmere microseconds (or less!) before the code is executed. To ensure \nthe fastest performance, JS engines use all kinds of tricks (like JITs, \nwhich lazy compile and even hot recompile, etc.) that are well beyond \nthe “scope” of our discussion here. \n\nLet’s just say, for simplicity sake, that any snippet of JavaScript has to \nbe compiled before (usually right before!) it’s executed. So, the JS com¬ \npiler will take the program var a = 2; and compile it first, and then \nbe ready to execute it, usually right away. \n\nUnderstanding Scope \n\nThe way we will approach learning about scope is to think of the pro¬ \ncess in terms of a conversation. But, who is having the conversation? \n\nThe Cast \n\nLet’s meet the cast of characters that interact to process the program \nvar a = 2 ;, so we understand their conversations that we’ll listen in \non shortly: \n\n\nUnderstanding Scope | 3 \n\n\n\n\nEngine","metadata":{"loc":{"lines":{"from":5670,"to":5698}}}}],["170",{"pageContent":"Let’s meet the cast of characters that interact to process the program \nvar a = 2 ;, so we understand their conversations that we’ll listen in \non shortly: \n\n\nUnderstanding Scope | 3 \n\n\n\n\nEngine \n\nResponsible for start-to-finish compilation and execution of our \nJavaScript program. \n\nCompiler \n\nOne of Engine’s friends; handles all the dirty work of parsing and \ncode-generation (see previous section). \n\nScope \n\nAnother friend of Engine; collects and maintains a look-up list of \nall the declared identifiers (variables), and enforces a strict set of \nrules as to how these are accessible to currently executing code. \n\nFor you to fully understand how JavaScript works, you need to begin \nto think like Engine (and friends) think, ask the questions they ask, \nand answer those questions the same. \n\nBack and Forth","metadata":{"loc":{"lines":{"from":5698,"to":5728}}}}],["171",{"pageContent":"For you to fully understand how JavaScript works, you need to begin \nto think like Engine (and friends) think, ask the questions they ask, \nand answer those questions the same. \n\nBack and Forth \n\nWhen you see the program var a = 2;, you most likely think of that \nas one statement. But that’s not how our new friend Engine sees it. In \nfact, Engine sees two distinct statements, one that Compiler will handle \nduring compilation, and one that Engine will handle during execution. \n\nSo, let’s break down how Engine and friends will approach the program \nvar a = 2;. \n\nThe first thing Compiler will do with this program is perform lexing \nto break it down into tokens, which it will then parse into a tree. But \nwhen Compiler gets to code generation, it will treat this program \nsomewhat differently than perhaps assumed.","metadata":{"loc":{"lines":{"from":5728,"to":5745}}}}],["172",{"pageContent":"A reasonable assumption would be that Compiler will produce code \nthat could be summed up by this pseudocode: “Allocate memory for \na variable, label it a, then stick the value 2 into that variable.” Unfortu¬ \nnately, that’s not quite accurate. \n\nCompiler will instead proceed as: \n\n1. Encountering var a, Compiler asks Scope to see if a variable a \nalready exists for that particular scope collection. If so, Compiler \nignores this declaration and moves on. Otherwise, Compiler asks \nScope to declare a new variable called a for that scope collection. \n\n2. Compiler then produces code for Engine to later execute, to han¬ \ndle the a = 2 assignment. The code Engine runs will first ask Scope \n\n\n4 | Chapter 1: What Is Scope? \n\n\n\nif there is a variable called a accessible in the current scope col¬ \nlection. If so, Engine uses that variable. If not, Engine looks else¬ \nwhere (see “Nested Scope” on page 8).","metadata":{"loc":{"lines":{"from":5747,"to":5769}}}}],["173",{"pageContent":"if there is a variable called a accessible in the current scope col¬ \nlection. If so, Engine uses that variable. If not, Engine looks else¬ \nwhere (see “Nested Scope” on page 8). \n\nIf Engine eventually finds a variable, it assigns the value 2 to it. If not, \nEngine will raise its hand and yell out an error! \n\nTo summarize: two distinct actions are taken for a variable assignment: \nFirst, Compiler declares a variable (if not previously declared) in the \ncurrent Scope, and second, when executing, Engine looks up the vari¬ \nable in Scope and assigns to it, if found. \n\nCompiler Speak \n\nWe need a little bit more compiler terminology to proceed further with \nunderstanding. \n\nWhen Engine executes the code that Compiler produced for step 2, it \nhas to look up the variable a to see if it has been declared, and this \nlook-up is consulting Scope. But the type of look-up Engine performs \naffects the outcome of the look-up.","metadata":{"loc":{"lines":{"from":5769,"to":5789}}}}],["174",{"pageContent":"In our case, it is said that Engine would be performing an LHS look¬ \nup for the variable a. The other type of look-up is called RHS. \n\nI bet you can guess what the “L” and “R” mean. These terms stand for \nlefthand side and righthand side. \n\nSide.. .of what? Of an assignment operation. \n\nIn other words, an LHS look-up is done when a variable appears on \nthe lefthand side of an assignment operation, and an RHS look-up is \ndone when a variable appears on the righthand side of an assignment \noperation. \n\nActually, let’s be a little more precise. An RHS look-up is indistin¬ \nguishable, for our purposes, from simply a look-up of the value of some \nvariable, whereas the LHS look-up is trying to find the variable con¬ \ntainer itself, so that it can assign. In this way, RHS doesn’t really mean \n“righthand side of an assignment” per se, it just, more accurately, \nmeans “not lefthand side”.","metadata":{"loc":{"lines":{"from":5791,"to":5809}}}}],["175",{"pageContent":"Being slightly glib for a moment, you could think RHS instead means \n“retrieve his/her source (value),” implying that RHS means “go get the \nvalue of...” \n\n\nUnderstanding Scope | 5 \n\n\n\nLet’s dig into that deeper. \n\nWhen I say: \n\nconsole.log ( a ); \n\nThe reference to a is an RHS reference, because nothing is being as¬ \nsigned to a here. Instead, we’re looking up to retrieve the value of a, \nso that the value can be passed to console, log(..). \n\nBy contrast: \n\na = 2; \n\nThe reference to a here is an LHS reference, because we don’t actually \ncare what the current value is, we simply want to find the variable as \na target for the = 2 assignment operation.","metadata":{"loc":{"lines":{"from":5811,"to":5836}}}}],["176",{"pageContent":"a = 2; \n\nThe reference to a here is an LHS reference, because we don’t actually \ncare what the current value is, we simply want to find the variable as \na target for the = 2 assignment operation. \n\n\n\nLHS and RHS meaning “left/righthand side of an assigment” \ndoesn’t necessarily literally mean “left/right side of the = as¬ \nsignment operator.” There are several other ways that assign¬ \nments happen, and so it’s better to conceptually think about it \nas: “Who’s the target of the assignment (LHS)?” and “Who’s the \nsource of the assignment (RHS)?” \n\n\nConsider this program, which has both LHS and RHS references: \n\nfunction foo(a) { \n\nconsole.log( a ); // 2 \n\n} \n\nfoo( 2 ); \n\nThe last line that invokes foo( ..) as a function call requires an RHS \nreference to f oo, meaning, “Go look up the value of f oo, and give it to \nme.” Moreover, (..) means the value of f oo should be executed, so \nit’d better actually be a function! \n\nThere’s a subtle but important assignment here.","metadata":{"loc":{"lines":{"from":5836,"to":5867}}}}],["177",{"pageContent":"There’s a subtle but important assignment here. \n\nYou mayhave missed the implied a = 2 in this code snippet. It happens \nwhen the value 2 is passed as an argument to the foo(..) function, in \nwhich case the 2 value is assigned to the parameter a. To (implicitly) \nassign to parameter a, an LHS look-up is performed. \n\nThere’s also an RHS reference for the value of a, and that resulting \nvalue is passed to console.log(..). console.log(.. ) needs a \n\n\n6 | Chapter 1: What Is Scope? \n\n\n\n\nreference to execute. It’s an RHS look-up for the console object, then \na property resolution occurs to see if it has a method called log. \n\nFinally, we can conceptualize that there’s an LHS/RHS exchange of \npassing the value 2 (by way of variable as RHS look-up) into \nlog( ..). Inside of the native implementation of log( ..), we can as¬ \nsume it has parameters, the first of which (perhaps called a rgl) has an \nLHS reference look-up, before assigning 2 to it.","metadata":{"loc":{"lines":{"from":5867,"to":5890}}}}],["178",{"pageContent":"You might be tempted to conceptualize the function declara¬ \ntion function foo(a) {... as a normal variable declaration and \nassignment, such as var foo and foo = function(a){.... In so \ndoing, it would be tempting to think of this function declara¬ \ntion as involving an LHS look-up. \n\n\nHowever, the subtle but important difference is that Compil¬ \ner handles both the declaration and the value definition dur¬ \ning code-generation, such that when Engine is executing code, \nthere’s no processing necessary to “assign” a function value to \nfoo. Thus, it’s not really appropriate to think of a function \ndeclaration as an LHS look-up assignment in the way were \ndiscussing them here. \n\n\nEngine/Scope Conversation \n\nfunction foo(a) { \n\nconsole.log( a ); // 2 \n\n} \n\n\nfoo( 2 ); \n\nLet’s imagine the above exchange (which processes this code snippet) \nas a conversation. The conversation would go a little something like \nthis: \n\n\nEngine: Hey Scope, I have an RHS reference for foo. Ever heard of it?","metadata":{"loc":{"lines":{"from":5894,"to":5926}}}}],["179",{"pageContent":"Engine: Hey Scope, I have an RHS reference for foo. Ever heard of it? \n\nScope: Why yes, I have. Compiler declared it just a second ago. It’s a \nfunction. Here you go. \n\nEngine: Great, thanks! OK, I’m executing foo. \n\nEngine: Hey, Scope, I’ve got an LHS reference for a, ever heard of it? \n\nScope: Why yes, I have. Compiler declared it as a formal parameter \nto foo just recently. Here you go. \n\nEngine: Helpful as always, Scope. Thanks again. Now, time to assign \n2 to a. \n\n\nUnderstanding Scope | 7 \n\n\n\n\nEngine: Hey, Scope, sorry to bother you again. I need an RHS look¬ \nup for console. Ever heard of it? \n\nScope: No problem, Engine, this is what I do all day. Yes, I’ve got \nconsole. It’s built-in. Here ya go. \n\nEngine: Perfect. Looking up log(..). OK, great, it’s a function. \n\nEngine: Yo, Scope. Can you help me out with an RHS reference to a. \nI think I remember it, but just want to double-check. \n\nScope: You’re right, Engine. Same variable, hasn’t changed. Here ya \ng°-","metadata":{"loc":{"lines":{"from":5926,"to":5959}}}}],["180",{"pageContent":"Engine: Yo, Scope. Can you help me out with an RHS reference to a. \nI think I remember it, but just want to double-check. \n\nScope: You’re right, Engine. Same variable, hasn’t changed. Here ya \ng°- \n\nEngine: Cool. Passing the value of a, which is 2, into log(..). \n\n\nQuiz \n\nCheck your understanding so far. Make sure to play the part ofEngine \nand have a “conversation” with Scope: \n\nfunction foo(a) { \nvar b = a; \nreturn a + b; \n\n} \n\nvar c = foo( 2 ); \n\n1. Identify all the LHS look-ups (there are 3!). \n\n2. Identify all the RHS look-ups (there are 4!). \n\n\n\nSee the chapter review for the quiz answers! \n\n\nNested Scope \n\nWe said that Scope is a set of rules for looking up variables by their \nidentifier name. There’s usually more than one scope to consider, \nhowever. \n\nJust as a block or function is nested inside another block or function, \nscopes are nested inside other scopes. So, if a variable cannot be found \nin the immediate scope, Engine consults the next outercontaining","metadata":{"loc":{"lines":{"from":5959,"to":5998}}}}],["181",{"pageContent":"8 | Chapter 1: What Is Scope? \n\n\n\n\nscope, continuing until is found or until the outermost (a.k.a., global) \nscope has been reached. \n\nConsider the following: \n\nfunction foo(a) { \n\nconsole.log( a + b ); \n\n} \n\n\nvar b = 2; \nfoo( 2 ); // 4 \n\nThe RHS reference for b cannot be resolved inside the function foo, \nbut it can be resolved in the scope surrounding it (in this case, the \nglobal). \n\nSo, revisiting the conversations between Engine and Scope, we’d over¬ \nhear: \n\nEngine: “Hey, Scope of foo, ever heard of b? Got an RHS reference for \nit.” \n\nScope: “Nope, never heard of it. Go fish.” \n\nEngine: “Hey, Scope outside of foo, oh you’re the global scope, OK \ncool. Ever heard of b? Got an RHS reference for it.” \n\nScope: “Yep, sure have. Here ya go.”","metadata":{"loc":{"lines":{"from":6001,"to":6036}}}}],["182",{"pageContent":"Engine: “Hey, Scope outside of foo, oh you’re the global scope, OK \ncool. Ever heard of b? Got an RHS reference for it.” \n\nScope: “Yep, sure have. Here ya go.” \n\nThe simple rules for traversing nested scope: Engine starts at the cur¬ \nrently executing scope, looks for the variable there, then if not found, \nkeeps going up one level, and so on. If the outermost global scope is \nreached, the search stops, whether it finds the variable or not. \n\nBuilding on Metaphors \n\nTo visualize the process of nested scope resolution, I want you to think \nof this tall building: \n\n\nNested Scope | 9 \n\n\n\n\nThe building represents our program’s nested scope ruleset. The first \nfloor of the building represents your currently executing scope, wher¬ \never you are. The top level of the building is the global scope.","metadata":{"loc":{"lines":{"from":6036,"to":6059}}}}],["183",{"pageContent":"You resolve LHS and RHS references by looking on your current floor, \nand if you don’t find it, taking the elevator to the next floor, looking \nthere, then the next, and so on. Once you get to the top floor (the global \nscope), you either find what you’re looking for, or you don’t. But you \nhave to stop regardless. \n\nErrors \n\nWhy does it matter whether we call it LHS or RHS? \n\nBecause these two types of look-ups behave differently in the circum¬ \nstance where the variable has not yet been declared (is not found in \nany consulted scope). \n\nConsider: \n\n\n10 | Chapter 1: What Is Scope? \n\n\n\n\n\n\n\n\n\n\n\nfunction foo(a) { \n\nconsole.log( a + b ); \nb = a; \n\n} \n\nfoo( 2 ); \n\nWhen the RHS look-up occurs for b the first time, it will not be found. \nThis is said to be an “undeclared” variable, because it is not found in \nthe scope.","metadata":{"loc":{"lines":{"from":6061,"to":6101}}}}],["184",{"pageContent":"} \n\nfoo( 2 ); \n\nWhen the RHS look-up occurs for b the first time, it will not be found. \nThis is said to be an “undeclared” variable, because it is not found in \nthe scope. \n\nIf an RHS look-up fails to ever find a variable, anywhere in the nested \nscopes, this results in a ReferenceError being thrown by the engine. \nIt’s important to note that the error is of the type ReferenceError. \n\nBy contrast, if the engine is performing an LHS look-up, and it arrives \nat the top floor (global scope) without finding it, if the program is not \nrunning in “Strict Mode,” 1 then the global scope will create a new vari¬ \nable of that name in the global scope, and hand it back to Engine. \n\n“No, there wasn’t one before, but I was helpful and created one for you. ”","metadata":{"loc":{"lines":{"from":6101,"to":6118}}}}],["185",{"pageContent":"“No, there wasn’t one before, but I was helpful and created one for you. ” \n\n“Strict Mode,” which was added in ES5, has a number of different be¬ \nhaviors from normal/relaxed/lazy mode. One such behavior is that it \ndisallows the automatic/implicit global variable creation. In that case, \nthere would be no global scoped variable to hand back from an LHS \nlook-up, and Engine would throw a ReferenceError similarly to the \nRHS case. \n\nNow, if a variable is found for an RHS look-up, but you try to do \nsomething with its value that is impossible, such as trying to execute- \nas-function a nonfunction value, or reference a property on a null or \nundefined value, then Engine throws a different kind of error, called \na TypeError. \n\nReferenceError is scope resolution-failure related, whereas TypeEr \nror implies that scope resolution was successful, but that there was an \nillegal/impossible action attempted against the result. \n\nReview","metadata":{"loc":{"lines":{"from":6118,"to":6137}}}}],["186",{"pageContent":"Review \n\nScope is the set of rules that determines where and how a variable \n(identifier) can be looked up. This look-up may be for the purposes of \n\n\n1. See the MDN’s break down of Strict Mode \n\n\nReview | 11 \n\n\n\nassigning to the variable, which is an LHS (lefthand-side) reference, \nor it may be for the purposes of retrieving its value, which is an RHS \n(righthand-side) reference. \n\nLHS references result from assignment operations. Scope-related as¬ \nsignments can occur either with the = operator or by passing argu¬ \nments to (assign to) function parameters. \n\nThe JavaScript engine first compiles code before it executes, and in so \ndoing, it splits up statements like va r a = 2; into two separate steps: \n\n1. First, var a to declare it in that scope. This is performed at the \nbeginning, before code execution. \n\n2. Later, a = 2 to look up the variable (LHS reference) and assign to \nit if found.","metadata":{"loc":{"lines":{"from":6137,"to":6165}}}}],["187",{"pageContent":"1. First, var a to declare it in that scope. This is performed at the \nbeginning, before code execution. \n\n2. Later, a = 2 to look up the variable (LHS reference) and assign to \nit if found. \n\nBoth LHS and RHS reference look-ups start at the currently executing \nscope, and if need be (that is, they don’t find what they’re looking for \nthere), they work their way up the nested scope, one scope (floor) at a \ntime, looking for the identifier, until they get to the global (top floor) \nand stop, and either find it, or don’t. \n\nUnfulfilled RHS references result in ReferenceErrors being thrown. \nUnfulfilled LHS references result in an automatic, implicitly created \nglobal of that name (if not in Strict Mode), or a ReferenceError (if in \nStrict Mode). \n\nQuiz Answers \n\nfunction foo(a) { \nvar b = a; \nreturn a + b; \n\n} \n\nvar c = foo( 2 ); \n\n1. Identify all the LHS look-ups (there are 3!). \n\nc = a = 2 (implicit param assignment) and b = ..","metadata":{"loc":{"lines":{"from":6165,"to":6194}}}}],["188",{"pageContent":"Quiz Answers \n\nfunction foo(a) { \nvar b = a; \nreturn a + b; \n\n} \n\nvar c = foo( 2 ); \n\n1. Identify all the LHS look-ups (there are 3!). \n\nc = a = 2 (implicit param assignment) and b = .. \n\n2. Identify all the RHS look-ups (there are 4!). \nfoo(2.., = a;, a .. and .. b \n\n\n12 | Chapter 1: What Is Scope? \n\n\n\n\nCHAPTER 2 \n\n\nLexical Scope \n\n\nIn Chapter 1, we defined “scope” as the set of rules that govern how \nthe engine can look up a variable by its identifier name and find it, \neither in the current scope, or in any of the nested scopes it’s contained \nwithin. \n\nThere are two predominant models for how scope works. The first of \nthese is by far the most common, used by the vast majority of pro¬ \ngramming languages. It’s called lexical scope, and we will examine it in \ndepth. The other model, which is still used by some languages (such \nas Bash scripting, some modes in Perl, etc) is called dynamic scope.","metadata":{"loc":{"lines":{"from":6194,"to":6232}}}}],["189",{"pageContent":"Dynamic scope is covered in Appendix A. I mention it here only to \nprovide a contrast with lexical scope, which is the scope model that \nJavaScript employs. \n\nLex-time \n\nAs we discussed in Chapter 1, the first traditional phase of a standard \nlanguage compiler is called lexing (a.k.a., tokenizing). If you recall, the \nlexing process examines a string of source code characters and assigns \nsemantic meaning to the tokens as a result of some stateful parsing. \n\nIt is this concept that provides the foundation to understand what \nlexical scope is and where the name comes from. \n\nTo define it somewhat circularly, lexical scope is scope that is defined \nat lexing time. In other words, lexical scope is based on where variables \nand blocks of scope are authored, by you, at write time, and thus is \n(mostly) set in stone by the time the lexer processes your code. \n\n\n13","metadata":{"loc":{"lines":{"from":6234,"to":6254}}}}],["190",{"pageContent":"13 \n\n\n\n\n\nWe will see in a little bit that there are some ways to cheat lexical \nscope, thereby modifying it after the lexer has passed by, but \nthese are frowned upon. It is considered best practice to treat \nlexical scope as, in fact, lexical-only, and thus entirely author¬ \ntime in nature. \n\n\nLet’s consider this block of code: \n\nfunction foo(a) { \n\nvar b = a * 2; \n\nfunction bar(c) { \n\nconsole.log( a, b, c ); \n\n} \n\nbar( b * 3 ); \n\n} \n\nfoo( 2 );// 2, 4, 12 \n\nThere are three nested scopes inherent in this code example. It may be \nhelpful to think about these scopes as bubbles inside of each other. \n\n\nO \n\n\nfunction foo(a) { \n\nvar b = a * 2; \n\n\ne \n\no \n\n\nfunction bar(c) { ^ \n\nconsole.log( a, b, c ); \n\n\nbar(b * 3); \n\n} \n\n\nfoo( 2 ); // 2j 4> 12 \n\n\nBubble 1 encompasses the global scope and has just one identifier in \nit: foo. \n\nBubble 2 encompasses the scope of foo, which includes the three \nidentifiers: a, bar, and b.","metadata":{"loc":{"lines":{"from":6254,"to":6319}}}}],["191",{"pageContent":"Bubble 1 encompasses the global scope and has just one identifier in \nit: foo. \n\nBubble 2 encompasses the scope of foo, which includes the three \nidentifiers: a, bar, and b. \n\nBubble 3 encompasses the scope of bar, and it includes just one iden¬ \ntifier: c. \n\nScope bubbles are defined by where the blocks of scope are written, \nwhich one is nested inside the other, etc. In the next chapter, we’ll \n\n\n14 | Chapter 2: Lexical Scope \n\n\n\n\ndiscuss different units of scope, but for now, let’s just assume that each \nfunction creates a new bubble of scope. \n\nThe bubble for bar is entirely contained within the bubble for foo, \nbecause (and only because) that’s where we chose to define the function \nbar.","metadata":{"loc":{"lines":{"from":6319,"to":6342}}}}],["192",{"pageContent":"The bubble for bar is entirely contained within the bubble for foo, \nbecause (and only because) that’s where we chose to define the function \nbar. \n\nNotice that these nested bubbles are strictly nested. We’re not talking \nabout Venn diagrams where the bubbles can cross boundaries. In other \nwords, no bubble for some function can simultaneously exist (parti¬ \nally) inside two other outer scope bubbles, just as no function can \npartially be inside each of two parent functions. \n\nLook-ups \n\nThe structure and relative placement of these scope bubbles fully ex¬ \nplains to the engine all the places it needs to look to find an identifier.","metadata":{"loc":{"lines":{"from":6342,"to":6355}}}}],["193",{"pageContent":"Look-ups \n\nThe structure and relative placement of these scope bubbles fully ex¬ \nplains to the engine all the places it needs to look to find an identifier. \n\nIn the previous code snippet, the engine executes the con \nsole.log(..) statement and goes looking for the three referenced \nvariables a, b, and c. It first starts with the innermost scope bubble, the \nscope of the bar(..) function. It won’t find a there, so it goes up one \nlevel, out to the next nearest scope bubble, the scope of foo(..). It \nfinds a there, and so it uses that a. Same thing for b. But c, it does find \ninside of bar(..). \n\nHad there been a c both inside of bar(..) and inside of foo(..), the \nconsole.log(..) statement would have found and used the one in \nbar(..), never getting to the one in foo(..).","metadata":{"loc":{"lines":{"from":6355,"to":6370}}}}],["194",{"pageContent":"Had there been a c both inside of bar(..) and inside of foo(..), the \nconsole.log(..) statement would have found and used the one in \nbar(..), never getting to the one in foo(..). \n\nScope look-up stops once it finds the first match. The same identifier \nname can be specified at multiple layers of nested scope, which is called \n“shadowing” (the inner identifer “shadows” the outer identifier). Re¬ \ngardless of shadowing, scope look-up always starts at the innermost \nscope being executed at the time, and works its way outward/upward \nuntil the first match, and stops. \n\n\nLex-time | 15 \n\n\n\n\nGlobal variables are automatically also properties of the glob¬ \nal object (window in browsers, etc.), so it is possible to refer¬ \nence a global variable not directly by its lexical name, but in¬ \nstead indirectly as a property reference of the global object. \n\nwindow. a","metadata":{"loc":{"lines":{"from":6370,"to":6392}}}}],["195",{"pageContent":"window. a \n\n\nThis technique gives access to a global variable that would \notherwise be inaccessible due to it being shadowed. However, \nnon-global shadowed variables cannot be accessed. \n\n\nNo matter where a function is invoked from, or even how it is invoked, \nits lexical scope is only defined by where the function was declared. \n\nThe lexical scope look-up process only applies to first-class identifiers, \nsuch as the a, b, and c. If you had a reference to f oo. ba r. ba z in a piece \nof code, the lexical scope look-up would apply to finding the foo \nidentifier, but once it locates that variable, object property-access rules \ntake over to resolve the bar and baz properties, respectively. \n\nCheating Lexical \n\nIf lexical scope is defined only by where a function is declared, which \nis entirely an author-time decision, how could there possibly be a way \nto “modify” (a.k.a., cheat) lexical scope at runtime?","metadata":{"loc":{"lines":{"from":6392,"to":6413}}}}],["196",{"pageContent":"JavaScript has two such mechanisms. Both of them are equally \nfrowned upon in the wider community as bad practices to use in your \ncode. But the typical arguments against them are often missing the \nmost important point: cheating lexical scope leads to poorer perfor¬ \nmance. \n\nBefore I explain the performance issue, though, let’s look at how these \ntwo mechanisms work. \n\neval \n\nThe eval (..) function in JavaScript takes a string as an argument and \ntreats the contents of the string as if it had actually been authored code \nat that point in the program. In other words, you can programatically \ngenerate code inside of your authored code, and run the generated \ncode as if it had been there at author time. \n\nEvaluating eval( ..) (pun intended) in that light, it should be clear \nhow eval (..) allows you to modify the lexical scope environment by \n\n\n16 | Chapter 2: Lexical Scope \n\n\n\n\ncheating and pretending that author-time (a.k.a., lexical) code was \nthere all along.","metadata":{"loc":{"lines":{"from":6415,"to":6442}}}}],["197",{"pageContent":"16 | Chapter 2: Lexical Scope \n\n\n\n\ncheating and pretending that author-time (a.k.a., lexical) code was \nthere all along. \n\nOn subsequent lines of code after an eval( ..) has executed, the engine \nwill not “know” or “care” that the previous code in question was dy¬ \nnamically interpreted and thus modified the lexical scope \nenvironment. The engine will simply perform its lexical scope look¬ \nups as it always does. \n\nConsider the following code: \n\nfunction foo(str, a) { \n\neval( str ); // cheating! \nconsole.log( a, b ); \n\n1 \n\n\nvar b = 2; \n\nfoo( \"var b = 3;\", 1 ); //l, 3 \n\nThe string \"var b = 3;\" is treated, at the point of the eval( ..) call, \nas code that was there all along. Because that code happens to declare \na new variable b, it modifies the existing lexical scope of foo(..). In \nfact, as mentioned earlier, this code actually creates variable b inside \nof foo(..) that shadows the b that was declared in the outer (global) \nscope.","metadata":{"loc":{"lines":{"from":6442,"to":6475}}}}],["198",{"pageContent":"When the console.log (..) call occurs, it finds both a and b in the \nscope of foo( ..), and never finds the outer b. Thus, we print out “1, \n3” instead of “1, 2” as would have normally been the case. \n\n\n\nIn this example, for simplicity sake, the string of “code” we pass \nin was a fixed literal. But it could easily have been programat- \nically created by adding characters together based on your \nprogram’s logic. eval(..) is usually used to execute dynami¬ \ncally created code, as dynamically evaluating essentially static \ncode from a string literal would provide no real benefit to just \nauthoring the code directly. \n\n\nBy default, if a string of code that eval( ..) executes contains one or \nmore declarations (either variables or functions), this action modifies \nthe existing lexical scope in which the eval( ..) resides. Technically, \neval( ..) can be invoked indirectly, through various tricks (beyond \nour discussion here), which causes it to instead execute in the context","metadata":{"loc":{"lines":{"from":6477,"to":6496}}}}],["199",{"pageContent":"Cheating Lexical | 17 \n\n\n\n\nof the global scope, thus modifying it. Butin either case, eval(..) can \nat runtime modify an author-time lexical scope. \n\n\n\neval(..) when used in a strict-mode program operates in its \nown lexical scope, which means declarations made inside of \nthe eval() do not actually modify the enclosing scope. \n\nfunction foo(str) { \n\n\"use strict\"; \n\n\neval( str ); \n\nconsole.log( a ); // ReferenceError: a is not defined \n\n\nfoo( \"var a = 2\" ); \n\n\nThere are other facilities in JavaScript that amount to a very similar \neffect to eval(..). setTimeout(.. ) and setlnterval(. .) can take a \nstring for their respective first argument, the contents of which are \nevaluated as the code of a dynamically generated function. This is old, \nlegacy behavior and long-since deprecated. Don’t do it!","metadata":{"loc":{"lines":{"from":6499,"to":6530}}}}],["200",{"pageContent":"The new Function (..) function constructor similarly takes a string \nof code in its last argument to turn into a dynamically generated func¬ \ntion (the first argument(s), if any, are the named parameters for the \nnew function). This function-constructor syntax is slightly safer than \neval( ..), but it should still be avoided in your code. \n\nThe use-cases for dynamically generating code inside your program \nare incredibly rare, as the performance degradations are almost never \nworth the capability. \n\nwith \n\nThe other frowned-upon (and now deprecated!) feature in JavaScript \nthat cheats lexical scope is the with keyword. There are multiple valid \nways that with can be explained, but I will choose here to explain it \nfrom the perspective of how it interacts with and affects lexical scope. \n\nwith is typically explained as a shorthand for making multiple prop¬ \nerty references against an object without repeating the object reference \nitself each time. \n\nFor example:","metadata":{"loc":{"lines":{"from":6532,"to":6553}}}}],["201",{"pageContent":"with is typically explained as a shorthand for making multiple prop¬ \nerty references against an object without repeating the object reference \nitself each time. \n\nFor example: \n\nvar obj = { \na: 1, \nb: 2, \n\n\n18 | Chapter 2: Lexical Scope \n\n\n\n\n\nc: 3 \n\n\n}; \n\n\n// more \"tedious\" to repeat \"obj\" \nobj.a = 2; \nobj.b = 3; \nobj.c = 4; \n\n// \"easier\" short-hand \nwith (obj) { \na = 3; \nb = 4; \nc = 5; \n\n} \n\nHowever, there’s much more going on here than just a convenient \nshorthand for object property access. Consider: \n\nfunction foo(obj) { \nwith (obj) { \na = 2; \n\n} \n\n} \n\nvar ol = { \na: 3 \n\n}; \n\nvar o2 = { \nb: 3 \n\n}; \n\n\nfoo( ol ); \n\nconsole.log ( ol.a ); // 2 \nfoo( o2 ); \n\nconsole.log( o2.a ); // undefined \nconsole.log( a ); // 2-0ops, leaked global!","metadata":{"loc":{"lines":{"from":6553,"to":6617}}}}],["202",{"pageContent":"} \n\n} \n\nvar ol = { \na: 3 \n\n}; \n\nvar o2 = { \nb: 3 \n\n}; \n\n\nfoo( ol ); \n\nconsole.log ( ol.a ); // 2 \nfoo( o2 ); \n\nconsole.log( o2.a ); // undefined \nconsole.log( a ); // 2-0ops, leaked global! \n\nIn this code example, two objects ol and o2 are created. One has an a \nproperty, and the other does not. The f oo (..) function takes an object \nreference obj as an argument, and calls with (obj) { .. }on the \nreference. Inside the with block, we make what appears to be a normal \nlexical reference to a variable a, an LHS reference in fact (see Chap¬ \nter 1), to assign to it the value of 2. \n\nWhen we pass in ol, the a = 2 assignment finds the property ol. a \nand assigns it the value 2, as reflected in the subsequent con \nsole.log(ol.a) statement. However, when we pass in o2, since it does \n\n\nCheating Lexical | 19 \n\n\n\nnot have an a property, no such property is created, and o2. a remains \nundefined.","metadata":{"loc":{"lines":{"from":6617,"to":6657}}}}],["203",{"pageContent":"Cheating Lexical | 19 \n\n\n\nnot have an a property, no such property is created, and o2. a remains \nundefined. \n\nBut then we note a peculiar side-effect, the fact that a global variable \na was created by the a = 2 assignment. How can this be? \n\nThe with statement takes an object, one that has zero or more prop¬ \nerties, and treats that object as if it is a wholly separate lexical scope, \nand thus the object’s properties are treated as lexically defined identi¬ \nfiers in that scope. \n\n\n\nEven though a with block treats an object like a lexical scope, \na normal var declaration inside that with block will not be \nscoped to that with block, but instead the containing func¬ \ntion scope. \n\n\nWhile the eval( ..) function can modify existing lexical scope if it \ntakes a string of code with one or more declarations in it, the with \nstatement actually creates a whole new lexical scope out of thin air, from \nthe object you pass to it.","metadata":{"loc":{"lines":{"from":6657,"to":6683}}}}],["204",{"pageContent":"Understoodin this way, the scope declared by the with statement when \nwe passed in ol was ol, and that scope had an identifier in it which \ncorresponds to the ol. a property. But when we used o2 as the scope, \nit had no such a identifier in it, and so the normal rules of LHS iden¬ \ntifier look-up (see Chapter 1) occurred. \n\nNeither the scope of o2, nor the scope of f oo (..), nor the global scope \neven, has an a identifier to be found, so when a = 2 is executed, it \nresults in the automatic global being created (since we’re in non-strict \nmode). \n\nIt is a strange sort of mind-bending thought to see with turning, at \nruntime, an object and its properties into a scope with identifiers. But \nthat is the clearest explanation I can give for the results we see.","metadata":{"loc":{"lines":{"from":6685,"to":6698}}}}],["205",{"pageContent":"In addition to being a bad idea to use, both eval(..) and with \nare affected (restricted) by Strict Mode, with is outright disal¬ \nlowed, whereas various forms of indirect or unsafe eval(..) \nare disallowed while retaining the core functionality. \n\n\n20 | Chapter 2: Lexical Scope \n\n\n\n\n\n\nPerformance \n\nBoth eval( ..) and with cheat the otherwise author-time defined lex¬ \nical scope by modifying or creating new lexical scope at runtime. \n\nSo, what’s the big deal, you ask? If they offer more sophisticated func¬ \ntionality and coding flexibility, aren’t these good features? No. \n\nThe JavaScript engine has a number of performance optimizations that \nit performs during the compilation phase. Some of these boil down to \nbeing able to essentially statically analyze the code as it lexes, and pre¬ \ndetermine where all the variable and function declarations are, so that \nit takes less effort to resolve identifiers during execution.","metadata":{"loc":{"lines":{"from":6702,"to":6727}}}}],["206",{"pageContent":"But if the engine finds an eval( ..) or with in the code, it essentially \nhas to assume that all its awareness of identifier location may be invalid, \nbecause it cannot know at lexing time exactly what code you may pass \nto eval(. .) to modify the lexical scope, or the contents of the object \nyou may pass to with to create a new lexical scope to be consulted. \n\nIn other words, in the pessimistic sense, most of those optimizations \nit would make are pointless if eval( ..) or wit hare present, so it simply \ndoesn’t perform the optimizations at all. \n\nYour code will almost certainly tend to run slower simply by the fact \nthat you include an eva l (. .) or with anywhere in the code. No matter \nhow smart the engine may be about trying to limit the side-effects of \nthese pessmistic assumptions, there’s no getting around the fact that \nwithout the optimizations, code runs slower. \n\nReview","metadata":{"loc":{"lines":{"from":6729,"to":6745}}}}],["207",{"pageContent":"Review \n\nLexical scope means that scope is defined by author-time decisions of \nwhere functions are declared. The lexing phase of compilation is es¬ \nsentially able to know where and how all identifiers are declared, and \nthus predict how they will be looked up during execution. \n\nTwo mechanisms in JavaScript can “cheat” lexical scope: eval (. .) and \nwith. The former can modify existing lexical scope (at runtime) by \nevaluating a string of “code” that has one or more declarations in it. \nThe latter essentially creates a whole new lexical scope (again, at run¬ \ntime) by treating an object reference as a scope and that object’s prop¬ \nerties as scoped identifiers. \n\n\nReview | 21 \n\n\n\n\nThe downside to these mechanisms is that it defeats the engine s ability \nto perform compile-time optimizations regarding scope look-up, be¬ \ncause the engine has to assume pessimistically that such optimizations \nwill be invalid. Code will run slower as a result of using either feature. \nDon’t use them.","metadata":{"loc":{"lines":{"from":6745,"to":6769}}}}],["208",{"pageContent":"22 | Chapter 2: Lexical Scope \n\n\n\nCHAPTER 3 \n\n\nFunction Versus Block Scope \n\n\nAs we explored in Chapter 2, scope consists of a series of “bubbles” \nthat each act as a container or bucket, in which identifiers (variables, \nfunctions) are declared. These bubbles nest neatly inside each other, \nand this nesting is defined at author time. \n\nBut what exactly makes a new bubble? Is it only the function? Can \nother structures in JavaScript create bubbles of scope? \n\nScope From Functions \n\nThe most common answer to those questions is that JavaScript has \nfunction-based scope. That is, each function you declare creates a \nbubble for itself, but no other structures create their own scope bub¬ \nbles. As we’ll see in just a little bit, this is not quite true. \n\nBut first, let’s explore function scope and its implications. \n\nConsider this code: \n\nfunction foo(a) { \nvar b = 2; \n\n// sone code \n\nfunction bar() { \n\n// ... \n\n} \n\n// more code \nvar c = 3; \n\n} \n\n\n23","metadata":{"loc":{"lines":{"from":6772,"to":6818}}}}],["209",{"pageContent":"Consider this code: \n\nfunction foo(a) { \nvar b = 2; \n\n// sone code \n\nfunction bar() { \n\n// ... \n\n} \n\n// more code \nvar c = 3; \n\n} \n\n\n23 \n\n\n\n\n\n\nIn this snippet, the scope bubble for foo(..) includes identifiers a, b, \nc, and bar. It doesn’t matter where in the scope a declaration appears, \nthe variable or function belongs to the containing scope bubble, re¬ \ngardless. We’ll explore how exactly that works in the next chapter. \n\nbar(..) has its own scope bubble. So does the global scope, which has \njust one identifier attached to it: f oo. \n\nBecause a, b, c, and bar all belong to the scope bubble offoo(..), they \nare not accessible outside of f oo (..). That is, the following code would \nall result in ReferenceError errors, as the identifiers are not available \nto the global scope: \n\nbar( ); // faiIs \n\nconsole.log( a, b, c ); // all 3 fail","metadata":{"loc":{"lines":{"from":6818,"to":6859}}}}],["210",{"pageContent":"bar( ); // faiIs \n\nconsole.log( a, b, c ); // all 3 fail \n\nHowever, all these identifiers (a, b, c, foo, and bar) are accessible inside \nof foo(..), and indeed also available inside of bar(..) (assuming \nthere are no shadow identifier declarations inside bar(..)). \n\nFunction scope encourages the idea that all variables belong to the \nfunction, and can be used and reused throughout the entirety of the \nfunction (and indeed, accessible even to nested scopes). This design \napproach can be quite useful, and certainly can make full use of the \n“dynamic” nature of JavaScript variables to take on values of different \ntypes as needed. \n\nOn the other hand, if you don’t take careful precautions, variables ex¬ \nisting across the entirety of a scope can lead to some unexpected pit- \nfalls. \n\nHiding in Plain Scope","metadata":{"loc":{"lines":{"from":6859,"to":6878}}}}],["211",{"pageContent":"On the other hand, if you don’t take careful precautions, variables ex¬ \nisting across the entirety of a scope can lead to some unexpected pit- \nfalls. \n\nHiding in Plain Scope \n\nThe traditional way of thinking about functions is that you declare a \nfunction and then add code inside it. But the inverse thinking is equally \npowerful and useful: take any arbitrary section of code you’ve written \nand wrap a function declaration around it, which in effect “hides” the \ncode. \n\nThe practical result is to create a scope bubble around the code in \nquestion, which means that any declarations (variable or function) in \nthat code will now be tied to the scope of the new wrapping function, \nrather than the previously enclosing scope. In other words, you can \n\n\n24 | Chapter 3: Function Versus Block Scope \n\n\n\n“hide” variables and functions by enclosing them in the scope of a \nfunction. \n\nWhy would “hiding” variables and functions be a useful technique?","metadata":{"loc":{"lines":{"from":6878,"to":6903}}}}],["212",{"pageContent":"24 | Chapter 3: Function Versus Block Scope \n\n\n\n“hide” variables and functions by enclosing them in the scope of a \nfunction. \n\nWhy would “hiding” variables and functions be a useful technique? \n\nThere’s a variety of reasons motivating this scope-based hiding. They \ntend to arise from the software design principle Principle of Least \nPrivilege 1 , also sometimes called Least Authority or Least Exposure. \nThis principle states that in the design of software, such as the API for \na module/object, you should expose only what is minimally necessary, \nand “hide” everything else.","metadata":{"loc":{"lines":{"from":6903,"to":6917}}}}],["213",{"pageContent":"This principle extends to the choice of which scope to contain variables \nand functions. If all variables and functions were in the global scope, \nthey would of course be accessible to any nested scope. But this would \nviolate the “Least...” principle in that you are (likely) exposing many \nvariables or functions that you should otherwise keep private, as prop¬ \ner use of the code would discourage access to those variables/func¬ \ntions. \n\nFor example: \n\nfunction doSomething(a) { \n\nb = a + doSomethingEtse( a * 2 ); \n\nconsole.log( b * 3 ); \n\n} \n\nfunction doSomethingElse(a) { \nreturn a - 1; \n\n} \n\nvar b; \n\ndoSomething( 2 );// 15","metadata":{"loc":{"lines":{"from":6919,"to":6944}}}}],["214",{"pageContent":"For example: \n\nfunction doSomething(a) { \n\nb = a + doSomethingEtse( a * 2 ); \n\nconsole.log( b * 3 ); \n\n} \n\nfunction doSomethingElse(a) { \nreturn a - 1; \n\n} \n\nvar b; \n\ndoSomething( 2 );// 15 \n\nIn this snippet, the b variable and the doSomethingElse(..) function \narelikely“private”detailsofhowdoSomething(..) doesitsjob. Giving \nthe enclosing scope “access” to band doSomething Else (..) is not only \nunnecessary but also possibly “dangerous,” in that they may be used \nin unexpected ways, intentionally or not, and this may violate pre¬ \ncondition assumptions of doSonething(..). A more “proper” design \nwould hide these private details inside the scope of doSometh \nlng(..), such as: \n\n\n1. Principle of Least Privilege \n\n\nHiding in Plain Scope | 25 \n\n\n\nfunction doSomething(a) { \n\nfunction doSomethlngElse(a) { \nreturn a - 1; \n\n} \n\nvar b; \n\nb = a + doSomethingElse( a * 2 ); \nconsole.log( b * 3 ); \n\n} \n\ndoSomething( 2 );// 15","metadata":{"loc":{"lines":{"from":6944,"to":6994}}}}],["215",{"pageContent":"function doSomething(a) { \n\nfunction doSomethlngElse(a) { \nreturn a - 1; \n\n} \n\nvar b; \n\nb = a + doSomethingElse( a * 2 ); \nconsole.log( b * 3 ); \n\n} \n\ndoSomething( 2 );// 15 \n\nNow, b and doSomethingElse(..) are not accessible to any outside \ninfluence, instead controlled only by doSomething(..). The func¬ \ntionality and end result has not been affected, but the design keeps \nprivate details private, which is usually considered better software. \n\nCollision Avoidance \n\nAnother benefit of “hiding” variables and functions inside a scope is \nto avoid unintended collision between two different identifiers with \nthe same name but different intended usages. Collision results often \nin unexpected overwriting of values. \n\nFor example: \n\nfunction foo() { \n\nfunction bar(a) { \n\ni = 3; // changing the 'i' in the enclosing scope's \n// for-loop \nconsole.log( a + i ); \n\n} \n\nfor (var i=0; i<10; i++) { \n\nbar( i * 2 ); // oops, inifinite loop ahead! \n\n} \n\n} \n\nfoo( );","metadata":{"loc":{"lines":{"from":6994,"to":7042}}}}],["216",{"pageContent":"i = 3; // changing the 'i' in the enclosing scope's \n// for-loop \nconsole.log( a + i ); \n\n} \n\nfor (var i=0; i<10; i++) { \n\nbar( i * 2 ); // oops, inifinite loop ahead! \n\n} \n\n} \n\nfoo( ); \n\nThe! = 3 assignment inside of bar(..) overwrites, unexpectedly, the \ni that was declared in f oo (..) at the f o r loop. In this case, it will result \nin an infinite loop, because i is set to a fixed value of 3 and that will \nforever remain < 10. \n\nThe assignment inside ba r (..) needs to declare a local variable to use, \nregardless of what identifier name is chosen, var i = 3; would fix \n\n\n26 | Chapter 3: Function Versus Block Scope","metadata":{"loc":{"lines":{"from":7042,"to":7067}}}}],["217",{"pageContent":"The assignment inside ba r (..) needs to declare a local variable to use, \nregardless of what identifier name is chosen, var i = 3; would fix \n\n\n26 | Chapter 3: Function Versus Block Scope \n\n\n\nthe problem (and would create the previously mentioned “shadowed \nvariable” declaration for i). An additional, not alternate, option is to \npick another identifier name entirely, such as va r j = 3;. But your \nsoftware design may naturally call for the same identifier name, so \nutilizing scope to “hide” your inner declaration is your best/only op¬ \ntion in that case. \n\nGlobal namespaces \n\nA particularly strong example of (likely) variable collision occurs in \nthe global scope. Multiple libraries loaded into your program can quite \neasily collide with each other if they don’t properly hide their internal/ \nprivate functions and variables.","metadata":{"loc":{"lines":{"from":7067,"to":7087}}}}],["218",{"pageContent":"Such libraries typically will create a single variable declaration, often \nan object, with a sufficiently unique name, in the global scope. This \nobject is then used as a namespace for that library, where all specific \nexposures of functionality are made as properties off that object \n(namespace), rather than as top-levellexically scoped identifiers them¬ \nselves. \n\nFor example: \n\nvar MyReallyCoolLtbrary = { \nawesome: \"stuff\", \ndoSomething: function/ ) { \n\n// ... \n\n}. \n\ndoAnotherThlng: function/) { \n\n// ... \n\n} \n\n1 ; \n\nModule management \n\nAnother option for collision avoidance is the more modern module \napproach, using any of various dependency managers. Using these \ntools, no libraries ever add any identifiers to the global scope, but are \ninstead required to have their identifier(s) be explicitly imported into \nanother specific scope through usage of the dependency managers \nvarious mechanisms.","metadata":{"loc":{"lines":{"from":7089,"to":7121}}}}],["219",{"pageContent":"It should be observed that these tools do not possess “magic” func¬ \ntionality that is exempt from lexical scoping rules. They simply use the \nrules of scoping as explained here to enforce that no identifiers are \ninjected into any shared scope, and are instead kept in private, \n\n\nHiding in Plain Scope | 27 \n\n\n\nnon-collision-susceptible scopes, which prevents any accidental scope \ncollisions. \n\nAs such, you can code defensively and achieve the same results as the \ndependency managers do without actually needing to use them, if you \nso choose. See the Chapter 5 for more information about the module \npattern. \n\nFunctions as Scopes \n\nWe’ve seen that we can take any snippet of code and wrap a function \naround it, and that effectively “hides” any enclosed variable or function \ndeclarations from the outside scope inside that functions inner scope. \n\nFor example: \n\nvar a = 2; \n\nfunction foo() { // <-- insert this \nvar a = 3; \n\nconsole.log( a ); // 3","metadata":{"loc":{"lines":{"from":7123,"to":7154}}}}],["220",{"pageContent":"For example: \n\nvar a = 2; \n\nfunction foo() { // <-- insert this \nvar a = 3; \n\nconsole.log( a ); // 3 \n\n} // <-- and this \nfoo(); // <-- and this \n\nconsole.log ( a ); // 2 \n\nWhile this technique works, it is not necessarily very ideal. There are \na few problems it introduces. The first is that we have to declare a \nnamed-function f oo (), which means that the identifier name f oo itself \n“pollutes” the enclosing scope (global, in this case). We also have to \nexplicitly call the function by name (foo()) so that the wrapped code \nactually executes. \n\nIt would be more ideal if the function didn’t need a name (or, rather, \nthe name didn’t pollute the enclosing scope), and if the function could \nautomatically be executed. \n\nFortunately, JavaScript offers a solution to both problems, \nvar a = 2; \n\n(function foo(){ // <-- insert this \nvar a = 3; \n\nconsole.log( a ); // 3 \n\n\n28 | Chapter 3: Function Versus Block Scope \n\n\n\n\n})(); // <-- and this","metadata":{"loc":{"lines":{"from":7154,"to":7193}}}}],["221",{"pageContent":"(function foo(){ // <-- insert this \nvar a = 3; \n\nconsole.log( a ); // 3 \n\n\n28 | Chapter 3: Function Versus Block Scope \n\n\n\n\n})(); // <-- and this \n\n\nconsole.log ( a ); // 2 \nLet’s break down what’s happening here. \n\nFirst, notice that the wrapping function statement starts with (func \ntion... as opposed to just function.... While this may seem like a minor \ndetail, it’s actually a major change. Instead of treating the function as \na standard declaration, the function is treated as a function- \nexpression. \n\n\n\nThe easiest way to distinguish declaration vs. expression is the \nposition of the word function in the statement (not just a line, \nbut a distinct statement). If function is the very first thing in \nthe statement, then it’s a function declaration. Otherwise, it’s a \nfunction expression. \n\n\nThe key difference we can observe here between a function declaration \nand a function expression relates to where its name is bound as an \nidentifier.","metadata":{"loc":{"lines":{"from":7193,"to":7227}}}}],["222",{"pageContent":"The key difference we can observe here between a function declaration \nand a function expression relates to where its name is bound as an \nidentifier. \n\nCompare the previous two snippets. In the first snippet, the name f oo \nis bound in the enclosing scope, and we call it directly with foo( ). In \nthe second snippet, the name f oo is not bound in the enclosing scope, \nbut instead is bound only inside of its own function. \n\nIn other words, (function foo( ){ .. }) as an expression means the \nidentifier f oo is found only in the scope where the .. indicates, not in \nthe outer scope. Hiding the name f oo inside itself means it does not \npollute the enclosing scope unnecessarily. \n\nAnonymous Versus Named \n\nYou are probably most familiar with function expressions as callback \nparameters, such as: \n\nsetTimeout( function(){ \n\nconsole.log(\" I waited 1 second!\"); \n\n}, 1000 );","metadata":{"loc":{"lines":{"from":7227,"to":7250}}}}],["223",{"pageContent":"Anonymous Versus Named \n\nYou are probably most familiar with function expressions as callback \nparameters, such as: \n\nsetTimeout( function(){ \n\nconsole.log(\" I waited 1 second!\"); \n\n}, 1000 ); \n\nThis is called an anonymous function expression, because function!) \n... has no name identifier on it. Function expressions can be anony¬ \nmous, but function declarations cannot omit the name—that would \nbe illegal JS grammar. \n\n\nFunctions as Scopes | 29 \n\n\n\n\n\nAnonymous function expressions are quick and easy to type, and \nmany libraries and tools tend to encourage this idiomatic style of code. \nHowever, they have several drawbacks to consider: \n\n1. Anonymous functions have no useful name to display in stack \ntraces, which can make debugging more difficult.","metadata":{"loc":{"lines":{"from":7250,"to":7278}}}}],["224",{"pageContent":"1. Anonymous functions have no useful name to display in stack \ntraces, which can make debugging more difficult. \n\n2. Without a name, if the function needs to refer to itself, for recur¬ \nsion, etc., the deprecated arguments. callee reference is unfortu¬ \nnately required. Another example of needing to self-reference is \nwhen an event handler function wants to unbind itself after it fires. \n\n3. Anonymous functions omit a name, which is often helpful in \nproviding more readable/understandable code. A descriptive \nname helps self-document the code in question. \n\nInline function expressions are powerful and useful—the question of \nanonymous versus named doesn’t detract from that. Providing a name \nfor your function expression quite effectively addresses all these draw¬ \nbacks, but has no tangible downsides. The best practice is to always \nname your function expressions: \n\nsetTimeout( function timeoutHandler( ){ // <-- Look, I have a \n\n// none! \n\nconsole.log( \"I waited 1 second!\" );","metadata":{"loc":{"lines":{"from":7278,"to":7300}}}}],["225",{"pageContent":"setTimeout( function timeoutHandler( ){ // <-- Look, I have a \n\n// none! \n\nconsole.log( \"I waited 1 second!\" ); \n\n}, 1000 ); \n\nInvoking Function Expressions Immediately \n\nvar a = 2; \n\n(function foo(){ \nvar a = 3; \n\nconsole.log( a ); // 3 \n})(); \n\nconsole.log( a ')•,// 2 \n\nNow that we have a function as an expression by virtue of wrapping \nit in a ( ) pair, we can execute that function by adding another () on \nthe end, like (function foo(){ .. })(). The first enclosing ( ) pair \nmakes the function an expression, and the second () executes the \nfunction. \n\n\n30 | Chapter 3: Function Versus Block Scope \n\n\n\n\nThis pattern is so common, a few years ago the community agreed on \na term for it: IIFE, which stands for immediately invoked function \nexpression.","metadata":{"loc":{"lines":{"from":7300,"to":7334}}}}],["226",{"pageContent":"30 | Chapter 3: Function Versus Block Scope \n\n\n\n\nThis pattern is so common, a few years ago the community agreed on \na term for it: IIFE, which stands for immediately invoked function \nexpression. \n\nOf course, IIFEs don’t need names, necessarily—the most common \nform of IIFE is to use an anonymous function expression. While cer¬ \ntainly less common, naming an IIFE has all the aforementioned ben¬ \nefits over anonymous function expressions, so it’s a good practice to \nadopt. \n\nvar a = 2; \n\n(function IIFE (){ \nvar a = 3; \n\nconsole.log( a ); // 3 \n})(); \n\nconsole.log ( a ); // 2 \n\nThere’s a slight variation on the traditional IIFE form, which some \nprefer: (function(){ .. }()). Look closely to see the difference. In \nthe first form, the function expression is wrapped in ( ), and then the \ninvoking () pair is on the outside right after it. In the second form, the \ninvoking () pair is moved to the inside of the outer ( ) wrapping pair.","metadata":{"loc":{"lines":{"from":7334,"to":7363}}}}],["227",{"pageContent":"These two forms are identical in functionality. It’s purely a stylistic \nchoice which you prefer. \n\nAnother variation on IIFEs that is quite common is to use the fact that \nthey are, in fact, just function calls, and pass in argument(s). \n\nFor instance: \n\nvar a = 2; \n\n(function IIFE( global ){ \nvar a = 3; \n\nconsole.log( a ); // 3 \nconsole.log( global.a ); // 2 \n\n})( window ); \n\nconsole.log ( a ); // 2 \n\nWe pass in the window object reference, but we name the parameter \nglobal, so that we have a clear stylistic delineation for global versus \n\n\nFunctions as Scopes | 31 \n\n\n\nnonglobal references. Of course, you can pass in anything from an \nenclosing scope you want, and you can name the parameter(s) any¬ \nthing that suits you. This is mostly just stylistic choice.","metadata":{"loc":{"lines":{"from":7365,"to":7395}}}}],["228",{"pageContent":"nonglobal references. Of course, you can pass in anything from an \nenclosing scope you want, and you can name the parameter(s) any¬ \nthing that suits you. This is mostly just stylistic choice. \n\nAnother application of this pattern addresses the (minor niche) con¬ \ncern that the default undefined identifier might have its value incor¬ \nrectly overwritten, causing unexpected results. By naming a parameter \nundefined, but not passing any value for that argument, we can guar¬ \nantee that the undefined identifier is in fact the undefined value in a \nblock of code: \n\nundefined = true; // setting a land-nine for other code! avoid! \n\n(function IIFE( undefined ){ \nvar a; \n\nif (a === undefined) { \n\nconsole.log( \"Undefined is safe here!\" ); \n\n} \n\n})();","metadata":{"loc":{"lines":{"from":7395,"to":7417}}}}],["229",{"pageContent":"undefined = true; // setting a land-nine for other code! avoid! \n\n(function IIFE( undefined ){ \nvar a; \n\nif (a === undefined) { \n\nconsole.log( \"Undefined is safe here!\" ); \n\n} \n\n})(); \n\nStill another variation of the IIFE inverts the order of things, where \nthe function to execute is given second, after the invocation and pa¬ \nrameters to pass to it. This pattern is used in the UMD (Universal \nModule Definition) project. Some people find it a little cleaner to un¬ \nderstand, though it is slightly more verbose. \n\nvar a = 2; \n\n(function IIFE( def ){ \ndef( window ); \n\n})(function def( global ){ \n\nvar a = 3; \n\nconsole.log( a ); // 3 \nconsole.log( global.a );// 2 \n\n\n}); \n\nThe def function expression is defined in the second-half of the snip¬ \npet, and then passed as a parameter (also called def) to the IIFE func¬ \ntion defined in the first half of the snippet. Finally, the parameter def \n(the function) is invoked, passing window in as the global parameter.","metadata":{"loc":{"lines":{"from":7417,"to":7454}}}}],["230",{"pageContent":"32 | Chapter 3: Function Versus Block Scope \n\n\n\n\nBlocks as Scopes \n\nWhile functions are the most common unit of scope, and certainly the \nmost widespread of the design approaches in the majority of JS in \ncirculation, other units of scope are possible, and the usage of these \nother scope units can lead to even better, cleaner to maintain code. \n\nMany languages other than JavaScript support block scope, and so \ndevelopers from those languages are accustomed to the mindset, \nwhereas those who’ve primarily only worked in JavaScript may find \nthe concept slightly foreign. \n\nBut even if you’ve never written a single line of code in block-scoped \nfashion, you are still probably familiar with this extremely common \nidiom in JavaScript: \n\nfor (var 1=0 ; t<10; i++) { \nconsole.log( t ); \n\n}","metadata":{"loc":{"lines":{"from":7457,"to":7481}}}}],["231",{"pageContent":"for (var 1=0 ; t<10; i++) { \nconsole.log( t ); \n\n} \n\nWe declare the variable i directly inside the for loop head, most likely \nbecause our intent is to use i only within the context of that for loop, \nand essentially ignore the fact that the variable actually scopes itself to \nthe enclosing scope (function or global). \n\nThat’s what block-scoping is all about. Declaring variables as close as \npossible, as local as possible, to where they will be used. Another ex¬ \nample: \n\nvar foo = true; \n\nif (foo) { \n\nvar bar = foo * 2; \nbar = something( bar ); \nconsole.log( bar ); \n\n}","metadata":{"loc":{"lines":{"from":7481,"to":7503}}}}],["232",{"pageContent":"var foo = true; \n\nif (foo) { \n\nvar bar = foo * 2; \nbar = something( bar ); \nconsole.log( bar ); \n\n} \n\nWe are using a bar variable only in the context of the if statement, so \nit makes a kind of sense that we would declare it inside the if block. \nHowever, where we declare variables is not relevant when using var, \nbecause they will always belong to the enclosing scope. This snippet is \nessentially fake block-scoping, for stylistic reasons, and relying on self¬ \nenforcement not to accidentally use ba r in another place in that scope. \n\nBlock scope is a tool to extend the earlier Principle of Least Privilege \nfrom hiding information in functions to hiding information in blocks \nof our code. \n\n\nBlocks as Scopes | 33 \n\n\n\nConsider the for loop example again: \n\nfor (var 1=0 ; i<10; i++) { \nconsole.log( 1 ); \n\n} \n\nWhy pollute the entire scope of a function with the i variable that is \nonly going to be (or only should be, at least) used for the for loop?","metadata":{"loc":{"lines":{"from":7503,"to":7537}}}}],["233",{"pageContent":"for (var 1=0 ; i<10; i++) { \nconsole.log( 1 ); \n\n} \n\nWhy pollute the entire scope of a function with the i variable that is \nonly going to be (or only should be, at least) used for the for loop? \n\nBut more important, developers may prefer to check themselves \nagainst accidentally (re)using variables outside of their intended pur¬ \npose, such being issued an error about an unknown variable if you try \nto use it in the wrong place. Block-scoping (if it were possible) for the \ni variable would make i available only for the for loop, causing an \nerror if i is accessed elsewhere in the function. This helps ensure vari¬ \nables are not reused in confusing or hard-to-maintain ways. \n\nBut, the sad reality is that, on the surface, JavaScript has no facility for \nblock scope. \n\nThat is, until you dig a little further. \n\nwith","metadata":{"loc":{"lines":{"from":7537,"to":7558}}}}],["234",{"pageContent":"But, the sad reality is that, on the surface, JavaScript has no facility for \nblock scope. \n\nThat is, until you dig a little further. \n\nwith \n\nWe learned about with in Chapter 2. While it is a frowned-upon con¬ \nstruct, it is an example of (a form of) block scope, in that the scope \nthat is created from the object only exists for the lifetime of that with \nstatement, and not in the enclosing scope. \n\ntry/catch \n\nIt’s a very little known fact that JavaScript in ES3 specified the variable \ndeclaration in the catch clause of a try/catch to be block-scoped to \nthe catch block. \n\nFor instance: \n\ntry { \n\nundeftnedQ; // illegal operation to force an exception! \n\n} \n\ncatch (err) { \n\nconsole.log( err ); // works! \n\n} \n\nconsole.log( err ); // ReferenceError: 'err' not found \n\nAs you can see, err exists only in the catch clause, and throws an error \nwhen you try to reference it elsewhere. \n\n\n34 | Chapter 3: Function Versus Block Scope","metadata":{"loc":{"lines":{"from":7558,"to":7596}}}}],["235",{"pageContent":"As you can see, err exists only in the catch clause, and throws an error \nwhen you try to reference it elsewhere. \n\n\n34 | Chapter 3: Function Versus Block Scope \n\n\n\n\nWhile this behavior has been specified and true of practically \nall standard JS environments (except perhaps old IE), many \nlinters seem to still complain if you have two or more catch \nclauses in the same scope that each declare their error vari¬ \nable with the same identifier name. This is not actually a re¬ \ndefinition, since the variables are safely block-scoped, but the \nlinters still seem to, annoyingly, complain about this fact. \n\n\nTo avoid these unnecessary warnings, some devs will name \ntheir catch variables errl, err2, etc. Other devs will simply \nturn off the linting check for duplicate variable names. \n\n\nThe block-scoping nature of catch may seem like a useless academic \nfact, but see Appendix B for more information on just how useful it \nmight be. \n\nlet","metadata":{"loc":{"lines":{"from":7596,"to":7623}}}}],["236",{"pageContent":"The block-scoping nature of catch may seem like a useless academic \nfact, but see Appendix B for more information on just how useful it \nmight be. \n\nlet \n\nThus far, we’ve seen that JavaScript only has some strange niche be¬ \nhaviors that expose block scope functionality. If that were all we had, \nand it was for many, many years, then block scoping would not be \nterribly useful to the JavaScript developer. \n\nFortunately, ES6 changes that, and introduces a new keyword let, \nwhich sits alongside va r as another way to declare variables. \n\nThe let keyword attaches the variable declaration to the scope of \nwhatever block (commonly a { .. } pair) it’s contained in. In other \nwords, let implicitly hijacks any block’s scope for its variable decla¬ \nration. \n\nvar foo = true; \n\nif (foo) { \n\nlet bar = foo * 2; \nbar = something( bar ); \nconsole.log( bar ); \n\n} \n\nconsole.log ( bar ); // ReferenceError","metadata":{"loc":{"lines":{"from":7623,"to":7652}}}}],["237",{"pageContent":"var foo = true; \n\nif (foo) { \n\nlet bar = foo * 2; \nbar = something( bar ); \nconsole.log( bar ); \n\n} \n\nconsole.log ( bar ); // ReferenceError \n\nUsing let to attach a variable to an existing block is somewhat implicit. \nIt can confuse if you’re not paying close attention to which blocks have \nvariables scoped to them and are in the habit of moving blocks around, \nwrapping them in other blocks, etc., as you develop and evolve code. \n\n\nBlocks as Scopes | 35 \n\n\n\n\nCreating explicit blocks for block-scoping can address some of these \nconcerns, making it more obvious where variables are attached and \nnot. Usually, explicit code is preferable over implicit or subtle code. \nThis explicit block-scoping style is easy to achieve and fits more nat¬ \nurally with how block-scoping works in other languages: \n\nvar foo = true; \n\n\nif (foo) { \n\n{//<-- explicit block \nlet bar = foo * 2; \nbar = something( bar ); \nconsole.log( bar ); \n\n} \n\n} \n\n\nconsole.log ( bar ); // ReferenceError","metadata":{"loc":{"lines":{"from":7652,"to":7696}}}}],["238",{"pageContent":"var foo = true; \n\n\nif (foo) { \n\n{//<-- explicit block \nlet bar = foo * 2; \nbar = something( bar ); \nconsole.log( bar ); \n\n} \n\n} \n\n\nconsole.log ( bar ); // ReferenceError \n\nWe can create an arbitrary block for let to bind to by simply including \na { .. } pair anywhere a statement is valid grammar. In this case, \nwe’ve made an explicit block inside the if statement, which may be \neasier as a whole block to move around later in refactoring, without \naffecting the position and semantics of the enclosing if statment. \n\n\n\nFor another way to express explicit block scopes, see Appen¬ \ndix B. \n\n\nIn Chapter 4, we will address hoisting, which talks about declarations \nbeing taken as existing for the entire scope in which they occur. \n\nHowever, declarations made with let will not hoist to the entire scope \nof the block they appear in. Such declarations will not observably “ex¬ \nist” in the block until the declaration statement. \n\n1 \n\nconsole.log( bar ); // ReferenceError! \nlet bar = 2; \n\n}","metadata":{"loc":{"lines":{"from":7696,"to":7737}}}}],["239",{"pageContent":"1 \n\nconsole.log( bar ); // ReferenceError! \nlet bar = 2; \n\n} \n\nGarbage collection \n\nAnother reason block-scoping is useful relates to closures and garbage \ncollection to reclaim memory. We’ll briefly illustrate here, but the clo¬ \nsure mechanism is explained in detail in Chapter 5. \n\n\n36 | Chapter 3: Function Versus Block Scope \n\n\n\n\n\n\nConsider: \n\n\nfunction process(data) { \n\n// do something interesting \n\n} \n\nvar someReallyBigData = { .. }; \nprocess( someReallyBigData ); \n\nvar btn = document. getElementById( \"my_button\" ); \n\nbtn.addEventListener( \"click\", function click(evt){ \nconsole. log(\"button clicked\"); \n\n}, /*capturingPhase=*/fa\\se );","metadata":{"loc":{"lines":{"from":7737,"to":7775}}}}],["240",{"pageContent":"var btn = document. getElementById( \"my_button\" ); \n\nbtn.addEventListener( \"click\", function click(evt){ \nconsole. log(\"button clicked\"); \n\n}, /*capturingPhase=*/fa\\se ); \n\nThe click function click handler callback doesn’t need the someReal \nlyBigData variable at all. That means, theoretically, after pro \ncess(. .) runs, the big memory-heavy data structure could be garbage \ncollected. However, it’s quite likely (though implementation depen¬ \ndent) that the JS engine will still have to keep the structure around, \nsince the click function has a closure over the entire scope. \n\nBlock-scoping can address this concern, making it clearer to the en¬ \ngine that it does not need to keep someReallyBigData around: \n\nfunction process(data) { \n\n// do something interesting \n\n1 \n\n// anything declared inside this block can go away after! \n\n1 \n\nlet someReallyBigData = { .. }; \nprocess( someReallyBigData ); \n\n1 \n\nvar btn = document. getElementById( \"my_button\" );","metadata":{"loc":{"lines":{"from":7775,"to":7807}}}}],["241",{"pageContent":"1 \n\n// anything declared inside this block can go away after! \n\n1 \n\nlet someReallyBigData = { .. }; \nprocess( someReallyBigData ); \n\n1 \n\nvar btn = document. getElementById( \"my_button\" ); \n\nbtn . addEventListener( \"click\", function click(evt){ \nconsole. log(\"button clicked\"); \n\n}, /*capturingPhase=*/fa\\se ); \n\nDeclaring explicit blocks for variables to locally bind to is a powerful \ntool that you can add to your code toolbox. \n\nlet loops \n\nA particular case where let shines is in the for loop case as we dis¬ \ncussed previously. \n\n\nBlocks as Scopes | 37 \n\n\n\nfor (let 1=0 ; l<10; i++) { \nconsole.log( 1 ); \n\n} \n\nconsole.log ( i ); // ReferenceError \n\nNot only does let in the for loop header bind the i to the for loop \nbody, but in fact, it rebinds it to each iteration of the loop, making sure \nto reassign it the value from the end of the previous loop iteration. \n\nHere’s another way of illustrating the per-iteration binding behavior \nthat occurs: \n\n{ \n\nlet j; \n\nfor ( j=0; j<10; j++) {","metadata":{"loc":{"lines":{"from":7807,"to":7856}}}}],["242",{"pageContent":"Here’s another way of illustrating the per-iteration binding behavior \nthat occurs: \n\n{ \n\nlet j; \n\nfor ( j=0; j<10; j++) { \n\nlet i = j; // re-bound for each iteration! \nconsole.log( 1 ); \n\n} \n\n} \n\nThe reason why this per-iteration binding is interesting will become \nclear in Chapter 5 when we discuss closures. \n\nBecause let declarations attach to arbitrary blocks rather than to the \nenclosing functions scope (or global), there can be gotchas where ex¬ \nisting code has a hidden reliance on function-scoped va r declarations, \nand replacing the var with let may require additional care when re¬ \nfactoring code. \n\nConsider: \n\nvar foo = true, baz = 10; \n\nIf (foo) { \n\nvar bar = 3; \n\nif (baz > bar) { \n\nconsole.log( baz ); \n\n} \n\n// ... \n\n} \n\nThis code is fairly easily refactored as: \nvar foo = true, baz = 10; \n\nif (foo) { \n\nvar bar = 3; \n\n\n38 | Chapter 3: Function Versus Block Scope \n\n\n\n\n// ... \n\n} \n\nif (baz > bar) { \n\nconsole.log( baz ); \n\n}","metadata":{"loc":{"lines":{"from":7856,"to":7920}}}}],["243",{"pageContent":"if (foo) { \n\nvar bar = 3; \n\n\n38 | Chapter 3: Function Versus Block Scope \n\n\n\n\n// ... \n\n} \n\nif (baz > bar) { \n\nconsole.log( baz ); \n\n} \n\nBut, be careful of such changes when using block-scoped variables: \nvar foo = true, baz = 10; \n\nif (foo) { \n\nlet bar = 3; \n\nif (baz > bar) { // <-- don't forget 'bar' when moving! \nconsole.log( baz ); \n\n} \n\n} \n\nSee Appendix B for an alternate (more explicit) style of block-scoping \nthat may provide easier to maintain/refactor code that’s more robust \nto these scenarios. \n\nconst \n\nIn addition to let, ES6 introduces const, which also creates a block- \nscoped variable, but whose value is fixed (constant). Any attempt to \nchange that value at a later time results in an error. \n\nvar foo = true; \n\nif (foo) { \n\nvar a = 2; \n\nconst b = 3; // block-scoped to the containing 'if' \n\na = 3; // just fine! \nb = 4; // error! \n\n} \n\nconsole.log ( a ); // 3 \n\nconsole.log( b ); // ReferenceError! \n\nReview","metadata":{"loc":{"lines":{"from":7920,"to":7981}}}}],["244",{"pageContent":"if (foo) { \n\nvar a = 2; \n\nconst b = 3; // block-scoped to the containing 'if' \n\na = 3; // just fine! \nb = 4; // error! \n\n} \n\nconsole.log ( a ); // 3 \n\nconsole.log( b ); // ReferenceError! \n\nReview \n\nFunctions are the most common unit of scope in JavaScript. Variables \nand functions that are declared inside another function are essentially \n“hidden” from any of the enclosing scopes, which is an intentional \ndesign principle of good software. \n\n\nReview | 39 \n\n\n\nBut functions are by no means the only unit of scope. Block scope \nrefers to the idea that variables and functions can b elong to an arbitrary \nblock (generally, any { .. } pair) of code, rather than only to the \nenclosing function. \n\nStarting with ES3, the try/catch structure has block scope in the \ncatch clause.","metadata":{"loc":{"lines":{"from":7981,"to":8014}}}}],["245",{"pageContent":"Starting with ES3, the try/catch structure has block scope in the \ncatch clause. \n\nIn ES6, the let keyword (a cousin to the var keyword) is introduced \nto allow declarations of variables in any arbitrary block of code, if \n(..) { let a = 2; } will declare a variable a that essentially hijacks \nthe scope of the if’s { .. } block and attaches itself there. \n\nThough some seem to believe so, block scope should not be taken as \nan outright replacement of var function scope. Both functionalities \nco-exist, and developers can and should use both function-scope and \nblock-scope techniques where respectively appropriate to produce \nbetter, more readable/maintainable code. \n\n\n40 | Chapter 3: Function Versus Block Scope \n\n\n\nCHAPTER 4 \n\n\nHoisting","metadata":{"loc":{"lines":{"from":8014,"to":8036}}}}],["246",{"pageContent":"40 | Chapter 3: Function Versus Block Scope \n\n\n\nCHAPTER 4 \n\n\nHoisting \n\n\nBy now, you should be fairly comfortable with the idea of scope, and \nhow variables are attached to different levels of scope depending on \nwhere and how they are declared. Both function scope and block scope \nbehave by the same rules in this regard: any variable declared within \na scope is attached to that scope. \n\nBut there’s a subtle detail of how scope attachment works with decla¬ \nrations that appear in various locations within a scope, and that detail \nis what we will examine here. \n\nChicken or the Egg? \n\nThere’s a temptation to think that all of the code you see in a JavaScript \nprogram is interpreted line-by-line, top-down in order, as the program \nexecutes. While that is substantially true, there’s one part of that as¬ \nsumption that can lead to incorrect thinking about your program. \n\nConsider this code: \n\na = 2; \n\nvar a; \n\nconsole.log ( a );","metadata":{"loc":{"lines":{"from":8036,"to":8069}}}}],["247",{"pageContent":"Consider this code: \n\na = 2; \n\nvar a; \n\nconsole.log ( a ); \n\nWhat do you expect to be printed in the console. log (..) statement? \n\nMany developers would expect undefined, since the var a statement \ncomes after the a = 2, and it would seem natural to assume that the \n\n\n41 \n\n\n\n\n\nvariable is redefined, and thus assigned the default undefined. How¬ \never, the output will be 2. \n\nConsider another piece of code: \nconsole.log ( a ); \nvar a = 2; \n\nYou might be tempted to assume that, since the previous snippet ex¬ \nhibited some less-than-top-down looking behavior, perhaps in this \nsnippet, 2 will also be printed. Others may think that since the a vari¬ \nable is used before it is declared, this must result in a ReferenceEr \nror being thrown. \n\nUnfortunately, both guesses are incorrect, undefined is the output. \n\nSo, what’s going on here? It would appear we have a chicken-and-the- \negg question. Which comes first, the declaration (“egg”), or the as¬ \nsignment (“chicken”)?","metadata":{"loc":{"lines":{"from":8069,"to":8106}}}}],["248",{"pageContent":"So, what’s going on here? It would appear we have a chicken-and-the- \negg question. Which comes first, the declaration (“egg”), or the as¬ \nsignment (“chicken”)? \n\nThe Compiler Strikes Again \n\nTo answer this question, we need to refer back to Chapter 1, and our \ndiscussion of compilers. Recall that the engine actually will compile \nyour JavaScript code before it interprets it. Part of the compilation \nphase was to find and associate all declarations with their appropriate \nscopes. Chapter 2 showed us that this is the heart of lexical scope. \n\nSo, the best way to think about things is that all declarations, both \nvariables and functions, are processed first, before any part of your \ncode is executed.","metadata":{"loc":{"lines":{"from":8106,"to":8120}}}}],["249",{"pageContent":"So, the best way to think about things is that all declarations, both \nvariables and functions, are processed first, before any part of your \ncode is executed. \n\nWhen you see var a = 2;, you probably think of that as one statement. \nBut JavaScript actually thinks of it as two statements: var a; and a = \n2;. The first statement, the declaration, is processed during the com¬ \npilation phase. The second statement, the assignment, is left in place \nfor the execution phase. \n\nOur first snippet then should be thought of as being handled like this: \nvar a; \na = 2; \n\nconsole.log ( a ); \n\n\n42 | Chapter 4: Hoisting \n\n\n\n\n.. .where the first part is the compilation and the second part is the \nexecution. \n\nSimilarly, our second snippet is actually processed as: \nvar a; \n\nconsole.log ( a ); \na = 2;","metadata":{"loc":{"lines":{"from":8120,"to":8149}}}}],["250",{"pageContent":".. .where the first part is the compilation and the second part is the \nexecution. \n\nSimilarly, our second snippet is actually processed as: \nvar a; \n\nconsole.log ( a ); \na = 2; \n\nSo, one way of thinking, sort of metaphorically, about this process, is \nthat variable and function declarations are “moved” from where they \nappear in the flow of the code to the top of the code. This gives rise to \nthe name hoisting. \n\nIn other words, the egg (declaration) comes before the chicken (assign¬ \nment). \n\n\n\nOnly the declarations themselves are hoisted, while any as¬ \nsignments or other executable logic are left in place. If hoist¬ \ning were to re-arrange the executable logic of our code, that \ncould wreak havoc. \n\nfooQ; \n\n\nfunction foo() { \n\nconsole.log ( a ); // undefined \n\n\nvar a = 2; \n\ni \n\n\nThe function f oo’s declaration (which in this case includes the implied \nvalue of it as an actual function) is hoisted, such that the call on the \nfirst line is able to execute.","metadata":{"loc":{"lines":{"from":8149,"to":8188}}}}],["251",{"pageContent":"var a = 2; \n\ni \n\n\nThe function f oo’s declaration (which in this case includes the implied \nvalue of it as an actual function) is hoisted, such that the call on the \nfirst line is able to execute. \n\nIt’s also important to note that hoisting is per-scope. So while our pre¬ \nvious snippets were simplified in that they only included global scope, \nthe foo(..) function we are now examining itself exhibits that var \na is hoisted to the top of foo(..) (not, obviously, to the top of the \nprogram). So the program can perhaps be more accurately interpreted \nlike this: \n\nfunction foo() { \nvar a; \n\nconsole.log( a ); // undefined \na = 2; \n\n\nThe Compiler Strikes Again | 43 \n\n\n\n\n} \n\n\nfoo( ); \n\nFunction declarations are hoisted, as we just saw. But function ex¬ \npressions are not. \n\nfoo(); // not ReferenceError, but TypeError! \n\nvar foo = function bar() { \n\n// ... \n\n};","metadata":{"loc":{"lines":{"from":8188,"to":8230}}}}],["252",{"pageContent":"} \n\n\nfoo( ); \n\nFunction declarations are hoisted, as we just saw. But function ex¬ \npressions are not. \n\nfoo(); // not ReferenceError, but TypeError! \n\nvar foo = function bar() { \n\n// ... \n\n}; \n\nThe variable identifier foo is hoisted and attached to the enclosing \nscope (global) of this program, so foo() doesn’t fail as a ReferenceEr \nror. But foo has no value yet (as it would if it had been a true function \ndeclaration instead of expression). So, foo() is attempting to invoke \nthe undefined value, which is a TypeError illegal operation. \n\nAlso recall that even though it’s a named function expression, the name \nidentifier is not available in the enclosing scope: \n\nfoo(); // TypeError \nbar (); // ReferenceError \n\nvar foo = function bar() { \n\n// ... \n\n}; \n\nThis snippet is more accurately interpreted (with hoisting) as: \nvar foo; \n\nfoo(); // TypeError \nbar(); // ReferenceError \n\nfoo = function() { \n\nvar bar = .. .self. .. \n\n// ... \n\n} \n\nFunctions First","metadata":{"loc":{"lines":{"from":8230,"to":8278}}}}],["253",{"pageContent":"foo(); // TypeError \nbar(); // ReferenceError \n\nfoo = function() { \n\nvar bar = .. .self. .. \n\n// ... \n\n} \n\nFunctions First \n\nBoth function declarations and variable declarations are hoisted. But \na subtle detail (that can show up in code with multiple “duplicate” \ndeclarations) is that functions are hoisted first, and then variables. \n\nConsider: \n\n\n44 | Chapter 4: Hoisting \n\n\n\n\nfoo(); // 1 \n\n\nvar foo; \n\nfunction foo() { \n\nconsole.log( 1 ); \n\n} \n\nfoo = function () { \nconsole.log( 2 ); \n\n}; \n\n1 is printed instead of 2! This snippet is interpreted by the Engine as: \n\nfunction foo() { \n\nconsole.log( 1 ); \n\n} \n\nfoo(); // 1 \n\nfoo = function () { \nconsole.log( 2 ); \n\n}; \n\nNotice that var foo was the duplicate (and thus ignored) declaration, \neven though it came before the function f oo()... declaration, because \nfunction declarations are hoisted before normal variables.","metadata":{"loc":{"lines":{"from":8278,"to":8336}}}}],["254",{"pageContent":"While multiple/duplicate var declarations are effectively ignored, \nsubsequent function declarations do override previous ones. \n\nfoo(); // 3 \n\nfunction foo() { \n\nconsole.log( 1 ); \n\n} \n\nvar foo = function/) { \nconsole.log( 2 ); \n\n}; \n\n\nfunction foo() { \n\nconsole.log( 3 ); \n\n} \n\nWhile this all may sound like nothing more than interesting academic \ntrivia, it highlights the fact that duplicate definitions in the same scope \nare a really bad idea and will often lead to confusing results. \n\n\nFunctions First | 45 \n\n\n\n\nFunction declarations that appear inside of normal blocks typically \nhoist to the enclosing scope, rather than being conditional as this code \nimplies: \n\nfoo(); // \"b\" \n\nvar a = true; \nif (a) { \n\nfunction foo() { consote.logC'a\"); } \n\n} \n\nelse { \n\nfunction foo() { console.logC'b\"); } \n\n}","metadata":{"loc":{"lines":{"from":8338,"to":8388}}}}],["255",{"pageContent":"foo(); // \"b\" \n\nvar a = true; \nif (a) { \n\nfunction foo() { consote.logC'a\"); } \n\n} \n\nelse { \n\nfunction foo() { console.logC'b\"); } \n\n} \n\nHowever, it’s important to note that this behavior is not reliable and is \nsubject to change in future versions of JavaScript, so it’s probably best \nto avoid declaring functions in blocks. \n\nReview \n\nWe can be tempted to look at var a = 2; as one statement, but the \nJavaScript engine does not see it that way. It sees var a and a = 2 as \ntwo separate statements, the first one a compiler-phase task, and the \nsecond one an execution-phase task. \n\nWhat this leads to is that all declarations in a scope, regardless of where \nthey appear, are processed first before the code itself is executed. You \ncan visualize this as declarations (variables and functions) being \n“moved” to the top of their respective scopes, which we call hoisting. \n\nDeclarations themselves are hoisted, but assignments, even assign¬ \nments of function expressions, are not hoisted.","metadata":{"loc":{"lines":{"from":8388,"to":8420}}}}],["256",{"pageContent":"Declarations themselves are hoisted, but assignments, even assign¬ \nments of function expressions, are not hoisted. \n\nBe careful about duplicate declarations, especially mixed between \nnormal var declarations and function declarations—peril awaits if you \ndo! \n\n\n46 | Chapter 4: Hoisting \n\n\n\nCHAPTER 5 \n\n\nScope Closure \n\n\nWe arrive at this point with hopefully a very healthy, solid under¬ \nstanding of how scope works. \n\nWe turn our attention to an incredibly important, but persistently \nelusive, almost mythological, part of the language: closure. If you have \nfollowed our discussion of lexical scope thus far, the payoff is that \nclosure is going to be, largely, anticlimactic, almost self-obvious. \nThere’s a man behind the wizard’s curtain, and we’re about to see \nhim. No, his name is not Crockford! \n\nIfhowever you have nagging questions aboutlexical scope, nowwould \nbe a good time to go back and review Chapter 2 before proceeding. \n\nEnlightenment","metadata":{"loc":{"lines":{"from":8420,"to":8451}}}}],["257",{"pageContent":"Ifhowever you have nagging questions aboutlexical scope, nowwould \nbe a good time to go back and review Chapter 2 before proceeding. \n\nEnlightenment \n\nFor those who are somewhat experienced in JavaScript but have per¬ \nhaps never fully grasped the concept of closures, understanding clo¬ \nsure can seem like a special nirvana that one must strive and sacrifice \nto attain. \n\nI recall years back when I had a firm grasp on JavaScript but had no \nidea what closure was. The hint that there was this other side to the \nlanguage, one that promised even more capability than I already pos¬ \nsessed, but it teased and taunted me. I remember reading through the \nsource code of early frameworks trying to understand how it actually \nworked. I remember the first time something of the “module pattern” \nbegan to emerge in my mind. I remember the aha! moments quite \nvividly. \n\n\n47","metadata":{"loc":{"lines":{"from":8451,"to":8471}}}}],["258",{"pageContent":"47 \n\n\n\n\nWhat I didn’t know back then, what took me years to understand, and \nwhat I hope to impart to you presently, is this secret: closure is all \naround you in JavaScript, you just have to recognize and embrace it. \nClosures are not a special opt-in tool that you must learn new syntax \nand patterns for. No, closures are not even a weapon that you must \nlearn to wield and master as Luke trained in the Force. \n\nClosures happen as a result of writing code that relies on lexical scope. \nThey just happen. You do not even really have to intentionally create \nclosures to take advantage of them. Closures are created and used for \nyou all over your code. What you are missing is the proper mental \ncontext to recognize, embrace, and leverage closures for your own will. \n\nThe enlightenment moment should be: oh, closures are already oc¬ \ncurring all over my code, I can finally see them now. Understanding \nclosures is like when Neo sees the Matrix for the first time. \n\nNitty Gritty","metadata":{"loc":{"lines":{"from":8471,"to":8493}}}}],["259",{"pageContent":"Nitty Gritty \n\nOK, enough hyperbole and shameless movie references. \n\nHere’s a down-and-dirty definition of what you need to know to un¬ \nderstand and recognize closures: \n\nClosure is when a function is able to remember and access its lexical \nscope even when that function is executing outside its lexical scope. \n\nLet’s jump into some code to illustrate that definition. \n\nfunction foo() { \nvar a = 2; \n\nfunction bar() { \n\nconsole.log( a ); // 2 \n\n} \n\nbar( ); \n\n} \n\nfoo( ); \n\nThis code should look familiar from our discussions of nested scope. \nFunction ba r () has access to the variable a in the outer enclosing scope \nbecause of lexical scope look-up rules (in this case, it’s an RHS refer¬ \nence look-up). \n\nIs this closure? \n\n\n48 | Chapter 5: Scope Closure","metadata":{"loc":{"lines":{"from":8493,"to":8528}}}}],["260",{"pageContent":"Is this closure? \n\n\n48 | Chapter 5: Scope Closure \n\n\n\n\nWell, technically.. .perhaps. But by our what-you-need-to-know defi¬ \nnition above... not exactly. I think the most accurate way to explain \nbar( ) referencing a is via lexical scope look-up rules, and those rules \nare only (an important!) part of what closure is. \n\nFrom a purely academic perspective, what is said of the above snippet \nis that the function bar( ) has a closure over the scope of foo() (and \nindeed, even over the rest of the scopes it has access to, such as the \nglobal scope in our case). Put slightly differently, it’s said that bar() \ncloses over the scope of foo(). Why? Because bar() appears nested \ninside of foo(). Plain and simple. \n\nBut, closure defined in this way is not directly observable, nor do we \nsee closure exercised in that snippet. We clearly see lexical scope, but \nclosure remains sort of a mysterious shifting shadow behind the code. \n\nLet us then consider code that brings closure into full light:","metadata":{"loc":{"lines":{"from":8528,"to":8552}}}}],["261",{"pageContent":"Let us then consider code that brings closure into full light: \n\nfunction foo() { \nvar a = 2; \n\nfunction bar() { \n\nconsole.log( a ); \n\n} \n\nreturn bar; \n\n} \n\nvar baz = foo(); \n\nbaz(); // 2 -- Whoa, closure was just observed, nan. \n\nThe function bar() has lexical scope access to the inner scope of \nfoo(). But then, we take bar(), the function itself, and pass it as a \nvalue. In this case, we return the function object itself that bar refer¬ \nences. \n\nAfter we execute foo(), we assign the value it returned (our inner \nbar( ) function) to a variable called baz, and then we actually invoke \nbaz( ), which of course is invoking our inner function bar( ), just by \na different identifier reference. \n\nbar( ) is executed, for sure. But in this case, it’s executed outside of its \ndeclared lexical scope. \n\nAfter foo( ) executed, normally we would expect that the entirety of \nthe inner scope of foo() would go away, because we know that the \n\n\nNitty Gritty | 49","metadata":{"loc":{"lines":{"from":8552,"to":8588}}}}],["262",{"pageContent":"After foo( ) executed, normally we would expect that the entirety of \nthe inner scope of foo() would go away, because we know that the \n\n\nNitty Gritty | 49 \n\n\n\nengine employs a garbage collector that comes along and frees up \nmemory once it’s no longer in use. Since it would appear that the con¬ \ntents of foo() are no longer in use, it would seem natural that they \nshould be considered gone. \n\nBut the “magic” of closures does not let this happen. That inner scope \nis in fact still in use, and thus does not go away. Who’s using it? The \nfunction ba r () itself. \n\nBy virtue of where it was declared, bar() has a lexical scope closure \nover that inner scope of foo(), which keeps that scope alive for bar() \nto reference at any later time. \n\nbar() still has a reference to that scope, and that reference is called \nclosure.","metadata":{"loc":{"lines":{"from":8588,"to":8610}}}}],["263",{"pageContent":"bar() still has a reference to that scope, and that reference is called \nclosure. \n\nSo, a few microseconds later, when the variable baz is invoked (in¬ \nvoking the inner function we initially labeled bar), it duly has access \nto author-time lexical scope, so it can access the variable a just as we’d \nexpect. \n\nThe function is being invoked well outside of its author-time lexical \nscope. Closure lets the function continue to access the lexical scope it \nwas defined in at author time. \n\nOf course, any of the various ways that functions can be passed \naround as values, and indeed invoked in other locations, are all ex¬ \namples of observing/exercising closure. \n\nfunction foo() { \nvar a = 2; \n\nfunction baz() { \n\nconsole.log( a ); // 2 \n\n} \n\nbar( baz ); \n\n} \n\nfunction bar(fn) { \n\nfn(); // look na, I saw closure! \n\n}","metadata":{"loc":{"lines":{"from":8610,"to":8643}}}}],["264",{"pageContent":"function foo() { \nvar a = 2; \n\nfunction baz() { \n\nconsole.log( a ); // 2 \n\n} \n\nbar( baz ); \n\n} \n\nfunction bar(fn) { \n\nfn(); // look na, I saw closure! \n\n} \n\nWe pass the inner function baz over to ba r, and call that inner function \n(labeled f n now), and when we do, its closure over the inner scope of \nfoo() is observed by accessing a. \n\nThese passings-around of functions can be indirect, too. \n\n\n50 | Chapter 5: Scope Closure \n\n\n\n\nvar fn; \n\n\nfunction foo() { \nvar a = 2; \n\nfunction baz() { \n\nconsole.log( a ); \n\n} \n\nfn = baz; // assign baz to global variable \n\n} \n\nfunction bar() { \n\nfn(); // look na, I saw closure! \n\n} \n\nfoo( ); \nbar(); // 2 \n\nWhatever facility we use to transport an inner function outside of its \nlexical scope, it will maintain a scope reference to where it was origi¬ \nnally declared, and wherever we execute him, that closure will be ex¬ \nercised. \n\nNow I Can See","metadata":{"loc":{"lines":{"from":8643,"to":8704}}}}],["265",{"pageContent":"Now I Can See \n\nThe previous code snippets are somewhat academic and artifically \nconstructed to illustrate using closure. But I promised you something \nmore than just a cool new toy. I promised that closure was something \nall around you in your existing code. Let us now see that truth. \n\nfunction wait(message) { \n\nsetTimeout( function tiner(){ \nconsole.log( message ); \n\n}, 1000 ); \n\n\n} \n\nwait( \"Hello, closure!\" ); \n\nWe take an inner function (named timer) and pass it to setTime \nout( ..). But timer has a scope closure over the scope of wait(..), \nindeed keeping and using a reference to the variable message. \n\n\nNow I Can See | 51 \n\n\n\n\nA thousand milliseconds after we have executed wait(..), and its \ninner scope should otherwise be long gone, that anonymous function \nstill has closure over that scope.","metadata":{"loc":{"lines":{"from":8704,"to":8735}}}}],["266",{"pageContent":"Now I Can See | 51 \n\n\n\n\nA thousand milliseconds after we have executed wait(..), and its \ninner scope should otherwise be long gone, that anonymous function \nstill has closure over that scope. \n\nDeep down in the guts of the engine, the built-in utility setTime \nout(..) has reference to some parameter, probably called fn or func \nor something like that. Engine goes to invoke that function, which is \ninvoking our inner timer function, and the lexical scope reference is \nstill intact. \n\nClosure. \n\nOr, if you’re of the jQuery persuasion (or any JS framework, for that \nmatter): \n\nfunction setupBot(name,setector) { \n\n$( selector ).click( function activator(){ \nconsole. log( \"Activating: \" + name ); \n\n} ); \n\n} \n\nsetupBot( \"Closure Bot 1\", \"#bot_l\" ); \nsetupBot( \"Closure Bot 2\", \"#bot_2\" ); \n\nI am not sure what kind of code you write, but I regularly write code \nthat is responsible for controlling an entire global drone army of clo¬ \nsure hots, so this is totally realistic!","metadata":{"loc":{"lines":{"from":8735,"to":8769}}}}],["267",{"pageContent":"I am not sure what kind of code you write, but I regularly write code \nthat is responsible for controlling an entire global drone army of clo¬ \nsure hots, so this is totally realistic! \n\n(Some) joking aside, essentially whenever and wherever you treat func¬ \ntions (that access their own respective lexical scopes) as first-class val¬ \nues and pass them around, you are likely to see those functions exer¬ \ncising closure. Be that timers, event handlers, Ajax requests, cross¬ \nwindow messaging, web workers, or any of the other asynchronous \n(or synchronous!) tasks, when you pass in a callback function, get ready \nto sling some closure around! \n\n\n\nChapter 3 introduced the IIFE pattern. While it is often said \nthat IIFE (alone) is an example of observed closure, I would \nsomewhat disagree, by our previous definition. \n\n\nvar a = 2; \n\n(function IIFE(){ \nconsole.log( a ); \n\nDO; \n\n\n52 | Chapter 5:Scope Closure","metadata":{"loc":{"lines":{"from":8769,"to":8796}}}}],["268",{"pageContent":"var a = 2; \n\n(function IIFE(){ \nconsole.log( a ); \n\nDO; \n\n\n52 | Chapter 5:Scope Closure \n\n\n\n\n\nThis code works, but it’s not strictly an observation of closure. Why? \nBecause the function (which we named IIFE here) is not executed \noutside its lexical scope. It’s still invoked right there in the same scope \nas it was declared (then enclosing/global scope that also holds a), a is \nfound via normal lexical scope look-up, not really via closure. \n\nWhile closure might technically be happening at declaration time, it \nis not strictly observable, and so, as they say, it’s a tree falling in the \nforest with no one around to hear it. \n\nThough an IIFE is not itself an example of observed closure, it abso¬ \nlutely creates scope, and it’s one of the most common tools we use to \ncreate scope which can be closed over. So IIFEs are indeed heavily \nrelated to closure, even if not exercising closure themselves.","metadata":{"loc":{"lines":{"from":8796,"to":8823}}}}],["269",{"pageContent":"Put this book down right now, dear reader. I have a task for you. Go \nopen up some of your recent JavaScript code. Look for your functions- \nas-values and identify where you are already using closure and maybe \ndidn’t even know it before. \n\nI’ll wait. \n\nNow you see! \n\n\nLoops and Closure \n\nThe most common canonical example used to illustrate closure in¬ \nvolves the humble for loop. \n\nfor (var 1=1 ; 1<=5 ; t++) { \n\nsetTimeout( function timer(){ \nconsole.log( 1 ); \n\n}, 1*1000 ); \n\n} \n\n\n\nLinters often complain when you put functions inside of loops, \nbecause the mistakes of not understanding closure are so com¬ \nmon among developers. We explain how to do so properly here, \nleveraging the full power of closure. But that subtlety is often \nlost on linters, and they will complain regardless, assuming you \ndon’t actually know what you’re doing.","metadata":{"loc":{"lines":{"from":8825,"to":8856}}}}],["270",{"pageContent":"The spirit of this code snippet is that we would normally expect for the \nbehavior to be that the numbers 1,2,.. .5 would be printed out, one at \na time, one per second, respectively. \n\n\nLoops and Closure | S3 \n\n\n\n\nIn fact, if you run this code, you get 6 printed out five times, at the \none-second intervals. \n\nHuh? \n\nFirst, let’s explain where 6 comes from. The terminating condition of \nthe loop is when i is not <=5. The first time that’s the case is when i is \n6. So, the output is reflecting the final value of the i after the loop \nterminates. \n\nThis actually seems obvious on second glance. The timeout function \ncallbacks are all running well after the completion of the loop. In fact, \nas timers go, even if it was setTimeout(.., 0) on each iteration, all \nthose function callbacks would still run strictly after the completion \nof the loop, and thus print 6 each time.","metadata":{"loc":{"lines":{"from":8859,"to":8883}}}}],["271",{"pageContent":"But there’s a deeper question at play here. What’s missing from our \ncode to actually have it behave as we semantically have implied? \n\nWhat’s missing is that we are trying to imply that each iteration of the \nloop “captures” its own copy of i, at the time of the iteration. But, the \nway scope works, all five of those functions, though they are defined \nseparately in eachloop iteration, are closed over the same shared global \nscope, which has, in fact, only one i in it. \n\nPut that way, of course all functions share a reference to the same i. \nSomething about the loop structure tends to confuse us into thinking \nthere’s something else more sophisticated at work. There is not. There’s \nno difference than if each of the five timeout callbacks were just de¬ \nclared one right after the other, with no loop at all. \n\nOK, so, back to our burning question. What’s missing? We need more \nclosured scope. Specifically, we need a new closured scope for each \niteration of the loop.","metadata":{"loc":{"lines":{"from":8885,"to":8902}}}}],["272",{"pageContent":"OK, so, back to our burning question. What’s missing? We need more \nclosured scope. Specifically, we need a new closured scope for each \niteration of the loop. \n\nWe learned in Chapter 3 that the IIFE creates scope by declaring a \nfunction and immediately executing it. \n\nLet’s try: \n\nfor (var 1=1 ; 1<=5 ; i++) { \n\n(function( ){ \n\nsetTimeout( function timer(){ \nconsole.log( 1 ); \n\n}, 1*1000 ); \n\n})(); \n\n} \n\n\n54 | Chapter 5: Scope Closure \n\n\n\n\nDoes that work? Try it. Again, I’ll wait. \n\nI’ll end the suspense for you. Nope. But why? We now obviously have \nmore lexical scope. Each timeout function callback is indeed closing \nover its own per-iteration scope created respectively by each IIFE. \n\nIt’s not enough to have a scope to close over if that scope is empty. Look \nclosely. Our IIFE is just an empty do-nothing scope. It needs some¬ \nthing in it to be useful to us. \n\nIt needs its own variable, with a copy of the i value at each iteration. \n\nfor (var i=l; i<=5; i++) {","metadata":{"loc":{"lines":{"from":8902,"to":8942}}}}],["273",{"pageContent":"It needs its own variable, with a copy of the i value at each iteration. \n\nfor (var i=l; i<=5; i++) { \n\n(function! ){ \nvar j = i; \n\nsetTimeout( function timer(){ \nconsote.log( j ); \n\n}, j*1000 ); \n\nDO; \n\n1 \n\nEureka! It works! \n\nA slight variation some prefer is: \n\nfor (var i=l; i<=5; i++) { \n\n(function! j){ \n\nsetTimeout( function timer(){ \nconsote.log( j ); \n\n}, j*1000 ); \n\n})( i ); \n\n} \n\nOf course, since these IIFEs are just functions, we can pass in i, and \nwe can call it j if we prefer, or we can even call it i again. Either way, \nthe code works now. \n\nThe use of an IIFE inside each iteration created a new scope for each \niteration, which gave our timeout function callbacks the opportunity \nto close over a new scope for each iteration, one which had a variable \nwith the right per-iteration value in it for us to access. \n\nProblem solved! \n\nBlock Scoping Revisited","metadata":{"loc":{"lines":{"from":8942,"to":8986}}}}],["274",{"pageContent":"Problem solved! \n\nBlock Scoping Revisited \n\nLook carefully at our analysis of the previous solution. We used an \nIIFE to create new scope per-iteration. In other words, we actually \nneeded a per-iteration block scope. Chapter 3 showed us the let \n\n\nLoops and Closure | 55 \n\n\n\ndeclaration, which hijacks a block and declares a variable right there \nin the block. \n\nIt essentially turns a block into a scope that we can close over. So, the \nfollowing awesome code just works: \n\nfor (var 1=1; t<=5; 1++) { \n\nlet j = 1; // yay, block-scope for closure! \nsetTlmeout( function tlner(){ \nconsole. log( j ); \n\n}, j*1000 ); \n\n} \n\nBut, that’s not all! (in my best Bob Barker voice). There’s a special \nbehavior defined for let declarations used in the head of a for loop. \nThis behavior says that the variable will be declared not just once for \nthe loop, but each iteration. And, it will, helpfully, be initialized at \neach subsequent iteration with the value from the end of the previous \niteration.","metadata":{"loc":{"lines":{"from":8986,"to":9020}}}}],["275",{"pageContent":"for (let 1=1; 1<=5; 1++) { \n\nsetTlmeout( function tlmer(){ \nconsole. log( 1 ); \n\n}, 1*1000 ); \n\n} \n\nHow cool is that? Block scoping and closure working hand-in-hand, \nsolving all the world’s problems. I don’t know about you, but that \nmakes me a happy JavaScripter. \n\nModules \n\nThere are other code patterns that leverage the power of closure but \nthat do not on the surface appear to be about callbacks. Let’s examine \nthe most powerful of them: the module. \n\nfunction foo() { \n\nvar something = \"cool\"; \nvar another = [1, 2, 3]; \n\nfunction doSomethlng( ) { \n\nconsole. log( something ); \n\n} \n\nfunction doAnotherQ { \n\nconsole. log( another . joln( \" ! \" ) ); \n\n} \n\n} \n\n\n56 | Chapter 5: Scope Closure \n\n\n\n\nAs this code stands right now, there’s no observable closure going on. \nWe simply have some private data variables something and another, \nand a couple of inner functions doSomething() and doAnotherQ, \nwhich both have lexical scope (and thus closure!) over the inner scope \nof foo().","metadata":{"loc":{"lines":{"from":9022,"to":9070}}}}],["276",{"pageContent":"But now consider: \n\nfunction CoolModuleQ { \n\nvar something = \"cool\"; \nvar another = [1, 2, 3]; \n\nfunction doSomething Q { \n\nconsole.log( something ); \n\n} \n\nfunction doAnotherQ { \n\nconsole.log( another . join( \" ! \" ) ); \n\n} \n\nreturn { \n\ndoSomething: doSomething, \ndoAnother: doAnother \n\n}; \n\n} \n\nvar foo = CoolModuleQ; \n\nfoo.doSomethingQ; // cool \nfoo.doAnotherQ; // 1 ! 2 ! 3 \n\nThis is the pattern in JavaScript we call module. The most common \nway of implementing the module pattern is often called revealing \nmodule, and it’s the variation we present here. \n\nLet’s examine some things about this code. \n\nFirst, CoolModuleQ is just a function, but it has to be invoked for there \nto be a module instance created. Without the execution of the outer \nfunction, the creation of the inner scope and the closures would not \noccur.","metadata":{"loc":{"lines":{"from":9072,"to":9114}}}}],["277",{"pageContent":"Second, the CoolModule() function returns an object, denoted by the \nobject-literal syntax { key: value, ... }. The object we return has \nreferences on it to our inner functions, but not to our inner data vari¬ \nables. We keep those hidden and private. It’s appropriate to think of \nthis object return value as essentially a public API for our module. \n\n\nModules | 57 \n\n\n\n\n\nThis object return value is ultimately assigned to the outer variable \nf oo, and then we can access those property methods on the API, like \nfoo.doSomethingQ. \n\n\n\nIt is not required that we return an actual object (literal) from \nour module. We could just return back an inner function di¬ \nrectly. jQuery is actually a good example of this. The jQuery \nand $ identifiers are the public API for the jQuery module, but \nthey are, themselves, just functions (which can themselves have \nproperties, since all functions are objects).","metadata":{"loc":{"lines":{"from":9116,"to":9140}}}}],["278",{"pageContent":"The doSomething () and doAnothe r () functions have closure over the \ninner scope of the module instance (arrived at by actually invoking \nCoolModuleQ). When we transport those functions outside of the \nlexical scope, by way of property references on the object we return, \nwe have now set up a condition by which closure can be observed and \nexercised. \n\nTo state it more simply, there are two requirements for the module \npattern to be exercised: \n\n1. There must bean outer enclosing function, and it must be invoked \nat least once (each time creates a new module instance). \n\n2. The enclosing function must return back at least one inner func¬ \ntion, so that this inner function has closure over the private scope, \nand can access and/or modify that private state.","metadata":{"loc":{"lines":{"from":9143,"to":9158}}}}],["279",{"pageContent":"2. The enclosing function must return back at least one inner func¬ \ntion, so that this inner function has closure over the private scope, \nand can access and/or modify that private state. \n\nAn object with a function property on it alone is not really a module. \nAn object that is returned from a function invocation that only has \ndata properties on it and no closured functions is not really a module, \nin the observable sense. \n\nThe previous code snippet shows a standalone module creator called \nCoolModule(), which can be invoked any number of times, each time \ncreating a new module instance. A slight variation on this pattern is \nwhen you only care to have one instance, a singleton of sorts: \n\nvar foo = (function CoolModuleQ { \nvar something = \"cool\"; \nvar another = [1, 2, 3]; \n\nfunction doSomething () { \n\nconsole.log( something ); \n\n} \n\n\n58 | Chapter 5: Scope Closure \n\n\n\n\n\nfunction doAnother() { \n\nconsole.log( another . join( \" ! \" ) ); \n\n} \n\nreturn {","metadata":{"loc":{"lines":{"from":9158,"to":9195}}}}],["280",{"pageContent":"function doSomething () { \n\nconsole.log( something ); \n\n} \n\n\n58 | Chapter 5: Scope Closure \n\n\n\n\n\nfunction doAnother() { \n\nconsole.log( another . join( \" ! \" ) ); \n\n} \n\nreturn { \n\ndoSomething: doSomething, \ndoAnother: doAnother \n\n}; \n\n})(); \n\nfoo.doSomethingQ; // cool \nfoo.doAnother(); // 1 ! 2 ! 3 \n\nHere, we turned our module function into an IIFE (see Chapter 3), \nand we immediately invoked it and assigned its return value directly \nto our single module instance identifier f oo. \n\nModules are just functions, so they can receive parameters: \n\nfunction CoolModule(id) { \nfunction identify() { \nconsole.log( id ); \n\n} \n\nreturn { \n\nidentify: identify \n\n}; \n\n} \n\nvar fool = CoolModule( \"foo 1\" ); \nvar foo2 = CoolModule( \"foo 2\" ); \n\nfool.identifyQ; // \"foo 1\" \nfoo2.identify(); // \"foo 2\" \n\nAnother slight but powerful variation on the module pattern is to \nname the object you are returning as your public API: \n\nvar foo = (function CoolModule(id) { \nfunction changeQ {","metadata":{"loc":{"lines":{"from":9195,"to":9256}}}}],["281",{"pageContent":"Another slight but powerful variation on the module pattern is to \nname the object you are returning as your public API: \n\nvar foo = (function CoolModule(id) { \nfunction changeQ { \n\n// modifying the public API \npublicAPI.identify = identify2; \n\n} \n\nfunction identifylQ { \nconsole.log( id ); \n\n} \n\nfunction identify2() { \n\nconsole.log( id . totlpperCase( ) ); \n\n} \n\n\nModules | 59 \n\n\n\n\n\nvar publicAPI = { \nchange: change, \nidentify: identifyl \n\n}; \n\n\nreturn publicAPI; \n\n})( \"foo nodule\" ); \n\nfoo.identify(); // foo nodule \nfoo.change(); \n\nfoo.identifyQ; // FOO MODULE \n\nBy retaining an inner reference to the public API object inside your \nmodule instance, you can modify that module instance from the in¬ \nside, including adding and removing methods and properties, and \nchanging their values. \n\nModern Modules","metadata":{"loc":{"lines":{"from":9256,"to":9306}}}}],["282",{"pageContent":"Modern Modules \n\nVarious module dependency loaders/managers essentially wrap up \nthis pattern of module definition into a friendly API. Rather than ex¬ \namine any one particular library, let me present a very simple proof of \nconcept for illustration purposes (only): \n\nvar MyModules = (function ManagerQ { \nvar nodules = {}; \n\nfunction define(name, deps, inpl) { \n\nfor (var i=0; i<deps.length; i++) { \ndeps[i] = modules[deps[i]]; \n\n} \n\nmodulesfname] = inpl.apply( inpl, deps ); \n\n} \n\nfunction get(nane) { \n\nreturn modulesfnane] ; \n\n} \n\nreturn { \n\ndefine: define, \nget: get \n\n}; \n\n})(); \n\nThe key part of this code is nodules [name] = inpl.apply(impl, \ndeps). This is invoking the definition wrapper function for a module \n(passing in any dependencies), and storing the return value, the mod¬ \nule’s API, into an internal list of modules tracked by name. \n\n\n60 | Chapter 5: Scope Closure \n\n\n\nAnd here’s how I might use it to define some modules:","metadata":{"loc":{"lines":{"from":9306,"to":9352}}}}],["283",{"pageContent":"60 | Chapter 5: Scope Closure \n\n\n\nAnd here’s how I might use it to define some modules: \n\nMyModules.define( \"bar\", [], function(){ \nfunction hello(who) { \n\nreturn \"Let me introduce: \" + who; \n\n} \n\nreturn { \n\nhello: hello \n\n}; \n\n} ); \n\nMyModules.define( \"foo\", [\"bar\"], function(bar){ \nvar hungry = \"hippo\"; \n\nfunction awesomeQ { \n\nconsole.log( bar.hello( hungry ). totlpperCase( ) ); \n\n} \n\nreturn { \n\nawesome: awesome \n\n}; \n\n} ); \n\nvar bar = MyModules.get( \"bar\" ); \nvar foo = MyModules.get( \"foo\" ); \n\nconsole.log ( \n\nbar.hello( \"hippo\" ) \n\n); // Let ne introduce: hippo \n\nfoo.awesomeQ; // LET ME INTRODUCE: HIPPO \n\nBoth the \"foo\" and \"bar\" modules are defined with a function that \nreturns a public API. \"foo\" even receives the instance of \"bar\" as a \ndependency parameter, and can use it accordingly.","metadata":{"loc":{"lines":{"from":9352,"to":9403}}}}],["284",{"pageContent":"Both the \"foo\" and \"bar\" modules are defined with a function that \nreturns a public API. \"foo\" even receives the instance of \"bar\" as a \ndependency parameter, and can use it accordingly. \n\nSpend some time examining these code snippets to fully understand \nthe power of closures put to use for our own good purposes. The key \ntake-away is that there’s not really any particular “magic” to module \nmanagers. They fulfill both characteristics of the module pattern I lis¬ \nted above: invoking a function definition wrapper, and keeping its \nreturn value as the API for that module. \n\nIn other words, modules are just modules, even if you put a friendly \nwrapper tool on top of them. \n\n\nModules | 61 \n\n\n\n\n\nFuture Modules \n\nES6 adds first-class syntax support for the concept of modules. When \nloaded via the module system, ES6 treats a file as a separate module. \nEach module can both import other modules or specific API members, \nas well export their own public API members.","metadata":{"loc":{"lines":{"from":9403,"to":9429}}}}],["285",{"pageContent":"Function-based modules aren’t a statically recognized pattern \n(something the compiler knows about), so their API seman¬ \ntics aren’t considered until runtime. That is, you can actually \nmodify a module’s API during the runtime (see earlier publi \ncAPI discussion). \n\n\nBy contrast, ES6 module APIs are static (the APIs don’t change \nat runtime). Since the compiler knows that, it can (and does!) \ncheck during (file loading and) compilation that a reference to \na member of an imported module’s API actually exists. If the \nAPI reference doesn’t exist, the compiler throws an “early” \nerror at compile time, rather than waiting for traditional dy¬ \nnamic runtime resolution (and errors, if any). \n\n\nES6 modules do not have an “inline” format, they must be defined in \nseparate files (one per module). The browsers/engines have a default \n“module loader” (which is overridable, but that’s well-beyond our dis¬ \ncussion here), which synchronously loads a module file when it’s im¬ \nported.","metadata":{"loc":{"lines":{"from":9433,"to":9453}}}}],["286",{"pageContent":"Consider: \n\nbar.js \n\nfunction hello(who) { \n\nreturn \"Let ne introduce: \" + who; \n\n1 \n\nexport hello; \n\nfoo.js \n\n// inport only 'hello()' fron the \"bar\" nodule \nimport hello from \"bar\"; \n\nvar hungry = \"hippo\"; \n\nfunction awesomeQ { \nconsole.log( \n\nhello( hungry ). tollpperCase( ) \n\n); \n\n\n62 | Chapter 5: Scope Closure \n\n\n\n\n\n} \n\n\nexport awesome; \nbaz.js \n\n// inport the entire \"foo\" and \"bar\" nodules \nmodule foo from \"foo\"; \nmodule bar from \"bar\"; \n\nconsole.log( \n\nbar.hello( \"rhino\" ) \n\n); // Let ne introduce: rhino \n\nfoo.awesomeQ; // LET ME INTRODUCE: HIPPO \n\n\n\nSeparate files foo.js and bar.js would need to be created, with \nthe contents as shown in the first two snippets, respectively. \nThen, your program baz.js would load/import those modules \nto use them, as shown in the third snippet.","metadata":{"loc":{"lines":{"from":9455,"to":9511}}}}],["287",{"pageContent":"import imports one or more members from a module’s API into the \ncurrent scope, each to a bound variable (hello in our case), module \nimports an entire module API to a bound variable (foo, bar in our \ncase), export exports an identifier (variable, function) to the public \nAPI for the current module. These operators can be used as many times \nin a module’s definition as is necessary. \n\nThe contents inside the module file are treated as if enclosed in a scope \nclosure, just like with the function-closure modules seen earlier. \n\nReview \n\nClosure seems to the unenlightened like a mystical world set apart \ninside of JavaScript that only the few bravest souls can reach. But it’s \nactually just a standard and almost obvious fact of how we write code \nin a lexically scoped environment, where functions are values and can \nbe passed around at will. \n\nClosure is when a function can remember and access its lexical scope \neven when it’s invoked outside its lexical scope.","metadata":{"loc":{"lines":{"from":9514,"to":9533}}}}],["288",{"pageContent":"Closure is when a function can remember and access its lexical scope \neven when it’s invoked outside its lexical scope. \n\nClosures can trip us up, for instance with loops, if we’re not careful to \nrecognize them and how they work. But they are also an immensely \npowerful tool, enabling patterns like modules in their various forms. \n\n\nReview | 63 \n\n\n\n\nModules require two key characteristics: 1) an outer wrapping func¬ \ntion being invoked, to create the enclosing scope 2) the return value \nof the wrapping function must include reference to at least one inner \nfunction that then has closure over the private inner scope of the \nwrapper. \n\nNow we can see closures all around our existing code, and we have the \nability to recognize and leverage them to our own benefit! \n\n\n64 | Chapter 5:Scope Closure \n\n\n\nAPPENDIX A \n\n\nDynamic Scope","metadata":{"loc":{"lines":{"from":9533,"to":9563}}}}],["289",{"pageContent":"Now we can see closures all around our existing code, and we have the \nability to recognize and leverage them to our own benefit! \n\n\n64 | Chapter 5:Scope Closure \n\n\n\nAPPENDIX A \n\n\nDynamic Scope \n\n\nIn Chapter 2, we talked about dynamic scope as a contrast to the lexical \nscope model, which is how scope works in JavaScript (and in fact, most \nother languages). \n\nWe will briefly examine dynamic scope, to hammer home the contrast. \nBut, more important, dynamic scope actually is a near cousin to an¬ \nother mechanism (this) in JavaScript, which we cover in the this & \nObject Prototypes title of the You Don’t Know JS book series. \n\nAs we saw in Chapter 2, lexical scope is the set of rules about how the \nengine can look up a variable and where it will find it. The key char¬ \nacteristic of lexical scope is that it is defined at author time, when the \ncode is written (assuming you don’t cheat with eval() or with).","metadata":{"loc":{"lines":{"from":9563,"to":9589}}}}],["290",{"pageContent":"Dynamic scope seems to imply, and for good reason, that there’s a \nmodel whereby scope can be determined dynamically at runtime, \nrather than statically at author time. That is in fact the case. Let’s il¬ \nlustrate via code: \n\nfunction foo() { \n\nconsole.log( a ); // 2 \n\n} \n\nfunction bar() { \nvar a = 3; \nfoo( ); \n\n} \n\nvar a = 2; \nbar(); \n\n\n65 \n\n\n\n\nLexical scope holds that the RHS reference to a in foo() will be re¬ \nsolved to the global variable a, which will result in value 2 being output. \n\nDynamic scope, by contrast, doesn’t concern itself with how and where \nfunctions and scopes are declared, but rather where they are called \nfrom. In other words, the scope chain is based on the call-stack, not \nthe nesting of scopes in code. \n\nSo, if JavaScript had dynamic scope, when foo() is executed, theoret¬ \nically the code below would instead result in 3 as the output. \n\nfunction foo() { \n\nconsole.log( a ); // 3 (not 2!) \n\n} \n\nfunction bar() { \nvar a = 3; \nfoo(); \n\n} \n\nvar a = 2; \nbar();","metadata":{"loc":{"lines":{"from":9591,"to":9641}}}}],["291",{"pageContent":"function foo() { \n\nconsole.log( a ); // 3 (not 2!) \n\n} \n\nfunction bar() { \nvar a = 3; \nfoo(); \n\n} \n\nvar a = 2; \nbar(); \n\nHow can this be? Because when foo() cannot resolve the variable \nreference for a, instead of stepping up the nested (lexical) scope chain, \nit walks up the call stack, to find where foo() was called from. Since \nfoo() was called from bar(), it checks the variables in scope for \nbar( ), and finds an a there with value 3. \n\nStrange? You’re probably thinking so, at the moment. \n\nBut that’s just because you’ve probably only ever worked on (or at least \ndeeply considered) code that is lexically scoped. So dynamic scoping \nseems foreign. If you had only ever written code in a dynamically \nscoped language, it would seem natural, and lexical scope would be \nthe odd ball. \n\nTo be clear, JavaScript does not, in fact, have dynamic scope. It has \nlexical scope. Plain and simple. But the this mechanism is kind of like \ndynamic scope. \n\n\n66 | Appendix A: Dynamic Scope","metadata":{"loc":{"lines":{"from":9641,"to":9675}}}}],["292",{"pageContent":"To be clear, JavaScript does not, in fact, have dynamic scope. It has \nlexical scope. Plain and simple. But the this mechanism is kind of like \ndynamic scope. \n\n\n66 | Appendix A: Dynamic Scope \n\n\n\nThe key contrast: lexical scope is write-time, whereas dynamic scope \n(and this!) are runtime. Lexical scope cares where a function was \ndeclared, but dynamic scope cares where a function was called from. \n\nFinally, this cares how a function was called, which shows how closely \nrelated the this mechanism is to the idea of dynamic scoping. To dig \nmore into this, read the You Don’t Know JS title this & Object Proto¬ \ntypes. \n\n\nDynamic Scope | 67 \n\n\n\nAPPENDIX B \n\n\nPolyfilling Block Scope \n\n\nIn Chapter 3, we explored block scope. We saw that with and the catch \nclause are both tiny examples of block scope that have existed in Java¬ \nScript since at least the introduction of ES3.","metadata":{"loc":{"lines":{"from":9675,"to":9706}}}}],["293",{"pageContent":"In Chapter 3, we explored block scope. We saw that with and the catch \nclause are both tiny examples of block scope that have existed in Java¬ \nScript since at least the introduction of ES3. \n\nBut it’s ES6’s introduction of let that finally gives full, unfettered block \nscoping capability to our code. There are many exciting things, both \nfunctionally and code-stylistically, that block scope will enable. \n\nBut what if we wanted to use block scope in pre-ES6 environments? \n\nConsider this code: \n\n1 \n\nlet a = 2; \n\nconsole.log( a ); // 2 \n\n1 \n\nconsole.log ( a ); // ReferenceError \n\nThis will work great in ES6 environments. But can we do so pre-ES6? \ncatch is the answer. \n\ntry{throw 2}catch(a){ \n\nconsole.log( a ); // 2 \n\n1 \n\nconsole.log ( a ); // ReferenceError","metadata":{"loc":{"lines":{"from":9706,"to":9737}}}}],["294",{"pageContent":"This will work great in ES6 environments. But can we do so pre-ES6? \ncatch is the answer. \n\ntry{throw 2}catch(a){ \n\nconsole.log( a ); // 2 \n\n1 \n\nconsole.log ( a ); // ReferenceError \n\nWhoa! That’s some ugly, weird looking code. We see a try/catch that \nappears to forcibly throw an error, but the “error” it throws is just a \nvalue 2, and then the variable declaration that receives it is in the \ncatch (a) clause. Mind: blown. \n\n\n69 \n\n\n\n\nThat’s right, the catch clause has block-scoping to it, which means it \ncan be used as a polyfill for block scope in pre-ES6 environments. \n\n“But”, you say, “no one wants to write ugly code like that!” That’s true. \nNo one writes (some of) the code output by the CoffeeScript compiler, \neither. That’s not the point.","metadata":{"loc":{"lines":{"from":9737,"to":9764}}}}],["295",{"pageContent":"“But”, you say, “no one wants to write ugly code like that!” That’s true. \nNo one writes (some of) the code output by the CoffeeScript compiler, \neither. That’s not the point. \n\nThe point is that tools can transpile ES6 code to work in pre-ES6 en¬ \nvironments. You can write code using block scoping, and benefit from \nsuch functionality, and let a build-step tool take care of producing code \nthat will actually work when deployed. \n\nThis is actually the preferred migration path for all (ahem, most) of \nES6: to use a code transpiler to take ES6 code and produce ES5- \ncompatible code during the transition from pre-ES6 to ES6. \n\nTraceur \n\nGoogle maintains a project called Traceur 1 , which is exactly tasked \nwith transpiling ES6 features into pre-ES6 (mostly ES5, but not all!) \nfor general usage. The TC39 committee relies on this tool (and others) \nto test out the semantics of the features they specify. \n\nWhat does Traceur produce from our snippet? You guessed it! \n\n{ \n\ntry {","metadata":{"loc":{"lines":{"from":9764,"to":9788}}}}],["296",{"pageContent":"What does Traceur produce from our snippet? You guessed it! \n\n{ \n\ntry { \n\nthrow undefined; \n\n} catch (a) { \n\na = 2; \n\nconsole.log( a ); \n\n} \n\n} \n\nconsole.log( a ); \n\nSo, with the use of such tools, we can start taking advantage of block \nscope regardless of if we are targeting ES6 or not, because try/ \ncatch has been around (and worked this way) from ES3 days. \n\n\n1. Google Traceur \n\n\n70 | Appendix B: Polyfilling Block Scope \n\n\n\nImplicit Versus Explicit Blocks \n\nIn Chapter 3, we identified some potential pitfalls to code maintaina- \nbility/refactorability when we introduce block scoping. Is there \nanother way to take advantage of block scope but to reduce this down¬ \nside? \n\nConsider this alternate form of let, called the let block or let state¬ \nment (contrasted with let declarations from before). \n\nlet (a = 2) { \n\nconsole.log( a ); // 2 \n\n} \n\nconsole.log ( a ); // ReferenceError","metadata":{"loc":{"lines":{"from":9788,"to":9836}}}}],["297",{"pageContent":"let (a = 2) { \n\nconsole.log( a ); // 2 \n\n} \n\nconsole.log ( a ); // ReferenceError \n\nInstead of implicitly hijacking an existing block, the let statement \ncreates an explicit block for its scope binding. Not only does the ex¬ \nplicit block stand out more, and perhaps fare more robustly in code \nrefactoring, it produces somewhat cleaner code by, grammatically, \nforcing all the declarations to the top of the block. This makes it easier \nto look at any block and know what’s scoped to it and not. \n\nAs a pattern, it mirrors the approach many people take in function \nscoping when they manually move/hoist all their var declarations to \nthe top of the function. The let statement puts them there at the top \nof the block by intent, and if you don’t use let declarations strewn \nthroughout, your block-scoping declarations are somewhat easier to \nidentify and maintain.","metadata":{"loc":{"lines":{"from":9836,"to":9856}}}}],["298",{"pageContent":"But, there’s a problem. The let statement form is not included in ES6. \nNeither does the official Traceur compiler accept that form of code. \n\nWe have two options. We can format using ES6-valid syntax and a little \nsprinkle of code discipline: \n\n/*let*/ { let a = 2; \nconsole.log( a ); \n\n} \n\nconsole.log ( a ); // ReferenceError \n\nBut, tools are meant to solve our problems. So the other option is to \nwrite explicit let statement blocks, and let a tool convert them to valid, \nworking code. \n\n\nImplicit Versus Explicit Blocks | 71 \n\n\n\n\nSo, I built a tool called let-er 2 to address just this issue, let-er is a build- \nstep code transpiler, but its only task is to find let statement forms \nand transpile them. It will leave alone any of the rest of your code, \nincluding any let declarations. You can safely use let-er as the first ES6 \ntranspiler step, and then pass your code through something like Trace- \nur if necessary.","metadata":{"loc":{"lines":{"from":9858,"to":9886}}}}],["299",{"pageContent":"Moreover, let-er has a configuration flag - -es6, which when turned \non (off by default), changes the kind of code produced. Instead of the \ntry/catch ES3 polyfill hack, let-er would take our snippet and pro¬ \nduce the fully ES6-compliant, non-hacky: \n\nI \n\nlet a = 2; \nconsole.log( a ); \n\n} \n\nconsole.log ( a ); // ReferenceError \n\nSo, you can start using let-er right away, and target all pre-ES6 envi¬ \nronments, and when you only care about ES6, you can add the flag \nand instantly target only ES6. \n\nAnd most important, you can use the more preferable and more ex¬ \nplicit let statement form even though it is not an official part of any \nES version (yet). \n\nPerformance \n\nLet me add one last quick note on the performance of try/catch, and / \nor to address the question, “Why not just use an IIFE to create the \nscope?”","metadata":{"loc":{"lines":{"from":9888,"to":9914}}}}],["300",{"pageContent":"Performance \n\nLet me add one last quick note on the performance of try/catch, and / \nor to address the question, “Why not just use an IIFE to create the \nscope?” \n\nFirst, the performance of try/catch is slower, but there’s no reason¬ \nable assumption that it has to be that way, or even that it always will \nhe that way. Since the official TC39-approvedES6 transpiler uses try/ \ncatch, the Traceur team has asked Chrome to improve the perfor¬ \nmance of try/catch, and they are obviously motivated to do so. \n\nSecondly, IIFE is not a fair apples-to-apples comparison with try/ \ncatch, because a function wrapped around any arbitrary code changes \nthe meaning, inside of that code, of this, return, break, and \n\n\n2. let-er on GitHub \n\n\n72 | Appendix B: Polyfilling Block Scope \n\n\n\n\ncontinue. IIFE is not a suitable general substitute. It could only be \nused manually in certain cases.","metadata":{"loc":{"lines":{"from":9914,"to":9940}}}}],["301",{"pageContent":"2. let-er on GitHub \n\n\n72 | Appendix B: Polyfilling Block Scope \n\n\n\n\ncontinue. IIFE is not a suitable general substitute. It could only be \nused manually in certain cases. \n\nThe question really becomes: do you want block scoping, or not. If \nyou do, these tools provide you that option. If not, keep using var and \ngo on about your coding! \n\n\nPerformance | 73 \n\n\n\nAPPENDIX C \n\n\nLexical this \n\n\nThough this title does not address the this mechanism in any detail, \nthere’s one ES6 topic that relates this to lexical scope in an important \nway, which we will quickly examine. \n\nES6 adds a special syntactic form of function declaration called the \narrow function. It looks like this: \n\nvar foo = a => { \n\nconsole.log( a ); \n\n}; \n\n\nfoo( 2 ); // 2 \n\nThe so-called “fat arrow” is often mentioned as a shorthand for the \ntediously verbose (sarcasm) function keyword.","metadata":{"loc":{"lines":{"from":9940,"to":9983}}}}],["302",{"pageContent":"var foo = a => { \n\nconsole.log( a ); \n\n}; \n\n\nfoo( 2 ); // 2 \n\nThe so-called “fat arrow” is often mentioned as a shorthand for the \ntediously verbose (sarcasm) function keyword. \n\nBut there’s something much more important going on with arrow \nfunctions that has nothing to do with saving keystrokes in your dec¬ \nlaration. Briefly, this code suffers a problem: \n\nvar obj = { \n\nid: \"awesome\", \ncoot: function coolFn() { \nconsole.log( this. id ); \n\n} \n\n}; \n\nvar id = \"not awesome\" \nobj.coolQ; // awesome \n\nsetTimeout( obj.cool, 100 ); // not awesome \n\n\n75 \n\n\n\n\n\nThe problem is the loss of this binding on the cool() function. There \nare various ways to address that problem, but one often-repeated sol¬ \nution is var self = this;. \n\nThat might look like: \n\nvar obj = { \ncount: 0, \n\ncoot: function coolFn() { \nvar self = this; \n\nif (self.count < 1) { \n\nsetTimeout( function tlner(){ \nself.count++; \n\nconsole.log( \"awesome?\" ); \n\n}, 100 ); \n\n} \n\n} \n\n}; \n\n\nobj.cool(); // awesome?","metadata":{"loc":{"lines":{"from":9983,"to":10049}}}}],["303",{"pageContent":"coot: function coolFn() { \nvar self = this; \n\nif (self.count < 1) { \n\nsetTimeout( function tlner(){ \nself.count++; \n\nconsole.log( \"awesome?\" ); \n\n}, 100 ); \n\n} \n\n} \n\n}; \n\n\nobj.cool(); // awesome? \n\nWithout getting too much into the weeds here, the var self = \nthis “solution” just ends-around the whole problem of understanding \nand properly using this binding, and instead falls back to something \nwe’re perhaps more comfortable with: lexical scope, self becomes just \nan identifier that can be resolved via lexical scope and closure, and \ncares not what happened to the this binding along the way. \n\nPeople don’t like writing verbose stuff, especially when they do it over \nand over again. So, a motivation of ES6 is to help alleviate these sce¬ \nnarios, and indeed, fix common idiom problems, such as this one. \n\nThe ES6 solution, the arrow function, introduces a behavior called \nlexical this. \n\nvar obj = { \ncount: 0, \n\ncool: function coolFn() { \nif (this .count < 1) {","metadata":{"loc":{"lines":{"from":10049,"to":10088}}}}],["304",{"pageContent":"The ES6 solution, the arrow function, introduces a behavior called \nlexical this. \n\nvar obj = { \ncount: 0, \n\ncool: function coolFn() { \nif (this .count < 1) { \n\nsetTimeout( ()=>{// arrow-function ftw? \nthis.count++; \n\nconsole.log( \"awesome?\" ); \n\n}, 100 ); \n\n} \n\n} \n\n}; \n\n\nobj.coolQ; // awesome? \n\n\n76 | Appendix C: Lexical this \n\n\n\n\nThe short explanation is that arrow functions do not behave at all like \nnormal functions when it comes to their this binding. They discard \nall the normal rules for this binding, and instead take on the this \nvalue of their immediate lexical enclosing scope, whatever it is. \n\nSo, in that snippet, the arrow function doesn’t get its this unbound in \nsome unpredictable way, it just “inherits” the this binding of the \ncool() function (which is correct if we invoke it as shown!).","metadata":{"loc":{"lines":{"from":10088,"to":10126}}}}],["305",{"pageContent":"While this makes for shorter code, my perspective is that arrow func¬ \ntions are really just codifying into the language syntax a common \nmistake of developers, which is to confuse and conflate this binding \nrules with lexical scope rules. \n\nPut another way: why go to the trouble and verbosity of using the this \nstyle coding paradigm, only to cut it off at the knees by mixing it with \nlexical references. It seems natural to embrace one approach or the \nother for any given piece of code, and not mix them in the same piece \nof code. \n\n\n\nOne other detraction from arrow functions is that they are \nanonymous, not named. See Chapter 3 for the reasons why \nanonymous functions are less desirable than named functions. \n\n\nA more appropriate approach, in my perspective, to this “problem,” is \nto use and embrace the this mechanism correctly. \n\nvar obj = { \ncount: 0, \n\ncoot: function coolFnQ { \nif (this .count < 1) { \n\nsetTimeout( function tlmer(){ \n\nthis.count++; // 'this' is safe","metadata":{"loc":{"lines":{"from":10128,"to":10157}}}}],["306",{"pageContent":"var obj = { \ncount: 0, \n\ncoot: function coolFnQ { \nif (this .count < 1) { \n\nsetTimeout( function tlmer(){ \n\nthis.count++; // 'this' is safe \n\n// because of 'bind(..)' \nconsole.tog( \"more awesome\" ); \n\n}.bind( this ), 100 ); // look, 'bind()'l \n\n} \n\n} \n\n}; \n\n\nobj.cool (); // more awesome \n\n\nLexical this | 77 \n\n\n\n\n\nWhether you prefer the new lexical this behavior of arrow functions, \nor you prefer the tried-and-true bindQ, it’s important to note that \narrow functions are not just about less typing of function. \n\nThey have an intentional behavioral difference that we should learn \nand understand, and if we so choose, leverage. \n\nNow that we fully understand lexical scoping (and closure!), under¬ \nstanding lexical this should be a breeze! \n\n\n78 | Appendix C: Lexical this \n\n\n\nAbout the Author","metadata":{"loc":{"lines":{"from":10157,"to":10203}}}}],["307",{"pageContent":"Now that we fully understand lexical scoping (and closure!), under¬ \nstanding lexical this should be a breeze! \n\n\n78 | Appendix C: Lexical this \n\n\n\nAbout the Author \n\n\nKyle Simpson is an Open Web Evangelist from Austin, TX. He’s pas¬ \nsionate about JavaScript, HTML5, real-time/peer-to-peer communi¬ \ncations, and web performance. Otherwise, he’s probably bored by it. \nKyle is an author, workshop trainer, tech speaker, and avid OSS com¬ \nmunity member. \n\n\n\n\nthis & Object Prototypes \n\n\nKyle Simpson \n\n\nBeijing • Cambridge • Farnham • Koln • Sebastopol • Tokyo \n\n\nO REILLY \n\n\n\n\n\nTable of Contents \n\n\nForeword. v \n\nPreface.vii \n\n\nthis or That?. \n\n. 1 \n\nWhy this? \n\n1 \n\nConfusions \n\n3 \n\nWhat’s this? \n\n9 \n\nReview \n\n9 \n\nthis All Makes Sense Now!. \n\n. 11 \n\nCall-Site \n\n11 \n\nNothing but Rules \n\n12 \n\nEverything in Order \n\n22 \n\nBinding Exceptions \n\n27 \n\nLexical this \n\n31 \n\nReview \n\n33 \n\nObjects. \n\n. 35 \n\nSyntax \n\n35 \n\nType \n\n36 \n\nContents \n\n39 \n\nIteration \n\n59 \n\nReview \n\n63","metadata":{"loc":{"lines":{"from":10203,"to":10316}}}}],["308",{"pageContent":"12 \n\nEverything in Order \n\n22 \n\nBinding Exceptions \n\n27 \n\nLexical this \n\n31 \n\nReview \n\n33 \n\nObjects. \n\n. 35 \n\nSyntax \n\n35 \n\nType \n\n36 \n\nContents \n\n39 \n\nIteration \n\n59 \n\nReview \n\n63 \n\nMixing (Up) \"Class\" Objects. \n\n. 65 \n\nClass Theory \n\n65 \n\nClass Mechanics \n\n68 \n\nClass Inheritance \n\n71 \n\nMixins \n\n76 \n\n\n\n\n\n\n\n\n\n\nReview 84 \n\n5. Prototypes. 85 \n\n[[Prototype]] 85 \n\n“Class” 90 \n\n(Prototypal) Inheritance 100 \n\nObject Links 107 \n\nReview 111 \n\n6. Behavior Delegation. 113 \n\nToward Delegation-Oriented Design 114 \n\nClasses Versus Objects 125 \n\nSimpler Design 131 \n\nNicer Syntax 136 \n\nIntrospection 139 \n\nReview 143 \n\nA. ES6 Class. 145 \n\n\niv | Table of Contents \n\n\n\n\n\n\nForeword \n\n\nWhile reading this book in preparation for writing this foreword, I \nwas forced to reflect on how I learned JavaScript and how much it has \nchanged over the last 15 years that I have been programming and de¬ \nveloping with it.","metadata":{"loc":{"lines":{"from":10316,"to":10431}}}}],["309",{"pageContent":"When I started using JavaScript 15 years ago, the practice of using non- \nHTML technologies such as CSS and JS in your web pages was called \nDHTML or Dynamic HTML. Back then, the usefulness of JavaScript \nvaried greatly and seemed to be tilted toward adding animated snow¬ \nflakes to your web pages or dynamic clocks that told the time in the \nstatus bar. Suffice it to say, I didn’t really pay much attention to Java¬ \nScript in the early part of my career because of the novelty of the im¬ \nplementations that I often found on the Internet.","metadata":{"loc":{"lines":{"from":10433,"to":10440}}}}],["310",{"pageContent":"It wasn’t until 2005 that I first rediscovered JavaScript as a real pro¬ \ngramming language that I needed to pay closer attention to. After dig¬ \nging into the first beta release of Google Maps, I was hooked on the \npotential it had. At the time, Google Maps was a first-of-its-kind \napplication—it allowed you to move a map around with your mouse, \nzoom in and out, and make server requests without reloading the page \n—all with JavaScript. It seemed like magic! \n\nWhen anything seems like magic, it is usually a good indication that \nyou are at the dawn of a new way of doing things. And boy, was I not \nwrong—fast-forwarding to today, I would say that JavaScript is one of \nthe primary languages I use for both client- and server-side program¬ \nming, and I wouldn’t have it any other way. \n\nOne of my regrets as I look over the past 15 years is that I didn’t give \nJavaScript more of a chance before 2005, or more accurately, that I","metadata":{"loc":{"lines":{"from":10442,"to":10457}}}}],["311",{"pageContent":"One of my regrets as I look over the past 15 years is that I didn’t give \nJavaScript more of a chance before 2005, or more accurately, that I \n\n\n\n\nlacked the foresight to see JavaScript as a true programming language \nthat is just as useful as C++, C#, Java, and many others. \n\nIf I had this You Don’t Know JS series of books at the start of my career, \nmy career history would look much different than it does today. And \nthat is one of the things I love about this series: it explains JavaScript \nat a level that builds your understanding as you go through the series, \nbut in a fun and informative way.","metadata":{"loc":{"lines":{"from":10457,"to":10470}}}}],["312",{"pageContent":"this & Object Prototypes is a wonderful continuation to the series. It \ndoes a great and natural job of building on the prior book, Scope & \nClosures, and extending that knowledge to a very important part of \nthe JS language, the this keyword and prototypes. These two simple \nthings are pivotal for what you will learn in the future books, because \nthey are foundational to doing real programming with JavaScript. The \nconcept of how to create objects, relate them, and extend them to rep¬ \nresent things in your application is necessary to create large and com¬ \nplex applications in JavaScript. And without them, creating complex \napplications (such as Google Maps) wouldn’t be possible in JavaScript.","metadata":{"loc":{"lines":{"from":10472,"to":10481}}}}],["313",{"pageContent":"I would say that the vast majority of web developers probably have \nnever built a JavaScript object and just treat the language as event¬ \nbinding glue between buttons and AJAX requests. I was in that camp \nat a point in my career, but after I learned how to master prototypes \nand create objects in JavaScript, a world of possibilities opened up for \nme. If you fall into the category of just creating event-binding glue \ncode, this book is a must-read; if you just need a refresher, this book \nwill be a go-to resource for you. Either way, you will not be disap¬ \npointed. Trust me! \n\n—Nick Berardi \nnickberardi.com, @nberardi \n\n\nvi | Foreword \n\n\n\nPreface \n\n\nI’m sure you noticed, but “JS” in the book series title is not an abbre¬ \nviation for words used to curse about JavaScript, though cursing at the \nlanguage’s quirks is something we can probably all identify with!","metadata":{"loc":{"lines":{"from":10483,"to":10506}}}}],["314",{"pageContent":"From the earliest days of the Web, JavaScript has been a foundational \ntechnology that drives interactive experience around the content we \nconsume. While flickering mouse trails and annoying pop-up \nprompts may be where JavaScript started, nearly two decades later, the \ntechnology and capability of JavaScript has grown many orders of \nmagnitude, and few doubt its importance at the heart of the world’s \nmost widely available software platform: the Web. \n\nBut as a language, it has perpetually been a target for a great deal of \ncriticism, owing partly to its heritage but even more to its design phi¬ \nlosophy. Even the name evokes, as Brendan Eich once put it, “dumb \nkid brother” status next to its more mature older brother Java. But the \nname is merely an accident of politics and marketing. The two lan¬ \nguages are vastly different in many important ways. “JavaScript” is as \nrelated to “Java” as “Carnival” is to “Car.”","metadata":{"loc":{"lines":{"from":10508,"to":10522}}}}],["315",{"pageContent":"Because JavaScript borrows concepts and syntax idioms from several \nlanguages, including proud C-style procedural roots as well as subtle, \nless obvious Scheme/Lisp-style functional roots, it is exceedingly ap¬ \nproachable to a broad audience of developers, even those with little to \nno programming experience. The “Hello World” of JavaScript is so \nsimple that the language is inviting and easy to get comfortable with \nin early exposure. \n\nWhile JavaScript is perhaps one of the easiest languages to get up and \nrunning with, its eccentricities make solid mastery of the language a \n\n\nVII \n\n\n\n\nvastly less common occurrence than in many other languages. Where \nit takes a pretty in-depth knowledge of a language like C or C++ to \nwrite a full-scale program, full-scale production JavaScript can, and \noften does, barely scratch the surface of what the language can do.","metadata":{"loc":{"lines":{"from":10524,"to":10544}}}}],["316",{"pageContent":"Sophisticated concepts that are deeply rooted into the language tend \ninstead to surface themselves in seemingly simplistic ways, such as \npassing around functions as callbacks, which encourages the Java¬ \nScript developer to just use the language as-is and not worry too much \nabout what’s going on under the hood. \n\nIt is simultaneously a simple, easy-to-use language that has broad ap¬ \npeal, and a complex and nuanced collection of language mechanics \nthat without careful study will elude true understanding even for the \nmost seasoned of JavaScript developers. \n\nTherein lies the paradox of JavaScript, the Achilles’ heel of the lan¬ \nguage, the challenge we are presently addressing. Because JavaScript \nca n be used without understanding, the understanding of the language \nis often never attained. \n\nMission","metadata":{"loc":{"lines":{"from":10546,"to":10562}}}}],["317",{"pageContent":"Mission \n\nIf at every point that you encounter a surprise or frustration in Java¬ \nScript, your response is to add it to the blacklist (as some are accus¬ \ntomed to doing), you soon will be relegated to a hollow shell of the \nrichness of JavaScript. \n\nWhile this subset has been famously dubbed “The Good Parts,” I would \nimplore you, dear reader, to instead consider it the “The Easy Parts,” \n“The Safe Parts,” or even “The Incomplete Parts.” \n\nThis You Don’t Know JS book series offers a contrary challenge: learn \nand deeply understand all of JavaScript, even and especially “The \nTough Parts.” \n\nHere, we address head-on the tendency of JS developers to learn “just \nenough” to get by, without ever forcing themselves to learn exactly \nhow and why the language behaves the way it does. Furthermore, we \neschew the common advice to retreat when the road gets rough.","metadata":{"loc":{"lines":{"from":10562,"to":10580}}}}],["318",{"pageContent":"I am not content, nor should you be, at stopping once something just \nworks and not really knowing why. I gently challenge you to journey \ndown that bumpy “road less traveled” and embrace all that JavaScript \nis and can do. With that knowledge, no technique, no framework, no \n\n\nviii | Preface \n\n\n\npopular buzzword acronym of the week will be beyond your \nunderstanding. \n\nThese books each take on specific core parts of the language that are \nmost commonly misunderstood or under-understood, and dive very \ndeep and exhaustively into them. You should come away from reading \nwith a firm confidence in your understanding, not just of the theo¬ \nretical, but the practical “what you need to know” bits.","metadata":{"loc":{"lines":{"from":10582,"to":10599}}}}],["319",{"pageContent":"The JavaScript you know right now is probably parts handed down to \nyou by others who’ve been burned by incomplete understanding. That \nJavaScript is but a shadow of the true language. You don’t really know \nJavaScript, yet, but if you dig into this series, you will. Read on, my \nfriends. JavaScript awaits you. \n\n\nReview \n\nJavaScript is awesome. It’s easy to learn partially, and much harder to \nlearn completely (or even sufficiently). When developers encounter \nconfusion, they usually blame the language instead of their lack of \nunderstanding. These books aim to fix that, inspiring a strong appre¬ \nciation for the language you can now, and should, deeply know. \n\n\n\nMany of the examples in this book assume modern (and future- \nreaching) JavaScript engine environments, such as ES6. Some \ncode may not work as described if run in older (pre-ES6) \nengines. \n\n\nConventions Used in This Book \n\nThe following typographical conventions are used in this book: \n\nItalic","metadata":{"loc":{"lines":{"from":10601,"to":10628}}}}],["320",{"pageContent":"Conventions Used in This Book \n\nThe following typographical conventions are used in this book: \n\nItalic \n\nIndicates new terms, URLs, email addresses, filenames, and file \nextensions. \n\nConstant width \n\nUsed for program listings, as well as within paragraphs to refer to \nprogram elements such as variable or function names, databases, \ndata types, environment variables, statements, and keywords. \n\n\nPreface | ix \n\n\n\n\n\n\nConstant width bold \n\nShows commands or other text that should be typed literally by \nthe user. \n\nConstant width italic \n\nShows text that should be replaced with user-supplied values or \nby values determined by context. \n\nThis element signifies a tip or suggestion. \n\n\n\n\nUsing Code Examples \n\nSupplemental material (code examples, exercises, etc.) is available for \ndownload at http://bit.ly/ydkjs-this-code.","metadata":{"loc":{"lines":{"from":10628,"to":10669}}}}],["321",{"pageContent":"This element signifies a tip or suggestion. \n\n\n\n\nUsing Code Examples \n\nSupplemental material (code examples, exercises, etc.) is available for \ndownload at http://bit.ly/ydkjs-this-code. \n\nThis book is here to help you get your job done. In general, if example \ncode is offered with this book, you may use it in your programs and \ndocumentation. You do not need to contact us for permission unless \nyou’re reproducing a significant portion of the code. For example, \nwriting a program that uses several chunks of code from this book \ndoes not require permission. Selling or distributing a CD-ROM of \nexamples from O’Reilly books does require permission. Answering a \nquestion by citing this book and quoting example code does not re¬ \nquire permission. Incorporating a significant amount of example code \nfrom this book into your product’s documentation does require per¬ \nmission. \n\n\nx | Preface","metadata":{"loc":{"lines":{"from":10669,"to":10692}}}}],["322",{"pageContent":"x | Preface \n\n\n\n\n\n\n\n\n\nWe appreciate, but do not require, attribution. An attribution usually \nincludes the title, author, publisher, and ISBN. For example: “this & \nObject Prototypes by Kyle Simpson (O’Reilly). Copyright 2014 Getify \nSolutions, Inc., 978-1-491-90415-2.” \n\nIf you feel your use of code examples falls outside fair use or the per¬ \nmission given above, feel free to contact us at permissions@oreilly.com. \n\n\nSafari* Books Online \n\n_ _ Safari Books Online is an on-demand digital li- \n\n^3 | 3 brary that delivers expert content in both book and \n\nvideo form from the world’s leading authors in \ntechnology and business. \n\n\nBooks Online \n\n\nTechnology professionals, software developers, web designers, and \nbusiness and creative professionals use Safari Books Online as their \nprimary resource for research, problem solving, learning, and certif¬ \nication training.","metadata":{"loc":{"lines":{"from":10692,"to":10727}}}}],["323",{"pageContent":"Safari Books Online offers a range of product mixes and pricing pro¬ \ngrams for organizations, government agencies, and individuals. Sub¬ \nscribers have access to thousands of books, training videos, and pre¬ \npublication manuscripts in one fully searchable database from pub¬ \nlishers like O’Reilly Media, Prentice Hall Professional, Addison- \nWesley Professional, Microsoft Press, Sams, Que, Peachpit Press, Focal \nPress, Cisco Press, John Wiley & Sons, Syngress, Morgan Kaufmann, \nIBM Redbooks, Packt, Adobe Press, FT Press, Apress, Manning, New \nRiders, McGraw-Hill, Jones & Bartlett, Course Technology, and doz¬ \nens more. For more information about Safari Books Online, please \nvisit us online. \n\n\nHow to Contact Us \n\nPlease address comments and questions concerning this book to the \npublisher: \n\nO’Reilly Media, Inc. \n\n1005 Gravenstein Highway North \nSebastopol, CA 95472 \n\n800-998-9938 (in the United States or Canada) \n\n707-829-0515 (international or local) \n\n707-829-0104 (fax)","metadata":{"loc":{"lines":{"from":10727,"to":10754}}}}],["324",{"pageContent":"O’Reilly Media, Inc. \n\n1005 Gravenstein Highway North \nSebastopol, CA 95472 \n\n800-998-9938 (in the United States or Canada) \n\n707-829-0515 (international or local) \n\n707-829-0104 (fax) \n\n\nPreface | xi \n\n\n\n\nWe have a web page for this book, where we list errata, examples, and \nany additional information. You can access this page at http://bit.ly/ \nydk-js-this-object-prototypes. \n\nTo comment or ask technical questions about this book, send email to \nbookquestions@oreilly.com. \n\nFor more information about our books, courses, conferences, and \nnews, see our website at http://www.oreilly.com. \n\nFind us on Facebook: http://facebook.com/oreilly \n\nFollow us on Twitter: http://twitter.com/oreillymedia \n\nWatch us on YouTube: http://www.youtube.com/oreillymedia \n\nCheck out the full You Don’t Know JS series: http://YouDont \nKnowJS.com \n\n\nxii | Preface \n\n\n\nCHAPTER 1 \n\n\nthis or That?","metadata":{"loc":{"lines":{"from":15316,"to":15360}}}}],["325",{"pageContent":"Watch us on YouTube: http://www.youtube.com/oreillymedia \n\nCheck out the full You Don’t Know JS series: http://YouDont \nKnowJS.com \n\n\nxii | Preface \n\n\n\nCHAPTER 1 \n\n\nthis or That? \n\n\nOne of the most confused mechanisms in JavaScript is the this key¬ \nword. It’s a special identifier keyword that’s automatically defined in \nthe scope of every function, but what exactly it refers to bedevils even \nseasoned JavaScript developers. \n\nAny sufficiently advanced technology is indistinguishable \nfrom magic. \n\n— Arthur C. Clarke \n\nJavaScript’s this mechanism isn’t actually that advanced, but devel¬ \nopers often paraphrase that quote in their own mind by inserting \n“complex” or “confusing,” and there’s no question that without lack of \nclear understanding, this can seem downright magical in your \nconfusion.","metadata":{"loc":{"lines":{"from":15360,"to":15390}}}}],["326",{"pageContent":"The word “this” is a terribly common pronoun in general dis¬ \ncourse. So, it can be very difficult, especially verbally, to deter¬ \nmine whether we are using “this” as a pronoun or using it to \nrefer to the actual keyword identifier. For clarity, I will always \nuse this to refer to the special keyword, and “this” or this or \nthis otherwise. \n\n\nWhy this? \n\nIf the this mechanism is so confusing, even to seasoned JavaScript \ndevelopers, one may wonder why it’s even useful. Is it more trouble \nthan it’s worth? Before we jump into the how, we should examine the \nwhy. \n\n\n1 \n\n\n\n\n\nLet’s try to illustrate the motivation and utility of this: \n\nfunction identlfyQ { \n\nreturn this. name.tolIpperCaseQ; \n\n} \n\nfunction speak() { \n\nvar greeting = \"Hello, I'm \" + identify.call( this ); \nconsole.log( greeting ); \n\n} \n\nvar me = { \n\nname: \"Kyle\" \n\n}; \n\n\nvar you = { \n\nname: \"Reader \n\n\n}; \n\n\nidentify.call( me ); // KYLE \nidentify.call( you ); // READER","metadata":{"loc":{"lines":{"from":15394,"to":15447}}}}],["327",{"pageContent":"} \n\nvar me = { \n\nname: \"Kyle\" \n\n}; \n\n\nvar you = { \n\nname: \"Reader \n\n\n}; \n\n\nidentify.call( me ); // KYLE \nidentify.call( you ); // READER \n\nspeak.call( me ); // Hello, I'm KYLE \nspeak.call( you ); // Hello, I'm READER \n\nIf the how of this snippet confuses you, don’t worry! We’ll get to that \nshortly. Just set those questions aside briefly so we can look into the \nwhy more clearly. \n\nThis code snippet allows the identify () and speak() functions to be \nreused against multiple context objects (me and you), rather than need¬ \ning a separate version of the function for each object. \n\nInstead of relying on t h i s, you could have explicitly passed in a context \nobject to both identify() and speakQ: \n\nfunction identify(context) { \n\nreturn context . name . totlpperCase( ); \n\n} \n\nfunction speak(context) { \n\nvar greeting = \"Hello, I'm \" + identify( context ); \nconsole.log( greeting ); \n\n} \n\nidentify( you ); // READER \nspeak( me ); // Hello, I'm KYLE \n\n\n2 | Chapter 1: this or That?","metadata":{"loc":{"lines":{"from":15447,"to":15498}}}}],["328",{"pageContent":"var greeting = \"Hello, I'm \" + identify( context ); \nconsole.log( greeting ); \n\n} \n\nidentify( you ); // READER \nspeak( me ); // Hello, I'm KYLE \n\n\n2 | Chapter 1: this or That? \n\n\n\n\n\nHowever, the this mechanism provides a more elegant way of im¬ \nplicitly “passing along” an object reference, leading to cleaner API \ndesign and easier reuse. \n\nThe more complex your usage pattern is, the more clearly you’ll see \nthat passing context around as an explicit parameter is often messier \nthan passing around a this context. When we explore objects and \nprototypes, you will see the helpfulness of a collection of functions \nbeing able to automatically reference the proper context object. \n\nConfusions \n\nWe’ll soon begin to explain how this actually works, but first we must \ndispel some misconceptions about how it doesn’t actually work. \n\nThe name “this” creates confusion when developers try to think about \nit too literally. There are two meanings often assumed, but both are \nincorrect. \n\nItself","metadata":{"loc":{"lines":{"from":15498,"to":15532}}}}],["329",{"pageContent":"The name “this” creates confusion when developers try to think about \nit too literally. There are two meanings often assumed, but both are \nincorrect. \n\nItself \n\nThe first common temptation is to assume this refers to the function \nitself. That’s a reasonable grammatical inference, at least. \n\nWhy would you want to refer to a function from inside itself? The \nmost common reasons would be things like recursion (calling a func¬ \ntion from inside itself) or having an event handler that can unbind \nitself when it’s first called. \n\nDevelopers new to JavaScript’s mechanisms often think that referenc¬ \ning the function as an object (all functions in JavaScript are objects!) \nlets you store state (values in properties) between function calls. While \nthis is certainly possible and has some limited uses, the rest of the book \nwill expound on many other patterns for better places to store state \nbesides the function object.","metadata":{"loc":{"lines":{"from":15532,"to":15551}}}}],["330",{"pageContent":"But for just a moment, we’ll explore that pattern, to illustrate how this \ndoesn’t let a function get a reference to itself like we might have \nassumed. \n\nConsider the following code, where we attempt to track how many \ntimes a function (foo) was called: \n\n\nConfusions | 3 \n\n\n\n\nfunction foo(num) { \n\nconsole.log( \"foo: \" + nun ); \n\n// keep track of how nany tines 'foo' is called \nthis.count++; \n\n} \n\nfoo. count = 0; \nvar 1; \n\nfor (1=0; t<10; i++) { \nif (i > 5) { \nfoo( i ); \n\n} \n\n} \n\n// foo: 6 \n// foo: 7 \n// foo: 8 \n// foo: 9 \n\n// how nany tines was 'foo' called? \nconsole.log ( foo.count ); // 0 -- WTF? \n\nfoo.count is still 0, even though the four console.log statements \nclearly indicate foo(..) was in fact called four times. The frustration \nstems from a too literal interpretation of what this (in \nthis.count++) means.","metadata":{"loc":{"lines":{"from":15553,"to":15597}}}}],["331",{"pageContent":"When the code executes foo. count = 0, indeed it’s adding a property \ncount to the function object foo. But for the this.count reference \ninside of the function, this is not in fact pointing at all to that function \nobject, and so even though the property names are the same, the root \nobjects are different, and confusion ensues. \n\n\n\nA responsible developer should ask at this point, “If I was in¬ \ncrementing a count property but it wasn’t the one I expected, \nwhich count was I incrementing?” In fact, were she to dig \ndeeper, she would find that she had accidentally created a \nglobal variable count (see Chapter 2 for how that happened!), \nand it currently has the value NaN. Of course, once she identi¬ \nfies this peculiar outcome, she then has a whole other set of \nquestions: “How was it global, and why did it end up NaN in¬ \nstead of some proper count value?” (see Chapter 2). \n\n\n4 | Chapter 1: this or That?","metadata":{"loc":{"lines":{"from":15599,"to":15618}}}}],["332",{"pageContent":"4 | Chapter 1: this or That? \n\n\n\n\n\n\nInstead of stopping at this point and digging into why the this refer¬ \nence doesn’t seem to be behaving as expected, and answering those \ntough but important questions, many developers simply avoid the is¬ \nsue altogether, and hack toward some other solution, such as creating \nanother object to hold the count property: \n\nfunction foo(num) { \n\nconsole.log( \"foo: \" + num ); \n\n// keep track of how many times 'foo' is called \ndata.count++; \n\n} \n\nvar data = { \ncount: 0 \n\n}; \n\n\nvar 1; \n\nfor (1=0; t<10; i++) { \nif (i > 5) { \nfoo( i ); \n\n} \n\n} \n\n// foo: 6 \n// foo: 7 \n// foo: 8 \n// foo: 9 \n\n// how many times was 'foo' called? \nconsole.log( data.count ); // 4 \n\nWhile it is true that this approach “solves” the problem, unfortunately \nit simply ignores the real problem—lack of understanding what this \nmeans and how it works—and instead falls back to the comfort zone \nof a more familiar mechanism: lexical scope.","metadata":{"loc":{"lines":{"from":15618,"to":15667}}}}],["333",{"pageContent":"Lexical scope is a perfectly fine and useful mechanism; I am \nnot belittling the use of it, by any means (see the Scope & \nClosures title of this book series). But constantly guessing at \nhow to use this, and usually being wrong, is not a good rea¬ \nson to retreat back to lexical scope and never learn why this \neludes you. \n\n\nTo reference a function object from inside itself, this by itself will \ntypically be insufficient. You generally need a reference to the function \nobject via a lexical identifier (variable) that points at it. \n\n\nConfusions | 5 \n\n\n\n\nConsider these two functions: \n\n\nfunction foo() { \n\nfoo.count = 4; // 'foo' refers to itself \n\n} \n\nsetTimeout( function(){ \n\n// anonymous function (no name), cannot \n// refer to itself \n\n}, 10 ); \n\nIn the first function, called a “named function,” foo is a reference that \ncan be used to refer to the function from inside itself.","metadata":{"loc":{"lines":{"from":15671,"to":15706}}}}],["334",{"pageContent":"}, 10 ); \n\nIn the first function, called a “named function,” foo is a reference that \ncan be used to refer to the function from inside itself. \n\nBut in the second example, the function callback passed to setTime \nout(..) has no name identifier (called an “anonymous function”), so \nthere’s no proper way to refer to the function object itself. \n\n\n\nThe old-school but now deprecated and frowned-upon argu \nments.callee reference inside a function also points to the \nfunction object of the currently executing function. This ref¬ \nerence is typically the only way to access an anonymous func¬ \ntion’s object from inside itself. The best approach, however, is \nto avoid the use of anonymous functions altogether, at least for \nthose that require a self-reference, and instead use a named \nfunction (expression), arguments.callee is deprecated and \nshould not be used.","metadata":{"loc":{"lines":{"from":15706,"to":15725}}}}],["335",{"pageContent":"So another solution to our running example would have been to use \nthe foo identifier as a function object reference in each place, and not \nuse this at all, which works: \n\nfunction foo(num) { \n\nconsole.log( \"foo: \" + num ); \n\n// keep track of how many times 'foo' is called \nfoo.count++; \n\n1 \n\nfoo.count = 0; \nvar 1; \n\nfor (i=0; i<10; i++) { \nif (i > 5) { \nfoo( i ); \n\n} \n\n} \n\n\n6 | Chapter 1: this or That? \n\n\n\n\n\n\n// foo: 6 \n// foo: 7 \n// foo: 8 \n// foo: 9 \n\n// how nany tines was 'foo' called? \nconsole.log ( foo.count ); // 4 \n\nHowever, that approach similarly side-steps actual understanding of \nthis and relies entirely on the lexical scoping of variable foo. \n\nYet another way of approaching the issue is to force this to actually \npoint at the foo function object: \n\nfunction foo(num) { \n\nconsole.log( \"foo: \" + nun ); \n\n// keep track of how nany tines 'foo' is called \n// Note: 'this' IS actually 'foo' now, based on \n// how 'foo' is called (see below) \n\nthis.count++; \n\n}","metadata":{"loc":{"lines":{"from":15728,"to":15784}}}}],["336",{"pageContent":"console.log( \"foo: \" + nun ); \n\n// keep track of how nany tines 'foo' is called \n// Note: 'this' IS actually 'foo' now, based on \n// how 'foo' is called (see below) \n\nthis.count++; \n\n} \n\nfoo.count = 0; \nvar 1; \n\nfor (i=0; i<10; i++) { \nif (i > 5) { \n\n// using 'call(..)', we ensure the 'this' \n\n// points at the function object ('foo') itself \nfoo.call( foo, i ); \n\n} \n\n} \n\n// foo: 6 \n// foo: 7 \n// foo: 8 \n// foo: 9 \n\n// how nany tines was 'foo' called? \nconsole.log( foo. count ); // 4 \n\nInstead of avoiding this, we embrace it. We’ll explain in a little bit \nhow such techniques work much more completely, so don’t worry if \nyou’re still a bit confused! \n\nIts Scope \n\nThe next most common misconception about the meaning of this is \nthat it somehow refers to the function’s scope. It’s a tricky question, \n\n\nConfusions | 7 \n\n\n\nbecause in one sense there is some truth, but in the other sense, it’s \nquite misguided.","metadata":{"loc":{"lines":{"from":15784,"to":15832}}}}],["337",{"pageContent":"Confusions | 7 \n\n\n\nbecause in one sense there is some truth, but in the other sense, it’s \nquite misguided. \n\nTo be clear, this does not, in anyway, refer to a function’s lexical scope. \nIt is true that internally, scope is kind of like an object with properties \nfor each of the available identifiers. But the scope “object” is not ac¬ \ncessible to JavaScript code. It’s an inner part of the engines implemen¬ \ntation. \n\nConsider code that attempts (and fails!) to cross over the boundary \nand use this to implicitly refer to a function’s lexical scope: \n\nfunction foo() { \nvar a = 2; \nthis.barQ; \n\n} \n\nfunction bar() { \n\nconsole.log( this. a ); \n\n} \n\nfoo(); //ReferenceError: a is not defined \n\nThere’s more than one mistake in this snippet. While it may seem \ncontrived, the code you see is a distillation of actual real-world code \nthat has been exchanged in public community help forums. It’s a won¬ \nderful (if not sad) illustration of just how misguided this assumptions \ncan be.","metadata":{"loc":{"lines":{"from":15832,"to":15866}}}}],["338",{"pageContent":"First, an attempt is made to reference the bar() function via \nthis.barQ. It is almost certainly an accident that it works, but we’ll \nexplain the how of that shortly. The most natural way to have invoked \nbar() would have been to omit the leading this, and just make a \nlexical reference to the identifier. \n\nHowever, the developer who writes such code is attempting to use this \nto create a bridge between the lexical scopes of foo( ) and bar( ), so \nthat bar( ) has access to the variable a in the inner scope of foo( ). No \nsuch bridge is possible. You cannot use a this reference to look some¬ \nthing up in a lexical scope. It is not possible. \n\nEvery time you feel yourself trying to mix lexical scope look-ups with \nthis, remind yourself: there is no bridge. \n\n\n8 | Chapter 1: this or That? \n\n\n\n\n\nWhat's this? \n\nHaving set aside various incorrect assumptions, let us now turn our \nattention to how the this mechanism really works.","metadata":{"loc":{"lines":{"from":15868,"to":15893}}}}],["339",{"pageContent":"8 | Chapter 1: this or That? \n\n\n\n\n\nWhat's this? \n\nHaving set aside various incorrect assumptions, let us now turn our \nattention to how the this mechanism really works. \n\nWe said earlier that this is not an author-time binding but a runtime \nbinding. It is contextual based on the conditions of the function’s in¬ \nvocation. this binding has nothing to do with where a function is \ndeclared, but has instead everything to do with the manner in which \nthe function is called. \n\nWhen a function is invoked, an activation record, otherwise known \nas an execution context, is created. This record contains information \nabout where the function was called from (the call-stack), how the \nfunction was invoked, what parameters were passed, etc. One of the \nproperties of this record is the this reference, which will be used for \nthe duration of that functions execution. \n\nIn the next chapter, we will learn to find a function’s call-site to deter¬ \nmine how its execution will bind this. \n\nReview","metadata":{"loc":{"lines":{"from":15893,"to":15920}}}}],["340",{"pageContent":"In the next chapter, we will learn to find a function’s call-site to deter¬ \nmine how its execution will bind this. \n\nReview \n\nthis binding is a constant source of confusion for the JavaScript de¬ \nveloper who does not take the time to learn how the mechanism ac¬ \ntually works. Guesses, trial and error, and blind copy and paste from \nStack Overflow answers is not an effective or proper way to leverage \nthis important this mechanism. \n\nTo learn this, you first have to learn what this is not, despite any \nassumptions or misconceptions that may lead you down those paths, \nthis is neither a reference to the function itself, nor is it a reference \nto the function’s lexical scope. \n\nthis is actually a binding that is made when a function is invoked, and \nwhat it references is determined entirely by the call-site where the \nfunction is called. \n\n\nWhat's this? | 9 \n\n\n\nCHAPTER 2 \n\n\nthis All Makes Sense Now!","metadata":{"loc":{"lines":{"from":15920,"to":15948}}}}],["341",{"pageContent":"What's this? | 9 \n\n\n\nCHAPTER 2 \n\n\nthis All Makes Sense Now! \n\n\nIn Chapter 1, we discarded various misconceptions about this and \nlearned instead that this is a binding made for each function invoca¬ \ntion, based entirely on its call-site (how the function is called). \n\nCall-Site \n\nTo understand this binding, we have to understand the call-site: the \nlocation in code where a function is called (not where it’s declared). \nWe must inspect the call-site to answer the question: what is this this \na reference to? \n\nFinding the call-site is generally “go locate where a function is called \nfrom,” but it’s not always that easy, as certain coding patterns can ob¬ \nscure the true call-site. \n\nWhat’s important is to think about the call-stack (the stack of functions \nthat have been called to get us to the current moment in execution). \nThe call-site we care about is in the invocation before the currently \nexecuting function. \n\nLet’s demonstrate the call-stack and call-site: \n\nfunction baz() {","metadata":{"loc":{"lines":{"from":15948,"to":15980}}}}],["342",{"pageContent":"Let’s demonstrate the call-stack and call-site: \n\nfunction baz() { \n\n// call-stack is: 'baz' \n\n// so, our call-site is in the global scope \n\nconsole.log( \"baz\" ); \n\nbar(); // <-- call-site for 'bar' \n\n} \n\nfunction bar() { \n\n\n11 \n\n\n\n\n\n// call-stack is: 'baz' -> 'bar' \n// so, our call-site is in 'baz' \n\n\nconsole.log( \"bar\" ); \n\nfoo(); // <-- call-site for 'foo' \n\n} \n\nfunction foo() { \n\n// call-stack is: 'baz' -> 'bar' -> 'foo' \n\n// so, our call-site is in 'bar' \n\nconsole.log( \"foo\" ); \n\n} \n\nbaz(); // <-- call-site for 'baz' \n\nTake care when analyzing code to find the actual call-site (from the \ncall-stack), because it’s the only thing that matters for this binding.","metadata":{"loc":{"lines":{"from":15980,"to":16026}}}}],["343",{"pageContent":"You can visualize a call-stack in your mind by looking at the \nchain of function calls in order, as we did with the comments \nin the previous snippet. But this is painstaking and error- \nprone. Another way of seeing the call-stack is using a debug¬ \nger tool in your browser. Most modern desktop browsers have \nbuilt-in developer tools that include a JS debugger. In the pre¬ \nvious snippet, you could have set a breakpoint in the tools for \nthe first line of the foo( ) function, or simply inserted the de \nbugger; statement on that first line. When you run the page, \nthe debugger will pause at this location, and will show you a \nlist of the functions that have been called to get to that line, \nwhich will be your call-stack. So, if you’re trying to diagnose \nthis binding, use the developer tools to get the call-stack, then \nfind the second item from the top, and that will show you the \nreal call-site. \n\n\nNothing but Rules","metadata":{"loc":{"lines":{"from":16030,"to":16047}}}}],["344",{"pageContent":"Nothing but Rules \n\nWe turn our attention now to how the call-site determines where this \nwill point during the execution of a function. \n\nYou must inspect the call-site and determine which of four rules ap¬ \nplies. We will first explain each of these four rules independently, and \nthen we will illustrate their order of precedence, if multiple rules could \napply to the call-site. \n\n\n12 | Chapter 2: this All Makes Sense Now! \n\n\n\n\n\nDefault Binding \n\nThe first rule we will examine comes from the most common case of \nfunction calls: standalone function invocation. Think of this this rule \nas the default catch-all rule when none of the other rules apply. \n\nConsider the following code: \n\nfunction foo() { \n\nconsole.log( this. a ); \n\n} \n\nvar a = 2; \n\nfoo(); // 2","metadata":{"loc":{"lines":{"from":16047,"to":16080}}}}],["345",{"pageContent":"Consider the following code: \n\nfunction foo() { \n\nconsole.log( this. a ); \n\n} \n\nvar a = 2; \n\nfoo(); // 2 \n\nThe first thing to note, if you were not already aware, is that variables \ndeclared in the global scope, as var a = 2 is, are synonymous with \nglobal-object properties of the same name. They’re not copies of each \nother, they are each other. Think of it as two sides of the same coin. \n\nSecond, we see that when foo() is called, this, a resolves toour global \nvariable a. Why? Because in this case, the default binding for this \napplies to the function call, and so points this at the global object. \n\nHow do we know that the default binding rule applies here? We ex¬ \namine the call-site to see how foo() is called. In our snippet, foo() is \ncalled with a plain, undecorated function reference. None of the other \nrules we will demonstrate will apply here, so the default binding applies \ninstead.","metadata":{"loc":{"lines":{"from":16080,"to":16105}}}}],["346",{"pageContent":"If strict node is in effect, the global object is not eligible for the \ndefault binding, so the this is instead set to undefined: \n\nfunction foo() { \n\n\"use strict\"; \n\nconsole.log( this. a ); \n\n1 \n\nvar a = 2; \n\nfoo(); // TypeError: 'this' is 'undefined' \n\nA subtle but important detail is that though the overall this binding \nrules are entirely based on the call-site, the global object is only eligible \nfor the default binding if the contents of foo() are not running in \n\n\nNothing but Rules | 13 \n\n\n\n\nstrict node; the strict node state of the call-site of foo() is \nirrelevant: \n\n\nfunction foo() { \n\nconsole.log( this. a ); \n\n} \n\nvar a = 2; \n\n(function( ){ \n\n\"use strict\"; \n\nf°°(); // 2 \n})();","metadata":{"loc":{"lines":{"from":16107,"to":16149}}}}],["347",{"pageContent":"strict node; the strict node state of the call-site of foo() is \nirrelevant: \n\n\nfunction foo() { \n\nconsole.log( this. a ); \n\n} \n\nvar a = 2; \n\n(function( ){ \n\n\"use strict\"; \n\nf°°(); // 2 \n})(); \n\n\n\nIntentionally mixing strict node and non-strict node to¬ \ngether in your own code is generally frowned upon. Your en¬ \ntire program should probably either be strict or non-strict. \nHowever, sometimes you include a third-party library that has \ndifferent strictness than your own code, so care must be tak¬ \nen over these subtle compatibility details. \n\n\nImplicit Binding \n\nAnother rule to consider is whether the call-site has a context object, \nalso referred to as an owning or containing object, though these alter¬ \nnate terms could be slightly misleading. \n\nConsider: \n\nfunction foo() { \n\nconsole.log( this. a ); \n\n} \n\nvar obj = { \na: 2, \nfoo: foo \n\n}; \n\n\nobj.foo(); // 2","metadata":{"loc":{"lines":{"from":16149,"to":16199}}}}],["348",{"pageContent":"Consider: \n\nfunction foo() { \n\nconsole.log( this. a ); \n\n} \n\nvar obj = { \na: 2, \nfoo: foo \n\n}; \n\n\nobj.foo(); // 2 \n\nFirst, notice the manner in which foo() is declared and then later \nadded as a reference property onto obj. Regardless of whether foo() \nis initially declared on foo, or is added as a reference later (as this \nsnippet shows), in neither case is the function really “owned” or “con¬ \ntained” by the obj object. \n\n\n14 | Chapter 2: this All Makes Sense Now! \n\n\n\n\n\nHowever, the call-site uses the ob j context to reference the function, \nso you could say that the ob j object “owns” or “contains” the function \nreference at the time the function is called.","metadata":{"loc":{"lines":{"from":16199,"to":16231}}}}],["349",{"pageContent":"However, the call-site uses the ob j context to reference the function, \nso you could say that the ob j object “owns” or “contains” the function \nreference at the time the function is called. \n\nWhatever you choose to call this pattern, at the point that foo() is \ncalled, it’s preceeded by an object reference to obj. When there is a \ncontext object for a function reference, the implicit binding rule says \nthat it’s that object that should be used for the function call’s this \nbinding. Because obj is the this for the foo() call, this. a is synon¬ \nymous with obj. a. \n\nOnly the top/last level of an object property reference chain matters \nto the call-site. For instance: \n\nfunction foo() { \n\nconsole.log( this. a ); \n\n} \n\nvar obj2 = { \na: 42, \nfoo: foo \n\n}; \n\n\nvar objl = { \na: 2, \n\nobj2: obj2 \n\n\nobjl.obj2.fooQ; // 42 \n\nImplicitly lost","metadata":{"loc":{"lines":{"from":16231,"to":16266}}}}],["350",{"pageContent":"function foo() { \n\nconsole.log( this. a ); \n\n} \n\nvar obj2 = { \na: 42, \nfoo: foo \n\n}; \n\n\nvar objl = { \na: 2, \n\nobj2: obj2 \n\n\nobjl.obj2.fooQ; // 42 \n\nImplicitly lost \n\nOne of the most common frustrations that this binding creates is \nwhen an implicitly bound function loses that binding, which usually \nmeans it falls back to the default binding of either the global object or \nundefined, depending on strict node. \n\nConsider: \n\nfunction foo() { \n\nconsole.log( this. a ); \n\n} \n\nvar obj = { \na: 2, \nfoo: foo \n\n}; \n\n\nvar bar = obj.foo; // function reference/alias! \n\n\nNothing but Rules | 15 \n\n\n\nvar a \n\n\noops, global\"; // 'a' also property on global object \n\n\nbar(); // \"oops, global\" \n\nEven though ba r appears to be a reference to ob j. f oo, in fact, it’s really \njust another reference to foo itself. Moreover, the call-site is what \nmatters, and the call-site is bar(), which is a plain, undecorated call, \nand thus the default binding applies.","metadata":{"loc":{"lines":{"from":16266,"to":16327}}}}],["351",{"pageContent":"The more subtle, more common, and more unexpected way this oc¬ \ncurs is when we consider passing a callback function: \n\nfunction foo() { \n\nconsole.log( this. a ); \n\n} \n\nfunction doFoo(fn) { \n\n// 'fn' is just another reference to 'foo' \nfn(); // <-- call-site! \n\n} \n\nvar obj = { \na: 2, \nfoo: foo \n\n}; \n\nvar a = \"oops, global\"; // 'a' also property on global object \n\ndoFoo( obj.foo ); // \"oops, global\" \n\nParameter passing is just an implicit assignment, and since we’re pass¬ \ning a function, it’s an implicit reference assignment, so the end result \nis the same as the previous snippet. \n\nWhat if the function you’re passing your callback to is not your own, \nbut built into the language? No difference, same outcome: \n\nfunction foo() { \n\nconsole.log( this. a ); \n\n} \n\nvar obj = { \na: 2, \nfoo: foo \n\n}; \n\nvar a = \"oops, global\"; // 'a' also property on global object \n\nsetTimeout( obj.foo, 100 ); // \"oops, global\" \n\n\n16 | Chapter 2: this All Makes Sense Now!","metadata":{"loc":{"lines":{"from":16329,"to":16379}}}}],["352",{"pageContent":"} \n\nvar obj = { \na: 2, \nfoo: foo \n\n}; \n\nvar a = \"oops, global\"; // 'a' also property on global object \n\nsetTimeout( obj.foo, 100 ); // \"oops, global\" \n\n\n16 | Chapter 2: this All Makes Sense Now! \n\n\n\n\nThink about this crude theoretical pseudoimplementation of setTi \nmeout() provided as a built-in from the JavaScript environment: \n\nfunction setTimeout(fn,delay) { \n\n// wait (somehow) for 'delay' milliseconds \nfn(); // <-- call-site! \n\n} \n\nIt’s quite common that our function callbacks lose their this binding, \nas we’ve just seen. But another way that this can surprise us is when \nthe function we’ve passed our callback to intentionally changes the \nthis for the call. Event handlers in popular JavaScript libraries are \nquite fond of forcing your callback to have a this that points to, for \ninstance, the DOM element that triggered the event. While that may \nsometimes be useful, other times it can be downright infuriating. Un¬ \nfortunately, these tools rarely let you choose.","metadata":{"loc":{"lines":{"from":16379,"to":16414}}}}],["353",{"pageContent":"Either way the this is changed unexpectedly, you are not really in \ncontrol of how your callback function reference will be executed, so \nyou have no way (yet) of controlling the call-site to give your intended \nbinding. We’ll see shortly a way of “fixing” that problem by fixing the \nthis. \n\nExplicit Binding \n\nWith implicit binding, as we just saw, we had to mutate the object in \nquestion to include a reference on itself to the function, and use this \nproperty function reference to indirectly (implicitly) bind this to the \nobject. \n\nBut, what if you want to force a function call to use a particular object \nfor the this binding, without putting a property function reference \non the object?","metadata":{"loc":{"lines":{"from":16416,"to":16431}}}}],["354",{"pageContent":"But, what if you want to force a function call to use a particular object \nfor the this binding, without putting a property function reference \non the object? \n\n“All” functions in the language have some utilities available to them \n(via their [ [Prototype] ]—more on that later), which can be useful \nfor this task. Specifically, functions have call(..) and apply(..) \nmethods. Technically, JavaScript host environments sometimes pro¬ \nvide functions that are special enough (a kind way of putting it!) that \nthey do not have such functionality. But those are few. The vast ma¬ \njority of functions provided, and certainly all functions you will create, \ndo have access to call(..) and apply(..). \n\nHow do these utilities work? They both take, as their first parameter, \nan object to use for the this, and then invoke the function with that \n\n\nNothing but Rules | 17 \n\n\n\n\nthis specified. Since you are directly stating what you want the this \nto be, we call it explicit binding. \n\nConsider:","metadata":{"loc":{"lines":{"from":16431,"to":16456}}}}],["355",{"pageContent":"Nothing but Rules | 17 \n\n\n\n\nthis specified. Since you are directly stating what you want the this \nto be, we call it explicit binding. \n\nConsider: \n\nfunction foo() { \n\nconsole.log( this. a ); \n\n} \n\nvar obj = { \na: 2 \n\n}; \n\n\nfoo.call( obj ); // 2 \n\nInvoking foo with explicit binding by foo. call(..) allows us to force \nits this to be obj. \n\nIf you pass a simple primitive value (of type string, boolean, or nun \nber) as the this binding, the primitive value is wrapped in its object- \nform (new String(..), new Boolean( ..), or new Nunber( ..), re¬ \nspectively). This is often referred to as “boxing.” \n\n\n\nWith respect to this binding, call(..) and apply(..) are \nidentical. They do behave differently with their additional pa¬ \nrameters, but that’s not something we care about presently.","metadata":{"loc":{"lines":{"from":16456,"to":16492}}}}],["356",{"pageContent":"With respect to this binding, call(..) and apply(..) are \nidentical. They do behave differently with their additional pa¬ \nrameters, but that’s not something we care about presently. \n\n\nUnfortunately, explicit binding alone still doesn’t offer any solution to \nthe issue mentioned previously, of a function “losing” its intended \nthis binding, or just having it paved over by a framework, etc. \n\nHard binding \n\nBut a variation pattern around explicit binding actually does the trick. \nConsider: \n\nfunction foo() { \n\nconsole.log( this. a ); \n\n} \n\nvar obj = { \na: 2 \n\n}; \n\n\nvar bar = function() { \nfoo.call( obj ); \n\n\n18 | Chapter 2: this All Makes Sense Now! \n\n\n\n\n\n}; \n\n\nbar(); // 2 \n\nsetTimeout( bar, 100 ); // 2 \n\n// hard-bound 'bar' can no longer have its 'this' overridden \nbar.call( window );// 2","metadata":{"loc":{"lines":{"from":16492,"to":16536}}}}],["357",{"pageContent":"18 | Chapter 2: this All Makes Sense Now! \n\n\n\n\n\n}; \n\n\nbar(); // 2 \n\nsetTimeout( bar, 100 ); // 2 \n\n// hard-bound 'bar' can no longer have its 'this' overridden \nbar.call( window );// 2 \n\nLet’s examine how this variation works. We create a function ba r () \nwhich, internally, manually calls foo. call(ob j), thereby forcibly in¬ \nvoking foo withobj binding for this. No matter how you later invoke \nthe function bar, it will always manually invoke foo with obj. This \nbinding is both explicit and strong, so we call it hard binding. \n\nThe most typical way to wrap a function with a hard binding creates a \npass-through of any arguments passed and any return value received: \n\nfunction foo(something) { \n\nconsole.log( this. a, something ); \nreturn this. a + something; \n\n} \n\nvar obj = { \na: 2 \n\n}; \n\n\nvar bar = function() { \n\nreturn foo.apply( obj, arguments ); \n\n}; \n\n\nvar b = bar( 3 ); // 2 3 \nconsole.log ( b ); // 5 \n\nAnother way to express this pattern is to create a reusable helper:","metadata":{"loc":{"lines":{"from":16536,"to":16584}}}}],["358",{"pageContent":"}; \n\n\nvar bar = function() { \n\nreturn foo.apply( obj, arguments ); \n\n}; \n\n\nvar b = bar( 3 ); // 2 3 \nconsole.log ( b ); // 5 \n\nAnother way to express this pattern is to create a reusable helper: \n\nfunction foo(something) { \n\nconsole.log( this. a, something ); \nreturn this. a + something; \n\n} \n\n// sinple 'bind' helper \nfunction bind(fn, obj) { \nreturn functionQ { \n\nreturn fn.apply( obj, arguments ); \n\n}; \n\n} \n\nvar obj = { \na: 2 \n\n}; \n\n\nNothing but Rules | 19 \n\n\n\n\nvar bar = bind( foo, obj ); \n\n\nvar b = bar( 3 ); // 2 3 \nconsole.log ( b ); // 5 \n\nSince hard binding is such a common pattern, it’s provided with a built- \nin utility as of ES5, Function, prototype, bind, and it’s used like this: \n\nfunction foo(something) { \n\nconsole.log( this. a, something ); \nreturn this. a + something; \n\n} \n\nvar obj = { \na: 2 \n\n}; \n\n\nvar bar = foo.bind ( obj ); \n\nvar b = bar( 3 ); // 2 3 \nconsole.log ( b ); // 5","metadata":{"loc":{"lines":{"from":16584,"to":16652}}}}],["359",{"pageContent":"console.log( this. a, something ); \nreturn this. a + something; \n\n} \n\nvar obj = { \na: 2 \n\n}; \n\n\nvar bar = foo.bind ( obj ); \n\nvar b = bar( 3 ); // 2 3 \nconsole.log ( b ); // 5 \n\nbind (..) returns a new function that is hardcoded to call the original \nfunction with the this context set as you specified. \n\nAPI call \"contexts\" \n\nMany libraries’ functions, and indeed many new built-in functions in \nthe JavaScript language and host environment, provide an optional \nparameter, usually called “context,” which is designed as a work¬ \naround for you not having to use bind(..) to ensure your callback \nfunction uses a particular this. \n\nFor instance: \n\nfunction foo(el) { \n\nconsole.log( el, this. id ); \n\n} \n\nvar obj = { \n\nid: \"awesome\" \n\n}; \n\n\n// use 'obj' as 'this' for 'foo(..)~ calls \n[1, 2, 3].forEach( foo, obj ); \n\n// 1 awesone 2 awesome 3 awesome \n\n\nInternally, these various functions almost certainly use explicit bind- \ningv ia call(..) or apply( ..), saving you the trouble.","metadata":{"loc":{"lines":{"from":16652,"to":16701}}}}],["360",{"pageContent":"// 1 awesone 2 awesome 3 awesome \n\n\nInternally, these various functions almost certainly use explicit bind- \ningv ia call(..) or apply( ..), saving you the trouble. \n\n\n20 | Chapter 2: this All Makes Sense Now! \n\n\n\n\nnew Binding \n\nThe fourth and final rule for this binding requires us to rethink a very \ncommon misconception about functions and objects in JavaScript. \n\nIn traditional class-oriented languages, “constructors” are special \nmethods attached to classes, and when the class is instantiated with a \nnew operator, the constructor of that class is called. This usually looks \nsomething like: \n\nsomething = new MyClass(..); \n\nJavaScript has a new operator, and the code pattern to use it looks \nbasically identical to what we see in those class-oriented languages; \nmost developers assume that JavaScript’s mechanism is doing some¬ \nthing similar. However, there really is no connection to class-oriented \nfunctionality implied by new usage in JS.","metadata":{"loc":{"lines":{"from":16701,"to":16729}}}}],["361",{"pageContent":"First, let’s redefine what a “constructor” in JavaScript is. In JS, con¬ \nstructors are just functions that happen to be called with the new op¬ \nerator in front of them. They are not attached to classes, nor are they \ninstantiating a class. They are not even special types of functions. \nThey’re just regular functions that are, in essence, hijacked by the use \nof new in their invocation. \n\nFor example, consider the Number (..) function acting as a construc¬ \ntor, quoting from the ES5.1 spec: \n\n15.7.2 The Number Constructor \n\nWhen Number is called as part of a new expression it is a constructor: \nit initialises the newly created object. \n\nSo, pretty much any of function, including the built-in object func¬ \ntions like Number (..) (see Chapter 3) can be called with new in front \nof it, and that makes that function call a constructor call. This is an \nimportant but subtle distinction: there’s really no such thing as “con¬ \nstructor functions,” but rather construction calls o/functions.","metadata":{"loc":{"lines":{"from":16731,"to":16750}}}}],["362",{"pageContent":"When a function is invoked with new in front of it, otherwise known \nas a constructor call, the following things are done automatically: \n\n1. A brand new object is created (aka constructed) out of thin air. \n\n2. The newly constructed object is [ [Prototype] ]-linked. \n\n3. The newly constructed object is set as the this binding for that \nfunction call. \n\n\nNothing but Rules | 21 \n\n\n\n4. Unless the function returns its own alternate object, the new- \ninvoked function call will automatically return the newly con¬ \nstructed object. \n\nSteps 1, 3, and 4 apply to our current discussion. We’ll skip over step \n2 for now and come back to it in Chapter 5. \n\nConsider this code: \n\nfunction foo(a) { \nthis. a = a; \n\n} \n\nvar bar = new foo( 2 ); \nconsole.log( bar.a ); // 2","metadata":{"loc":{"lines":{"from":16752,"to":16782}}}}],["363",{"pageContent":"Consider this code: \n\nfunction foo(a) { \nthis. a = a; \n\n} \n\nvar bar = new foo( 2 ); \nconsole.log( bar.a ); // 2 \n\nBy calling foo(..) with new in front of it, we’ve constructed a new \nobject and set that new object as the this for the call of foo(..). So \nnew is the final way that a function call’s this can be bound. We’ll call \nthis new binding. \n\nEverything in Order \n\nSo, now we’ve uncovered the four rules for binding this in function \ncalls. All you need to do is find the call-site and inspect it to see which \nrule applies. But, what if the call-site has multiple eligible rules? There \nmust be an order of precedence to these rules, and so we will next \ndemonstrate what order to apply the rules. \n\nIt should be clear that the default binding is the lowest priority rule of \nthe four. So we’ll just set that one aside. \n\nWhich is more precedent, implicit binding or explicit binding ? Let’s \ntest it: \n\nfunction foo() { \n\nconsole.log( this. a ); \n\n} \n\nvar objl = { \na: 2, \nfoo: foo \n\n};","metadata":{"loc":{"lines":{"from":16782,"to":16821}}}}],["364",{"pageContent":"Which is more precedent, implicit binding or explicit binding ? Let’s \ntest it: \n\nfunction foo() { \n\nconsole.log( this. a ); \n\n} \n\nvar objl = { \na: 2, \nfoo: foo \n\n}; \n\n\nvar obj2 = { \na: 3, \nfoo: foo \n\n\n22 | Chapter 2: this All Makes Sense Now! \n\n\n\n\nobjl.fooQ; // 2 \nobj2.foo(); // 3 \n\nobjl.foo.call( obj2 ); // 3 \nobj2.foo.call( objl ); // 2 \n\nSo, explicit binding takes precedence over implicit binding, which \nmeans you should ask first if explicit binding applies before checking \nfor implicit binding. \n\nNow, we just need to figure out where new binding fits in the \nprecedence: \n\nfunction foo(something) { \nthis. a = something; \n\n} \n\nvar objl = { \nfoo: foo \n\n}; \n\n\nvar obj2 = {}; \n\nobjl.foo( 2 ); \n\nconsole.log ( objl.a ); // 2 \n\nobjl.foo.call( obj2, 3 ); \nconsole.log( obj2.a ); // 3 \n\nvar bar = new objl.foo( 4 ); \nconsole.log ( objl.a ); // 2 \nconsole.log( bar.a ); // 4","metadata":{"loc":{"lines":{"from":16821,"to":16882}}}}],["365",{"pageContent":"objl.foo( 2 ); \n\nconsole.log ( objl.a ); // 2 \n\nobjl.foo.call( obj2, 3 ); \nconsole.log( obj2.a ); // 3 \n\nvar bar = new objl.foo( 4 ); \nconsole.log ( objl.a ); // 2 \nconsole.log( bar.a ); // 4 \n\nOK, new binding is more precedent than implicit binding. But do you \nthink new binding is more or less precedent than explicit binding ? \n\n\n\nnew and call/apply cannot be used together, so new \nfoo.call(objl) is not allowed to test new binding directly \nagainst explicit binding. But we can still use a hard binding to \ntest the precedence of the two rules. \n\n\nBefore we explore that in a code listing, think back to how hard bind¬ \ning physically works, which is that Function. prototype. bind(..) \ncreates a new wrapper function that is hardcoded to ignore its own \nthis binding (whatever it may be), and use a manual one we provide. \n\n\nEverything in Order | 23","metadata":{"loc":{"lines":{"from":16882,"to":16910}}}}],["366",{"pageContent":"Everything in Order | 23 \n\n\n\n\n\nBy that reasoning, it would seem obvious to assume that hard bind¬ \ning (which is a form of explicit binding) is more precedent than new \nbinding, and thus cannot be overridden with new. \n\nLet’s check: \n\nfunction foo(something) { \nthis. a = something; \n\n} \n\nvar objl = {}; \n\nvar bar = foo.bind( objl ); \nbar( 2 ); \n\nconsole.log ( objl.a ); // 2 \n\nvar baz = new bar( 3 ); \nconsole.log ( objl.a ); // 2 \nconsole.log ( baz.a );// 3 \n\nWhoa! bar is hard-bound against objl, but new bar (3) did not change \nobjl .a to 3 as we would have expected. Instead, the hard-bound (to \nobjl) call to bar(..) is able to be overridden with new. Since new was \napplied, we got the newly created object back, which we named baz, \nand we see in fact that baz. a has the value 3. \n\nThis should be surprising if you go back to our “fake” bind helper: \n\nfunction bind(fn, obj) { \nreturn function () { \n\nfn.apply( obj, arguments ); \n\n}; \n\n}","metadata":{"loc":{"lines":{"from":16910,"to":16953}}}}],["367",{"pageContent":"This should be surprising if you go back to our “fake” bind helper: \n\nfunction bind(fn, obj) { \nreturn function () { \n\nfn.apply( obj, arguments ); \n\n}; \n\n} \n\nIf you think about how the helper’s code works, it does not have a way \nfor a new operator call to override the hard-binding to obj as we just \nobserved. \n\nBut the built-in Function. prototype. bind(..) as of ES5 is more so¬ \nphisticated, quite a bit so in fact. Here is the (slightly reformatted) \npolyfill provided by the MDN page for bind(..): \n\nif (! Function. prototype.bind) { \n\nFunction. prototype.bind = function(oThis) { \nif (typeof this !== \"function\") { \n\n// closest thing possible to the ECMAScript 5 \n// internal IsCallable function \nthrow new TypeError( \n\n\"Function.prototype.bind - what is trying \" + \n\n\"to be bound is not callable\" \n\n\n24 | Chapter 2: this All Makes Sense Now! \n\n\n\n\n); \n\n} \n\nvar aArgs = Array. prototype.slice.call( arguments, 1 ), \nfToBind = this, \nfNOP = function(){}, \nfBound = functlon(){","metadata":{"loc":{"lines":{"from":16953,"to":16998}}}}],["368",{"pageContent":"24 | Chapter 2: this All Makes Sense Now! \n\n\n\n\n); \n\n} \n\nvar aArgs = Array. prototype.slice.call( arguments, 1 ), \nfToBind = this, \nfNOP = function(){}, \nfBound = functlon(){ \n\nreturn fToBind . apply( \n\n( \n\nthis instanceof fNOP && \noThis ? this : oThis \n\n), \n\naArgs.concat( \n\nArray. prototype.slice.call( arguments ) \n\n); \n\n} \n\n\nfNOP.prototype = this. prototype; \nfBound . prototype = new fNOP(); \n\nreturn fBound; \n\n}; \n\n} \n\n\n\nThe btnd(. .) polyfill shown above differs from the built-in \nbind (..) in ES5 with respect to hard-bound functions that will \nbe used with new (read on to learn why that’s useful). Because \nthe polyfill cannot create a function without a .prototype as \nthe built-in utility does, there’s some nuanced indirection to \napproximate the same behavior. Tread carefully if you plan to \nuse new with a hard-bound function and you rely on this \npolyfill. \n\n\nThe part that’s allowing new overriding is: \n\nthis instanceof fNOP && \noThis ? this : oThis \n\n// ... and:","metadata":{"loc":{"lines":{"from":16998,"to":17056}}}}],["369",{"pageContent":"The part that’s allowing new overriding is: \n\nthis instanceof fNOP && \noThis ? this : oThis \n\n// ... and: \n\nfNOP.prototype = this. prototype; \nfBound . prototype = new fNOP (); \n\nWe won’t actually dive into explaining how this trickery works (it’s \ncomplicated and beyond our scope here), but essentially the utility \ndetermines whether or not the hard-bound function has been called \nwith new (resulting in a newly constructed object being its this), and \n\n\nEverything in Order | 25 \n\n\n\n\nif so, it uses that newly created this rather than the previously specified \nhard binding for this. \n\nWhy is new being able to override hard binding useful?","metadata":{"loc":{"lines":{"from":17056,"to":17080}}}}],["370",{"pageContent":"Everything in Order | 25 \n\n\n\n\nif so, it uses that newly created this rather than the previously specified \nhard binding for this. \n\nWhy is new being able to override hard binding useful? \n\nThe primary reason for this behavior is to create a function (that can \nbe used with new for constructing objects) that essentially ignores the \nthis hard binding, but which presets some or all of the functions ar¬ \nguments. One of the capabilities of bind(..) is that any arguments \npassed after the first this binding argument are defaulted as standard \narguments to the underlying function (technically called “partial ap¬ \nplication,” which is a subset of “currying”). For example: \n\nfunction foo(pl,p2) { \n\nthis.val = pi + p2; \n\n} \n\n// using 'null' here because we don't care about \n// the 'this' hard-binding in this scenario, and \n// it will be overridden by the 'new' call anyway! \nvar bar = foo.bind( null, \"pi\" ); \n\nvar baz = new bar( \"p2\" ); \n\nbaz.val; // plp2 \n\nDetermining this","metadata":{"loc":{"lines":{"from":17080,"to":17113}}}}],["371",{"pageContent":"var baz = new bar( \"p2\" ); \n\nbaz.val; // plp2 \n\nDetermining this \n\nNow, we can summarize the rules for determining this from a func¬ \ntion call’s call-site, in their order of precedence. Ask these questions \nin this order, and stop when the first rule applies. \n\n1. Is the function called with new {new binding )? If so, this is the \nnewly constructed object. \n\nvar bar = new foo() \n\n2. Is the function called with call or apply {explicit binding), even \nhidden inside a bind hard binding ? If so, this is the explicitly \nspecified object. \n\nvar bar = foo.call( obj2 ) \n\n3. Is the function called with a context {implicit binding), otherwise \nknown as an owning or containing object? If so, this is that con¬ \ntext object. \n\nvar bar = objl.foo() \n\n\n26 | Chapter 2: this All Makes Sense Now! \n\n\n\n\n4. Otherwise, default the this ( default binding). If in strict node, \npick undefined, otherwise pick the global object, \nvar bar = foo()","metadata":{"loc":{"lines":{"from":17113,"to":17148}}}}],["372",{"pageContent":"26 | Chapter 2: this All Makes Sense Now! \n\n\n\n\n4. Otherwise, default the this ( default binding). If in strict node, \npick undefined, otherwise pick the global object, \nvar bar = foo() \n\nThat’s it. That’s all it takes to understand the rules of this binding for \nnormal function calls. Well.. .almost. \n\nBinding Exceptions \n\nAs usual, there are some exceptions to the “rules.” \n\nThe this-binding behavior can in some scenarios be surprising, where \nyou intended a different binding but you end up with binding behavior \nfrom the default binding rule. \n\nIgnored this \n\nIf you pass null or undefined as a this binding parameter to call, \napply, or bind, those values are effectively ignored, and instead the \ndefault binding rule applies to the invocation: \n\nfunction foo() { \n\nconsole.log( this. a ); \n\n} \n\nvar a = 2; \n\nfoo.call( null ); // 2 \n\nWhy would you intentionally pass something like null for a this \nbinding?","metadata":{"loc":{"lines":{"from":17148,"to":17185}}}}],["373",{"pageContent":"function foo() { \n\nconsole.log( this. a ); \n\n} \n\nvar a = 2; \n\nfoo.call( null ); // 2 \n\nWhy would you intentionally pass something like null for a this \nbinding? \n\nIt’s quite common to use apply(..) for spreading out arrays ofvalues \nas parameters to a function call. Similarly, bind(..) can curry pa¬ \nrameters (preset values), which can be very helpful: \n\nfunction foo(a,b) { \n\nconsole.log( \"a:\" + a + \", b:\" + b ); \n\n} \n\n// spreading out array as parameters \nfoo.apply( null, [2, 3] ); // a:2, b:3 \n\n// currying with 'bind(..)~ \nvar bar = foo.bind( null, 2 ); \nbar( 3 ); // a:2, b:3 \n\n\nBinding Exceptions | 27 \n\n\n\nBoth these utilities require a this binding for the first parameter. If \nthe functions in question don’t care about this, you need a placeholder \nvalue, and null might seem like a reasonable choice as shown in this \nsnippet.","metadata":{"loc":{"lines":{"from":17185,"to":17223}}}}],["374",{"pageContent":"We don’t cover it in this book, but ES6 has the ... spread \noperator, which will let you syntactically “spread out” an ar¬ \nray as parameters without needing apply (..), such as foo(... \n[1,2]), which amounts to f oo (1,2 )—syntactically avoiding a \nthis binding if it’s unnecessary. Unfortunately, there’s no ES6 \nsyntactic substitute for currying, so the this parameter of the \nbind( ..) call still needs attention. \n\n\nHowever, there’s a slight hidden “danger” in always using null when \nyou don’t care about the this binding. If you ever use that against a \nfunction call (for instance, a third-party library function that you don’t \ncontrol), and that function does make a this reference, the default \nbinding rule means it might inadvertently reference (or worse, mu¬ \ntate!) the global object (window in the browser). \n\nObviously, such a pitfall can lead to a variety of bugs that are very \ndifficult to diagnose and track down. \n\nSafer this","metadata":{"loc":{"lines":{"from":17227,"to":17246}}}}],["375",{"pageContent":"Obviously, such a pitfall can lead to a variety of bugs that are very \ndifficult to diagnose and track down. \n\nSafer this \n\nPerhaps a somewhat “safer” practice is to pass a specifically set up \nobject for this that is guaranteed not to be an object that can create \nproblematic side effects in your program. Borrowing terminology \nfrom networking (and the military), we can create a “DMZ” (de¬ \nmilitarized zone) object—nothing more special than a completely \nempty, nondelegated object (see Chapters 5 and 6). \n\nIf we always pass a DMZ object for ignored this bindings we don’t \nthink we need to care about, we’re sure any hidden/unexpected usage \nof this will be restricted to the empty object, which insulates our pro¬ \ngram’s global object from side effects.","metadata":{"loc":{"lines":{"from":17246,"to":17261}}}}],["376",{"pageContent":"Since this object is totally empty, I personally like to give it the variable \nname 0 (the lowercase mathematical symbol for the empty set). On \nmany keyboards (like US-layout on Mac), this symbol is easily typed \nwith T+o (Option-o). Some systems also let you set up hotkeys for \nspecific symbols. If you don’t like the 0 symbol, or your keyboard \n\n\n28 | Chapter 2: this All Makes Sense Now! \n\n\n\n\ndoesn’t make it easy to type, you can of course call it whatever you \nwant. \n\nWhatever you call the variable, the easiest way to set it up as totally \nempty is Object.create(null) (see Chapter 5). Object.ere \nate(null) is similar to { }, but without the delegation to Object, pro \ntotype, so it’s “more empty” than just { }: \n\nfunction foo(a,b) { \n\nconsole.log( \"a:\" + a + \", b:\" + b ); \n\n} \n\n// our DMZ empty object \nvar 0 = Object. create( null ); \n\n// spreading out array as parameters \nfoo.apply( 0 , [2, 3] ); // a:2, b:3","metadata":{"loc":{"lines":{"from":17263,"to":17293}}}}],["377",{"pageContent":"console.log( \"a:\" + a + \", b:\" + b ); \n\n} \n\n// our DMZ empty object \nvar 0 = Object. create( null ); \n\n// spreading out array as parameters \nfoo.apply( 0 , [2, 3] ); // a:2, b:3 \n\n// currying with 'bind(..)' \nvar bar = foo.bind( a, 2 ); \nbar( 3 ); // a:2, b:3 \n\nNot only is it functionally “safer,” but there’s a sort of stylistic benefit \nto 0 , in that it semantically conveys “I want the this to be empty” a \nlittle more clearly than null might. But again, name your DMZ object \nwhatever you prefer. \n\nIndirection \n\nAnother thing to be aware of is that you can (intentionally or not!) \ncreate “indirect references” to functions, and in those cases, when that \nfunction reference is invoked, the default binding rule also applies. \n\nOne of the most common ways that indirect references occur is from \nan assignment: \n\nfunction foo() { \n\nconsole.log( this. a ); \n\n} \n\nvar a = 2; \n\nvar o = { a: 3, foo: foo }; \nvar p = { a: 4 }; \n\no.fooO; // 3 \n(p.foo = o.foo)0; // 2","metadata":{"loc":{"lines":{"from":17293,"to":17333}}}}],["378",{"pageContent":"function foo() { \n\nconsole.log( this. a ); \n\n} \n\nvar a = 2; \n\nvar o = { a: 3, foo: foo }; \nvar p = { a: 4 }; \n\no.fooO; // 3 \n(p.foo = o.foo)0; // 2 \n\nThe result value of the assignment expression p. foo = o. foo is a \nreference to just the underlying function object. As such, the effective \n\n\nBinding Exceptions | 29 \n\n\n\ncall-site is just foo(), not p.fooQ or o.fooQ as you might expect. \nPer the rules mentioned earlier, the default binding rule applies. \n\nReminder: regardless of how you get to a function invocation using \nthe default binding rule, the strict node status of the contents of the \ninvoked function making the this reference—not the function call- \nsite—determines the default binding value: either the global object if \ninnon-strict node or undefined if in strict node. \n\nSoftening Binding","metadata":{"loc":{"lines":{"from":17333,"to":17364}}}}],["379",{"pageContent":"Softening Binding \n\nWe saw earlier that hard binding was one strategy for preventing a \nfunction call falling back to the default binding rule inadvertently, by \nforcing it to be bound to a specific this (unless you use new to override \nit!). The problem is, hard binding greatly reduces the flexibility of a \nfunction, preventing manual this override with either implicit bind¬ \ning or even subsequent explicit binding attempts. \n\nIt would be nice if there was a way to provide a different default for \ndefault binding (not global or undefined), while still leaving the \nfunction able to be manually this-bound via implicit binding or ex¬ \nplicit binding techniques. \n\nWe can construct a so-called soft binding utility that emulates our de¬ \nsired behavior: \n\nif (IFunction. prototype.softBind) { \n\nFunction. prototype.softBind = function(obj ) { \nvar fn = this; \n\n// capture any curried parameters \nvar curried [] .slice.calt( arguments, 1 ); \nvar bound = function! ) { \nreturn fn.apply!","metadata":{"loc":{"lines":{"from":17364,"to":17389}}}}],["380",{"pageContent":"Function. prototype.softBind = function(obj ) { \nvar fn = this; \n\n// capture any curried parameters \nvar curried [] .slice.calt( arguments, 1 ); \nvar bound = function! ) { \nreturn fn.apply! \n\n(!this || this === (window || global)) ? \nobj : this \n\ncurried.concat.apply! curried, arguments ) \n\n); \n\n}; \n\nbound . prototype = Object. create! fn.prototype ); \nreturn bound; \n\n}; \n\n} \n\nThe softBind(. •) utility provided here works similarly to the built- \nin ES5 bind (..) utility, except with our soft binding behavior. It wraps \nthe specified function in logic that checks the this at call-time and if \nit’s global or undefined, uses a prespecified alternate default (obj). \n\n\n30 | Chapter 2: this All Makes Sense Now! \n\n\n\nOtherwise the this is left untouched. It also provides optional curry¬ \ning (see the bind(..) discussion earlier). \n\nLet’s demonstrate its usage: \n\nfunction foo() { \n\nconsole. log(\"name: \" + this. name); \n\n}","metadata":{"loc":{"lines":{"from":17389,"to":17432}}}}],["381",{"pageContent":"Let’s demonstrate its usage: \n\nfunction foo() { \n\nconsole. log(\"name: \" + this. name); \n\n} \n\nvar obj = { name: \"obj\" }, \nobj2 = { name: \"obj2\" }, \nobj3 = { name: \"obj3\" }; \n\nvar fooOBJ = foo.softBind( obj ); \n\nfooOBJQ; // none: obj \n\nobj2.foo = foo.softBind(obj); \nobj2.foo(); // none: obj2 < - look!!! \n\nfooOBJ. call( obj3 ); // none: obj3 <- look! \n\nsetTimeout( obj2.foo, 10 ); \n\n// none: obj < - falls back to soft-binding \n\nThe soft-bound version of the foo() function can be manually this- \nbound to obj 2 or obj 3 as shown, but it falls back to obj if the default \nbinding would otherwise apply. \n\nLexical this \n\nNormal functions abide by the four rules we just covered. But ES6 \nintroduces a special kind of function that does not use these rules: the \narrow-function.","metadata":{"loc":{"lines":{"from":17432,"to":17465}}}}],["382",{"pageContent":"Lexical this \n\nNormal functions abide by the four rules we just covered. But ES6 \nintroduces a special kind of function that does not use these rules: the \narrow-function. \n\nArrow-functions are signified not by the function keyword, but by \nthe so-called “fat arrow” operator, =>. Instead of using the four stan¬ \ndard this rules, arrow-functions adopt the this binding from the \nenclosing (function or global) scope. \n\nLet’s illustrate the arrow-function lexical scope: \n\nfunction foo() { \n\n// return an arrow function \nreturn (a) => { \n\n// 'this' here is lexically inherited from 'foo()' \nconsole. log( this. a ); \n\n}; \n\n} \n\n\nLexical this | 31 \n\n\n\nvar objl = { \na: 2 \n\n}; \n\n\nvar obj2 = { \na: 3 \n\n}; \n\n\nvar bar = foo.call( objl ); \nbar.call( obj2 ); // 2, not 3!","metadata":{"loc":{"lines":{"from":17465,"to":17508}}}}],["383",{"pageContent":"}; \n\n} \n\n\nLexical this | 31 \n\n\n\nvar objl = { \na: 2 \n\n}; \n\n\nvar obj2 = { \na: 3 \n\n}; \n\n\nvar bar = foo.call( objl ); \nbar.call( obj2 ); // 2, not 3! \n\nThe arrow-function created in foo() lexically captures whatever \nfooQs this is at its call-time. Since foo() was this-bound to objl, \nbar (a reference to the returned arrow-function) will also be this- \nbound to objl. The lexical binding of an arrow-function cannot be \noverridden (even with new!). \n\nThe most common use case will likely be in the use of callbacks, such \nas event handlers or timers: \n\nfunction foo() { \n\nsetTlmeout(() => { \n\n// 'this' here is lexically inherited from 'foo()' \nconsole.log( this. a ); \n\n}, 100 ); \n\n} \n\nvar obj = { \na: 2 \n\n}; \n\n\nfoo.call( obj ')•,// 2","metadata":{"loc":{"lines":{"from":17508,"to":17558}}}}],["384",{"pageContent":"function foo() { \n\nsetTlmeout(() => { \n\n// 'this' here is lexically inherited from 'foo()' \nconsole.log( this. a ); \n\n}, 100 ); \n\n} \n\nvar obj = { \na: 2 \n\n}; \n\n\nfoo.call( obj ')•,// 2 \n\nWhile arrow-functions provide an alternative to using bind(..) on a \nfunction to ensure its this, which can seem attractive, it’s important \nto note that they essentially are disabling the traditional this mecha¬ \nnism in favor of more widely understood lexical scoping. Pre-ES6, we \nalready have a fairly common pattern for doing so, which is basically \nalmost indistinguishable from the spirit of ES6 arrow-functions: \n\nfunction foo() { \n\nvar self = this; // lexical capture of 'this' \nsetTimeout( function(){ \nconsole.log( self.a ); \n\n}, 100 ); \n\n} \n\nvar obj = { \na: 2 \n\n\n32 | Chapter 2: this All Makes Sense Now! \n\n\n\n\n}; \n\n\nfoo.call( obj ); // 2","metadata":{"loc":{"lines":{"from":17558,"to":17606}}}}],["385",{"pageContent":"}, 100 ); \n\n} \n\nvar obj = { \na: 2 \n\n\n32 | Chapter 2: this All Makes Sense Now! \n\n\n\n\n}; \n\n\nfoo.call( obj ); // 2 \n\nWhile self = this and arrow-functions both seem like good “solu¬ \ntions” to not wanting to use bind ( ..). they are essentially fleeing from \nthis instead of understanding and embracing it. \n\nIf you find yourself writing this-style code, but most or all the time, \nyou defeat the this mechanism with lexical self = this or arrow- \nfunction “tricks,” perhaps you should either: \n\n1. Use only lexical scope and forget the false pretense of this-style \ncode. \n\n2. Embrace this-style mechanisms completely, including using \nbind(..) where necessary, and try to avoid self = this and \narrow-function “lexical this” tricks.","metadata":{"loc":{"lines":{"from":17606,"to":17637}}}}],["386",{"pageContent":"2. Embrace this-style mechanisms completely, including using \nbind(..) where necessary, and try to avoid self = this and \narrow-function “lexical this” tricks. \n\nA program can effectively use both styles of code (lexical and this), \nbut inside of the same function, and indeed for the same sorts of look¬ \nups, mixing the two mechanisms is usually asking for harder-to- \nmaintain code, and probably working too hard to be clever. \n\nReview \n\nDetermining the this binding for an executing function requires \nfinding the direct call-site of that function. Once examined, four rules \ncan be applied to the call-site, in this order of precedence: \n\n1. Called with new? Use the newly constructed object. \n\n2. Called with call or apply (or bind)? Use the specified object. \n\n3. Called with a context object owning the call? Use that context \nobject. \n\n4. Default: undefined in strict node, global object otherwise.","metadata":{"loc":{"lines":{"from":17637,"to":17659}}}}],["387",{"pageContent":"3. Called with a context object owning the call? Use that context \nobject. \n\n4. Default: undefined in strict node, global object otherwise. \n\nBe careful of accidental/unintentional invoking of the default bind¬ \ning rule. In cases where you want to “safely” ignore a this binding, a \n“DMZ” object like 0 = Object. create(null) is a good placeholder \nvalue that protects the global object from unintended side effects. \n\n\nReview | 33 \n\n\n\n\nInstead of the four standard binding rules, ES6 arrow-functions use \nlexical scoping for this binding, which means they inherit the this \nbinding (whatever it is) from its enclosing function call. They are es¬ \nsentially a syntactic replacement of self = this in pre-ES6 coding. \n\n\n34 | Chapter 2: this All Makes Sense Now! \n\n\n\nCHAPTER 3 \n\n\nObjects","metadata":{"loc":{"lines":{"from":17659,"to":17688}}}}],["388",{"pageContent":"34 | Chapter 2: this All Makes Sense Now! \n\n\n\nCHAPTER 3 \n\n\nObjects \n\n\nIn Chapters 1 and 2, we explained how the this binding points to \nvarious objects depending on the call-site of the function invocation. \nBut what exactly are objects, and why do we need to point to them? \nWe will explore objects in detail in this chapter. \n\nSyntax \n\nObjects come in two forms: the declarative (literal) form and the con¬ \nstructed form. \n\nThe literal syntax for an object looks like this: \n\nvar myObj = { \nkey: value \n// ... \n\n1 ; \n\nThe constructed form looks like this: \n\nvar myObj = new ObjectQ; \nmyObj.key = value; \n\nThe constructed form and the literal form result in exactly the same \nsort of object. The only difference really is that you can add one or \nmore key/value pairs to the literal declaration, whereas with \nconstructed-form objects, you must add the properties one by one. \n\n\n35","metadata":{"loc":{"lines":{"from":17688,"to":17727}}}}],["389",{"pageContent":"35 \n\n\n\n\n\n\nIt’s extremely uncommon to use the “constructed form” for \ncreating objects as just shown. You would pretty much al¬ \nways want to use the literal syntax form. The same will be true \nof most of the built-in objects (explained later). \n\n\nType \n\nObjects are the general building block upon which much of JS is built. \nThey are one of the six primary types (called “language types” in the \nspecification) in JS: \n\n• string \n\n• number \n\n• boolean \n\n• null \n\n• undefined \n\n• object \n\nNote that the simple primitives (string, boolean, number, null, and \nundefined) are not themselves objects, null is sometimes referred \nto as an object type, but this misconception stems from a bug in the \nlanguage that causes typeof null to return the string \"object\" in¬ \ncorrectly (and confusingly). In fact, null is its own primitive type. \n\nIt’s a common misstatement that “everything in JavaScript is an obj ect.” \nThis is clearly not true.","metadata":{"loc":{"lines":{"from":17727,"to":17765}}}}],["390",{"pageContent":"It’s a common misstatement that “everything in JavaScript is an obj ect.” \nThis is clearly not true. \n\nBy contrast, there are a few special object subtypes, which we can refer \nto as complex primitives. \n\nfunction is a subtype of object (technically, a “callable object”). Func¬ \ntions in JS are said to be “first class” in that they are basically just \nnormal objects (with callable behavior semantics bolted on), and so \nthey can be handled like any other plain object. \n\nArrays are also a form of objects, with extra behavior. The organization \nof contents in arrays is slightly more structured than for general \nobjects. \n\n\n36 | Chapter 3: Objects \n\n\n\n\n\nBuilt-in Objects \n\nThere are several other object subtypes, usually referred to as built-in \nobjects. For some of them, their names seem to imply they are directly \nrelated to their simple primitive counterparts, but in fact, their rela¬ \ntionship is more complicated, which we’ll explore shortly. \n\n• String \n\n• Number \n\n• Boolean","metadata":{"loc":{"lines":{"from":17765,"to":17798}}}}],["391",{"pageContent":"• String \n\n• Number \n\n• Boolean \n\n• Object \n\n• Function \n\n• Array \n\n• Date \n\n• RegExp \n\n• Error \n\nThese built-ins have the appearance of being actual types, even classes, \nif you rely on the similarity to other languages such as Java’s String \nclass. \n\nBut in JS, these are actually just built-in functions. Each of these built- \nin functions can be used as a constructor (that is, a function call with \nthe new operator—see Chapter 2), with the result being a newly con¬ \nstructed object of the subtype in question. For instance: \n\nvar strPrinitive = \"I an a string\"; \ntypeof strPrinitive; // \"string\" \nstrPrinitive instanceof String; // false \n\nvar strObject = new String( \"I an a string\" ); \ntypeof strObject; // \"object\" \nstrObject instanceof String; // true \n\n// inspect the object sub-type \n\nObject. prototype.toString.call( strObject ); // [object String]","metadata":{"loc":{"lines":{"from":17798,"to":17835}}}}],["392",{"pageContent":"// inspect the object sub-type \n\nObject. prototype.toString.call( strObject ); // [object String] \n\nWe’ll see in detail in a later chapter exactly how the Object.proto \ntype . toString ... bit works, but briefly, we can inspect the internal \nsubtype by borrowing the base default toString () method, and you \ncan see it reveals that strObject is an object that was in fact created \nby the String constructor. \n\n\nType | 37 \n\n\n\n\nThe primitive value \" I an a string\" is not an object, it’s a primitive \nliteral and immutable value. To perform operations on it, such as \nchecking its length, accessing its individual character contents, etc., a \nString object is required.","metadata":{"loc":{"lines":{"from":17835,"to":17854}}}}],["393",{"pageContent":"Luckily, the language automatically coerces a string primitive to a \nString object when necessary, which means you almost never need \nto explicitly create the Object form. It is strongly preferred by the \nmajority of the JS community to use the literal form for a value, where \npossible, rather than the constructed object form. \n\nConsider: \n\nvar strPrinitive = \"I an a string\"; \nconsole.log( strPrinitive.length ); // 13 \n\nconsole.log( strPrinitive.charAt( 3 ) ); // \"n\" \n\nIn both cases, we call a property or method on a string primitive, and \nthe engine automatically coerces it to a String object, so that the \nproperty/method access works. \n\nThe same sort of coercion happens between the number literal prim¬ \nitive 42 and the new Number(42) object wrapper, when using methods \nlike 42.359.toFixed(2). Likewise for Boolean objects from \n\"boolean\" primitives.","metadata":{"loc":{"lines":{"from":17856,"to":17876}}}}],["394",{"pageContent":"null and undefined have no object wrapper form, only their primitive \nvalues. By contrast, Date values can only be created with their con¬ \nstructed object form, as they have no literal form counterpart. \n\nObjects, Arrays, Functions, and RegExps (regular expressions) are all \nobjects regardless of whether the literal or constructed form is used. \nThe constructed form does offer, in some cases, more options in cre¬ \nation than the literal form counterpart. Since objects are created either \nway, the simpler literal form is almost universally preferred. Only use \nthe constructed form if you need the extra options. \n\nError objects are rarely created explicitly in code, but usually created \nautomatically when exceptions are thrown. They can be created with \nthe constructed form new Error( ..), but it’s often unnecessary. \n\n\n38 | Chapter 3: Objects \n\n\n\n\nContents","metadata":{"loc":{"lines":{"from":17878,"to":17899}}}}],["395",{"pageContent":"38 | Chapter 3: Objects \n\n\n\n\nContents \n\nAs mentioned earlier, the contents of an object consist of values (any \ntype) stored at specifically named locations, which we call properties. \n\nIt’s important to note that while we say “contents,” which implies that \nthese values are actually stored inside the object, that’s merely an ap¬ \npearance. The engine stores values in implementation-dependent \nways, and may very well not store them in some object container. What \nis stored in the container are these property names, which act as point¬ \ners (technically, references) to where the values are stored. \n\nConsider: \n\nvar myObject = { \na: 2 \n\n}; \n\n\nmyObject.a; // 2 \nnyObject[ \"a\" ];// 2","metadata":{"loc":{"lines":{"from":17899,"to":17925}}}}],["396",{"pageContent":"Consider: \n\nvar myObject = { \na: 2 \n\n}; \n\n\nmyObject.a; // 2 \nnyObject[ \"a\" ];// 2 \n\nTo access the value at the location a in myOb ject, we need to use either \nthe . operator or the [ ] operator. The . a syntax is usually referred to \nas “property access,” whereas the [\" a\" ] syntax is usually referred to as \n“key access.” In reality, they both access the same location and will pull \nout the same value, 2, so the terms can be used interchangeably. We \nwill use the most common term, “property access,” from here on. \n\nThe main difference between the two syntaxes is that the . operator \nrequires an Identifier-compatible property name after it, whereas \nthe syntax can take basically any UTF-8/Unicode-compatible \n\nstring as the name for the property. To reference a property of the name \n\"Super-Fun!\", for instance, you would have to use the [\"Super- \nFun!\"] access syntax, as Super-Fun! is not a valid Identifier prop¬ \nerty name.","metadata":{"loc":{"lines":{"from":17925,"to":17950}}}}],["397",{"pageContent":"Also, since the syntax uses a string’s value to specify the loca¬ \n\ntion, this means the program can programmatically build up the value \nof the string, such as: \n\nvar myObject = { \na: 2 \n\n}; \n\n\nvar Idx; \n\n\nContents | 39 \n\n\n\nif (wantA) { \nidx = \"a\"; \n\n} \n\n// later \n\nconsole.log( myObject[idx] ); // 2 \n\nIn objects, property names are always strings. If you use any other \nvalue besides a string (primitive) as the property, it will first be con¬ \nverted to a string. This even includes numbers, which are commonly \nused as array indexes, so be careful not to confuse the use of numbers \nbetween objects and arrays: \n\nvar myObject = { }; \n\nmyObject[true] = \"foo\"; \nmy0bject[3] = \"bar\"; \nmyObject[myObject] = \"baz\"; \n\nnyObject[ \"true\"] ; // \"foo\" \n\nmyObject[ \"3\" ]; // \"bar\" \n\nmyObject[\" [object Object]\"]; // \"baz\" \n\nComputed Property Names","metadata":{"loc":{"lines":{"from":17952,"to":17997}}}}],["398",{"pageContent":"nyObject[ \"true\"] ; // \"foo\" \n\nmyObject[ \"3\" ]; // \"bar\" \n\nmyObject[\" [object Object]\"]; // \"baz\" \n\nComputed Property Names \n\nThe myObject[.. ] property access syntax we just described is useful \nif you need to use a computed expression value as the key name, like \nmyObject[prefix + name]. But that’s not really helpful when declar¬ \ning objects using the object-literal syntax. \n\nES6 adds computed property names, where you can specify an expres¬ \nsion, surrounded by a [ ] pair, in the key-name position of an object- \nliteral declaration: \n\nvar prefix = \"foo\"; \n\nvar myObject = { \n\n[prefix + \"bar\"] \"hello\", \n\n[prefix + \"baz\"] \"world\" \n\n}; \n\n\nmyObject[ \"foobar\" ]; // hello \nmyObject[\"foobaz\"]; // world \n\nThe most common usage of computed property names will probably \nbe for ES6 Symbols, which we will not be covering in detail in this book. \nIn short, they’re a new primitive data type that has an opaque un- \nguessable value (technically a string value). You will be strongly","metadata":{"loc":{"lines":{"from":17997,"to":18031}}}}],["399",{"pageContent":"40 | Chapter 3: Objects \n\n\n\ndiscouraged from working with the actual value of a Symbol (which \ncan theoretically be different between different JS engines), so the \nname of the Symbol, like Symbol. Something (just a made up name!), \nwill be what you use: \n\nvar myObject = { \n\n[Symbol.Something]: \"hello world\" \n\n}; \n\nProperty Versus Method \n\nSome developers like to make a distinction when talking about a \nproperty access on an object, if the value being accessed happens to be \na function. Because it’s tempting to think of the function as belong¬ \ning to the object, and in other languages, functions that belong to ob¬ \njects (aka “classes”) are referred to as “methods,” it’s not uncommon \nto hear “method access” as opposed to “property access.” \n\nThe specification makes this same distinction, interestingly.","metadata":{"loc":{"lines":{"from":18034,"to":18058}}}}],["400",{"pageContent":"The specification makes this same distinction, interestingly. \n\nTechnically, functions never “belong” to objects, so saying that a func¬ \ntion that just happens to be accessed on an object reference is auto¬ \nmatically a “method” seems a bit of a stretch of semantics. \n\nIt is true that some functions have this references in them, and that \nsometimes these this references refer to the object reference at the \ncall-site. But this usage really does not make that function any more a \n“method” than any other function, as this is dynamically bound at \nruntime, at the call-site, and thus its relationship to the object is indi¬ \nrect, at best.","metadata":{"loc":{"lines":{"from":18058,"to":18069}}}}],["401",{"pageContent":"Every time you access a property on an object, that is a property access, \nregardless of the type of value you get back. If you happen to get a \nfunction from that property access, it’s not magically a “method” at \nthat point. There’s nothing special (outside of possible implicit this \nbinding as explained earlier) about a function that comes from a \nproperty access. \n\nFor instance: \n\nfunction foo() { \n\nconsole.log( \"foo\" ); \n\n} \n\nvar someFoo = foo; // variable reference to 'foo' \nvar myObject = { \n\n\nContents | 41 \n\n\n\nsomeFoo: foo \n\n\n}; \n\n\nfoo; // function foo(){..} \nsomeFoo; // function foo(){..} \nmyObject.someFoo; // function foo(){..}","metadata":{"loc":{"lines":{"from":18071,"to":18102}}}}],["402",{"pageContent":"Contents | 41 \n\n\n\nsomeFoo: foo \n\n\n}; \n\n\nfoo; // function foo(){..} \nsomeFoo; // function foo(){..} \nmyObject.someFoo; // function foo(){..} \n\nsomeFoo and myObject. someFoo are just two separate references to the \nsame function, and neither implies anything about the function being \nspecial or “owned” by any other object. If foo() was defined to have a \nthis reference inside it, that myObject.someFoo implicit binding \nwould be the only observable difference between the two references. \nIt doesn’t make sense to call either reference a “method.” \n\nPerhaps one could argue that a function becomes a method, not at \ndefinition time, but during runtime just for that invocation, depending \non how it’s called at its call-site (with or without an object reference \ncontext—see Chapter 2 for more details). Even this interpretation is a \nbit of a stretch. \n\nThe safest conclusion is probably that “function” and “method” are \ninterchangeable in JavaScript.","metadata":{"loc":{"lines":{"from":18102,"to":18130}}}}],["403",{"pageContent":"The safest conclusion is probably that “function” and “method” are \ninterchangeable in JavaScript. \n\n\n\nES6 adds a super reference, which is typically going to be used \nwith class (see Appendix A). The way super behaves (static \nbinding rather than late binding as this) gives further weight \nto the idea that a function that is super-bound somewhere is \nmore a “method” than “function.” But again, these are just \nsubtle semantic (and mechanical) nuances. \n\n\nEven when you declare a function expression as part of the object \nliteral, that function doesn’t magically belong more to the object— \nthere are still just multiple references to the same function object: \n\nvar myObject = { \n\nfoo: functionQ { \n\nconsole.log( \"foo\" ); \n\n} \n\n}; \n\n\nvar someFoo = myObject. foo; \nsomeFoo; // function foo(){..} \nmyObject. foo; // function foo(){..} \n\n\n42 | Chapter 3: Objects \n\n\n\n\n\nIn Chapter 6, we will cover an ES6 shorthand for that foo: \nfunction (){ .. } declaration syntax in our object literal.","metadata":{"loc":{"lines":{"from":18130,"to":18170}}}}],["404",{"pageContent":"42 | Chapter 3: Objects \n\n\n\n\n\nIn Chapter 6, we will cover an ES6 shorthand for that foo: \nfunction (){ .. } declaration syntax in our object literal. \n\n\n\nArrays \n\nArrays also use the [ ] access form, but as mentioned earlier, they have \nslightly more structured organization for how and where values are \nstored (though still no restriction on what type of values are stored). \nArrays assume numeric indexing, which means that values are stored \nin locations, usually called indices, at positive integers, such as 0 and 42: \n\nvar myArray = [ \"foo\", 42, \"bar\" ]; \nmyArray.length; // 3 \nmyArray[6]; // \"foo\" \n\n\nmyArray[2]; // \"bar\" \n\nArrays are objects, so even though each index is a positive integer, you \ncan also add properties onto the array: \n\nvar myArray = [ \"foo\", 42, \"bar\" ]; \n\n\nmyArray.baz = \"baz\"; \nmyArray.length; // 3 \nmyArray. baz; // \"baz\" \n\nNotice that adding named properties (regardless of . or [ ] operator \nsyntax) does not change the reported length of the array.","metadata":{"loc":{"lines":{"from":18170,"to":18207}}}}],["405",{"pageContent":"myArray.baz = \"baz\"; \nmyArray.length; // 3 \nmyArray. baz; // \"baz\" \n\nNotice that adding named properties (regardless of . or [ ] operator \nsyntax) does not change the reported length of the array. \n\nYou could use an array as a plain key/value object, and never add any \nnumeric indices, but this is bad idea because arrays have behavior and \noptimizations specific to their intended use, and likewise with plain \nobjects. Use objects to store key/value pairs, and arrays to store values \nat numeric indices. \n\nBe careful: if you try to add a property to an array, but the property \nname looks like a number, it will end up instead as a numeric index \n(thus modifying the array contents): \n\n\nContents | 43 \n\n\n\n\n\nvar myArray = [ \"foo\", 42, \"bar\" ]; \n\n\nnyArray[ \"3 1 ' ] = \"baz\"; \nmyArray.length; // 4 \nmyArray [3]; // \"baz\" \n\nDuplicating Objects","metadata":{"loc":{"lines":{"from":18207,"to":18238}}}}],["406",{"pageContent":"Contents | 43 \n\n\n\n\n\nvar myArray = [ \"foo\", 42, \"bar\" ]; \n\n\nnyArray[ \"3 1 ' ] = \"baz\"; \nmyArray.length; // 4 \nmyArray [3]; // \"baz\" \n\nDuplicating Objects \n\nOne of the most commonly requested features when developers newly \ntake up the JavaScript language is how to duplicate an object. It would \nseem like there should just be a built-in copy() method, right? It turns \nout that it’s a little more complicated than that, because it’s not fully \nclear what, by default, should be the algorithm for the duplication. \n\nFor example, consider this object: \n\nfunction anotherFunctlon( ) { /*..*/ } \n\nvar anotherObject = { \nc: true \n\n}; \n\n\nvar anotherArray = []; \n\nvar myObject = { \na: 2, \n\nb: anotherObject, // reference, not a copy! \nc: anotherArray, // another reference! \nd: anotherFunction \n\n}; \n\n\nanotherArray.push( anotherObject, myObject ); \n\nWhat exactly should be the representation of a copy of myObject?","metadata":{"loc":{"lines":{"from":18238,"to":18283}}}}],["407",{"pageContent":"}; \n\n\nanotherArray.push( anotherObject, myObject ); \n\nWhat exactly should be the representation of a copy of myObject? \n\nFirst, we should answer if it should be a shallow or deep copy? A shallow \ncopy would end up with a on the new object as a copy of the value 2, \nbut the b, c, and d properties as just references to the same places as \nthe references in the original object. A deep copy would duplicate not \nonly myObject, but anotherObject and anotherArray. But then we \nhave the issue that anotherArray has references to anotherObject \nand myObject in it, so those should also be duplicated rather than \nreference-preserved. Now we have an infinite circular duplication \nproblem because of the circular reference. \n\n\n44 | Chapter 3: Objects \n\n\n\n\n\nShould we detect a circular reference and just break the circular tra¬ \nversal (leaving the deep element not fully duplicated) ? Should we error \nout completely? Something in between?","metadata":{"loc":{"lines":{"from":18283,"to":18309}}}}],["408",{"pageContent":"Should we detect a circular reference and just break the circular tra¬ \nversal (leaving the deep element not fully duplicated) ? Should we error \nout completely? Something in between? \n\nMoreover, it’s not really clear what “duplicating” a function would \nmean. There are some hacks like pulling out the toString() seriali¬ \nzation of a functions source code (which varies across implementa¬ \ntions and is not even reliable in all engines depending on the type of \nfunction being inspected). \n\nSo how do we resolve all these tricky questions? Various JS frameworks \nhave each picked their own interpretations and made their own deci¬ \nsions. But which of these (if any) should JS adopt as the standard? For \na long time, there was no clear answer. \n\nOne subset solution is that objects that are JSON-safe (that is, can be \nserialized to a JSON string and then reparsed to an object with the \nsame structure and values) can easily be duplicated with:","metadata":{"loc":{"lines":{"from":18309,"to":18326}}}}],["409",{"pageContent":"var newObj = JSON.parse( JSON . stringlfy( someObj ) ); \n\nOf course, that requires you to ensure your object is JSON-safe. For \nsome situations, that’s trivial. For others, it’s insufficient. \n\nAt the same time, a shallow copy is fairly understandable and has far \nfewerissues,so ES6hasnow defined Object.assign(..) forthistask. \nObject. assign (..) takes a target object as its first parameter, and one \nor more source objects as its subsequent parameters. It iterates over all \nthe enumerable (see the following code), owned keys (immediately \npresent) on the source object(s) and copies them (via = assignment \nonly) to the target. It also, helpfully, returns the target, as you can see \nhere: \n\nvar newObj = Object. assign( {}, myObject ); \nnewObj .a; // 2 \n\nnewObj.b === anotherObject; // true \nnewObj.c === anotherArray; // true \nnewObj.d === anotherFunction; // true","metadata":{"loc":{"lines":{"from":18328,"to":18347}}}}],["410",{"pageContent":"var newObj = Object. assign( {}, myObject ); \nnewObj .a; // 2 \n\nnewObj.b === anotherObject; // true \nnewObj.c === anotherArray; // true \nnewObj.d === anotherFunction; // true \n\n\n\nIn the next section, we describe “property descriptors” (prop¬ \nerty characteristics) and show the use of Object.defineProp \nerty(..). The duplication that occurs for Object.as \nsign( ..), however, is purely = style assignment, so any spe¬ \ncial characteristics of a property (like writable) on a source \nobject are not preserved on the target object. \n\n\nContents | 45 \n\n\n\n\n\nProperty Descriptors \n\nPrior to ES5, the JavaScript language gave no direct way for your code \nto inspect or draw any distinction between the characteristics of prop¬ \nerties, such as whether the property was read-only or not. \n\nBut as of ES5, all properties are described in terms of a property de¬ \nscriptor. \n\nConsider this code: \n\nvar myObject = { \na: 2 \n\n}; \n\n\nObject. getOwnPropertyDescriptor( myObject, \"a\" ); \n\n// { \n\n// value: 2,","metadata":{"loc":{"lines":{"from":18347,"to":18391}}}}],["411",{"pageContent":"Consider this code: \n\nvar myObject = { \na: 2 \n\n}; \n\n\nObject. getOwnPropertyDescriptor( myObject, \"a\" ); \n\n// { \n\n// value: 2, \n\n// writable: true, \n\n// enumerable: true, \n\n// configurable: true \n\n// } \n\nAs you can see, the property descriptor (called a “data descriptor” since \nit’s only for holding a data value) for our normal object property a is \nmuch more than just its value of 2. It includes three other character¬ \nistics: writable, enumerable,and configurable. \n\nWhile we can see what the default values for the property descriptor \ncharacteristics are when we create a normal property, we can use Ob \nject.defineProperty(..) to add a new property, or modify an ex¬ \nisting one (if it’s configurable!), with the desired characteristics. \n\nFor example: \n\nvar myObject = {}; \n\nObject. deftneProperty( myObject, \"a\", { \nvalue: 2, \nwritable: true, \nconfigurable: true, \nenumerable: true \n\n} ); \n\nmyObject. a; // 2","metadata":{"loc":{"lines":{"from":18391,"to":18435}}}}],["412",{"pageContent":"For example: \n\nvar myObject = {}; \n\nObject. deftneProperty( myObject, \"a\", { \nvalue: 2, \nwritable: true, \nconfigurable: true, \nenumerable: true \n\n} ); \n\nmyObject. a; // 2 \n\nUsing defineProperty(..), we added the plain, normal a property \nto myObject in a manually explicit way. However, you generally \n\n\n46 | Chapter 3: Objects \n\n\n\n\nwouldn’t use this manual approach unless you wanted to modify one \nof the descriptor characteristics from its normal behavior. \n\nWritable \n\nThe ability for you to change the value of a property is controlled by \nwritable. \n\nConsider: \n\nvar myObject = {}; \n\nObject. deftneProperty( myObject, \"a\", { \nvalue: 2, \n\nwritable: false, // not writable! \nconfigurable: true, \nenumerable: true \n\n} ); \n\nmyObject.a = 3; \nmyObject. a; // 2 \n\nAs you can see, our modification of the value silently failed. If we try \nin strict mode, we get an error: \n\n\"use strict\"; \nvar myObject = {}; \n\nObject. defineProperty( myObject, \"a\", { \nvalue: 2,","metadata":{"loc":{"lines":{"from":18435,"to":18489}}}}],["413",{"pageContent":"As you can see, our modification of the value silently failed. If we try \nin strict mode, we get an error: \n\n\"use strict\"; \nvar myObject = {}; \n\nObject. defineProperty( myObject, \"a\", { \nvalue: 2, \n\nwritable: false, // not writable! \nconfigurable: true, \nenumerable: true \n\n} ); \n\nmyObject.a = 3; // Type Error \n\nThe Type Error tells us we cannot change a nonwritable property. \n\n\n\nWe will discuss getters/setters shortly, but briefly, you can ob¬ \nserve that writable: false means a value cannot be changed, \nwhich is somewhat equivalent to if you defined a no-op set¬ \nter. Actually, your no-op setter would need to throw a TypeEr \nror when called to be truly conformant to writable: false. \n\n\nContents | 47 \n\n\n\n\n\nConfigurable \n\nAs long as a property is currently configurable, we can modify its de¬ \nscriptor definition, using the same defineProperty(..) utility: \n\nvar myObject = { \na: 2 \n\n}; \n\n\nmyObject.a = 3; \nmyObject. a; // 3","metadata":{"loc":{"lines":{"from":18489,"to":18535}}}}],["414",{"pageContent":"var myObject = { \na: 2 \n\n}; \n\n\nmyObject.a = 3; \nmyObject. a; // 3 \n\nObject. deftneProperty( myObject, \"a\", { \nvalue: 4, \nwritable: true, \n\nconfigurable: false, // not configurable! \nenumerable: true \n\n} ); \n\nmyObject. a; // 4 \nmyObject.a = 5; \nmyObject. a; // 5 \n\nObject. defineProperty( myObject, \"a\", { \nvalue: 6, \nwritable: true, \nconfigurable: true, \nenumerable: true \n})',// TypeError \n\nThe final defineProperty(..) call results in a TypeError, regardless \nof strict mode, if you attempt to change the descriptor definition of \na nonconfigurable property. Be careful: as you can see, changing con \nfigurable to false is a one-way action, and cannot be undone! \n\n\n\nThere’s a nuanced exception to be aware of: even if the prop¬ \nerty is already configurable:false, writable can always be \nchanged from true to false without error, but not back to \ntrue if already false. \n\n\nAnother thing configurable: false prevents is the ability to use the \ndelete operator to remove an existing property:","metadata":{"loc":{"lines":{"from":18535,"to":18578}}}}],["415",{"pageContent":"Another thing configurable: false prevents is the ability to use the \ndelete operator to remove an existing property: \n\nvar myObject = { \na: 2 \n\n}; \n\n\nmyObject. a; // 2 \n\n\n48 | Chapter 3: Objects \n\n\n\n\n\ndelete myObject.a; \nmyObject.a; // undefined \n\nObject. defineProperty( myObject, \"a\", { \nvalue: 2, \nwritable: true, \nconfigurable: false, \nenumerable: true \n\n} ); \n\nmyObject.a; // 2 \ndelete myObject.a; \nmyObject.a; // 2 \n\nAs you can see, the last delete call failed (silently) because we made \nthe a property nonconfigurable.","metadata":{"loc":{"lines":{"from":18578,"to":18612}}}}],["416",{"pageContent":"} ); \n\nmyObject.a; // 2 \ndelete myObject.a; \nmyObject.a; // 2 \n\nAs you can see, the last delete call failed (silently) because we made \nthe a property nonconfigurable. \n\ndelete is only used to remove object properties (which can be re¬ \nmoved) directly from the object in question. If an object property is \nthe last remaining reference to some object/function, and you de \nlete it, that removes the reference and now that unreferenced object/ \nfunction can be garbage-collected. But, it is not proper to think of \ndelete as a tool to free up allocated memory as it does in other lan¬ \nguages (like C/C++), delete is just an object property removal oper¬ \nation—nothing more. \n\nEnumerable \n\nThe final descriptor characteristic we will mention here (there are two \nothers, which we deal with shortly when we discuss getter/setters) is \nenumerable.","metadata":{"loc":{"lines":{"from":18612,"to":18634}}}}],["417",{"pageContent":"Enumerable \n\nThe final descriptor characteristic we will mention here (there are two \nothers, which we deal with shortly when we discuss getter/setters) is \nenumerable. \n\nThe name probably makes it obvious, but this characteristic controls \nwhether a property will show up in certain object-property enumer¬ \nations, such as the for. .in loop. Set enumerable to false to keep the \nproperty from showing up in such enumerations, even though it’s still \ncompletely accessible. Set it to true to include the property in \nenumerations. \n\nAll normal user-defined properties are defaulted to enumerable, as \nthis is most commonly what you want. But if you have a special prop¬ \nerty you want to hide from enumeration, set it to enumerable: false. \n\nWe’ll demonstrate enumerability in much more detail shortly, so keep \na mental bookmark on this topic. \n\n\nContents | 49 \n\n\n\n\nImmutability","metadata":{"loc":{"lines":{"from":18634,"to":18660}}}}],["418",{"pageContent":"We’ll demonstrate enumerability in much more detail shortly, so keep \na mental bookmark on this topic. \n\n\nContents | 49 \n\n\n\n\nImmutability \n\nSometimes you want to make properties or objects that cannot be \nchanged (either by accident or intentionally). ES5 adds support for \nhandling that in a variety of different nuanced ways. \n\nIt’s important to note that all of these approaches create shallow im¬ \nmutability. That is, they affect only the object and its direct property \ncharacteristics. If an object has a reference to another object (array, \nobject, function, etc.), the contents of that object are not affected and \nremain mutable: \n\nmylmmutableObject.foo; // [1,2,3] \nmylmmutableObject.foo.push( 4 ); \nmylmmutableObject.foo; // [1,2,3,4]","metadata":{"loc":{"lines":{"from":18660,"to":18683}}}}],["419",{"pageContent":"mylmmutableObject.foo; // [1,2,3] \nmylmmutableObject.foo.push( 4 ); \nmylmmutableObject.foo; // [1,2,3,4] \n\nWe assume in this snippet that mylmmutableOb ject is already created \nand protected as immutable. But, to also protect the contents of my I m \nmutableObject.foo (which is its own object—an array), you would \nalso need to make f oo immutable, using one or more of the following \nfunctionalities. \n\n\n\nIt is not terribly common to create deeply entrenched immut¬ \nable objects in JS programs. Special cases can certainly call for \nit, but as a general design pattern, if you find yourself want¬ \ning to seal or freeze all your objects, you may want to take a \nstep back and reconsider your program design to be more \nrobust to potential changes in objects’ values. \n\n\nObject constant \n\nBy combining writable:false and configurable:false, you can \nessentially create a constant (cannot be changed, redefined, or deleted) \nas an object property, like: \n\nvar myObject = {};","metadata":{"loc":{"lines":{"from":18683,"to":18709}}}}],["420",{"pageContent":"By combining writable:false and configurable:false, you can \nessentially create a constant (cannot be changed, redefined, or deleted) \nas an object property, like: \n\nvar myObject = {}; \n\nObject. deftneProperty( myObject, \"FAVORITE_NUMBER\" , { \nvalue: 42, \nwritable: false, \nconfigurable: false \n\n} ); \n\n\n50 | Chapter 3: Objects \n\n\n\n\nPrevent extensions \n\n\nIf you want to prevent an object from having new properties added to \nit, but otherwise leave the rest of the object’s properties alone, call \nObject.preventExtensions(..): \n\nvar myObject = { \na: 2 \n\n}; \n\n\nObject. preventExtensions( myObject ); \n\nmyObject.b = 3; \nmyObject. b; // undefined \n\nIn non-strict node, the creation of b fails silently. In strict node, \nit throws a TypeError. \n\nSeal \n\nObject. seal(..) creates a “sealed” object, which means it takes an \nexisting object and essentially calls Object. preventExtensions(..) \non it, but also marks all its existing properties as configurable: false.","metadata":{"loc":{"lines":{"from":18709,"to":18753}}}}],["421",{"pageContent":"So, not only can you not add any more properties, but you also cannot \nreconfigure or delete any existing properties (though you can still \nmodify their values). \n\nFreeze \n\nObject. freeze(..) creates a frozen object, which means it takes an \nexisting object and essentially calls Object. seal(..) on it, but it also \nmarks all “data accessor” properties as writable: false, so that their \nvalues cannot be changed. \n\nThis approach is the highest level of immutability that you can attain \nfor an object itself, as it prevents any changes to the object or to any \nof its direct properties (though, as mentioned earlier, the contents of \nany referenced other objects are unaffected).","metadata":{"loc":{"lines":{"from":18755,"to":18769}}}}],["422",{"pageContent":"You could “deep freeze” an object by calling Object.freeze(..) on \nthe object, and then recursively iterating over all objects it references \n(which would have been unaffected thus far), and calling Ob \nject. freeze(..) on them as well. Be careful, though, as that could \naffect other (shared) objects you’re not intending to affect. \n\n\nContents | 51 \n\n\n\n\n[[Get]] \n\nThere’s a subtle, but important, detail about how property accesses are \nperformed. Consider: \n\nvar myObject = { \na: 2 \n\n}; \n\n\nmyObject. a; // 2 \n\nThe myObject. a is a property access, but it doesn’t just look in myOb \nject for a property of the name a, as it might seem. \n\nAccording to the spec, the previous code actually performs a [ [Get] ] \noperation (kinda like a function call: [ [Get] ] ()) on the myObject. The \ndefault built-in [ [Get] ] operation for an object first inspects the object \nfor a property of the requested name, and if it finds it, it will return \nthe value accordingly.","metadata":{"loc":{"lines":{"from":18771,"to":18803}}}}],["423",{"pageContent":"However, the [ [Get] ] algorithm defines other important behavior if \nit does not find a property of the requested name. We will examine in \nChapter 5 what happens next (traversal of the [ [Prototype] ] chain, \nif any). \n\nBut one important result of this [ [Get] ] operation is that if it cannot \nthrough any means come up with a value for the requested property, \nit instead returns the value undefined: \n\nvar myObject = { \na: 2 \n\n}; \n\n\nmyObject. b; // undefined \n\nThis behavior is different from when you reference variables by their \nidentifier names. If you reference a variable that cannot be resolved \nwithin the applicable lexical scope lookup, the result is not unde \nfined as it is for object properties, but instead a ReferenceError is \nthrown: \n\nvar myObject = { \na: undefined \n\n}; \n\n\nmyObject. a; // undefined \nmyObject. b; // undefined \n\n\n52 | Chapter 3: Objects","metadata":{"loc":{"lines":{"from":18805,"to":18838}}}}],["424",{"pageContent":"var myObject = { \na: undefined \n\n}; \n\n\nmyObject. a; // undefined \nmyObject. b; // undefined \n\n\n52 | Chapter 3: Objects \n\n\n\n\nFrom a value perspective, there is no difference between these two \nreferences—they both result in undefined. However, the [[Get]] op¬ \neration underneath, though subtle at a glance, potentially performed \na bit more “work” for the reference myOb ject. b than for the reference \nnyObject.a. \n\nInspecting only the value results, you cannot distinguish whether a \nproperty exists and holds the explicit value undefined, or whether the \nproperty does not exist and undefined was the default return value \nafter [ [Get] ] failed to return something explicitly. However, we will \nsee shortly how you can distinguish these two scenarios. \n\n[[Put]] \n\nSince there’s an internally defined [ [ Get ] ] operation for getting a val¬ \nue from a property, it should be obvious there’s also a default [ [Put] ] \noperation.","metadata":{"loc":{"lines":{"from":18838,"to":18869}}}}],["425",{"pageContent":"[[Put]] \n\nSince there’s an internally defined [ [ Get ] ] operation for getting a val¬ \nue from a property, it should be obvious there’s also a default [ [Put] ] \noperation. \n\nIt may be tempting to think that an assignment to a property on an \nobject would just invoke [ [ Put ] ] to set or create that property on the \nobject in question. But the situation is more nuanced than that. \n\nWhen invoking [ [Put] ], how it behaves differs based on a number of \nfactors, including (most impactfully) whether the property is already \npresent on the object or not. \n\nIf the property is present, the [ [Put] ] algorithm will roughly check: \n\n1. Is the property an accessor descriptor (see “Getters and Setters” \non page 54)? If so, call the setter, if any. \n\n2. Is the property a data descriptor with writable of false? If so, \nsilently fail in non-strict node, or throw TypeError in strict \nnode. \n\n3. Otherwise, set the value to the existing property as normal.","metadata":{"loc":{"lines":{"from":18869,"to":18892}}}}],["426",{"pageContent":"3. Otherwise, set the value to the existing property as normal. \n\nIf the property is not yet present on the object in question, the [[Put]] \noperation is even more nuanced and complex. We will revisit this sce¬ \nnario in Chapter 5 when we discuss [ [Prototype] ] to give it more \nclarity. \n\n\nContents | 53 \n\n\n\n\nGetters and Setters \n\nThe default [[Put]] and [[Get]] operations for objects completely \ncontrol how values are set to existing or new properties, or retrieved \nfrom existing properties, respectively. \n\n\n\nUsing future/advanced capabilities of the language, it may be \npossible to override the default [[Get]] or [[Put]] opera¬ \ntions for an entire object (not just per property). This is be¬ \nyond the scope of our discussion in this book, but may be \ncovered later in the You Don’t Know JS series.","metadata":{"loc":{"lines":{"from":18892,"to":18917}}}}],["427",{"pageContent":"ES5 introduced a way to override part of these default operations, not \non an object level but a per-property level, through the use of getters \nand setters. Getters are properties that actually call a hidden function \nto retrieve a value. Setters are properties that actually call a hidden \nfunction to set a value. \n\nWhen you define a property to have either a getter or a setter or both, \nits definition becomes an “accessor descriptor” (as opposed to a “data \ndescriptor”). For accessor desciptors, the value and writable char¬ \nacteristics of the descriptor are moot and ignored, and instead JS con¬ \nsiders the set and get characteristics of the property (as well as con \nfigurable and enumerable). \n\nConsider: \n\nvar myObject = { \n\n// define a getter for 'a' \nget a() { \n\nreturn 2; \n\n} \n\n}; \n\n\nObject .defineProperty( \nmyObject, // target \n\n\"b\", // property none \n\n{ // descriptor \n\n// define a getter for 'b' \n\nget: function(){ return this. a * 2 },","metadata":{"loc":{"lines":{"from":18920,"to":18956}}}}],["428",{"pageContent":"return 2; \n\n} \n\n}; \n\n\nObject .defineProperty( \nmyObject, // target \n\n\"b\", // property none \n\n{ // descriptor \n\n// define a getter for 'b' \n\nget: function(){ return this. a * 2 }, \n\n// make sure '£>' shows up as an object property \nenumerable: true \n\n} \n\n); \n\n\nmyObject. a; // 2 \n\n\n54 | Chapter 3: Objects \n\n\n\n\n\nmyObject.b; // 4 \n\nEither through object-literal syntax with get a() { .. } or through \nexplicit definition with defineProperty(. .), in both cases we created \na property on the object that actually doesn’t hold a value, but whose \naccess automatically results in a hidden function call to the getter \nfunction, with whatever value it returns being the result of the property \naccess: \n\nvar myObject = { \n\n// define a getter for 'a ' \nget a() { \n\nreturn 2 ; \n\n} \n\n}; \n\n\nnyObject.a = 3; \nmyObject. a; // 2","metadata":{"loc":{"lines":{"from":18956,"to":19013}}}}],["429",{"pageContent":"var myObject = { \n\n// define a getter for 'a ' \nget a() { \n\nreturn 2 ; \n\n} \n\n}; \n\n\nnyObject.a = 3; \nmyObject. a; // 2 \n\nSince we only defined a getter for a, if we try to set the value of a later, \nthe set operation won’t throw an error but will just silently throw the \nassignment away. Even if there was a valid setter, our custom getter is \nhardcoded to return only 2, so the set operation would be moot. \n\nTo make this scenario more sensible, properties should also be defined \nwith setters, which override the default [[Put]] operation (aka as¬ \nsignment), per-property, just as you’d expect. You will almost certainly \nwant to always declare both getter and setter (having only one or the \nother often leads to unexpected/surprising behavior): \n\nvar myObject = { \n\n// define a getter for 'a' \nget a() { \n\nreturn this._a_; \n\n}, \n\n\n// define a setter for 'a' \nset a(val) { \n\nthis._a_ = val * 2; \n\n} \n\n\nmyObject.a = 2; \nmyObject. a; // 4 \n\n\nContents | 55","metadata":{"loc":{"lines":{"from":19013,"to":19061}}}}],["430",{"pageContent":"// define a getter for 'a' \nget a() { \n\nreturn this._a_; \n\n}, \n\n\n// define a setter for 'a' \nset a(val) { \n\nthis._a_ = val * 2; \n\n} \n\n\nmyObject.a = 2; \nmyObject. a; // 4 \n\n\nContents | 55 \n\n\n\n\nIn this example, we actually store the specified value 2 of the \nassigment ([ [Put]] operation) into another variable _a_. The \n_a_ name is purely by convention for this example and im¬ \nplies nothing special about its behavior—it’s a normal proper¬ \nty like any other. \n\n\nExistence \n\nWe showed earlier that a property access like myOb ject. a may result \nin an undefined value if either the explicit undefined is stored there \nor the a property doesn’t exist at all. So, if the value is the same in both \ncases, how else do we distinguish them? \n\nWe can ask an object if it has a certain property without asking to get \nthat property’s value: \n\nvar myObject = { \na: 2 \n\n}; \n\n\n(\"a\" in myObject); // true \n(\"b\" in myObject); // false","metadata":{"loc":{"lines":{"from":19061,"to":19110}}}}],["431",{"pageContent":"We can ask an object if it has a certain property without asking to get \nthat property’s value: \n\nvar myObject = { \na: 2 \n\n}; \n\n\n(\"a\" in myObject); // true \n(\"b\" in myObject); // false \n\nmyObject.hasOwnProperty( \"a\" ); // true \nmyObject.hasOwnProperty! \"b\" ); // false \n\nThe in operator will check to see if the property is in the object, or if \nit exists at any higher level ofthe [ [Prototype] ] chain object traversal \n(see Chapter 5). By contrast, hasOwnProperty(.. ) checks to see if only \nmyObject has the property or not, and will not consult the [ [Proto \ntype] ] chain. We’ll come back to the important differences between \nthese two operations in Chapter 5 when we explore [ [Prototype] ]s \nin detail.","metadata":{"loc":{"lines":{"from":19110,"to":19131}}}}],["432",{"pageContent":"hasOwnProperty(.. ) is accessible for all normal objects via delegation \nto Object.prototype (see Chapter 5). But it’s possible to create an \nobject that does not link to Object, prototype (via Ob ject. ere \nate(nuil)— see Chapter 5). In this case, a method call like myOb \nject. hasOwnProperty (..) would fail. \n\nIn that scenario, a more robust way of performing such a check is \nObject.prototype.hasOwnProperty.call(myObject,\"a\" ), which \nborrows the base hasOwnProperty( ..) method and uses explicit bind¬ \ning (see Chapter 2) to apply it against our myObject. \n\n\n56 | Chapter 3: Objects \n\n\n\n\n\n\nIt appears that the in operator will check for the existence of a \nvalue inside a container, but it actually checks for the exis¬ \ntence of a property name. This difference is important to note \nwith respect to arrays, as the temptation to try a check like 4 \nin [2, 4, 6] is strong, but this will not behave as expected. \n\n\nEnumeration","metadata":{"loc":{"lines":{"from":19133,"to":19159}}}}],["433",{"pageContent":"Enumeration \n\nPreviously, we explained briefly the idea of “enumerability” when we \nlooked at the enumerable property descriptor characteristic. Let’s re¬ \nvisit that and examine it in closer detail: \n\nvar myObject = { }; \n\nObject .defineProperty( \nmyObject, \n\n\"a\", \n\n// nake 'a' enumerable, as normal \n{ enumerable: true, value: 2 } \n\n); \n\n\nObject .defineProperty( \nmyObject, \n\n\"b\", \n\n// make 'b' NON-enumerable \n{ enumerable: false, value: 3 } \n\n); \n\n\nmyObject.b; // 3 \n\n(\"b\" in myObject); // true \n\nmyObject.hasOwnProperty( \"b\" ); // true \n\n// . \n\nfor (var k in myObject) { \n\nconsole.log( k, myObject[k] ); \n\n} \n\n// \"a\" 2 \n\nYou’ll notice that myObject. b in fact exists and has an accessible value, \nbut it doesn’t show up in a for.. in loop (though, surprisingly it is \nrevealed by the in operator existence check). That’s because “enu¬ \nmerable” basically means “will be included if the object’s properties \nare iterated through.” \n\n\nContents | 57","metadata":{"loc":{"lines":{"from":19159,"to":19212}}}}],["434",{"pageContent":"Contents | 57 \n\n\n\n\n\n\n\nfor. .in loops applied to arrays can give somewhat unexpec¬ \nted results, in that the enumeration of an array will include not \nonly all the numeric indices, but also any enumerable proper¬ \nties. It’s a good idea to use for.. in loops only on objects, and \ntraditional for loops with numeric index iteration for arrays. \n\n\nConsider another way that enumerable and nonenumerable proper¬ \nties can be distinguished: \n\nvar myObject = { }; \n\nObject .defineProperty( \nmyObject, \n\n\"a\", \n\n// make 'a' enumerable, as normal \n{ enumerable: true, value: 2 } \n\n); \n\n\nObject .defineProperty( \nmyObject, \n\n\"b\", \n\n// make 'b' nonenumerable \n{ enumerable: false, value: 3 } \n\n); \n\n\nmyObject.propertyIsEnumerable( \"a\" ); // true \nmyObject.propertyIsEnumerable( \"b\" ); // false \n\nObject. keys( myObject ); // [\"a\"] \n\nObject.getOwnPropertyNames( myObject ); // [\"a\", \"b\"]","metadata":{"loc":{"lines":{"from":19212,"to":19259}}}}],["435",{"pageContent":"); \n\n\nmyObject.propertyIsEnumerable( \"a\" ); // true \nmyObject.propertyIsEnumerable( \"b\" ); // false \n\nObject. keys( myObject ); // [\"a\"] \n\nObject.getOwnPropertyNames( myObject ); // [\"a\", \"b\"] \n\npropertyIsEnumerable(.. ) tests whether the given property name \nexists directly on the object and is also enumerable: true. \n\nObject.keys(.. ) returns an array of all enumerable properties, \nwhereas Object.getOwnPropertyNames( ..) returns an array of all \nproperties, enumerable or not. \n\nWhereas in versus hasOwnProperty( ..) differ in whether they con¬ \nsult the [[Prototype]] chain or not, Object.keys(.. ) and Ob \nject.getOwnPropertyNames(. .) both inspect only the direct object \nspecified. \n\nThere’s (currently) no built-in way to get a list of all properties that is \nequivalent to what the in operator test would consult (traversing all \nproperties on the entire [ [Prototype] ] chain, as explained in Chap¬ \nter 5). You could approximate such a utility by recursively traversing","metadata":{"loc":{"lines":{"from":19259,"to":19284}}}}],["436",{"pageContent":"58 | Chapter 3: Objects \n\n\n\n\nthe [[Prototype]] chain of an object, and for each level, capturing \nthe list from Object. keys(..)—only enumerable properties. \n\nIteration \n\nThe f or.. in loop iterates over the list of enumerable properties on an \nobject (including its [ [Prototype] ] chain). But what if you instead \nwant to iterate over the values? \n\nWith numerically indexed arrays, iterating over the values is typically \ndone with a standard for loop, like: \n\nvar nyArray = [1, 2, 3]; \n\nfor (var i = 0; i < nyArray.length; i++) { \nconsole.log( nyArrayfi] ); \n\n} \n\n// 1 2 3 \n\nThis isn’t iterating over the values, though, but iterating over the \nindices, where you then use the index to reference the value, as myAr \nray[i],","metadata":{"loc":{"lines":{"from":19287,"to":19315}}}}],["437",{"pageContent":"} \n\n// 1 2 3 \n\nThis isn’t iterating over the values, though, but iterating over the \nindices, where you then use the index to reference the value, as myAr \nray[i], \n\nES5 also added several iteration helpers for arrays, including \nforEach(..), every(..), andsome(..). Each of these helpers accepts \na function callback to apply to each element in the array, differing only \nin how they respectively respond to a return value from the callback. \n\nfor Each (..) will iterate over all values in the array, and it ignores any \ncallback return values. every(..) keeps going until the end or the \ncallback returns a false (or “falsy”) value, whereas some(..) keeps \ngoing until the end or the callback returns a true (or “truthy”) value. \n\nThese special return values inside every(..) and sorne(..) act some¬ \nwhat like a break statement inside a normal for loop, in that they stop \nthe iteration early before it reaches the end.","metadata":{"loc":{"lines":{"from":19315,"to":19335}}}}],["438",{"pageContent":"These special return values inside every(..) and sorne(..) act some¬ \nwhat like a break statement inside a normal for loop, in that they stop \nthe iteration early before it reaches the end. \n\nIf you iterate on an object with a for.. In loop, you’re also only getting \nat the values indirectly, because it’s actually iterating only over the \nenumerable properties of the object, leaving you to access the prop¬ \nerties manually to get the values. \n\n\nIteration | 59 \n\n\n\n\n\nAs contrasted with iterating over an array’s indices in a nu¬ \nmerically ordered way (for loop or other iterators), the order \nof iteration over an object’s properties is not guaranteed and \nmay vary between different JS engines. Do not rely on any \nobserved ordering for anything that requires consistency \namong environments, as any observed agreement is unreliable.","metadata":{"loc":{"lines":{"from":19335,"to":19356}}}}],["439",{"pageContent":"But what if you want to iterate over the values directly instead of the \narray indicies (or object properties)? Helpfully, ES6 adds a for. .of \nloop syntax for iterating over arrays (and objects, if the object defines \nits own custom iterator): \n\nvar myArray = [ 1, 2, 3 ]; \n\nfor (var v of myArray) { \nconsole.log( v ); \n\n} \n\n// 1 \n// 2 \n// 2 \n\nThe for.. of loop asks for an iterator object (from a default internal \nfunction known as @@iterator in spec-speak) of the thing to be iter¬ \nated, and the loop then iterates over the successive return values from \ncalling that iterator object’s nextQ method, once for each loop \niteration. \n\nArrays have a built-in @@iterator, so for.. of works easily on them, \nas shown. But let’s manually iterate the array using the built-in @@iter \na tor, to see how it works: \n\nvar myArray = [ 1, 2, 3 ]; \n\nvar it = myArray[Symbol.iterator](); \n\nIt.nextQ; // { value:l, done:false } \ntt.nextQ; // { value:2, done:false } \n\nIt. nextQ; // { value:3, done:false }","metadata":{"loc":{"lines":{"from":19359,"to":19392}}}}],["440",{"pageContent":"var myArray = [ 1, 2, 3 ]; \n\nvar it = myArray[Symbol.iterator](); \n\nIt.nextQ; // { value:l, done:false } \ntt.nextQ; // { value:2, done:false } \n\nIt. nextQ; // { value:3, done:false } \n\nIt. nextQ; // { done: true } \n\n\n60 | Chapter 3: Objects \n\n\n\n\n\nWe get at the @@iterator internal property of an object using \nan ES6 Symbol: Symbol.iterator. We briefly mentioned Sym \nbol semantics earlier in the chapter (see “Computed Property \nNames” on page 40), so the same reasoning applies here. You’ll \nalways want to reference such special properties by Symbol \nname reference instead of by the special value it may hold. Also, \ndespite the name’s implications, @@tterator is not the itera¬ \ntor object itself, but a function that returns the iterator object \n—a subtle but important detail!","metadata":{"loc":{"lines":{"from":19392,"to":19418}}}}],["441",{"pageContent":"As the previous snippet reveals, the return value from an iterators \nnext () call is an object of the form { value: .. , done: .. }, where \nvalue is the current iteration value, and done is a boolean that indi¬ \ncates whether there’s more to iterate. \n\nNotice the value 3 was returned with a done:false, which seems \nstrange at first glance. You have to call the next () a fourth time (which \nthe for. .of loop in the previous snippet automatically does) to get \ndone: true and know you’re truly done iterating. The reason for this \nquirk is beyond the scope of what we’ll discuss here, but it comes from \nthe semantics of ES6 generator functions. \n\nWhile arrays do automatically iterate in for.. of loops, regular objects \ndo not have a built-in @@iterator. The reasons for this intentional \nomission are more complex than we will examine here, but in general, \nit was better to not include some implementation that could prove \ntroublesome for future types of objects.","metadata":{"loc":{"lines":{"from":19421,"to":19437}}}}],["442",{"pageContent":"It is possible to define your own default @@iterator for any object that \nyou care to iterate over. For example: \n\nvar myObject = { \na: 2, \nb: 3 \n\n}; \n\n\nObject. deflneProperty( myObject, Symbol.iterator, { \nenumerable: false, \nwritable: false, \nconfigurable: true, \nvalue: function() { \nvar o = this; \nvar idx = 0; \n\nvar ks = Object. keys( o ); \n\nreturn { \n\nnext: function() { \n\n\nIteration | 61 \n\n\n\n\n\nreturn { \n\nvalue: o[ks[ldx++]] , \ndone: (Idx > ks. length) \n\n}; \n\n} \n\n}; \n\n} \n\n} ); \n\n// iterate 'nyObject' manually \nvar it = myObject[Symbol.lterator](); \nIt.nextQ; // { value:2, done:false } \nlt.next(); // { value:3, done:false } \nIt.nextQ; // { value undefined, done .-true } \n\n// iterate 'nyObject' with 'for..of' \nfor (var v of nyObject) { \nconsole.log( v ); \n\n} \n\n// 2 \n\n// 3","metadata":{"loc":{"lines":{"from":19439,"to":19499}}}}],["443",{"pageContent":"// iterate 'nyObject' with 'for..of' \nfor (var v of nyObject) { \nconsole.log( v ); \n\n} \n\n// 2 \n\n// 3 \n\n\n\nWe used Object.deflneProperty( ..) to define our custom \n@@iterator (mostly so we could make it nonenumerable), but \nusing the Symbol as a computed property name (covered earli¬ \ner in this chapter), we could have declared it directly, like var \nmyObject = { a:2, b:3, [Symbol.iterator]: functionQ \n{/*..*/}}• \n\n\nEach time the for.. of loop calls next( ) on myOb ject’s iterator object, \nthe internal pointer will advance and return back the next value from \nthe object’s properties list (see the note earlier in this section about \niteration ordering on object properties/values).","metadata":{"loc":{"lines":{"from":19499,"to":19522}}}}],["444",{"pageContent":"The iteration we just demonstrated is a simple value-by-value itera¬ \ntion, but you can of course define arbitrarily complex iterations for \nyour custom data structures, as you see fit. Custom iterators combined \nwith ES6’s f or.. of loop are a powerful new syntactic tool for manip¬ \nulating user-defined objects. \n\nFor example, a list of Pixel objects (with x and y coordinate values) \ncould decide to order its iteration based on the linear distance from \nthe (0,0) origin, or filter out points that are “too far away,” etc. As long \nas your iterator returns the expected { value: .. } return values \nfrom next() calls, and a { done: true } after the iteration is com¬ \nplete, ES6’s for.. of can iterate over it. \n\n\n62 | Chapter 3: Objects","metadata":{"loc":{"lines":{"from":19524,"to":19538}}}}],["445",{"pageContent":"62 | Chapter 3: Objects \n\n\n\n\nIn fact, you can even define “infinite” iterators that never “finish” and \nalways return a new value (such as a random number, an incremented \nvalue, a unique identifier, etc.), though you probably will not use such \niterators with an unbounded f or.. of loop, as it would never end and \nwould hang your program: \n\nvar randoms = { \n\n[Symbol.iterator]: functionQ { \nreturn { \n\nnext: functionQ { \n\nreturn { value: Math. random( ) }; \n\n} \n\n}; \n\n} \n\n}; \n\nvar randoms_pool = []; \nfor (var n of randoms) { \nrandoms_pool.push( n ); \n\n// don't proceed unbounded! \nif (randoms_pool.length === 100) break; \n\n} \n\nThis iterator will generate random numbers “forever,” so we’re careful \nto only pull out 100 values so our program doesn’t hang. \n\nReview","metadata":{"loc":{"lines":{"from":19538,"to":19578}}}}],["446",{"pageContent":"} \n\nThis iterator will generate random numbers “forever,” so we’re careful \nto only pull out 100 values so our program doesn’t hang. \n\nReview \n\nObjects in JS have both a literal form (such as var a = { .. }) and \na constructed form (such as var a = new Array(.. )). The literal form \nis almost always preferred, but the constructed form offers, in some \ncases, more creation options. \n\nMany people mistakenly claim “everything in JavaScript is an object,” \nbut this is incorrect. Objects are one of the six (or seven, depending \non your perspective) primitive types. Objects have subtypes, including \nfunction, and also can be behavior-specialized, like [object Ar \nray] as the internal label representing the array object subtype.","metadata":{"loc":{"lines":{"from":19578,"to":19594}}}}],["447",{"pageContent":"Objects are collections of key/value pairs. The values can be accessed \nas properties, via the .propName or [\"propName\"] syntax. Whenever \na property is accessed, the engine actually invokes the internal default \n[ [Get] ] operation (and [ [ Put] ] for setting values), which not only \nlooks for the property directly on the object, but will traverse the \n[ [Prototype] ] chain (see Chapter 5) if not found. \n\n\nReview | 63 \n\n\n\nProperties have certain characteristics that can be controlled through \nproperty descriptors, such as writable and configurable. In addi¬ \ntion, objects can have their mutability (and that of their properties) \ncontrolled to various levels of immutability using Object. preventEx \ntensions(..),Object.seal( ..),and Object.freeze(..).","metadata":{"loc":{"lines":{"from":19596,"to":19612}}}}],["448",{"pageContent":"Properties don’t have to contain values—they can be “accessor prop¬ \nerties” as well, with getters/setters. They can also be either enumera¬ \nble or not, which controls whether they show up in for.. in loop iter¬ \nations, for instance. \n\nYou can also iterate over the values in data structures (arrays, objects, \netc.) using the ES6 for. .of syntax, which looks for either a built-in \nor custom @@iterator object consisting of a next() method to ad¬ \nvance through the data values one at a time. \n\n\n64 | Chapter 3: Objects \n\n\n\nCHAPTER 4 \n\n\nMixing (Up) \"Class\" Objects \n\n\nFollowing our exploration of objects from the previous chapter, it’s \nnatural that we now turn our attention to object-oriented (OO) pro¬ \ngramming, with classes. We’ll first look at class orientation as a design \npattern, before examining the mechanics of classes: instantiation, in¬ \nheritance, and (relative) polymorphism.","metadata":{"loc":{"lines":{"from":19614,"to":19639}}}}],["449",{"pageContent":"We’ll see that these concepts don’t really map very naturally to the \nobject mechanism in JS, and the efforts (mixins, etc.) many JavaScript \ndevelopers expend to overcome such challenges. \n\n\n\nThis chapter spends quite a bit of time (the first half!) on heavy \nobject-oriented programming theory. We eventually relate \nthese ideas to real concrete JavaScript code in the second half, \nwhen we talk about mixins. But there’s a lot of concept and \npseudocode to wade through first, so don’t get lost—just stick \nwith it! \n\n\nClass Theory \n\nClass/inheritance describes a certain form of code organization and \narchitecture—a way of modeling real world problem domains in our \nsoftware.","metadata":{"loc":{"lines":{"from":19641,"to":19659}}}}],["450",{"pageContent":"Class Theory \n\nClass/inheritance describes a certain form of code organization and \narchitecture—a way of modeling real world problem domains in our \nsoftware. \n\nOO or class-oriented programming stresses that data intrinsically has \nassociated behavior (of course, different depending on the type and \nnature of the data!) that operates on it, so proper design is to package \nup (aka encapsulate) the data and the behavior together. This is some¬ \ntimes called data structures in formal computer science. \n\n\n65 \n\n\n\n\n\nFor example, a series of characters that represents a word or phrase is \nusually called a string. The characters are the data. But you almost \nnever just care about the data, you usually want to do things with the \ndata, so the behaviors that can apply to that data (calculating its length, \nappending data, searching, etc.) are all designed as methods of a \nString class.","metadata":{"loc":{"lines":{"from":19659,"to":19683}}}}],["451",{"pageContent":"Any given string is just an instance of this class, which means that it’s \na neatly collected packaging of both the character data and the func¬ \ntionality we can perform on it. \n\nClasses also imply a way of classifying a certain data structure. The way \nwe do this is to think about any given structure as a specific variation \nof a more general base definition. \n\nLet’s explore this classification process by looking at a commonly cited \nexample. A car can be described as a specific implementation of a more \ngeneral “class” of thing, called a vehicle. \n\nWe model this relationship in software with classes by defining a \nVehicle class and a Car class. \n\nThe definition of Vehicle might include things like propulsion (en¬ \ngines, etc.), the ability to carry people, etc., which would all be the \nbehaviors. What we define in Vehicle is all the stuff that is common \nto all (or most of) the different types of vehicles (the “planes, trains, \nand automobiles”).","metadata":{"loc":{"lines":{"from":19685,"to":19704}}}}],["452",{"pageContent":"It might not make sense in our software to redefine the basic essence \nof “ability to carry people” over and over again for each different type \nof vehicle. Instead, we define that capability once in Vehicle, and then \nwhen we define Car, we simply indicate that it inherits (or extends) the \nbase definition from Vehicle. The definition of Ca r is said to specialize \nthe general Vehicle definition. \n\nWhile Vehicle and Car collectively define the behavior by way of \nmethods, the data in an instance would be things like the unique VIN \nof a specific car, etc. \n\nAnd thus, classes, inheritance, and instantiation emerge. \n\nAnother key concept with classes is polymorphism, which describes \nthe idea that a general behavior from a parent class can be overridden \nin a child class to give it more specifics. In fact, relative polymorphism \nlets us reference the base behavior from the overridden behavior. \n\n\n66 | Chapter 4: Mixing (Up) \"Class\" Objects","metadata":{"loc":{"lines":{"from":19706,"to":19725}}}}],["453",{"pageContent":"66 | Chapter 4: Mixing (Up) \"Class\" Objects \n\n\n\nClass theory strongly suggests that a parent class and a child class share \nthe same method name for a certain behavior, so that the child over¬ \nrides the parent (differentially). As we’ll see later, doing so in your \nJavaScript code is opting into frustration and code brittleness. \n\n\"Class\" Design Pattern \n\nYou may never have thought about classes as a design pattern, since \nit’s most common to see discussion of popular OO design patterns, \nlike Iterator, Observer, Factory, Singleton, etc. As presented this way, \nit’s almost an assumption that OO classes are the lower-level mechan¬ \nics by which we implement all (higher-level) design patterns, as if OO \nis a given foundation for all (proper) code.","metadata":{"loc":{"lines":{"from":19725,"to":19741}}}}],["454",{"pageContent":"Depending on your level of formal education in programming, you \nmay have heard of procedural programming as away of describing code \nthat only consists of procedures (aka functions) calling other func¬ \ntions, without any higher abstractions. You may have been taught that \nclasses were the proper way to transform procedural-style “spaghetti \ncode” into well-formed, well-organized code. \n\nOf course, if you have experience with functional programming (Mo¬ \nnads, etc.), you know very well that classes are just one of several \ncommon design patterns. But for others, this may be the first time \nyou’ve asked yourself if classes really are a fundamental foundation for \ncode, or if they are an optional abstraction on top of code.","metadata":{"loc":{"lines":{"from":19743,"to":19754}}}}],["455",{"pageContent":"Some languages (like Java) don’t give you the choice, so it’s not very \noptional at all—everything’s a class. Other languages like C/C++ or \nPHP give you both procedural and class-oriented syntaxes, and it’s left \nmore to the developer’s choice which style or mixture of styles is \nappropriate. \n\nJavaScript \"Classes\" \n\nWhere does JavaScript fall in this regard? JS has had some class-like \nsyntactic elements (like new and instanceof) for quite a while, and \nmore recently in ES6, some additions, like the class keyword (see \nAppendix A). \n\nBut does that mean JavaScript actually has classes? Plain and simple: \n\nNO. \n\n\nClass Theory | 67 \n\n\n\n\nSince classes are a design pattern, you can, with quite a bit of effort (as \nwe’ll see throughout the rest of this chapter), implement approxima¬ \ntions for much of classical class functionality. JS tries to satisfy the \nextremely pervasive desire to design with classes by providing seem¬ \ningly class-like syntax.","metadata":{"loc":{"lines":{"from":19756,"to":19783}}}}],["456",{"pageContent":"While we may have a syntax that looks like classes, it’s as if JavaScript \nmechanics are fighting against you using the class design pattern, be¬ \ncause behind the curtain, the mechanisms that you build on are op¬ \nerating quite differently. Syntactic sugar and (extremely widely used) \nJS “class” libraries go a long way toward hiding this reality from you, \nbut sooner or later you will face the fact that the classes you have in \nother languages are not like the “classes” you’re faking in JS. \n\nWhat this boils down to is that classes are an optional pattern in soft¬ \nware design, and you have the choice to use them in JavaScript or not. \nSince many developers have a strong affinity to class-oriented software \ndesign, we’ll spend the rest of this chapter exploring what it takes to \nmaintain the illusion of classes with what JS provides, and the pain \npoints we experience. \n\nClass Mechanics","metadata":{"loc":{"lines":{"from":19785,"to":19800}}}}],["457",{"pageContent":"Class Mechanics \n\nIn many class-oriented languages, the “standard library” provides a \n“stack” data structure (push, pop, etc.) as a Stack class. This class \nwould have an internal set of variables that stores the data, and it would \nhave a set of publicly accessible behaviors (“methods”) provided by \nthe class, which gives your code the ability to interact with the (hidden) \ndata (adding and removing data, etc.). \n\nBut in such languages, you don’t really operate directly on Stack (un¬ \nless making a static class member reference, which is outside the scope \nof our discussion). The Stack class is merely an abstract explanation \nof what any “stack” should do, but it’s not itself a “stack.” You must \ninstantiate the Stack class before you have a concrete data structure \nthing to operate against. \n\nBuilding \n\nThe traditional metaphor for “class”- and “instance”-based thinking \ncomes from building construction. \n\n\n68 | Chapter 4: Mixing (Up) \"Class\" Objects","metadata":{"loc":{"lines":{"from":19800,"to":19822}}}}],["458",{"pageContent":"Building \n\nThe traditional metaphor for “class”- and “instance”-based thinking \ncomes from building construction. \n\n\n68 | Chapter 4: Mixing (Up) \"Class\" Objects \n\n\n\n\n\nAn architect plans out all the characteristics of a building: how wide, \nhow tall, how many windows and in what locations, even what type of \nmaterial to use for the walls and roof. She doesn’t necessarily care, at \nthis point, where the building will be built, nor does she care how \nmany copies of that building will be built. \n\nThe architect also doesn’t care very much about the contents of the \nbuilding—the furniture, wallpaper, ceiling fans, etc.—only what type \nof structure they will be contained by.","metadata":{"loc":{"lines":{"from":19822,"to":19842}}}}],["459",{"pageContent":"The architect also doesn’t care very much about the contents of the \nbuilding—the furniture, wallpaper, ceiling fans, etc.—only what type \nof structure they will be contained by. \n\nThe architectural blueprints are only plans for a building. They don’t \nactually constitute a building where we can walk in and sit down. We \nneed a builder for that task. A builder will take those plans and follow \nthem, exactly, as he builds the building. In a very real sense, he is \ncopying the intended characteristics from the plans to the physical \nbuilding. \n\nOnce complete, the building is a physical instantiation of the blueprint \nplans, hopefully an essentially perfect copy. And then the builder can \nmove to the open lot next door and do it all over again, creating yet \nanother copy.","metadata":{"loc":{"lines":{"from":19842,"to":19856}}}}],["460",{"pageContent":"The relationship between the building and blueprint is indirect. You \ncan examine a blueprint to understand how the building was struc¬ \ntured, for any parts where direct inspection of the building itself was \ninsufficient. But if you want to open a door, you have to go to the \nbuilding itself—the blueprint merely has lines drawn on a page that \nrepresent where the door should be. \n\nA class is a blueprint. To actually get an object we can interact with, \nwe must build (aka instantiate) something from the class. The end \nresult of such “construction” is an object, typically called an instance, \nwhich we can directly call methods on and access any public data \nproperties from, as necessary. \n\nThis object is a copy of all the characteristics described by the class.","metadata":{"loc":{"lines":{"from":19858,"to":19871}}}}],["461",{"pageContent":"This object is a copy of all the characteristics described by the class. \n\nYou likely wouldn’t expect to walk into a building and find, framed \nand hanging on the wall, a copy of the blueprints used to plan the \nbuilding, though the blueprints are probably on file with a public re¬ \ncords office. Similarly, you don’t generally use an object instance to \ndirectly access and manipulate its class, but it is usually possible to at \nleast determine which class an object instance comes from. \n\n\nClass Mechanics | 69 \n\n\n\n\nIt’s more useful to consider the direct relationship of a class to an object \ninstance, rather than any indirect relationship between an object in¬ \nstance and the class it came from. A class is instantiated into object \nform by a copy operation: \n\n\n\nAs you can see, the arrows move from left to right, and from top to \nbottom, which indicates the copy operations that occur, both concep¬ \ntually and physically. \n\nConstructor","metadata":{"loc":{"lines":{"from":19871,"to":19897}}}}],["462",{"pageContent":"As you can see, the arrows move from left to right, and from top to \nbottom, which indicates the copy operations that occur, both concep¬ \ntually and physically. \n\nConstructor \n\nInstances of classes are constructed by a special method of the class, \nusually of the same name as the class, called a constructor. This meth¬ \nod’s explicit job is to initialize any information (state) the instance will \nneed. \n\nFor example, consider this loose pseudocode (invented syntax) for \nclasses: \n\nclass CoolGuy { \n\nspecialTrick = nothing \n\nCoolGuy( trick ) { \n\nspecialTrick = trick \n\n} \n\nshowOffQ { \n\noutput( \"Here's my trick: \", specialTrick ) \n\n} \n\n} \n\nTo make a CoolGuy instance, we would call the class constructor: \n\n\n70 | Chapter 4: Mixing (Up) \"Class\" Objects \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nJoe = new CoolGuy( \"jumping rope\" ) \n\n\nJoe.showOff() // Here's my trick: jumping rope","metadata":{"loc":{"lines":{"from":19897,"to":19952}}}}],["463",{"pageContent":"70 | Chapter 4: Mixing (Up) \"Class\" Objects \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nJoe = new CoolGuy( \"jumping rope\" ) \n\n\nJoe.showOff() // Here's my trick: jumping rope \n\nNotice that the CoolGuy class has a constructor CoolGuy(), which is \nactually what we call when we say new CoolGuy (..) ■ We get an object \nback (an instance of our class) from the constructor, and we can call \nthe method showOffQ, which prints out that particular CoolGuy s \nspecial trick. \n\nObviously, jumping rope makes Joe a pretty cool guy. \n\nThe constructor of a class belongs to the class, and almost universally \nhas the same name as the class. Also, constructors pretty much always \nneed to be called with new to let the language engine know you want \nto construct a new class instance. \n\nClass Inheritance \n\nIn class-oriented languages, not only can you define a class that can \nbe instantiated itself, but you can define another class that inherits \nfrom the first class.","metadata":{"loc":{"lines":{"from":19952,"to":19991}}}}],["464",{"pageContent":"Class Inheritance \n\nIn class-oriented languages, not only can you define a class that can \nbe instantiated itself, but you can define another class that inherits \nfrom the first class. \n\nThe second class is often said to be a “child class,” whereas the first is \nthe “parent class.” These terms obviously come from the metaphor of \nparents and children, though the metaphors here are a bit stretched, \nas you’ll see shortly. \n\nWhen a parent has a biological child, the genetic characteristics of the \nparent are copied into the child. Obviously, in most biological repro¬ \nduction systems, there are two parents who coequally contribute genes \nto the mix. But for the purposes of the metaphor, we’ll assume just one \nparent. \n\nOnce the child exists, he is separate from the parent. The child was \nheavily influenced by the inheritance from his parent, but is unique \nand distinct. If a child ends up with red hair, that doesn’t mean the \nparent’s hair was or automatically becomes red.","metadata":{"loc":{"lines":{"from":19991,"to":20011}}}}],["465",{"pageContent":"In a similar way, once a child class is defined, it’s separate and distinct \nfrom the parent class. The child class contains an initial copy of the \nbehavior from the parent, but can then override any inherited behavior \nand even define new behavior. \n\nIt’s important to remember that we’re talking about parent and child \nclasses, which aren’t physical things. This is where the metaphor of \n\n\nClass Inheritance | 71 \n\n\n\n\nparent and child gets a little confusing, because we actually should say \nthat a parent class is like a parent’s DNA and a child class is like a child’s \nDNA. We have to make (aka instantiate) a person out of each set of \nDNA to actually have a physical person to have a conversation with. \n\nLet’s set aside biological parents and children, and look at inheritance \nthrough a slightly different lens: different types of vehicles. That’s one \nof the most canonical (and often groan-worthy) metaphors to under¬ \nstand inheritance.","metadata":{"loc":{"lines":{"from":20013,"to":20035}}}}],["466",{"pageContent":"Let’s revisit the Vehicle and Car discussion from earlier in this chapter. \nConsider this loose pseudocode (invented syntax) for inherited \nclasses: \n\nclass Vehicle { \nengines = 1 \n\nignition() { \n\noutput( \"Turning on my engine.” ); \n\n} \n\ndrive() { \n\nignition( ); \n\noutput( \"Steering and moving forward!\" ) \n\n} \n\n} \n\nclass Car inherits Vehicle { \nwheels = 4 \n\ndrive() { \n\ninherited:drive() \n\noutput( \"Rolling on all \", wheels, \" wheels!\" ) \n\n} \n\n} \n\nclass SpeedBoat inherits Vehicle { \nengines = 2 \n\nignitionQ { \n\noutput( \"Turning on my \", engines, \" engines.\" ) \n\n} \n\npilot() { \n\ninherited:drive() \n\noutput( \"Speeding through the water with ease!\" ) \n\n} \n\n} \n\n\n72 | Chapter 4: Mixing (Up) \"Class\" Objects \n\n\n\n\n\nFor clarity and brevity, constructors for these classes have been \nomitted.","metadata":{"loc":{"lines":{"from":20037,"to":20100}}}}],["467",{"pageContent":"output( \"Speeding through the water with ease!\" ) \n\n} \n\n} \n\n\n72 | Chapter 4: Mixing (Up) \"Class\" Objects \n\n\n\n\n\nFor clarity and brevity, constructors for these classes have been \nomitted. \n\n\n\nWe define the Vehicle class to assume an engine, a way to turn on the \nignition, and a way to drive around. But you wouldn’t ever manufac¬ \nture just a generic “vehicle,” so it’s really just an abstract concept at this \npoint. \n\nSo then we define two specific kinds of vehicle: Car and SpeedBoat. \nThey each inherit the general characteristics of Vehicle, but then they \nspecialize the characteristics appropriately for each kind. A car needs \nfour wheels, and a speedboat needs two engines, which means it needs \nextra attention to turn on the ignition of both engines. \n\nPolymorphism","metadata":{"loc":{"lines":{"from":20100,"to":20129}}}}],["468",{"pageContent":"Polymorphism \n\nCar defines its own drive() method, which overrides the method of \nthe same name it inherited from Vehicle. But then, Car’s driveQ \nmethod calls inherited: driveQ, which indicates that Car can refer¬ \nence the original pre-overridden driveQ it inherited. SpeedBoat’s \npilotQ method also makes a reference to its inherited copy of \ndriveQ. \n\nThis technique is called polymorphism, or virtual polymorphism. More \nspecifically to our current point, we’ll call it relative polymorphism. \n\nPolymorphism is a much broader topic than we will exhaust here, but \nour current “relative” semantics refer to one particular aspect: the idea \nthat any method can reference another method (of the same or dif¬ \nferent name) at a higher level of the inheritance hierarchy. We say \n“relative” because we don’t absolutely define which inheritance level \n(aka class) we want to access, but rather relatively reference it by es¬ \nsentially saying “look one level up.”","metadata":{"loc":{"lines":{"from":20129,"to":20147}}}}],["469",{"pageContent":"In many languages, the keyword super is used, in place of this exam¬ \nple’s Inherited:, which leans on the idea that a “superclass” is the \nparent/ancestor of the current class. \n\nAnother aspect of polymorphism is that a method name can have \nmultiple definitions at different levels of the inheritance chain, and \n\n\nClass Inheritance | 73 \n\n\n\n\nthese definitions are automatically selected as appropriate when re¬ \nsolving which methods are being called. \n\nWe see two occurrences of that behavior in our previous example: \ndrlveQ is defined in both Vehicle and Car, and ignition() is de¬ \nfined in both Vehicle and SpeedBoat.","metadata":{"loc":{"lines":{"from":20149,"to":20167}}}}],["470",{"pageContent":"We see two occurrences of that behavior in our previous example: \ndrlveQ is defined in both Vehicle and Car, and ignition() is de¬ \nfined in both Vehicle and SpeedBoat. \n\n\n\nAnother thing that traditional class-oriented languages give \nyou via super is a direct way for the constructor of a child class \nto reference the constructor of its parent class. This is largely \ntrue because with real classes, the constructor belongs to the \nclass. However, in JS, it’s the reverse—it’s actually more appro¬ \npriate to think of the “class” belonging to the constructor (the \nFoo.prototype. .. type references). Since in JS the relation¬ \nship between child and parent exists only between the \ntwo .prototype objects of the respective constructors, the \nconstructors themselves are not directly related, and thus \nthere’s no simple way to relatively reference one from the oth¬ \ner (see Appendix A on the ES6 class, which “solves” this with \nsuper).","metadata":{"loc":{"lines":{"from":20167,"to":20185}}}}],["471",{"pageContent":"An interesting implication of polymorphism can be seen specifically \nwith ignition(). Inside pilot(), a relative-polymorphic reference is \nmade to (the inherited) Vehicles version of d rive(). But that d rive () \nreferences an ignition () method just by name (no relative reference). \n\nWhich version of ignition() will the language engine use, the one \nfrom Vehicle or the one from SpeedBoat? It uses the SpeedBoat ver¬ \nsion of ignition(). If you were to instantiate the Vehicle class itself, \nand then call its drive(), the language engine would instead just use \nVehicle’s ignition() method definition. \n\nPut another way, the definition for the method ignition() poly¬ \nmorphs (changes) depending on which class (level of inheritance) you \nare referencing an instance of. \n\nThis may seem like overly deep academic detail. But understanding \nthese details is necessary to properly contrast similar (but distinct) \nbehaviors in JavaScript’s [[Prototype]] mechanism.","metadata":{"loc":{"lines":{"from":20188,"to":20205}}}}],["472",{"pageContent":"This may seem like overly deep academic detail. But understanding \nthese details is necessary to properly contrast similar (but distinct) \nbehaviors in JavaScript’s [[Prototype]] mechanism. \n\nWhen classes are inherited, there is a way for the classes themselves \n(not the object instances created from them!) to relatively reference \nthe class inherited from, and this relative reference is usually called \nsuper. \n\n\n74 | Chapter 4: Mixing (Up) \"Class\" Objects \n\n\n\n\nRemember this figure from earlier? \n\n\n\nNotice how for both instantiation (al, a2, bl, and b2) and inheritance \n(Bar), the arrows indicate a copy operation.","metadata":{"loc":{"lines":{"from":20205,"to":20225}}}}],["473",{"pageContent":"Remember this figure from earlier? \n\n\n\nNotice how for both instantiation (al, a2, bl, and b2) and inheritance \n(Bar), the arrows indicate a copy operation. \n\nConceptually, it would seem a child class Bar can access behavior in \nits parent class Foo using a relative polymorphic reference (aka \nsuper). However, in reality, the child class is merely given a copy of \nthe inherited behavior from its parent class. If the child “overrides” a \nmethod it inherits, both the original and overridden verions of the \nmethod are actually maintained, so that they are both accessible. \n\nDon’t let polymorphism confuse you into thinking a child class is \nlinked to its parent class. A child class instead gets a copy of what it \nneeds from the parent class. Class inheritance implies copies. \n\nMultiple Inheritance","metadata":{"loc":{"lines":{"from":20225,"to":20243}}}}],["474",{"pageContent":"Multiple Inheritance \n\nRecall our earlier discussion of parent(s) and children and DNA? We \nsaid that the metaphor was a bit weird because biologically most off¬ \nspring come from two parents. If a class could inherit from two other \nclasses, it would more closely fit the parent/child metaphor. \n\nSome class-oriented languages allow you to specify more than one \n“parent” class to “inherit” from. Multiple inheritance means that each \nparent class definition is copied into the child class. \n\nOn the surface, this seems like a powerful addition to class orientation, \ngiving us the ability to compose more functionality together. However, \nthere are certainly some complicating questions that arise. If both \n\n\nClass Inheritance | 75","metadata":{"loc":{"lines":{"from":20243,"to":20259}}}}],["475",{"pageContent":"Class Inheritance | 75 \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nparent classes provide a method called drive( ), which version would \na driveQ reference in the child resolve to? Would you always have to \nmanually specify which parent’s drive () you meant, thus losing some \nof the gracefulness of polymorphic inheritance? \n\nThere’s another variation, the so-called diamond problem, which refers \nto the scenario where a child class D inherits from two parent classes \n(B and C), and each of those in turn inherits from a common A parent. \nIf A provides a method driveQ, and both B and C override (poly¬ \nmorph) that method, when D references driveQ, which version \nshould it use (B:drive( ) or C:drive())? \n\n\nA \n\n>> \n\nB C \n\n\n\nD \n\n\nThese complications go much deeper than this quick glance. We ad¬ \ndress them here only so we can contrast with how JavaScript’s mech¬ \nanisms work.","metadata":{"loc":{"lines":{"from":20259,"to":20302}}}}],["476",{"pageContent":"A \n\n>> \n\nB C \n\n\n\nD \n\n\nThese complications go much deeper than this quick glance. We ad¬ \ndress them here only so we can contrast with how JavaScript’s mech¬ \nanisms work. \n\nJavaScript is simpler: it does not provide a native mechanism for \n“multiple inheritance.” Many see this is a good thing, because the \ncomplexity savings more than make up for the “reduced” functionality. \nBut this doesn’t stop developers from trying to fake it in various ways, \nas we’ll see next. \n\nMixins \n\nJavaScript’s object mechanism does not automatically perform copy \nbehavior when you inherit or instantiate. Plainly, there are no “classes” \nin JavaScript to instantiate, only objects. And objects don’t get copied \nto other objects, they get linked together (more on that in Chapter 5). \n\nSince observed class behaviors in other languages imply copies, let’s \nexamine how JS developers fake the missing copy behavior of classes \n\n\n76 | Chapter 4: Mixing (Up) \"Class\" Objects","metadata":{"loc":{"lines":{"from":20302,"to":20334}}}}],["477",{"pageContent":"Since observed class behaviors in other languages imply copies, let’s \nexamine how JS developers fake the missing copy behavior of classes \n\n\n76 | Chapter 4: Mixing (Up) \"Class\" Objects \n\n\n\n\n\n\n\n\n\n\n\nin JavaScript: mixins. We’ll look at two types of mixin: explicit and \nimplicit. \n\nExplicit Mixins \n\nLet’s again revisit our Vehicle and Car example from before. Since \nJavaScript will not automatically copy behavior from Vehicle to Car, \nwe can instead create a utility that manually copies. Such a utility is \noften called extend (..) by many libraries/frameworks, but we will \ncall it niixin(..) here for illustrative purposes: \n\n// vastly simplified 'mixin(..)' example: \nfunction nixin( sourceObj, targetObj ) { \nfor (var key in sourceObj) { \n\n// only copy if not already present \nif (!( key in targetObj)) { \n\ntargetObj[key] = sourceObj[key] ; \n\n} \n\n} \n\nreturn targetObj; \n\n} \n\nvar Vehicle = { \nengines: 1, \n\nignition: function() { \n\nconsole.log( \"Turning on my engine.\" ); \n\n}.","metadata":{"loc":{"lines":{"from":20334,"to":20385}}}}],["478",{"pageContent":"targetObj[key] = sourceObj[key] ; \n\n} \n\n} \n\nreturn targetObj; \n\n} \n\nvar Vehicle = { \nengines: 1, \n\nignition: function() { \n\nconsole.log( \"Turning on my engine.\" ); \n\n}. \n\n\ndrive: functionQ { \nthis.ignition(); \n\nconsole.log( \"Steering and moving forward!\" ); \n\n} \n\n}; \n\n\nvar Car = mixin( Vehicle, { \nwheels: 4, \n\ndrive: functionQ { \n\nVehicle.drive.call( this ); \nconsole.log( \n\n\"Rolling on all \" + this. wheels + \" wheels! \n\n); \n\n} \n\n\nMixins | 77 \n\n\n\n\n\nSubtly but importantly, were not dealing with classes any¬ \nmore, because there are no classes in JavaScript. Vehicle and \nCar are just objects that we make copies from and to, respec¬ \ntively.","metadata":{"loc":{"lines":{"from":20385,"to":20439}}}}],["479",{"pageContent":"Subtly but importantly, were not dealing with classes any¬ \nmore, because there are no classes in JavaScript. Vehicle and \nCar are just objects that we make copies from and to, respec¬ \ntively. \n\n\nCar now has a copy of the properties and functions from Vehicle. \nTechnically, functions are not actually duplicated, but rather refer¬ \nences to the functions are copied. So, Car now has a property called \nignition, which is a copied reference to the ignition() function, as \nwell as a property called engines with the copied value of 1 from \nVehicle. \n\nCar already had a drive property (function), so that property refer¬ \nence was not overridden (see the if statement in mixin(..) earlier). \n\nPolymorphism revisited \n\nLet’s examine this statement: Vehicle.drive.call( this ). This is \nwhat I call explicit pseudopolymorphism. Recall in our previous pseu¬ \ndocode this line was inherited :drive(), which we called relative \npolymorphism.","metadata":{"loc":{"lines":{"from":20439,"to":20460}}}}],["480",{"pageContent":"JavaScript does not have (prior to ES6; see Appendix A) a facility for \nrelative polymorphism. So, because both Ca r and Vehicle had a func¬ \ntion of the same name, driveQ, to distinguish a call to one or the \nother, we must make an absolute (not relative) reference. We explicitly \nspecify the Vehicle object by name and call the drive() function on \nit. \n\nBut if we said Vehicle. driveQ, the this binding for that function \ncall would be the Vehicle object instead of the Car object (see Chap¬ \nter 2), which is not what we want. So, instead we use .call( this ) \n(Chapter 2) to ensure that driveQ is executed in the context of the \nCar object. \n\n\n78 | Chapter 4: Mixing (Up) \"Class\" Objects","metadata":{"loc":{"lines":{"from":20462,"to":20476}}}}],["481",{"pageContent":"78 | Chapter 4: Mixing (Up) \"Class\" Objects \n\n\n\n\n\n\nIf the function name identifier for Car.driveQ hadn’t \noverlapped with (aka “shadowed”; see Chapter 5) Vehi \ncle.drive( ), we wouldn’t have been exercising method poly¬ \nmorphism. So, a reference to Vehicle.drive() would have \nbeen copied over by the mixin( ..) call, and we could have \naccessed directly with this.drive(). The chosen identifier \noverlap shadowing is why we have to use the more complex \nexplicit pseudopolymorphism approach. \n\n\nIn class-oriented languages, which have relative polymorphism, the \nlinkage between Car and Vehicle is established once, at the top of the \nclass definition, which makes for only one place to maintain such \nrelationships.","metadata":{"loc":{"lines":{"from":20476,"to":20496}}}}],["482",{"pageContent":"But because of JavaScript’s peculiarities, explicit pseudopolymorphism \n(because of shadowing!) creates brittle manual/explicit linkage in \nevery single function where you need such a (pseudo)polymorphic \nreference. This can significantly increase the maintenance cost. More¬ \nover, while explicit pseudopolymorphism can emulate the behavior of \nmultiple inheritance, it only increases the complexity and brittleness. \n\nThe result of such approaches is usually more complex, harder-to- \nread, and harder-to-maintain code. Explicit pseudopolymorphism \nshould be avoided wherever possible, because the cost outweighs the \nbenefit in most respects. \n\nMixing copies \n\nRecall the mixin(..) utility from earlier: \n\n// vastly simplified 'mixin()' example: \nfunction nixin( sourceObj, targetObj ) { \nfor (var key in sourceObj) { \n\n// only copy if not already present \nif (!( key in targetObj)) { \n\ntargetObj [key] = sourceObjfkey] ; \n\n} \n\n} \n\nreturn targetObj; \n\n}","metadata":{"loc":{"lines":{"from":20498,"to":20529}}}}],["483",{"pageContent":"// only copy if not already present \nif (!( key in targetObj)) { \n\ntargetObj [key] = sourceObjfkey] ; \n\n} \n\n} \n\nreturn targetObj; \n\n} \n\nNow, let’s examine how mixin(..) works. It iterates over the proper¬ \nties of sourceObj (Vehicle, in our example), and if there’s no matching \nproperty of that name in targetObj (Car, in our example), it makes a \n\n\nMixins | 79 \n\n\n\n\ncopy. Since we’re making the copy after the initial object exists, we are \ncareful to not copy over a target property. \n\nIf we made the copies first, before specifying the Car-specific contents, \nwe could omit this check against targetObj, but that’s a little more \nclunky and less efficient, so it’s generally less preferred: \n\n// alternate mixin, less \"safe\" to overwrites \nfunction mtxin( sourceObj, targetObj ) { \nfor (var key in sourceObj) { \n\ntargetObj[key] = sourceObj[key] ; \n\n} \n\nreturn targetObj; \n\n} \n\nvar Vehicle = { \n\n// ... \n\n};","metadata":{"loc":{"lines":{"from":20529,"to":20575}}}}],["484",{"pageContent":"targetObj[key] = sourceObj[key] ; \n\n} \n\nreturn targetObj; \n\n} \n\nvar Vehicle = { \n\n// ... \n\n}; \n\n\n// first, create an empty object with \n// Vehicle's stuff copied in \nvar Car = mixin( Vehicle, { } ); \n\n// now copy the intended contents into Car \nnixin( { \n\nwheels: 4, \n\ndrive: functionQ { \n\n// ... \n\n} \n\n}, Car ); \n\nWith either approach, we have explicitly copied the nonoverlapping \ncontents of Vehicle into Car. The name “mixin” comes from an al¬ \nternate way of explaining the task: Car has Vehicle’s contents mixed \nin, just like you mix in chocolate chips into your favorite cookie dough. \n\nAs a result of the copy operation, Car will operate somewhat separately \nfrom Vehicle. If you add a property onto Car, it will not affect Vehi \ncle, and vice versa. \n\n\n\nA few minor details have been skimmed over here. There are \nstill some subtle ways the two objects can “affect” each other \neven after copying, such as if they both share a reference to a \ncommon object (such as an array).","metadata":{"loc":{"lines":{"from":20575,"to":20621}}}}],["485",{"pageContent":"80 | Chapter 4: Mixing (Up) \"Class\" Objects \n\n\n\n\n\n\nSince the two objects also share references to their common functions, \nthat means that even manual copying of functions (aka mixins) from \none object to another doesn’t actually emulate the real duplication \nfrom class to instance that occurs in class-oriented languages. \n\nJavaScript functions can’t really be duplicated (in a standard, reliable \nway), so what you end up with instead is a duplicated reference to the \nsame shared function object (functions are objects; see Chapter 3). If \nyou modified one of the shared function objects (like ignition ()) by \nadding properties on top of it, for instance, both Vehicle and Car \nwould be “affected” via the shared reference.","metadata":{"loc":{"lines":{"from":20624,"to":20641}}}}],["486",{"pageContent":"Explicit mixins are a fine mechanism in JavaScript. But they appear \nmore powerful than they really are. Not much benefit is actually de¬ \nrived from copying a property from one object to another, as opposed \nto just defining the properties twice, once on each object. And that’s \nespecially true given the function-object reference nuance we just \nmentioned. \n\nIf you explicitly mix in two or more objects into your target object, \nyou can partially emulate the behavior of multiple inheritance, but \nthere’s no direct way to handle collisions if the same method or prop¬ \nerty is being copied from more than one source. Some developers/ \nlibraries have come up with “late binding” techniques and other exotic \nworkarounds, but fundamentally, these “tricks” are usually more effort \n(with less performance!) than the payoff.","metadata":{"loc":{"lines":{"from":20643,"to":20656}}}}],["487",{"pageContent":"Take care only to use explicit mixins where it actually helps make more \nreadable code, and avoid the pattern if you find it making code that’s \nharder to trace, or if you find it creates unnecessary or unwieldy de¬ \npendencies between objects. \n\nIf it starts to get harder to properly use mixins than before you used \nthem, you should probably stop using mixins. In fact, if you have to \nuse a complex library/utility to work out all these details, it might be \na sign that you’re going about it the harder way, perhaps unnecessarily. \nIn Chapter 6, we’ll try to distill a simpler way that accomplishes the \ndesired outcomes without all the fuss. \n\nParasitic inheritance \n\nA variation on this explicit mixin pattern, which is both in some ways \nexplicit and in other ways implicit, is called “parasitic inheritance,” \npopularized mainly by Douglas Crockford. \n\n\nMixins | 81 \n\n\n\nHere’s how it can work: \n\n// \"Traditional JS Class\" 'Vehicle' \n\nfunction VehicleQ { \nthis. engines = 1; \n\n}","metadata":{"loc":{"lines":{"from":20658,"to":20688}}}}],["488",{"pageContent":"Mixins | 81 \n\n\n\nHere’s how it can work: \n\n// \"Traditional JS Class\" 'Vehicle' \n\nfunction VehicleQ { \nthis. engines = 1; \n\n} \n\nVehicle.prototype.ignition = functionQ { \nconsole.log( \"Turning on my engine.\" ); \n\n}; \n\nVehicle.prototype.drive = functionQ { \nthis.ignitionQ; \n\nconsole.log( \"Steering and moving forward!\" ); \n\n}; \n\n\n// \"Parasitic Class\" 'Car' \nfunction Car() { \n\n//first, 'car' is a 'Vehicle' \nvar car = new VehicleQ; \n\n// now, let's modify our 'car' to specialize it \ncar.wheels = 4; \n\n// save a privileged reference to 'Vehicle::drive()' \nvar vehDrive = car.drive; \n\n// override 'Vehicle::drive()' \n\ncar.drive = functionQ { \nvehDrive.call( this ); \nconsole.log( \n\n\"Rolling on all \" + this. wheels + \" wheels!\" \n\n); \n\n\nreturn car; \n\n} \n\nvar myCar = new CarQ; \n\n\nmyCar.driveQ; \n\n// Turning on my engine. \n\n// Steering and moving forward! \n// Rolling on all 4 wheels!","metadata":{"loc":{"lines":{"from":20688,"to":20749}}}}],["489",{"pageContent":"); \n\n\nreturn car; \n\n} \n\nvar myCar = new CarQ; \n\n\nmyCar.driveQ; \n\n// Turning on my engine. \n\n// Steering and moving forward! \n// Rolling on all 4 wheels! \n\n\nAs you can see, we initially make a copy of the definition from the \nVehicle parent class (object), then mix in our child class (object) def¬ \ninition (preserving privileged parent-class references as needed), and \npass off this composed object car as our child instance. \n\n\n82 | Chapter 4: Mixing (Up) \"Class\" Objects \n\n\n\n\n\n\nWhen we call new Car(), a new object is created and refer¬ \nenced by Car’s this reference (see Chapter 2). But since we \ndon’t use that object, and instead return our own car object, \nthe initially created object is just discarded. So, Car( ) could be \ncalled without the new keyword, and the functionality just de¬ \nscribed would be identical, but without the wasted object cre¬ \nation/garbage collection. \n\n\nImplicit Mixins","metadata":{"loc":{"lines":{"from":20749,"to":20789}}}}],["490",{"pageContent":"Implicit Mixins \n\nImplicit mixins are closely related to explicit pseudopolymorphism, \nas explained previously. As such, they come with the same caveats and \nwarnings. \n\nConsider this code: \n\nvar Something = { \n\ncool: functi.on() { \n\nthis. greeting = \"Hello World\"; \n\nthis. count = this. count ? this. count +1:1; \n\n} \n\n}; \n\n\nSomething. cool(); \n\nSomething.greeting; // \"Hello World\" \n\nSomething . count; // 1 \n\nvar Another = { \n\ncool: function!) { \n\n// implicit mixin of 'Something' to 'Another' \nSomething.cool.call( this ); \n\n} \n\n}; \n\n\nAnother.cool(); \n\nAnother.greeting; // \"Hello World\" \n\nAnother.count; // 1 (not shared state with 'Something')","metadata":{"loc":{"lines":{"from":20789,"to":20832}}}}],["491",{"pageContent":"} \n\n}; \n\n\nAnother.cool(); \n\nAnother.greeting; // \"Hello World\" \n\nAnother.count; // 1 (not shared state with 'Something') \n\nWith Something.cool.call( this ), which can happen either in a \nconstructor call (most common) or in a method call (shown here), we \nessentially “borrow” the function Something. cool() and call it in the \ncontext of Another (via its this binding; see Chapter 2) instead of \nSomething. The end result is that the assignments that Some \nthing.cool() makes are applied against the Another object rather \nthan the Something object. \n\n\nMixins | 83 \n\n\n\n\n\nSo, it is said that we “mixed in” Something’s behavior with (or into) \nAnother.","metadata":{"loc":{"lines":{"from":20832,"to":20859}}}}],["492",{"pageContent":"Mixins | 83 \n\n\n\n\n\nSo, it is said that we “mixed in” Something’s behavior with (or into) \nAnother. \n\nWhile this sort of technique seems to take useful advantage of this \nrebinding functionality, it’s a brittle Something. cool. call( this ) \ncall, which cannot be made into a relative (and thus more flexible) \nreference, that you should heed with caution. Generally, avoid such \nconstructs wherever possible to keep cleaner and more maintainable \ncode. \n\nReview \n\nClasses are a design pattern. Many languages provide syntax that en¬ \nables natural class-oriented software design. JS also has a similar \nsyntax, but it behaves very differently from what you’re used to with \nclasses in those other languages. \n\nClasses mean copies. \n\nWhen traditional classes are instantiated, a copy of behavior from class \nto instance occurs. When classes are inherited, a copy of behavior from \nparent to child also occurs.","metadata":{"loc":{"lines":{"from":20859,"to":20886}}}}],["493",{"pageContent":"When traditional classes are instantiated, a copy of behavior from class \nto instance occurs. When classes are inherited, a copy of behavior from \nparent to child also occurs. \n\nPolymorphism (having different functions at multiple levels of an in¬ \nheritance chain with the same name) may seem like it implies a ref¬ \nerential relative link from child back to parent, but it’s still just a result \nof copy behavior. \n\nJavaScript does not automatically create copies (as classes imply) be¬ \ntween objects. \n\nThe mixin pattern (both explicit and implicit) is often used to sort of \nemulate class copy behavior, but this usually leads to ugly and brittle \nsyntax like explicit pseudopolymorphism (OtherObj.method \nName, call (this, ...)), which often results in code that is harder to \nunderstand and maintain.","metadata":{"loc":{"lines":{"from":20886,"to":20902}}}}],["494",{"pageContent":"Explicit mixins are also not exactly the same as class-copy behavior, \nsince objects (and functions!) only have shared references duplicated, \nnot the objects/functions themselves. Not paying attention to such \nnuance is the source of a variety of gotchas. \n\nIn general, faking classes in JS often sets more landmines for future \ncoding than solving present real problems. \n\n\n84 | Chapter 4: Mixing (Up) \"Class\" Objects \n\n\n\n\nCHAPTER 5 \n\n\nPrototypes \n\n\nIn Chapters 3 and 4, we mentioned the [ [Prototype] ] chain several \ntimes, but haven’t said what exactly it is. We will now examine proto¬ \ntypes in detail. \n\n\n\nAll of the attempts to emulate class-copy behavior described \npreviously in Chapter 4, labeled as variations of mixins, com¬ \npletely circument the [[Prototype]] chain mechanism we \nexamine here in this chapter. \n\n\n[[Prototype]]","metadata":{"loc":{"lines":{"from":20904,"to":20936}}}}],["495",{"pageContent":"[[Prototype]] \n\nObjects in JavaScript have an internal property, denoted in the speci¬ \nfication as [ [Prototype] ], which is simply a reference to another ob¬ \nject. Almost all objects are given a non-null value for this property, at \nthe time of their creation. \n\nNote: we will see shortly that it is possible for an object to have an \nempty [ [Prototype] ] linkage, though this is somewhat less common. \n\nConsider: \n\nvar myObject = { \na: 2 \n\n}; \n\n\nmyObject.a; // 2 \n\nWhat is the [ [Prototype] ] reference used for? In Chapter 3, we ex¬ \namined the [ [Get] ] operation that is invoked when you reference a \n\n\n85 \n\n\n\n\n\nproperty on an object, such as myObject. a. For that default [ [Get] ] \noperation, the first step is to check if the object itself has a properly a \non it, and if so, it’s used.","metadata":{"loc":{"lines":{"from":20936,"to":20968}}}}],["496",{"pageContent":"85 \n\n\n\n\n\nproperty on an object, such as myObject. a. For that default [ [Get] ] \noperation, the first step is to check if the object itself has a properly a \non it, and if so, it’s used. \n\n\n\nES6 Proxies are outside of our discussion scope in this book \n(they will be covered in a later book in the series), but every¬ \nthing we discuss here about normal [ [Get] ] and [ [Put] ] be¬ \nhavior does not apply if a Proxy is involved. \n\n\nBut it’s what happens if a isn’t present on myObject that brings our \nattention now to the [ [Prototype] ] link of the object. \n\nThe default [[Get]] operation proceeds to follow the [[Proto \ntype] ] link of the object if it cannot find the requested property on \nthe object directly: \n\nvar anotherObject = { \na: 2 \n\n}; \n\n\n// create an object linked to 'anotherObject' \nvar myObject = Object. create( anotherObject ); \n\nmyObject.a; // 2","metadata":{"loc":{"lines":{"from":20968,"to":21002}}}}],["497",{"pageContent":"var anotherObject = { \na: 2 \n\n}; \n\n\n// create an object linked to 'anotherObject' \nvar myObject = Object. create( anotherObject ); \n\nmyObject.a; // 2 \n\n\n\nWe will explain what Object.create( ..) does, and how it \noperates, shortly. For now, just assume it creates an object with \nthe [[Prototype]] linkage were examining to the object \nspecified. \n\n\nSo, we have myObject that is now [ [Prototype] ] linked to another \nObject. Clearly myObject.a doesn’t actually exist, but nevertheless, \nthe property access succeeds (being found on anotherObject instead) \nand indeed finds the value 2. \n\nBut, if a weren’t found on anotherObject either, its [[Prototype]] \nchain, if nonempty, is again consulted and followed. \n\nThis process continues until either a matching property name is found, \nor the [[Prototype]] chain ends. If no matching property is ever \nfound by the end of the chain, the return result from the [[Get]] \noperation is undefined. \n\n\n86 | Chapter 5: Prototypes","metadata":{"loc":{"lines":{"from":21002,"to":21035}}}}],["498",{"pageContent":"86 | Chapter 5: Prototypes \n\n\n\n\n\n\n\nSimilar to this [[Prototype]] chain lookup process, if you use a \nf or.. in loop to iterate over an object, any property that can be reached \nvia its chain (and is also enumerable —see Chapter 3) will be enumer¬ \nated. If you use the In operator to test for the existence of a property \non an object, in will check the entire chain of the object (regardless of \nenumerability): \n\nvar anotherObject = { \na: 2 \n\n}; \n\n\n// create an object linked to 'anotherObject' \nvar myObject = Object. create( anotherObject ); \n\nfor (var k in nyObject) { \n\nconsole. log(\"found: \" + k); \n\n} \n\n// found: a \n\n(\"a\" in myObject); // true \n\nSo, the [[Prototype]] chain is consulted, one link at a time, when you \nperform property lookups in various fashions. The lookup stops once \nthe property is found or the chain ends. \n\nObject.prototype \n\nBut where exactly does the [ [Prototype] ] chain “end”?","metadata":{"loc":{"lines":{"from":21035,"to":21075}}}}],["499",{"pageContent":"Object.prototype \n\nBut where exactly does the [ [Prototype] ] chain “end”? \n\nThe top end of every normal [[Prototype]] chain is the built-in \nObject. prototype. This object includes a variety of common utilities \nused all over JS, because all normal (built-in, not host-specific exten¬ \nsion) objects in JavaScript “descend from” (aka have at the top of their \n[[Prototype]] chain) the Object.prototype object. \n\nSome utilities found here you may be familiar with include .to \nString( ) and .valueOfQ. In Chapter 3, we introduced anoth¬ \ner: . hasOwnProperty (..). And yet another function on Object. pro \ntotype you may not be familiar with is . isPrototypeOf (..), which \nwe’ll address later in this chapter. \n\nSetting and Shadowing Properties \n\nBack in Chapter 3, we mentioned that setting properties on an object \nwas more nuanced than just adding a new property to the object or \n\n\n[[Prototype]] | 87","metadata":{"loc":{"lines":{"from":21075,"to":21097}}}}],["500",{"pageContent":"Setting and Shadowing Properties \n\nBack in Chapter 3, we mentioned that setting properties on an object \nwas more nuanced than just adding a new property to the object or \n\n\n[[Prototype]] | 87 \n\n\n\nchanging an existing property’s value. We will now revisit this situation \nmore completely: \n\nmyObject.foo = \"bar\"; \n\nIf the myObject object already has a normal data accessor property \ncalled f oo directly present on it, the assignment is as simple as chang¬ \ning the value of the existing properly. \n\nIf foo is not already present directly on myObject, the [[Proto \ntype] ] chain is traversed, just like for the [ [Get] ] operation. If foo is \nnot found anywhere in the chain, the property foo is added directly \nto myObject with the specified value, as expected. \n\nHowever, if foo is already present somewhere higher in the chain, \nnuanced (and perhaps surprising) behavior can occur with the myOb \nject.foo = \"bar\" assignment. We’ll examine that more in just a mo¬ \nment.","metadata":{"loc":{"lines":{"from":21097,"to":21124}}}}],["501",{"pageContent":"If the property name foo ends up both on myObject itself and at a \nhigher level of the [ [Prototype] ] chain that starts at myObject, this \nis called shadowing. The foo property directly on myObject shadows \nany foo property that appears higher in the chain, because the myOb \nject. foo lookup would always find the foo property that’s lowest in \nthe chain. \n\nAs we just hinted, shadowing foo on myObject is not as simple as it \nmay seem. We will now examine three scenarios for the myOb j ect. foo \n= \"bar\" assignment when foo is not already on myObject directly, but \nis at a higher level of myObject’s [ [Prototype] ] chain: \n\n1. If a normal data accessor (see Chapter 3) property named foo is \nfound anywhere higher on the [ [Prototype] ] chain, and it’s not \nmarked as read-only (writable:false), then a new property \ncalled foo is added directly to myObject, resulting in a shadowed \nproperty.","metadata":{"loc":{"lines":{"from":21126,"to":21142}}}}],["502",{"pageContent":"2. If a foo is found higher on the [[Prototype]] chain, but it’s \nmarked as read-only (writable : false), then both the setting of \nthat existing property as well as the creation of the shadowed \nproperty on myObject are disallowed. If the code is running in \nstrict mode, an error will be thrown. Otherwise, the setting of \nthe property value will silently be ignored. Either way, no shad¬ \nowing occurs. \n\n\n88 | Chapter 5: Prototypes \n\n\n\n\n\n3. If a foo is found higher on the [[Prototype]] chain and it’s a \nsetter (see Chapter 3), then the setter will always be called. No foo \nwill be added to (aka shadowed on) myObject, nor will the foo \nsetter be redefined. \n\nMost developers assume that assignment of a property ([ [ Put ] ]) will \nalways result in shadowing if the property already exists higher on the \n[ [Prototype] ] chain, but as you can see, that’s only true in one of the \nthree situations just described (case 1).","metadata":{"loc":{"lines":{"from":21144,"to":21167}}}}],["503",{"pageContent":"If you want to shadow foo in cases 2 and 3, you cannot use = assign¬ \nment, but must instead use Object. deftneProperty( ..) (see Chap¬ \nter 3) to add foo to myObject.","metadata":{"loc":{"lines":{"from":21169,"to":21171}}}}],["504",{"pageContent":"Case 2 may be the most surprising of the three. The presence \nof a read-only property prevents a property of the same name \nfrom being implicitly created (shadowed) at a lower level of a \n[[Prototype]] chain. The reason for this restriction is pri¬ \nmarily to reinforce the illusion of class-inherited properties. If \nyou think of the foo at a higher level of the chain as having \nbeen inherited (copied down) to myObject, then it makes sense \nto enforce the nonwritable nature of that foo property on my \nObject. If you however separate the illusion from the fact, and \nrecognize that no such inheritance copying actually occured \n(see Chapters 4 and 5), it’s a little unnatural that myObject \nwould be prevented from having a foo property just because \nsome other object had a nonwritable foo on it. It’s even strang¬ \ner that this restriction only applies to = assignment, but is not \nenforced when using Object. deftneProperty(..).","metadata":{"loc":{"lines":{"from":21175,"to":21189}}}}],["505",{"pageContent":"Shadowing methods leads to ugly explicit pseudopolymorphism (see \nChapter 4) if you need to delegate between them. Usually, shadowing \nis more complicated and nuanced than it’s worth, so you should try to \navoid it if possible. See Chapter 6 for an alternative design pattern, \nwhich among other things, discourages shadowing in favor of cleaner \nalternatives. \n\nShadowing can even occur implicitly in subtle ways, so care must be \ntaken if trying to avoid it. Consider: \n\nvar anotherObject = { \na: 2 \n\n}; \n\n\n[[Prototype]] | 89 \n\n\n\n\n\nvar myObject = Object. create( anotherObject ); \n\n\nanotherObject.a; // 2 \nmyObject. a; // 2 \n\nanotherObject.hasOwnProperty( \"a\" ); // true \nmyObject.hasOwnProperty( \"a\" ); // false \n\nmyObject. a++; // oops, implicit shadowing! \n\nanotherObject.a; // 2 \nmyObject. a; // 3 \n\nmyObject.hasOwnProperty( \"a\" ); // true","metadata":{"loc":{"lines":{"from":21192,"to":21228}}}}],["506",{"pageContent":"myObject. a++; // oops, implicit shadowing! \n\nanotherObject.a; // 2 \nmyObject. a; // 3 \n\nmyObject.hasOwnProperty( \"a\" ); // true \n\nThough it may appear that myObject. a++ should (via delegation) look \nup and just increment the anotherObject. a property itself in place, \ninstead the++operation corresponds to myObject.a = myObject.a \n+ 1. The result is [[Get]] looking up a property via [[Prototype]] \nto get the current value 2 from anotherObject.a, incrementing the \nvalue by one, then [ [Put] ] assigning the 3 value to a new shadowed \nproperty a on myObject. Oops! \n\nBe very careful when dealing with delegated properties that you mod¬ \nify. Ifyou wanted to increment anotherObject. a, the onlyproperway \nis anotherObject.a++. \n\n\"Class\"","metadata":{"loc":{"lines":{"from":21228,"to":21247}}}}],["507",{"pageContent":"Be very careful when dealing with delegated properties that you mod¬ \nify. Ifyou wanted to increment anotherObject. a, the onlyproperway \nis anotherObject.a++. \n\n\"Class\" \n\nAt this point, you might be wondering: Why does one object need to \nlink to another object? What’s the real benefit? That is a very appro¬ \npriate question to ask, but we must first understand what [[Proto \ntype] ] is not before we can fully understand and appreciate what it is \nand how it’s useful. \n\nAs we explained in Chapter 4, in JavaScript, there are no abstract pat¬ \nterns/blueprints for objects called classes as there are in class-oriented \nlanguages. JavaScriptjusf has objects. \n\nIn fact, JavaScript is almost unique among languages as perhaps the \nonly language with the right to use the label “object-oriented,” because \nit’s one of a very short list of languages where an object can be created \ndirectly, without a class at all. \n\n\n90 | Chapter 5: Prototypes","metadata":{"loc":{"lines":{"from":21247,"to":21269}}}}],["508",{"pageContent":"90 | Chapter 5: Prototypes \n\n\n\n\n\nIn JavaScript, classes can’t (being that they don’t exist!) describe what \nan object can do. The object defines its own behavior directly. There’s \njust the object. \n\n\"Class\" Functions \n\nThere’s a peculiar kind of behavior in JavaScript that has been shame¬ \nlessly abused for years to hack something that looks like classes. We’ll \nexamine this approach in detail. \n\nThe peculiar “sort-of class” behavior hinges on a strange characteristic \nof functions: all functions by default get a public, nonenumerable (see \nChapter 3) property on them called prototype, which points at an \notherwise arbitrary object: \n\nfunction Foo() { \n\n// ... \n\n} \n\nFoo.prototype; // { }","metadata":{"loc":{"lines":{"from":21269,"to":21296}}}}],["509",{"pageContent":"function Foo() { \n\n// ... \n\n} \n\nFoo.prototype; // { } \n\nThis object is often called Foo’sprototype, because we access it via an \nunfortunately named Foo.prototype property reference. However, \nthat terminology is hopelessly destined to lead us into confusion, as \nwe’ll see shortly. Instead, I will call it “the object formerly known as \nFoo’s prototype.” Just kidding. How about “the object arbitrarily la¬ \nbeled Foo dot prototype”? \n\nWhatever we call it, what exactly is this object? \n\nThe most direct way to explain it is that each object created from calling \nnew Foo() (see Chapter 2) will end up (somewhat arbitrarily) \n[ [Prototype] ]-linked to this “Foo dot prototype” object. \n\nLet’s illustrate: \n\nfunction Foo() { \n\n// ... \n\n} \n\nvar a = new Foo(); \n\nObject.getPrototypeOf( a ) === Foo.prototype; // true \n\n\n'Class\" | 91","metadata":{"loc":{"lines":{"from":21296,"to":21330}}}}],["510",{"pageContent":"Let’s illustrate: \n\nfunction Foo() { \n\n// ... \n\n} \n\nvar a = new Foo(); \n\nObject.getPrototypeOf( a ) === Foo.prototype; // true \n\n\n'Class\" | 91 \n\n\n\n\nWhen a is created by calling new Foo (), one of the things that happens \n(see Chapter 2 for all four steps) is that a gets an internal [[Proto \ntype] ] link to the object that Foo. prototype is pointing at. \n\nStop for a moment and ponder the implications of that statement. \n\nIn class-oriented languages, multiple copies (aka instances) of a class \ncan be made, like stamping something out from a mold. As we saw in \nChapter 4, this happens because the process of instantiating (or in¬ \nheriting from) a class means, “copy the behavior plan from that class \ninto a physical object,” and this is done again for each new instance.","metadata":{"loc":{"lines":{"from":21330,"to":21358}}}}],["511",{"pageContent":"But in JavaScript, there are no such copy actions performed. You don’t \ncreate multiple instances of a class. You can create multiple objects that \nare [ [Prototype] ]-linked to a common object. But by default, no \ncopying occurs, and thus these objects don’t end up totally separate \nand disconnected from each other, but rather, quite linked. \n\nnew Foo( ) results in a new object (we called it a), and that new object \na is internally [ [Prototype] ]-linked to the Foo.prototype object. \n\nWe end up with two objects, linked to each other. That’s it. We didn’t \ninstantiate a class. We certainly didn’t do any copying of behavior from \na “class” into a concrete object. We just caused two objects to be linked \nto each other.","metadata":{"loc":{"lines":{"from":21360,"to":21372}}}}],["512",{"pageContent":"In fact, the secret, which eludes most JS developers, is that the new \nFoo( ) function calling had really almost nothing direct to do with the \nprocess of creating the link. It was sort of an accidental side effect, new \nFoo( ) is an indirect, roundabout way to end up with what we want: a \nnew object linked to another object. \n\nCan we get what we want in a more direct way? Yes! The hero is \nObject. create( ..). But we’ll get to that in a little bit. \n\nWhat's in a name? \n\nIn JavaScript, we don’t make copies from one object (“class”) to another \n(“instance”). We make links between objects. For the [ [Prototype] ] \nmechanism, visually, the arrows move from right to left, and from \nbottom to top: \n\n\n92 | Chapter 5: Prototypes","metadata":{"loc":{"lines":{"from":21374,"to":21391}}}}],["513",{"pageContent":"92 | Chapter 5: Prototypes \n\n\n\n\n\n\nThis mechanism is often called prototypal inheritance (we’ll explore \nthe code in detail shortly), which is commonly said to be the dynamic- \nlanguage version of classical inheritance. It’s an attempt to piggyback \non the common understanding of what “inheritance” means in the \nclass-oriented world, but tweak (read: pave over) the understood se¬ \nmantics, to fit dynamic scripting. \n\nThe word “inheritance” has a very strong meaning (see Chapter 4), \nwith plenty of mental precedent. Merely adding “prototypal” in front \nto distinguish the actually nearly opposite behavior in JavaScript has \nleft in its wake nearly two decades of miry confusion.","metadata":{"loc":{"lines":{"from":21391,"to":21408}}}}],["514",{"pageContent":"I like to say that sticking “prototypal” in front of “inheritance” to dras¬ \ntically reverse its actual meaning is like holding an orange in one hand, \nan apple in the other, and insisting on calling the apple a “red orange.” \nNo matter what confusing label I put in front of it, that doesn’t change \nthe fact that one fruit is an apple and the other is an orange. \n\nThe better approach is to plainly call an apple an apple—to use the \nmost accurate and direct terminology. That makes it easier to under¬ \nstand both their similarities and their many differences, because we \nall have a simple, shared understanding of what “apple” means. \n\nBecause of the confusion and conflation of terms, I believe the label \n“prototypal inheritance” itself (and trying to misapply all its associated \nclass-orientation terminology, like “class,” “constructor,” “instance,” \n“polymorphism,” etc.) has done more harm than good in explaining \nhow JavaScript’s mechanism really works. \n\n\n'Class\" | 93","metadata":{"loc":{"lines":{"from":21410,"to":21428}}}}],["515",{"pageContent":"'Class\" | 93 \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nInheritance implies a copy operation, and JavaScript doesn’t copy ob¬ \nject properties (natively, by default). Instead, JS creates a link between \ntwo objects, where one object can essentially delegate property/func¬ \ntion access to another object. Delegation (see Chapter 6) is a much \nmore accurate term for JavaScript’s object-linking mechanism. \n\nAnother term that is sometimes thrown around in JavaScript is dif¬ \nferential inheritance. The idea here is that we describe an object’s be¬ \nhavior in terms of what is different from a more general descriptor. \nFor example, you explain that a car is a kind of vehicle, but one that \nhas exactly four wheels, rather than redescribing all the specifics of \nwhat makes up a general vehicle (engine, etc.).","metadata":{"loc":{"lines":{"from":21428,"to":21457}}}}],["516",{"pageContent":"If you try to think of any given object in JS as the sum total of all \nbehavior that is available via delegation, and in your mind you flatten \nall that behavior into one tangible thing, then you can (sorta) see how \ndifferential inheritance might fit. \n\nBut just like with prototypal inheritance, differential inheritance pre¬ \ntends that your mental model is more important than what is phys- \ncially happening in the language. It overlooks the fact that object B is \nnot actually differentially constructed, but is instead built with specific \ncharacteristics defined, alongside “holes” where nothing is defined. It \nis in these “holes” (gaps in, or lack of, definition) that delegation can \ntake over and, on the fly, “fill them in” with delegated behavior.","metadata":{"loc":{"lines":{"from":21459,"to":21470}}}}],["517",{"pageContent":"The object is not, by native default, flattened into the single differential \nobject, through copying, that the mental model of differential inheri¬ \ntance implies. As such, differential inheritance is just not as natural a \nfit for describing how JavaScript’s [[Prototype]] mechanism actually \nworks. \n\nYou can choose to prefer the differential inheritance terminology and \nmental model, as a matter of taste, but there’s no denying the fact that \nit only fits the mental acrobatics in your mind, not the physical be¬ \nhavior in the engine. \n\n\"Constructors\" \n\nLet’s go back to some earlier code: \n\nfunction Foo() { \n\n// ... \n\n} \n\nvar a = new Foo(); \n\n\n94 | Chapter 5: Prototypes \n\n\n\n\n\nWhat exactly leads us to think Foo is a “class”?","metadata":{"loc":{"lines":{"from":21472,"to":21502}}}}],["518",{"pageContent":"\"Constructors\" \n\nLet’s go back to some earlier code: \n\nfunction Foo() { \n\n// ... \n\n} \n\nvar a = new Foo(); \n\n\n94 | Chapter 5: Prototypes \n\n\n\n\n\nWhat exactly leads us to think Foo is a “class”? \n\nFor one, we see the use of the new keyword, just as we see in class- \noriented languages when they construct class instances. For another, \nit appears that we are in fact executing a constructor method of a class, \nbecause Foo () is actually a method that gets called, just like how a real \nclass’s constructor gets called when you instantiate that class. \n\nTo further the confusion of “constructor” semantics, the arbitrarily \nlabeled Foo. prototype object has another trick up its sleeve. Consider \nthis code: \n\nfunction Foo() { \n\n// ... \n\n} \n\nFoo.prototype.constructor === Foo; // true \n\nvar a = new Foo(); \na.constructor === Foo; // true","metadata":{"loc":{"lines":{"from":21502,"to":21542}}}}],["519",{"pageContent":"function Foo() { \n\n// ... \n\n} \n\nFoo.prototype.constructor === Foo; // true \n\nvar a = new Foo(); \na.constructor === Foo; // true \n\nThe Foo. prototype object by default (at declaration-time on line 1 of \nthe snippet!) gets a public, nonenumerable (see Chapter 3) property \ncalled . constructor, and this property is a reference back to the func¬ \ntion (Foo in this case) that the object is associated with. Moreover, we \nsee that object a created by the “constructor” call new Foo() seems to \nalso have a property on it called . constructor, which similarly points \nto “the function which created it.” \n\n\n\nThis is not actually true, a has no .constructor property on \nit, and though a.constructor does in fact resolve to the Foo \nfunction, “constructor” does not actually mean “was construc¬ \nted by,” as it appears. We’ll explain this strangeness shortly.","metadata":{"loc":{"lines":{"from":21542,"to":21566}}}}],["520",{"pageContent":"Oh, yeah, also...by convention in the JavaScript world, a “class” is \nnamed with a capital letter, so the fact that it’s Foo instead of foo is a \nstrong clue that we intend it to be a “class.” That’s totally obvious to \nyou, right!? \n\n\n'Class\" | 95 \n\n\n\n\n\n\nThis convention is so strong that many JS linters actually com¬ \nplain if you call new on a method with a lowercase name, or if \nwe don’t call new on a function that happens to start with a \n^ capital letter. It sort of boggles the mind that we struggle so \nmuch to get (fake) “class orientation” right in JavaScript that \nwe create linter rules to ensure we use capital letters, even \nthough the capital letter doesn’t mean anything at all to the JS \nengine. \n\n\nConstructor or call? \n\nIn the previous snippet, it’s tempting to think that Foo is a constructor, \nbecause we call it with new and we observe that it “constructs” an object.","metadata":{"loc":{"lines":{"from":21569,"to":21595}}}}],["521",{"pageContent":"Constructor or call? \n\nIn the previous snippet, it’s tempting to think that Foo is a constructor, \nbecause we call it with new and we observe that it “constructs” an object. \n\nIn reality, Foo is no more a “constructor” than any other function in \nyour program. Functions themselves are not constructors. However, \nwhen you put the new keyword in front of a normal function call, that \nmakes that function call a “constructor call.” In fact, new sort of hijacks \nany normal function and calls it in a fashion that constructs an object, \nin addition to whatever else it was going to do. \n\nFor example: \n\nfunction NothingSpecial( ) { \n\nconsole.log( \"Don't mind me!\" ); \n\n1 \n\nvar a = new NothingSpecialQ; \n\n// \"Don't mind me!\" \n\na; // {} \n\nNothingSpecial is just a plain old normal function, but when called \nwith new, it constructs an object, almost as a side effect, which we hap¬ \npen to assign to a. The call was a constructor call, but NothingSpe \ncial is not, in and of itself, a constructor.","metadata":{"loc":{"lines":{"from":21595,"to":21624}}}}],["522",{"pageContent":"In other words, in JavaScript, it’s most appropriate to say that a “con¬ \nstructor” is any function called with the new keyword in front of it. \n\nFunctions aren’t constructors, but function calls are “constructor calls” \nif and only if new is used. \n\n\n96 | Chapter 5: Prototypes \n\n\n\n\n\n\nMechanics \n\nAre those the only common triggers for ill-fated “class” discussions in \nJavaScript? \n\nNot quite. JS developers have strived to simulate as much as they can \nof class orientation: \n\nfunction Foo(name) { \nthis. name = name; \n\n} \n\nFoo.prototype.myName = function!) { \nreturn this. name; \n\n}; \n\nvar a = new Foo( \"a\" ); \nvar b = new Foo( \"b\" ); \n\na. myName(); // \"a\" \n\nb. myNameQ; // \"b\" \n\nThis snippet shows two additional “class orientation” tricks in play: \n\n1. this.name = name adds the .name property onto each object (a \nand b, respectively; see Chapter 2 about this binding), similar to \nhow class instances encapsulate data values.","metadata":{"loc":{"lines":{"from":21626,"to":21669}}}}],["523",{"pageContent":"1. this.name = name adds the .name property onto each object (a \nand b, respectively; see Chapter 2 about this binding), similar to \nhow class instances encapsulate data values. \n\n2. Foo.prototype.myName = ... is perhaps the more interesting \ntechnique; this adds a property (function) to the Foo. prototype \nobject. Now, a. myName() works, but perhaps surprisingly. How? \n\nIn the previous snippet, it’s strongly tempting to think that when a and \nb are created, the properties/functions on the Foo.prototype object \nare copied over to each of the a and b objects. However, that’s not what \nhappens. \n\nAtthe beginning of this chapter, we explained the [[Prototype]] link, \nand how it provides the fallback lookup steps if a property reference \nisn’t found directly on an object, as part of the default [[Get]] \nalgorithm.","metadata":{"loc":{"lines":{"from":21669,"to":21685}}}}],["524",{"pageContent":"So, by virtue of how they are created, a and b each end up with an \ninternal [[Prototype]] linkage to Foo.prototype. When myName is \nnot found on a or b, respectively, it’s instead found (through delega¬ \ntion; see Chapter 6) on Foo.prototype. \n\n\n'Class\" | 97 \n\n\n\n\n\"Constructor\" redux \n\nRecall the discussion from earlier about the .constructor property, \nand how it seems like a. constructor === Foo being true means that \na has an actual .constructor property on it, pointing at Foo? Not \ncorrect. \n\nThis is just unfortunate confusion. In actuality, the .constructor \nreference is also delegated up to Foo .prototype, which happens to, by \ndefault, have a .constructor that points at Foo.","metadata":{"loc":{"lines":{"from":21687,"to":21707}}}}],["525",{"pageContent":"This is just unfortunate confusion. In actuality, the .constructor \nreference is also delegated up to Foo .prototype, which happens to, by \ndefault, have a .constructor that points at Foo. \n\nIt seems awfully convenient that an obj ect a “constructed by” F oo would \nhave access to a . constructor property that points to Foo. But that’s \nnothing more than a false sense of security. It’s a happy accident, almost \ntangentially, that a .constructor happens to point at Foo via this de¬ \nfault [ [Prototype] ] delegation. There are actually several ways that \nthe ill-fated assumption of .constructor meaning “was constructed \nby” can come back to bite you. \n\nFor one, the . constructor property on Foo . prototype is only there \nby default on the object created when Foo the function is declared. If \nyou create a new object, and replace a function’s default .prototype \nobject reference, the new object will not by default magically get \na .constructor on it. \n\nConsider:","metadata":{"loc":{"lines":{"from":21707,"to":21725}}}}],["526",{"pageContent":"Consider: \n\nfunction Foo() { /* .. */ } \n\nFoo.prototype ={/*.. */};// create a new prototype object \n\nvar at = new Foo(); \n\nal.constructor === Foo; // false! \n\nal.constructor === Object; // true! \n\nObjectf • •) didn’t “construct” al, did it? It sure seems like Foo() \n“constructed” it. Most developers think of Foo() as doing the \nconstruction, but where everything falls apart is when you think “con¬ \nstructor” means “was constructed by,” because by that reasoning, \nal.constructor should be Foo, but it isn’t! \n\nWhat’s happening? al has no .constructor property, so it delegates \nup the [ [ Prototype] ] chain to Foo. prototype. But that object doesn’t \nhave a .constructor either (like the default Foo.prototype object \nwould have had!), so it keeps delegating, this time up to Object. pro \ntotype, the top of the delegation chain. That object indeed has \n\n\n98 | Chapter 5: Prototypes \n\n\n\na .constructor on it, which points to the built-in Object(..) \nfunction. \n\nMisconception: busted.","metadata":{"loc":{"lines":{"from":21725,"to":21757}}}}],["527",{"pageContent":"98 | Chapter 5: Prototypes \n\n\n\na .constructor on it, which points to the built-in Object(..) \nfunction. \n\nMisconception: busted. \n\nOf course, you can add .constructor back to the Foo.prototype \nobject, but this takes manual work, especially if you want to match \nnative behavior and have it be nonenumerable (see Chapter 3). \n\nFor example: \n\nfunction Foo() { /* .. */ } \n\nFoo.prototype ={/*.. */};// create a new prototype object \n\n// Need to properly \"fix\" the missing '.constructor' \n\n// property on the new object serving as 'Foo.prototype'. \n\n// See Chapter 3 for 'defineProperty(..)'. \n\nObject. defineProperty( Foo.prototype, \"constructor\" , { \nenumerable: false, \nwritable: true, \nconfigurable: true, \n\nvalue: Foo //point '.constructor' at 'Foo' \n\n} ); \n\nThat’s a lot of manual work to fix . constructor. Moreover, all we’re \nreally doing is perpetuating the misconception that “constructor” \nmeans “was constructed by.” That’s an expensive illusion.","metadata":{"loc":{"lines":{"from":21757,"to":21793}}}}],["528",{"pageContent":"That’s a lot of manual work to fix . constructor. Moreover, all we’re \nreally doing is perpetuating the misconception that “constructor” \nmeans “was constructed by.” That’s an expensive illusion. \n\nThe fact is, . constructor on an object arbitrarily points, by default, \nat a function that, reciprocally, has a reference back to the object—a \nreference that it calls . prototype. The words “constructor” and “pro¬ \ntotype” only have a loose default meaning that might or might not hold \ntrue later. The best thing to do is remind yourself that “constructor \ndoes not mean constructed by.” \n\n. constructor is not a magic immutable property. It is nonenumerable \n(see previous snippet), but its value is writable (can be changed), and \nmoreover, you can add or overwrite (intentionally or accidentally) a \nproperty of the name constructor on any object in any [[Proto \ntype] ] chain, with any value you see fit.","metadata":{"loc":{"lines":{"from":21793,"to":21808}}}}],["529",{"pageContent":"By virtue of how the [[Get]] algorithm traverses the [[Proto \ntype]] chain, a .constructor property reference found anywhere \nmay resolve quite differently than you’d expect. \n\nSee how arbitrary its meaning actually is? \n\n\n'Class\" | 99 \n\n\n\nThe result? Some arbitrary object-property reference like al.con \nst ructor cannot actually be trusted to be the assumed default function \nreference. Moreover, as we’ll see shortly, just by simple omission, \nal. constructor can even end up pointing somewhere quite surpris¬ \ning and insensible. \n\nal.constructor is extremely unreliable, and it’s an unsafe reference \nto rely upon in your code. Generally, such references should be avoided \nwhere possible. \n\n(Prototypal) Inheritance \n\nWe’ve seen some approximations of class mechanics as typically \nhacked into JavaScript programs. But JavaScript classes would be rath¬ \ner hollow if we didn’t have an approximation of “inheritance.”","metadata":{"loc":{"lines":{"from":21810,"to":21835}}}}],["530",{"pageContent":"Actually, we’ve already seen the mechanism commonly called proto¬ \ntypal inheritance at work when a was able to “inherit from” Foo. pro \ntotype, and thus get access to the myName( ) function. But we tradi¬ \ntionally think of inheritance as being a relationship between two \nclasses, rather than between class and instance: \n\n\n\nRecall this figure from earlier, which shows not only delegation from \nan object (aka “instance”) al to object Foo.prototype, but from \nBar.prototype to Foo.prototype, which somewhat resembles the \nconcept of parent-child class inheritance. Resembles, except of course \nfor the direction of the arrows, which show these are delegation links \nrather than copy operations. \n\n\n100 | Chapters: Prototypes \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nAnd, here’s the typical “prototype-style” code that creates such links: \n\nfunction Foo(name) { \nthis. name = name; \n\n} \n\nFoo.prototype.myName = functionQ { \nreturn this. name; \n\n}; \n\n\nfunction Bar(name,tabel) {","metadata":{"loc":{"lines":{"from":21837,"to":21884}}}}],["531",{"pageContent":"function Foo(name) { \nthis. name = name; \n\n} \n\nFoo.prototype.myName = functionQ { \nreturn this. name; \n\n}; \n\n\nfunction Bar(name,tabel) { \n\nFoo.call( this, name ); \nthis. label = label; \n\n} \n\n// here, we make a new 'Bar.prototype' \n\n// linked to 'Foo.prototype' \n\nBar . prototype = Object. create( Foo.prototype ); \n\n// Beware! Now 'Bar.prototype.constructor' is gone, \n// and night need to be nanually \"fixed\" if you're \n// in the habit of relying on such properties! \n\nBar.prototype.myLabel = functionQ { \nreturn this. label; \n\n}; \n\n\nvar a = new Bar( \"a\", \"obj a\" ); \n\na. myName Q; // \"a\" \na.myLabelQ; // \"obj a\" \n\n\n\nTo understand why this points to a in the previous code snip¬ \npet, see Chapter 2. \n\n\nThe important part is Bar.prototype = Object.create( Foo.pro \ntotype ). The call to Object.create( ..) creates a “new” object out \nof thin air, and links that new object’s internal [ [Prototype] ] to the \nobject you specify (Foo. prototype in this case).","metadata":{"loc":{"lines":{"from":21884,"to":21932}}}}],["532",{"pageContent":"In other words, that line says: “make a new Bar dot prototype object \nthat’s linked to Foo dot prototype” \n\nWhen function Bar() { .. } is declared, Bar, like any other func¬ \ntion, has a . prototype link to its default object. But that object is not \n\n\n(Prototypal) Inheritance | 101 \n\n\n\n\nlinked to Foo. prototype like we want. So, we create a new object that \nis linked as we want, effectively throwing away the original incorrectly \nlinked object. \n\nA common misconception here is that either of the following ap¬ \nproaches would also work, but they do not work as you’d expect: \n\n// doesn't work like you want! \n\nBar . prototype = Foo.prototype; \n\n// works kinda like you want, but with \n\n// side effects you probably don't want :( \n\nBar . prototype = new Foo();","metadata":{"loc":{"lines":{"from":21934,"to":21961}}}}],["533",{"pageContent":"// doesn't work like you want! \n\nBar . prototype = Foo.prototype; \n\n// works kinda like you want, but with \n\n// side effects you probably don't want :( \n\nBar . prototype = new Foo(); \n\nBar.prototype = Foo.prototype doesn’t create a new object for \nBar .prototype to be linked to. It just makes Bar. prototype another \nreference to Foo. prototype, which effectively links Bar directly to the \nsame object to which Foo links: Foo. prototype. This means when you \nstart assigning, like Bar. prototype. myLabel = ..., you’re modifying \nnot a separate object but the shared Foo. prototype object itself, which \nwould affect any objects linked to Foo .prototype. This is almost cer¬ \ntainly not what you want. If it is what you want, then you likely don’t \nneed Bar at all, and should just use only Foo and make your code \nsimpler.","metadata":{"loc":{"lines":{"from":21961,"to":21980}}}}],["534",{"pageContent":"Bar. prototype = new Foo() does in fact create a new object that is \nduly linked to Foo. prototype as we’d want. But, it used the Foo(..) \n“constructor call” to do it. If that function has any side effects (such as \nlogging, changing state, registering against other objects, adding data \nproperties to this, etc.), those side effects happen at the time of this \nlinking (and likely against the wrong object!), rather than only when \nthe eventual Bar() “descendents” are created, as would likely be \nexpected. \n\nSo, we’re left with using Object.create(..) to make a new object \nthat’s properly linked, but without having the side effects of calling \nFoo(..). The slight downside is that we have to create a new object, \nthrowing the old one away, instead of modifying the existing default \nobject we’re provided. \n\nIt would be nice if there was a standard and reliable way to modify the \nlinkage of an existing object. Prior to ES6, there’s a nonstandard and","metadata":{"loc":{"lines":{"from":21982,"to":21998}}}}],["535",{"pageContent":"It would be nice if there was a standard and reliable way to modify the \nlinkage of an existing object. Prior to ES6, there’s a nonstandard and \n\nnot fully cross-browser way, via the ._proto_property, which is \n\nsettable. ES6 adds a Object. setPrototypeOf (..) helper utility, which \ndoes the trick in a standard and predictable way. \n\n\n102 | Chapters: Prototypes \n\n\n\nCompare the pre-ES6 and ES6-standardized techniques for linking \nBar .prototype to Foo.prototype, side by side: \n\n// pre-ES6 \n\n// throws away default existing ' Bar.prototype' \n\nBar . prototype = Object. create( Foo.prototype ); \n\n// ES6+ \n\n//modifies existing 'Bar.prototype' \n\nObject. setPrototypeOf( Bar.prototype, Foo.prototype ); \n\nIgnoring the slight performance disadvantage (throwing away an ob¬ \nject that’s later garbage-collected) of the Object.create( ..) ap¬ \nproach, it’s a little bit shorter and may be perhaps a little easier to read \nthan the ES6+ approach. But it’s probably a syntactic wash either way.","metadata":{"loc":{"lines":{"from":21998,"to":22029}}}}],["536",{"pageContent":"Inspecting \"Class\" Relationships \n\nWhat if you have an object like a and want to find out what object (if \nany) it delegates to? Inspecting an instance (just an object in JS) for its \ninheritance ancestry (delegation linkage in JS) is often called intro¬ \nspection (or reflection) in traditional class-oriented environments. \n\nConsider: \n\nfunction Foo() { \n\n// ... \n\n} \n\nFoo.prototype.blah = ...; \nvar a = new Foo(); \n\nHow do we then introspect a to find out its “ancestry” (delegation \nlinkage)? The first approach embraces the “class” confusion: \n\na instanceof Foo; // true \n\nThe instanceof operator takes a plain object as its lefthand operand \nand a function as its righthand operand. The question instanceof \nanswers is: in the entire [[Prototype]] chain of a, does the object \narbitrarily pointed to by Foo .prototype ever appear?","metadata":{"loc":{"lines":{"from":22031,"to":22057}}}}],["537",{"pageContent":"Unfortunately, this means that you can only inquire about the “an¬ \ncestry” of some object (a) if you have some function (Foo, with its \nattached . prototype reference) to test with. If you have two arbitrary \nobjects, say a and b, and want to find out if the objects are related to \n\n\n(Prototypal) Inheritance | 103 \n\n\n\neach other through a [[Prototype]] chain, instanceof alone can’t \nhelp. \n\n\n\nIf you use the built-in ,bind(..) utility to make a hard¬ \nbound function (see Chapter 2), the function created will not \nhave a .prototype property. Using instanceof with such a \nfunction transparently substitutes the .prototype of the tar¬ \nget function that the hard-bound function was created from. \n\n\nIt’s fairly uncommon to use hard-bound functions as “con¬ \nstructor calls”, but if you do, it will behave as if the original \ntarget function was invoked instead, which means that using \ninstanceof with a hard-bound function also behaves accord¬ \ning to the original function.","metadata":{"loc":{"lines":{"from":22059,"to":22085}}}}],["538",{"pageContent":"This snippet illustrates the ridiculousness of trying to reason about \nrelationships between two objects using “class” semantics and \ninstanceof: \n\n// helper utility to see if 'ol' is \n// related to (delegates to) 'o2' \nfunction isRelatedTo(ol, o2) { \nfunction F(){} \n\nF. prototype = o2; \nreturn ol instanceof F; \n\n} \n\nvar a = {}; \n\nvar b = Object. create( a ); \nisRetatedTo( b, a ); // true \n\nInside isRelatedTo( ..), we borrow a throwaway function F, reassign \nits . prototype to arbitrarily point to some object o2, and then ask if \nol is an “instance of” F. Obviously ol wasn’t actually inherited or de¬ \nscended or even constructed from F, so it should be clear why this kind \nof exercise is silly and confusing. The problem comes down to the \nawkwardness of class semantics forced upon JavaScript, in this case as \nrevealed by the indirect semantics of Instanceof. \n\nThe second, and much cleaner, approach to [[Prototype]] reflection \nis: \n\n\nFoo.prototype.IsPrototypeOf ( a ); // true","metadata":{"loc":{"lines":{"from":22088,"to":22119}}}}],["539",{"pageContent":"The second, and much cleaner, approach to [[Prototype]] reflection \nis: \n\n\nFoo.prototype.IsPrototypeOf ( a ); // true \n\nNotice that in this case, we don’t really care (or even need) Foo, we just \nneed an object (in our case, arbitrarily labeled Foo. prototype) to test \n\n\n104 | Chapters: Prototypes \n\n\n\n\nagainst another object. The question isPrototypeOf (..) answers is: \nin the entire [[Prototype]] chain of a, does Foo.prototype ever \nappear? \n\nSame question, and exact same answer. But in this second approach, \nwe don’t actually need the indirection of referencing a function (Foo) \nwhose . prototype property will automatically be consulted. \n\nWe just need two objects to inspect a relationship between them. For \nexample: \n\n// Simply: does b appear anywhere in \n// c's [[Prototype]] chain? \nb.isPrototypeOf ( c );","metadata":{"loc":{"lines":{"from":22119,"to":22147}}}}],["540",{"pageContent":"We just need two objects to inspect a relationship between them. For \nexample: \n\n// Simply: does b appear anywhere in \n// c's [[Prototype]] chain? \nb.isPrototypeOf ( c ); \n\nNotice that this approach doesn’t require a function (“class”) at all. It \njust uses object references directly to b and c, and inquires about their \nrelationship. In other words, our isRelatedTo(..) utility is built in \nto the language, and it’s called IsPrototypeOf (..). \n\nWe can also directly retrieve the [[Prototype]] of an object. As of \nES5, the standard way to do this is: \n\nObject.getPrototypeOf( a ); \n\nAnd you’ll notice that object reference is what we’d expect: \nObject.getPrototypeOf( a ) === Foo.prototype; // true \n\nMost browsers (not all!) have also long supported a nonstandard al¬ \nternate way of accessing the internal [ [Prototype] ]: \n\na._proto_ === Foo.prototype; // true \n\nThe strange ._proto_(not standardized until ES6!) property “mag¬","metadata":{"loc":{"lines":{"from":22147,"to":22172}}}}],["541",{"pageContent":"a._proto_ === Foo.prototype; // true \n\nThe strange ._proto_(not standardized until ES6!) property “mag¬ \n\nically” retrieves the internal [ [Prototype] ] of an object as a reference, \nwhich is quite helpful if you want to directly inspect (or even tra¬ \nverse: ._proto_._proto_ ...) the chain. \n\nJust as we saw earlier with .constructor, ._proto_doesn’t actually \n\nexist on the object you’re inspecting (a in our running example). \nIn fact, it exists (nonenumerable; see Chapter 2) on the built-in \nObject.prototype, along with the other common utilities (.to \nString(), .isPrototypeOf (..), etc.). \n\nMoreover, ._proto_looks like a property, but it’s actually more ap¬ \n\npropriate to think of it as a getter/setter (see Chapter 3). \n\n\n(Prototypal) Inheritance | 105 \n\n\n\nRoughly, we could envision ._proto_implemented (see Chapter 3 \n\nfor object property definitions) like this: \n\nObject. deftneProperty( Object. prototype, \"_proto_ \", { \n\nget: function () { \n\nreturn Object.getPrototypeOf( this );","metadata":{"loc":{"lines":{"from":22172,"to":22204}}}}],["542",{"pageContent":"for object property definitions) like this: \n\nObject. deftneProperty( Object. prototype, \"_proto_ \", { \n\nget: function () { \n\nreturn Object.getPrototypeOf( this ); \n\n}. \n\nset: function(o) { \n\n// setPrototypeOf(..) as of ES6 \nObject. setPrototypeOf ( this, o ); \nreturn o; \n\n} \n\n} ); \n\nSo, when we access (retrieve the value of) a._proto_, it’s like calling \n\na._proto_() (calling the getter function). That function call has a \n\nas its this even though the getter function exists on the Object. pro \ntotype object (see Chapter 2 for this binding rules), so it’s just like \nsaying Object.getPrototypeOf( a ). \n\n. proto is also a settable property, just like using ES6’s Ob j ect. set \n\nPrototypeOf (..) shown earlier. However, generally you should not \nchange the [ [Prototype] ] of an existing object.","metadata":{"loc":{"lines":{"from":22204,"to":22235}}}}],["543",{"pageContent":". proto is also a settable property, just like using ES6’s Ob j ect. set \n\nPrototypeOf (..) shown earlier. However, generally you should not \nchange the [ [Prototype] ] of an existing object. \n\nThere are some very complex, advanced techniques used deep in some \nframeworks that allow tricks like “subclassing” an Array, but this is \ncommonly frowned on in general programming practice, as it usually \nleads to much harder to understand/maintain code. \n\n\n\nAs of ES6, the class keyword will allow something that ap¬ \nproximates “subclassing” of built-ins like Array. See Appen¬ \ndix A for discussion of the class syntax added in ES6.","metadata":{"loc":{"lines":{"from":22235,"to":22249}}}}],["544",{"pageContent":"As of ES6, the class keyword will allow something that ap¬ \nproximates “subclassing” of built-ins like Array. See Appen¬ \ndix A for discussion of the class syntax added in ES6. \n\n\nThe only other narrow exception (as mentioned earlier) would be set¬ \nting the [ [Prototype] ] of a default function’s . prototype object to \nreference some other object (besides Object .prototype). That would \navoid replacing that default object entirely with a new linked object. \nOtherwise, it’s best to treat object [[Prototype]] linkage as a read¬ \nonly characteristic for ease of reading your code later. \n\n\n106 | Chapters: Prototypes \n\n\n\n\n\n\nThe JavaScript community unofficially coined a term for the \ndouble underscore, specifically the leading one in properties \n\nlike _ proto _: “dunder.” So, the “cool kids” in JavaScript \n\nwould generally pronounce_ proto _as “dunder proto.” \n\n\nObject Links","metadata":{"loc":{"lines":{"from":22249,"to":22277}}}}],["545",{"pageContent":"like _ proto _: “dunder.” So, the “cool kids” in JavaScript \n\nwould generally pronounce_ proto _as “dunder proto.” \n\n\nObject Links \n\nAs we’ve now seen, the [[Prototype]] mechanism is an internal link \nthat exists on one object that references some other object. \n\nThis linkage is (primarily) exercised when a property/method refer¬ \nence is made against the first object, and no such property/method \nexists. In that case, the [ [Prototype] ] linkage tells the engine to look \nfor the property/method on the linked-to object. In turn, if that object \ncannot fulfill the lookup, its [[Prototype]] is followed, and so on. \nThis series of links between objects forms what is called the “prototype \nchain.” \n\nCreate()ing Links \n\nWe’ve thoroughly debunked why JavaScript’s [[Prototype]] mecha¬ \nnism is not like classes, and we’ve seen how it instead creates links \nbetween proper objects.","metadata":{"loc":{"lines":{"from":22277,"to":22299}}}}],["546",{"pageContent":"Create()ing Links \n\nWe’ve thoroughly debunked why JavaScript’s [[Prototype]] mecha¬ \nnism is not like classes, and we’ve seen how it instead creates links \nbetween proper objects. \n\nWhat’s the point of the [[Prototype]] mechanism? Why is it so com¬ \nmon for JS developers to go to so much effort (emulating classes) in \ntheir code to wire up these linkages? \n\nRemember we said much earlier in this chapter that Object.ere \nate( ..) would be a hero? Now, we’re ready to see how: \n\nvar foo = { \n\nsomething: functionQ { \n\nconsole.log( \"Tell me something good...\" ); \n\n} \n\n}; \n\n\nvar bar = Object. create( foo ); \n\nbar . something( ); // Tell me something good... \n\nObject.create( ..) creates a new object (bar) linked to the objectwe \nspecified (foo), which gives us all the power (delegation) of the [ [Pro \ntotype] ] mechanism, but without any of the unnecessary complica¬ \ntion of new functions acting as classes and constructor calls, \n\n\nObject Links | 107","metadata":{"loc":{"lines":{"from":22299,"to":22333}}}}],["547",{"pageContent":"Object Links | 107 \n\n\n\n\nconfusing .prototype and .constructor references, or any of that \nextra stuff. \n\n\n\nObject .create(null) creates an object that has an empty (aka \nnull) [[Prototype]] linkage, and thus the object can’t dele¬ \ngate anywhere. Since such an object has no prototype chain, \nthe Instanceof operator (explained earlier) has nothing to \ncheck, so it will always return false. These special empty- \n[ [Prototype] ] objects are often called “dictionaries,” as they \nare typically used purely for storing data in properties, most¬ \nly because they have no possible surprise effects from any \ndelegated properties/functions on the [[Prototype]] chain, \nand are thus purely flat data storage. \n\n\nWe don’t need classes to create meaningful relationships between two \nobjects. The only thing we should really care about is objects linked \ntogether for delegation, and Ob ject. create(.. ) gives us that linkage \nwithout all the class cruft. \n\nObject.createO polyfill","metadata":{"loc":{"lines":{"from":22333,"to":22360}}}}],["548",{"pageContent":"Object.createO polyfill \n\nObject. create( ..) was added in ES5. You may need to support pre- \nES5 environments (like older IEs), so let’s take a look at a simple par¬ \ntial polyfill for Ob ject. create(. .) that gives us the capability that we \nneed even in those older JS environments: \n\nif (lObject. create) { \n\nObject. create = function(o) { \nfunction F(){} \n\nF.prototype = o; \nreturn new F(); \n\n}; \n\n} \n\nThis polyfill works by using a throwaway F function, and we override \nits .prototype property to point to the object we want to link to. Then \nwe use new F() construction to make a new object that will be linked \nas we specified. \n\nThis usage of Object. create(.. ) is by far the most common usage, \nbecause it’s the part that can be polyfilled. There’s an additional set of \nfunctionality that the standard ES5 built-in Object . create(. .) pro¬ \nvides, which is not polyfillable for pre-ES5. As such, this capability is \n\n\n108 | Chapters: Prototypes","metadata":{"loc":{"lines":{"from":22360,"to":22390}}}}],["549",{"pageContent":"108 | Chapters: Prototypes \n\n\n\n\n\nfar less commonly used. For completeness sake, let’s look at that ad¬ \nditional functionality: \n\nvar anotherObject = { \na: 2 \n\n}; \n\n\nvar myObject = Object. create( anotherObject, { \n\nb: { \n\nenumerable: false, \nwritable: true, \nconfigurable: false, \nvalue: 3 \n\n}. \n\nc: { \n\nenumerable: true, \nwritable: false, \nconfigurable: false, \nvalue: 4 \n\n} \n\n} ); \n\nmyObject.hasOwnProperty( \"a\" ); // false \n\nmyObject.hasOwnProperty( \"b\" ); // true \n\nmyObject.hasOwnProperty( \"c\" ); // true \n\nmyObject. a; // 2 \nmyObject. b; // 3 \nmyObject.c; // 4 \n\nThe second argument to Object.create(..) specifies property \nnames to add to the newly created object, via declaring each new \nproperty’s property descriptor (see Chapter 3). Because polyfilling \nproperty descriptors into pre-ES5 is not possible, this additional func¬ \ntionality on Object.create(..) cannot be polyfilled.","metadata":{"loc":{"lines":{"from":22390,"to":22441}}}}],["550",{"pageContent":"Thevast majority ofusageofObject.create(..) uses the polyfill-safe \nsubset of functionality, so most developers are fine with using the par¬ \ntial polyfill in pre-ES5 environments. \n\nSome developers take a much stricter view, which is that no function \nshould be polyfilled unless it can be fully polyfilled. Since Object .ere \nate(..) is one of those partial polyfillable utilities, this narrower per¬ \nspective says that if you need to use any of the functionality of Ob \nject.create(..) in a pre-ES5 environment, instead of polyfilling, \nyou should use a custom utility, and stay away from using the name \nObject.create entirely. You could instead define your own utility, \nlike: \n\n\nObject Links | 109 \n\n\n\n\nfunction createAndLlnkObject(o) { \nfunction F(){} \n\nF. prototype = o; \nreturn new F(); \n\n\nvar anotherObject = { \na: 2 \n\n}; \n\n\nvar myObject = createAndLinkObject( anotherObject ); \nnyObject.a; // 2","metadata":{"loc":{"lines":{"from":22443,"to":22476}}}}],["551",{"pageContent":"function createAndLlnkObject(o) { \nfunction F(){} \n\nF. prototype = o; \nreturn new F(); \n\n\nvar anotherObject = { \na: 2 \n\n}; \n\n\nvar myObject = createAndLinkObject( anotherObject ); \nnyObject.a; // 2 \n\nI do not share this strict opinion. I fully endorse the common partial \npolyfill of Object. create( ..) as shown earlier, and using it in your \ncode even in pre-ES5. I’ll leave it to you to make your own decision. \n\nLinks as Fallbacks? \n\nIt may be tempting to think that these links between objects primari¬ \nly provide a sort of fallback for “missing” properties or methods. While \nthat may be an observed outcome, I don’t think it represents the right \nway of thinking about [ [Prototype] ]. \n\nConsider: \n\nvar anotherObject = { \ncoot: functton() { \n\nconsole.log( \"cool!\" ); \n\n} \n\n}; \n\n\nvar myObject = Object. create( anotherObject ); \nmyObject.coolQ; // \"cool!\"","metadata":{"loc":{"lines":{"from":22476,"to":22516}}}}],["552",{"pageContent":"Consider: \n\nvar anotherObject = { \ncoot: functton() { \n\nconsole.log( \"cool!\" ); \n\n} \n\n}; \n\n\nvar myObject = Object. create( anotherObject ); \nmyObject.coolQ; // \"cool!\" \n\nThat code will work by virtue of [ [Prototype] ], but if you wrote it \nthat way so that anotherObject was acting as a fallback just in case \nmyOb ject couldn’t handle some property/method that some developer \nmay try to call, odds are that your software is going to be a bit more \n“magical” and harder to understand and maintain. \n\nThat’s not to say there aren’t cases where fallbacks are an appropriate \ndesign pattern, but it’s not very common or idiomatic in JS, so if you \nfind yourself doing so, you might want to take a step back and recon¬ \nsider if that’s really appropriate and sensible design. \n\n\n110 | Chapters: Prototypes","metadata":{"loc":{"lines":{"from":22516,"to":22543}}}}],["553",{"pageContent":"110 | Chapters: Prototypes \n\n\n\n\n\nIn ES6, an advanced functionality called Proxy is introduced \nthat can provide something of a “method not found” type of \nbehavior. Proxy is beyond the scope of this book, but will be \ncovered in detail in a later book in this series. \n\n\nDon’t miss an important but nuancedpoint here. \n\nDesigning software where you intend for a developer to, for instance, \ncall myObject.coolQ and have that work even though there is no \ncool( ) method on myOb ject, introduces some “magic” into your API \ndesign that can be surprising for future developers who maintain your \nsoftware. \n\nYou can however design your API with less “magic” to it, but still take \nadvantage of the power of [ [Prototype] ] linkage: \n\nvar anotherObject = { \ncool: function! ) { \n\nconsole.log( \"cool!\" ); \n\n} \n\n}; \n\n\nvar myObject = Object. create! anotherObject ); \n\nmyObject.doCool = function!) { \n\nthis.coolQ; // internal delegation! \n\n}; \n\n\nmyObject.doCool!); // \"cool!\"","metadata":{"loc":{"lines":{"from":22543,"to":22585}}}}],["554",{"pageContent":"console.log( \"cool!\" ); \n\n} \n\n}; \n\n\nvar myObject = Object. create! anotherObject ); \n\nmyObject.doCool = function!) { \n\nthis.coolQ; // internal delegation! \n\n}; \n\n\nmyObject.doCool!); // \"cool!\" \n\nHere, we call myObject.doCool!), which is a method that actually \nexists on myObject, making our API design more explicit (less “mag¬ \nical”). Internally, our implementation follows the delegation design \npattern (see Chapter 6), taking advantage of [[Prototype]] delega¬ \ntion to anotherObject.cool(). \n\nIn other words, delegation will tend to be less surprising/confusing if \nit’s an internal implementation detail rather than plainly exposed in \nyour API interface design. We will expound on delegation in great \ndetail in the next chapter. \n\nReview \n\nWhen attempting a property access on an object that doesn’t have that \nproperty, the object’s internal [[Prototype]] linkage defines where \n\n\nReview | 111","metadata":{"loc":{"lines":{"from":22585,"to":22620}}}}],["555",{"pageContent":"Review \n\nWhen attempting a property access on an object that doesn’t have that \nproperty, the object’s internal [[Prototype]] linkage defines where \n\n\nReview | 111 \n\n\n\n\nthe [ [Get] ] operation (see Chapter 3) should look next. This cascad¬ \ning linkage from object to object essentially defines a “prototype chain” \n(somewhat similar to a nested scope chain) of objects to traverse for \nproperty resolution. \n\nAll normal objects have the built-in Object, prototype as the top of \nthe prototype chain (like the global scope in scope lookup), where \nproperty resolution will stop if not found anywhere prior in the chain. \ntoString(), valueOf (), and several other common utilities exist on \nthis Object. prototype object, explaining how all objects in the lan¬ \nguage are able to access them. \n\nThe most common way to get two objects linked to each other is using \nthe new keyword with a function call, which among its four steps (see \nChapter 2) creates a new object linked to another object.","metadata":{"loc":{"lines":{"from":22620,"to":22645}}}}],["556",{"pageContent":"The “another object” that the new object is linked to happens to be the \nobject referenced by the arbitrarily named . prototype property of the \nfunction called with new. Functions called with new are often called \n“constructors,” despite the fact that they are not actually instantiating \na class as constructors do in traditional class-oriented languages. \n\nWhile these JavaScript mechanisms can seem to resemble “class in¬ \nstantiation” and “class inheritance” from traditional class-oriented \nlanguages, the key distinction is that in JavaScript, no copies are made. \nRather, objects end up linked to each other via an internal [ [Proto \ntype]] chain. \n\nFor a variety of reasons, not the least of which is terminology prece¬ \ndent, “inheritance” (and “prototypal inheritance”) and all the other \nOO terms just do not make sense when considering how JavaScript \nactually works (not just applied to our forced mental models).","metadata":{"loc":{"lines":{"from":22647,"to":22662}}}}],["557",{"pageContent":"Instead, “delegation” is a more appropriate term, because these rela¬ \ntionships are not copies but delegation links. \n\n\n112 | Chapters: Prototypes \n\n\n\nCHAPTER 6 \n\n\nBehavior Delegation \n\n\nIn Chapter 5, we addressed the [ [Prototype] ] mechanism in detail, \nand why it’s confusing and inappropriate (despite countless attempts \nfor nearly two decades) to describe it in the context of “class” or “in¬ \nheritance.” We trudged through not only the fairly verbose syntax \n(. prototype littering the code), but the various gotchas (like surpris¬ \ning . constructor resolution or ugly pseudopolymorphic syntax). We \nexplored variations of the “mixin” approach, which many people use \nto attempt to smooth over such rough areas.","metadata":{"loc":{"lines":{"from":22664,"to":22685}}}}],["558",{"pageContent":"It’s a common reaction at this point to wonder why it has to be so \ncomplex to do something seemingly so simple. Now that we’ve pulled \nback the curtain and seen just how dirty it all gets, it’s not a surprise \nthat most JS developers never dive this deep, and instead relegate such \nmess to a “class” library to handle it for them. \n\nI hope by now you’re not content to just gloss over and leave such \ndetails to a “black box” library. Let’s now dig into how we could and \nshould bethinking about the object [[Prototype]] mechanism in JS, \nin a much simpler and more straightforward way than the confusion \nof classes. \n\nAs a brief review of our conclusions from Chapter 5, the [[Proto \ntype] ] mechanism is an internal link that exists on one object that \nreferences another object.","metadata":{"loc":{"lines":{"from":22687,"to":22701}}}}],["559",{"pageContent":"As a brief review of our conclusions from Chapter 5, the [[Proto \ntype] ] mechanism is an internal link that exists on one object that \nreferences another object. \n\nThis linkage is exercised when a property/method reference is made \nagainst the first object, and no such property/method exists. In that \ncase, the [ [Prototype] ] linkage tells the engine to look for the prop¬ \nerty/method on the linked-to object. In turn, if that object cannot fulfill \n\n\n113 \n\n\n\n\nthe lookup, its [ [Prototype] ] is followed, and so on. This series of \nlinks between objects forms what is called the “prototype chain.” \n\nIn other words, the actual mechanism, the essence of what’s important \nto the functionality we can leverage in JavaScript, is all about objects \nbeing linked to other objects. \n\nThat single observation is fundamental and critical to understanding \nthe motivations and approaches for the rest of this chapter! \n\nToward Delegation-Oriented Design","metadata":{"loc":{"lines":{"from":22701,"to":22726}}}}],["560",{"pageContent":"That single observation is fundamental and critical to understanding \nthe motivations and approaches for the rest of this chapter! \n\nToward Delegation-Oriented Design \n\nTo properly focus our thoughts on how to use [ [Prototype] ] in the \nmost straightforward way, we must recognize that it represents a fun¬ \ndamentally different design pattern from classes (see Chapter 4). \n\n\n\nSome principles of class-oriented design are still very valid, so \ndon’t toss out everything you know (just most of it!). For ex¬ \nample, encapsulation is quite powerful, and is compatible \n(though not as common) with delegation. \n\n\nWe need to try to change our thinking from the class/inheritance de¬ \nsign pattern to the behavior delegation design pattern. If you have done \nmost or all of your programming in your education/career thinking \nin classes, this may be uncomfortable or feel unnatural. You may need \nto try this mental exercise quite a few times to get the hang of this very \ndifferent way of thinking.","metadata":{"loc":{"lines":{"from":22726,"to":22748}}}}],["561",{"pageContent":"I’m going to walk you through some theoretical exercises first, then \nwe’ll look side by side at a more concrete example to give you practical \ncontext for your own code. \n\nClass Theory \n\nLet’s say we have several similar tasks (“XYZ,” “ABC,” etc.) that we need \nto model in our software. \n\nWith classes, the way you design the scenario is as follows: define a \ngeneral parent (base) class like Task, defining shared behavior for all \nthe “alike” tasks. Then, you define child classes XYZ and ABC, both of \nwhich inherit from Task, and each of which adds specialized behavior \nto handle its respective task. \n\n\n114 | Chapter 6: Behavior Delegation","metadata":{"loc":{"lines":{"from":22750,"to":22766}}}}],["562",{"pageContent":"114 | Chapter 6: Behavior Delegation \n\n\n\n\n\n\nImportantly, the class design pattern encourages you to employ meth¬ \nod overriding (and polymorphism) to get the most out of inheritance, \nwhere you override the definition of some general Task method in \nyour XYZ task, perhaps even making use of super to call to the base \nversion of that method while adding more behavior to it. You’ll likely \nfind quite a few places where you can “abstract” out general behavior \nto the parent class and specialize (override) it in your child classes. \n\nHere’s some loose pseudocode for that scenario: \n\nclass Task { \nid; \n\n// constructor 'Task()' \n\nTask(ID) { id = ID; } \noutputTaskQ { output( id ); } \n\n} \n\nclass XYZ inherits Task { \nlabel; \n\n// constructor 'XYZ()~ \n\nXYZ(ID,Label) { super( ID ); label = Label; } \noutputTaskQ { superQ; output( label ); } \n\n} \n\nclass ABC inherits Task { \n\n// ... \n\n}","metadata":{"loc":{"lines":{"from":22766,"to":22807}}}}],["563",{"pageContent":"} \n\nclass XYZ inherits Task { \nlabel; \n\n// constructor 'XYZ()~ \n\nXYZ(ID,Label) { super( ID ); label = Label; } \noutputTaskQ { superQ; output( label ); } \n\n} \n\nclass ABC inherits Task { \n\n// ... \n\n} \n\nNow, you can instantiate one or more copies of the XYZ child class, and \nuse those instance(s) to perform task “XYZ.” These instances have \ncopies both of the general Task defined behavior as well as the specific \nXYZ defined behavior. Likewise, instances of the ABC class would have \ncopies of the Task behavior and the specific ABC behavior. After con¬ \nstruction, you will generally only interact with these instances (and \nnot the classes), as the instances each have copies of all the behavior \nyou need to do the intended task. \n\nDelegation Theory \n\nBut now let’s try to think about the same problem domain, using \nbehavior delegation instead of classes.","metadata":{"loc":{"lines":{"from":22807,"to":22837}}}}],["564",{"pageContent":"Delegation Theory \n\nBut now let’s try to think about the same problem domain, using \nbehavior delegation instead of classes. \n\nYou will first define an object (not a class, nor a function as most JSers \nwould lead you to believe) called Task, and it will have concrete be¬ \nhavior on it that includes utility methods that various tasks can use \n\n\nToward Delegation-Oriented Design | 115 \n\n\n\n\n(read: delegate to!). Then, for each task (“XYZ,” “ABC”), you define an \nobject to hold that task-specific data/behavior. You link your task- \nspecific object(s) to the Task utility object, allowing them to delegate \nto it when they need to. \n\nBasically, think about needing behaviors from two sibling/peer objects \n(XYZ and Task) to perform task “XYZ.” But rather than needing to \ncompose them together, via class copies, we can keep them in their \nseparate objects, and we can allow the XYZ object to delegate to Task \nwhen needed. \n\nHere’s some simple code to suggest how you accomplish that:","metadata":{"loc":{"lines":{"from":22837,"to":22863}}}}],["565",{"pageContent":"Here’s some simple code to suggest how you accomplish that: \n\nTask = { \n\nsetID: function(ID) { this. id = ID; }, \noutputID: function() { console.log( this. id ); } \n\n}; \n\n\n// make 'XYZ' delegate to 'Task' \n\nXYZ = Object. create( Task ); \n\nXYZ.prepareTask = function(ID, Label) { \nthis.setID( ID ); \nthis. label = Label; \n\n\nXYZ.outputTaskDetails = function() { \nthis .outputID( ); \nconsole.log( this. label ); \n\n}; \n\n\n// ABC = Object.create( Task ); \n\n//ABC ... = ... \n\nIn this code, Task and XYZ are not classes (or functions), they’re just \nobjects. XYZ is set up via Object.create( ..) to [ [Prototype]]- \ndelegate to the Task object (see Chapter 5). \n\nAs compared to class orientation (aka object orientation), I call this \nstyle of code OLOO (objects linked to other objects). All we really \ncare about is that the XYZ object delegates to the Task object (as does \nthe ABC object).","metadata":{"loc":{"lines":{"from":22863,"to":22900}}}}],["566",{"pageContent":"In JavaScript, the [[Prototype]] mechanism links objects to other \nobjects. There are no abstract mechanisms like “classes,” no matter \nhow much you try to convince yourself otherwise. It’s like paddling a \ncanoe upstream: you can do it, but you’re choosing to go against the \n\n\n116 | Chapter 6: Behavior Delegation \n\n\n\nnatural current, so it’s obviously going to be harder to get where you’re \ngoing. \n\nSome other differences to note with OLOO-style code: \n\n1. Both the id and label data members from the previous class ex¬ \nample are data properties directly on XYZ (neither is on Task). In \ngeneral, with [ [Prototype] ] delegation, you want state to be on \nthe delegators (XYZ, ABC), not on the delegate (Task).","metadata":{"loc":{"lines":{"from":22902,"to":22920}}}}],["567",{"pageContent":"2. With the class design pattern, we intentionally named output \nTask the same on both parent (Task) and child (XYZ), so that we \ncould take advantage of overriding (polymorphism). In behavior \ndelegation, we do the opposite: we avoid if at all possible naming \nthings the same at different levels of the [[Prototype]] chain \n(called shadowing—see Chapter 5), because having those name \ncollisions creates awkward/brittle syntax to disambiguate refer¬ \nences (see Chapter 4), and we want to avoid that if we can. \n\nThis design pattern calls for less use of general method names that \nare prone to overriding and instead more use of descriptive meth¬ \nod names, specific to the type of behavior each object is doing. This \ncan actually create easier to understand/maintain code, because \nthe names of methods (not only at the definition location but \nstrewn throughout other code) are more obvious (self- \ndocumenting).","metadata":{"loc":{"lines":{"from":22922,"to":22937}}}}],["568",{"pageContent":"3. this.setlD(ID); inside of a method on the XYZ object first looks \non XYZ for setID(. .), but since it doesn’t find a method of that \nname on XYZ, [ [Prototype] ] delegation means it can follow the \nlink to Tasktolookfor setID( ..), which it of course finds. More¬ \nover, because of implicit call-site this binding rules (see Chap¬ \nter 2), when setID( ..) runs, even though the method was found \non Task, the this binding for that function call is XYZ, exactly as \nwe’d expect and want. We see the same thing with this.outpu \ntID( ) later in the code listing. \n\nIn other words, the general utility methods that exist on Task are \navailable to us while interacting with XYZ, because XYZ can delegate \nto Task. \n\nBehavior delegation means to let some object (XYZ) provide a delega¬ \ntion (to Task) for property or method references if they are not found \non the object (XYZ). \n\n\nToward Delegation-Oriented Design | 117","metadata":{"loc":{"lines":{"from":22939,"to":22958}}}}],["569",{"pageContent":"Toward Delegation-Oriented Design | 117 \n\n\n\n\nThis is an extremely powerful design pattern, very distinct from the \nideas of parent and child classes, inheritance, polymorphism, etc. \nRather than organizing the objects in your mind vertically, with pa¬ \nrents flowing down to children, think of objects side by side, as peers, \nwith any direction of delegation links between the objects as necessary. \n\n\n\nDelegation is more properly used as an internal implementa¬ \ntion detail rather than exposed directly in the API interface \ndesign. In the previous example, we don’t necessarily intend \nwith our API design for developers to call XYZ.setlDQ \n(though we can, of course!). We sorta hide the delegation as an \ninternal detail of our API, where XYZ. prepareTask( ..) dele¬ \ngates to Task.setID( ..). See “Links as Fallbacks?” on page 110 \nin Chapter 5 for more detail. \n\n\nMutual delegation (disallowed)","metadata":{"loc":{"lines":{"from":22958,"to":22981}}}}],["570",{"pageContent":"Mutual delegation (disallowed) \n\nYou cannot create a cycle where two or more objects are mutually \ndelegated (bidirectionally) to each other. If you link B to A, and then \ntry to link A to B, you will get an error. \n\nIt’s a shame (not terribly surprising, but mildly annoying) that this is \ndisallowed. If you made a reference to a property/method that didn’t \nexist in either place, you’d have an infinite recursion on the [ [Proto \ntype] ] loop. But if all references were strictly present, then B could \ndelegate to A, and vice versa, and it could work. This would mean you \ncould use either obj ect to delegate to the other, for various tasks. There \nare a few niche use cases where this might be helpful. \n\nBut it’s disallowed because engine implementors have observed that \nit’s more performant to check for (and reject!) the infinite circular \nreference once at set-time rather than needing to have the performance \nhit of that guard check every time you look up a property on an object.","metadata":{"loc":{"lines":{"from":22981,"to":22998}}}}],["571",{"pageContent":"Debugged \n\nWe’ll briefly cover a subtle detail that can be confusing to developers. \nIn general, the JS specification does not control how browser developer \ntools should represent specific values/structures to a developer, so each \nbrowser/engine is free to interpret such things as it sees fit. As such, \nbrowsers/tools don’t always agree. Specifically, the behavior we will \nnow examine is currently observed only in Chrome’s Developer Tools. \n\n\n118 | Chapter 6: Behavior Delegation \n\n\n\n\n\n\nConsider this traditional “class constructor” style JS code, as it would \nappear in the console of Chrome Developer Tools: \n\nfunction Foo() {} \nvar at = new Foo(); \nat; // Foo {} \n\nLet’s look at the last line of that snippet: the output of evaluating the \nal expression, which prints Foo {}. Ifyou try this same code in Firefox, \nyou will likely see Object {}. Why the difference? What do these out¬ \nputs mean?","metadata":{"loc":{"lines":{"from":23000,"to":23027}}}}],["572",{"pageContent":"Chrome is essentially saying “{} is an empty object that was constructed \nby a function with name Foo.” Firefox is saying “{} is an empty object \nof general construction from Object .” The subtle difference is that \nChrome is actively tracking, as an internal property, the name of the \nactual function that did the construction, whereas other browsers \ndon’t track that additional information. \n\nIt would be tempting to attempt to explain this with JavaScript \nmechanisms: \n\nfunction Foo() {} \n\nvar al = new Foo(); \n\nal.constructor; // Foo(){'} \nal.constructor.name; // \"Foo\" \n\nSo, is that how Chrome is outputting Foo, by simply examining the \nobject’s . constructor. name? Confusingly, the answer is both yes and \nno. \n\nConsider this code: \nfunction Foo() {} \nvar al = new FooQ; \n\nFoo.prototype.constructor = function Gotcha(){}; \n\nal.constructor; // Cotcha(){} \nal.constructor.name; // \"Gotcha\" \n\nal; // Foo {}","metadata":{"loc":{"lines":{"from":23029,"to":23059}}}}],["573",{"pageContent":"Consider this code: \nfunction Foo() {} \nvar al = new FooQ; \n\nFoo.prototype.constructor = function Gotcha(){}; \n\nal.constructor; // Cotcha(){} \nal.constructor.name; // \"Gotcha\" \n\nal; // Foo {} \n\nEven though we change al.constructor.name to legitimately be \nsomething else (Gotcha), Chrome’s console still uses the Foo name. \n\n\nToward Delegation-Oriented Design | 119 \n\n\n\n\nSo, it would appear the answer to previous question (does it use . con \nstructor. name?) is no; it must track it somewhere else, internally. \n\nBut not so fast! Let’s see how this kind of behavior works with OLOO- \nstyle code: \n\nvar Foo = {}; \n\nvar at = Object. create( Foo ); \nat; // Object {} \n\nObject. deftneProperty( Foo, \"constructor\", { \nenumerable: false, \nvalue: function Gotcha(){} \n\n}); \n\nal; // Gotcha {}","metadata":{"loc":{"lines":{"from":23059,"to":23096}}}}],["574",{"pageContent":"var Foo = {}; \n\nvar at = Object. create( Foo ); \nat; // Object {} \n\nObject. deftneProperty( Foo, \"constructor\", { \nenumerable: false, \nvalue: function Gotcha(){} \n\n}); \n\nal; // Gotcha {} \n\nAh-ha! Gotcha! Here, Chrome’s console did find and use the . con \nstructor. name. Actually, while writing this book, this exact behavior \nwas identified as a bug in Chrome, and by the time you’re reading this, \nit may have already been fixed. So you may instead have seen the cor¬ \nrected al; // Object {}. \n\nAside from that bug, the internal tracking (apparently only for debug \noutput purposes) of the “constructor name” that Chrome does (shown \nin the earlier snippets) is an intentional Chrome-only extension of \nbehavior beyond what the JS specification calls for.","metadata":{"loc":{"lines":{"from":23096,"to":23118}}}}],["575",{"pageContent":"If you don’t use a “constructor” to make your objects, as we’ve dis¬ \ncouraged with OLOO-style code here in this chapter, then you’ll get \nobjects that Chrome does not track an internal “constructor name” for, \nand such objects will correctly only be outputted as Object {}, mean¬ \ning “object generated from Object() construction.” \n\nDon’t think this represents a drawback of OLOO-style coding. When \nyou code with OLOO and behavior delegation as your design pattern, \nwho “constructed” (that is, which function was called with new?) some \nobject is an irrelevant detail. Chrome’s specific internal “constructor \nname” tracking is really only useful if you’re fully embracing class-style \ncoding, but is moot if you’re instead embracing OLOO delegation. \n\n\n120 | Chapter 6: Behavior Delegation \n\n\n\n\n\nMental Models Compared","metadata":{"loc":{"lines":{"from":23120,"to":23140}}}}],["576",{"pageContent":"120 | Chapter 6: Behavior Delegation \n\n\n\n\n\nMental Models Compared \n\nNow that you can see a difference between “class” and “delegation” \ndesign patterns, at least theoretically, let’s see the implications these \ndesign patterns have on the mental models we use to reason about our \ncode. \n\nWe’ll examine some more theoretical (Foo, Bar) code, and compare \nboth ways (OO versus OLOO) of implementing the code. The first \nsnippet uses the classical (“prototypal”) OO style: \n\nfunction Foo(who) { \nthis. me = who; \n\n1 \n\nFoo.prototype.identify = function() { \nreturn \"I an \" + this.ne; \n\n1 ; \n\n\nfunction Bar(who) { \n\nFoo.call( this, who ); \n\n1 \n\nBar . prototype = Object. create( Foo.prototype ); \n\nBar.prototype.speak = function() { \n\nalert( \"Hello, \" + this. identify () + ); \n\n}; \n\n\nvar bl = new Bar( \"bl\" ); \nvar bZ = new Bar( \"b2\" ); \n\nbl.speak(); \n\nb2.speak();","metadata":{"loc":{"lines":{"from":23140,"to":23188}}}}],["577",{"pageContent":"Bar.prototype.speak = function() { \n\nalert( \"Hello, \" + this. identify () + ); \n\n}; \n\n\nvar bl = new Bar( \"bl\" ); \nvar bZ = new Bar( \"b2\" ); \n\nbl.speak(); \n\nb2.speak(); \n\nParent class Foo is inherited by child class Bar, which is then instan¬ \ntiated twice as bl and b2. What we have is bl delegating to Bar. pro \ntotype, which delegates to Foo.prototype. This should look fairly \nfamiliar to you, at this point. Nothing too groundbreaking going on. \n\nNow, let’s implement the exact same functionality using OLOO-style \ncode: \n\nFoo = { \n\ninit: function(who) { \nthis.ne = who; \n\n}. \n\nidentify: functionQ { \n\nreturn \"I an \" + this.ne; \n\n} \n\n\nToward Delegation-Oriented Design | 121 \n\n\n\nBar = Object. create( Foo ); \n\n\nBar.speak = functionQ { \n\nalert( \"Hello, \" + this. identify () + ); \n\n}; \n\n\nvar bl = Object. create( Bar ); \nbl.init( \"bl\" ); \nvar b2 = Object. create( Bar ); \nb2.init( \"b2\" ); \n\nbl.speak(); \n\nb2.speak();","metadata":{"loc":{"lines":{"from":23188,"to":23245}}}}],["578",{"pageContent":"alert( \"Hello, \" + this. identify () + ); \n\n}; \n\n\nvar bl = Object. create( Bar ); \nbl.init( \"bl\" ); \nvar b2 = Object. create( Bar ); \nb2.init( \"b2\" ); \n\nbl.speak(); \n\nb2.speak(); \n\nWe take exactly the same advantage of [ [ Prototype ] ] delegation from \nbl to Bar to Foo as we didin the previous snippet between bl, Bar. pro \ntotype, and Foo. prototype. We still have the same three objects linked \ntogether. \n\nBut, importantly, we’ve greatly simplified all the other stuff going on, \nbecause now we just set up objects linked to each other, without need¬ \ning all the cruft and confusion of things that look (but don’t behave!) \nlike classes, with constructors and prototypes and new calls. \n\nAsk yourself: if I can get the same functionality with OLOO-style code \nas I do with class-style code, but OLOO is simpler and has less things \nto think about, isn’t OLOO better? \n\nLet’s examine the mental models involved between these two snippets.","metadata":{"loc":{"lines":{"from":23245,"to":23273}}}}],["579",{"pageContent":"Let’s examine the mental models involved between these two snippets. \n\nFirst, the class-style code snippet implies this mental model of entities \nand their relationships: \n\n\n122 | Chapter 6: Behavior Delegation \n\n\n\n.constructor \n\n\n\nActually, that’s a little unfair/misleading, because it’s showing a lot of \nextra detail that you don’t technically need to know at all times (though \nyou do need to understand it!). One takeaway is that it’s quite a complex \nseries of relationships. But another takeaway: if you spend the time to \nfollow those relationship arrows around, there’s an amazing amount \nof internal consistency in JS’s mechanisms.","metadata":{"loc":{"lines":{"from":23273,"to":23292}}}}],["580",{"pageContent":"For instance, the ability of a JS function to access calt(..), ap \nply( ..), and bind( ..) (see Chapter 2) is because functions them¬ \nselves are objects, and function-objects also have a [[Prototype]] \nlinkage, to the Function.prototype object, which defines those de¬ \nfault methods that any function-object can delegate to. JS can do those \nthings, and you can too! \n\n\nToward Delegation-Oriented Design | 123 \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nOK, let’s now look at a slightly simplified version of that diagram that \nis a little more “fair” for comparison—it shows only the relevant en¬ \ntities and relationships: \n\n\n\ni_ j \n\n.constructor","metadata":{"loc":{"lines":{"from":23294,"to":23352}}}}],["581",{"pageContent":"OK, let’s now look at a slightly simplified version of that diagram that \nis a little more “fair” for comparison—it shows only the relevant en¬ \ntities and relationships: \n\n\n\ni_ j \n\n.constructor \n\nStill pretty complex, eh? The dotted lines are depicting the implied \nrelationships when you set up the “inheritance” between Foo.proto \ntype and Bar . prototype and haven’t yet fixed the missing . construe \ntor property reference (see ““Constructor” redux” on page 98 in \nChapter 5). Even with those dotted lines removed, the mental model \nis still an awful lot to juggle every time you work with object linkages. \n\n\n124 | Chapter 6: Behavior Delegation \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nNow, let’s look at the mental model for OLOO-style code: \n\nObject.prototype","metadata":{"loc":{"lines":{"from":23352,"to":23405}}}}],["582",{"pageContent":"124 | Chapter 6: Behavior Delegation \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nNow, let’s look at the mental model for OLOO-style code: \n\nObject.prototype \n\n\n\nAs you can see comparing them, it’s quite obvious that OLOO-style \ncode has vastly less stuff to worry about, because OLOO-style code \nembraces the fact that the only thing we ever really cared about was \nthe objects linked to other objects. \n\nAll the other “class” cruft was a confusing and complex way of getting \nthe same end result. Remove that stuff, and things get much simpler \n(without losing any capability). \n\nClasses Versus Objects \n\nWe’ve just seen various theoretical explorations and mental models of \n“classes” versus “behavior delegation.” But, let’s now look at more con¬ \ncrete code scenarios to show how’d you actually use these ideas. \n\n\nClasses Versus Objects | 125 \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nWe’ll first examine a typical scenario in frontend web dev: creating UI \nwidgets (buttons, drop-downs, etc.). \n\nWidget \"Classes\"","metadata":{"loc":{"lines":{"from":23405,"to":23486}}}}],["583",{"pageContent":"Classes Versus Objects | 125 \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nWe’ll first examine a typical scenario in frontend web dev: creating UI \nwidgets (buttons, drop-downs, etc.). \n\nWidget \"Classes\" \n\nBecause you’re probably still so used to the OO design pattern, you’ll \nlikely immediately think of this problem domain in terms of a parent \nclass (perhaps called Widget) with all the common base widget be¬ \nhavior, and then child derived classes for specific widget types (like \n\nButton). \n\n\n\nWe’re going to use j Query here for DOM and CSS manipula¬ \ntion, only because it’s a detail we don’t really care about for the \npurposes of our current discussion. None of this code cares \nwhich JS framework (jQuery, Dojo, YUI, etc.), if any, you might \nsolve such mundane tasks with. \n\n\nLet’s examine how we’d implement the “class” design in classic-style \npure JS without any “class” helper library or syntax: \n\n// Parent class","metadata":{"loc":{"lines":{"from":23486,"to":23533}}}}],["584",{"pageContent":"Let’s examine how we’d implement the “class” design in classic-style \npure JS without any “class” helper library or syntax: \n\n// Parent class \n\nfunction Widget(width,height) { \nthis. width = width || 50; \nthis. height = height || 50; \nthis.$etem = null; \n\n\nWidget . prototype.render = function($where){ \nif (this.$elem) { \n\nthis.$elem.css( { \n\nwidth: this. width + \"px\", \nheight: this. height + \"px\" \n\n} ).appendTo( $where ); \n\n} \n\n\n// Child class \n\nfunction Button(width,height,label) { \n\n// \"super\" constructor call \nWidget.call( this, width, height ); \nthis. label = label || \"Default\"; \n\nthis.$elem = $( \"<button>\" ).text( this. label ); \n\n} \n\n// nake 'Button' \"inherit\" fron 'Widget' \n\nButton.prototype = Object. create( Widget . prototype ); \n\n\n126 | Chapter 6: Behavior Delegation \n\n\n\n\n\n// override base \"inherited\" 'render(..)' \n\nButton.prototype.render = function($where) { \n\n// \"super\" call","metadata":{"loc":{"lines":{"from":23533,"to":23584}}}}],["585",{"pageContent":"126 | Chapter 6: Behavior Delegation \n\n\n\n\n\n// override base \"inherited\" 'render(..)' \n\nButton.prototype.render = function($where) { \n\n// \"super\" call \n\nWidget . prototype.render. call( this, $where ); \nthls.$elem.cllck( this.onCllck.blnd( this ) ); \n\n\nButton.prototype.onCllck = functlon(evt) { \n\nconsole.log( \"Button + this. label + clicked!\" ); \n\n}; \n\n\n$( document ).ready( function(){ \nvar $body = $( document. body ); \nvar btnl = new Button( 125, 30, \"Hello\" ); \nvar btn2 = new Button( 150, 40, \"World\" ); \n\nbtnl.render( $body ); \nbtn2.render( $body ); \n\n} ); \n\nOO design patterns tell us to declare a base render(..) in the parent \nclass, then override it in our child class, not to replace it per se, but \nrather to augment the base functionality with button-specific behavior.","metadata":{"loc":{"lines":{"from":23584,"to":23619}}}}],["586",{"pageContent":"Notice the ugliness of explicit pseudopolymorphism (see Chapter 4) \nwith Widget. call and Widget.prototype.render. call references \nfor faking “super” calls from the child “class” methods back up to the \n“parent” class base methods. Yuck. \n\nES6 class sugar \n\nWe cover ES6 class syntax sugar in detail in Appendix A, but let’s \nbriefly demonstrate how we’d implement the same code using class: \n\nclass Widget { \n\nconstructor(wldth,height) { \nthis. width = width || 50; \nthis. height = height || 50; \nthis.$elem = null; \n\n} \n\nrender($where){ \n\nif (this.$elem) { \n\nthis.$elem.css( { \n\nwidth: this. width + \"px\", \nheight: this. height + \"px\" \n\n} ).appendTo( $where ); \n\n} \n\n} \n\n} \n\n\nClasses Versus Objects | 127 \n\n\n\nclass Button extends Widget { \n\nconstructor(width,height , label) { \nsuper( width, height ); \nthis. label = label || \"Default\"; \nthis.$elem = $( \"<button>\" ).text( this. label ); \n\n} \n\nrender($where) { \n\nsuper( $where ); \n\nthis.$elem.click( this.onClick.bind( this ) ); \n\n}","metadata":{"loc":{"lines":{"from":23621,"to":23677}}}}],["587",{"pageContent":"} \n\nrender($where) { \n\nsuper( $where ); \n\nthis.$elem.click( this.onClick.bind( this ) ); \n\n} \n\nonClick(evt) { \n\nconsole.log( \"Button + this. label + clicked!\" ); \n\n} \n\n} \n\n$( document ).ready( function(){ \nvar $body = $( document. body ); \nvar btnl = new Button( 125, 30, \"Hello\" ); \nvar btn2 = new Button( 150, 40, \"World\" ); \n\nbtnl.render( $body ); \nbtn2.render( $body ); \n\n} ); \n\nUndoubtedly, a number of the syntax uglies of the previous classical \napproach have been smoothed over with ES6’s class. The presence of \na super( ..) in particular seems quite nice (though when you dig into \nit, it’s not all roses!).","metadata":{"loc":{"lines":{"from":23677,"to":23708}}}}],["588",{"pageContent":"Despite syntactic improvements, these are not real classes, as they still \noperate on top of the [[Prototype]] mechanism. They suffer from \nall the same mental-model mismatches we explored in Chapters 4 and \n5 and thus far in this chapter. Appendix A will expound on the ES6 \nclass syntax and its implications in detail. We’ll see why solving syntax \nhiccups doesn’t substantially solve our class confusions in JS, though \nit makes a valiant effort masquerading as a solution! \n\nWhether you use the classic prototypal syntax or the new ES6 sugar, \nyou’ve still made a choice to model the problem domain (UI widgets) \nwith “classes.” And as the previous few chapters try to demonstrate, \nthis choice in JavaScript is opting you into extra headaches and mental \ntax. \n\n\n128 | Chapter 6: Behavior Delegation \n\n\n\n\n\nDelegating Widget Objects \n\nHere’s our simpler Widget/Button example, using OLOO-style \ndelegation: \n\nvar Widget = {","metadata":{"loc":{"lines":{"from":23710,"to":23736}}}}],["589",{"pageContent":"128 | Chapter 6: Behavior Delegation \n\n\n\n\n\nDelegating Widget Objects \n\nHere’s our simpler Widget/Button example, using OLOO-style \ndelegation: \n\nvar Widget = { \n\ninit: functlon(wldth, height)! \nthis. width = width || 50; \nthis. height = height || 50; \nthis.$elem = null; \n\n}. \n\ninsert: function($where){ \nif (this.$elem) { \n\nthis.$elem.css( { \n\nwidth: this. width + \"px\", \nheight: this. height + \"px\" \n\n} ).appendTo( $where ); \n\n} \n\n} \n\n}; \n\nvar Button = Object. create( Widget ); \n\nButton.setup = function(width,height, label)! \n\n// delegated call \nthis.init( width, height ); \nthis. label = label || \"Default\"; \n\nthis.$elem = $( \"<button>\" ).text( this. label ); \n\n}; \n\nButton.build = function($where) ! \n\n// delegated call \nthis. insert! $where ); \n\nthis. $elem. click( this.onClick.bind( this ) ); \n\n}; \n\nButton.onClick = function(evt) ! \n\nconsole.log( \"Button + this. label + clicked!\" ); \n\n\n$( document ). ready! function! )! \nvar $body = $( document. body );","metadata":{"loc":{"lines":{"from":23736,"to":23799}}}}],["590",{"pageContent":"}; \n\nButton.onClick = function(evt) ! \n\nconsole.log( \"Button + this. label + clicked!\" ); \n\n\n$( document ). ready! function! )! \nvar $body = $( document. body ); \n\nvar btnl = Object. create! Button ); \nbtnl.setup! 125, 30, \"Hello\" ); \n\nvar btn2 = Object. create! Button ); \nbtn2.setup! 150, 40, \"World\" ); \n\nbtnl.build( $body ); \nbtn2.build( $body ); \n\n\nClasses Versus Objects | 129 \n\n\n\nWith this OLOO-style approach, we don’t think of Widget as a parent \nand Button as a child. Rather, Widget is just an object and is sort of a \nutility collection that any specific type of widget might want to delegate \nto, and Button is also just a standalone object (with a delegation link \nto Widget, of course!).","metadata":{"loc":{"lines":{"from":23799,"to":23827}}}}],["591",{"pageContent":"From a design pattern perspective, we didn’t share the same method \nname render(. .) in both objects, the way classes suggest, but instead \nwe chose different names (insert(..)andbuild(..)) that were more \ndescriptive of what task each does specifically. The initialization \nmethods are called ini t(..) andsetup(.. ), respectively, for the same \nreasons. \n\nNot only does this delegation design pattern suggest different and \nmore descriptive names (rather than shared and more generic names), \nbut doing so with OLOO happens to avoid the ugliness of the explicit \npseudopolymorphic calls (Widget.call and Widget.prototype, ren \nder.call), as you can see by the simple, relative, delegated calls to \nthis.init( ..) and this.insert( ..). \n\nSyntactically, we also don’t have any constructors, .prototype, or new \npresent, as they are, in fact, just unnecessary cruft.","metadata":{"loc":{"lines":{"from":23829,"to":23844}}}}],["592",{"pageContent":"Syntactically, we also don’t have any constructors, .prototype, or new \npresent, as they are, in fact, just unnecessary cruft. \n\nNow, if you’re paying close attention, you may notice that what was \npreviously just one call (var btnl = new Button(. .)) is now two \ncalls (var btnl = Object.create(Button) and btnl.setup(..)). \nInitially this may seem like a drawback (more code). \n\nHowever, even this is something that’s a pro of OLOO-style code as \ncompared to classical prototype style code. How? \n\nWith class constructors, you are forced (not really, but it is strongly \nsuggested) to do both construction and initialization in the same step. \nHowever, there are many cases where being able to do these two steps \nseparately (as you do with OLOO!) is more flexible.","metadata":{"loc":{"lines":{"from":23844,"to":23858}}}}],["593",{"pageContent":"For example, let’s say you create all your instances in a pool at the \nbeginning of your program, but you wait to initialize them with a \nspecific setup when they are pulled from the pool and used. We showed \nthe two calls happening right next to each other, but of course they can \nhappen at very different times and in very different parts of our code, \nas needed. \n\n\n130 | Chapter 6: Behavior Delegation \n\n\n\n\n\nOLOO better supports the principle of separation of concerns, \n\nwhere creation and initialization are not necessarily conflated into the \nsame operation. \n\nSimpler Design \n\nIn addition to OLOO providing ostensibly simpler (and more flexi¬ \nble!) code, behavior delegation as a pattern can actually lead to simpler \ncode architecture. Let’s examine one last example that illustrates how \nOLOO simplifies your overall design.","metadata":{"loc":{"lines":{"from":23860,"to":23884}}}}],["594",{"pageContent":"The scenario we’ll examine is two controller objects, one for handling \nthe login form of a web page, and another for actually handling the \nauthentication (communication) with the server. \n\nWe’ll need a utility helper for making the Ajax communication to the \nserver. We’ll use jQuery (though any framework would do fine), since \nit handles not only the Ajax for us, but it returns a Promise-like answer \nso that we can listen for the response in our calling code \nwith .then(..). \n\n\n\nWe don’t cover Promises here, but we will cover them in a \nfuture title of this series. \n\n\nFollowing the typical class design pattern, we’ll put the base function¬ \nality of the task in a class called Controller, and then we’ll derive two \nchild classes, LoglnController and AuthController, which both in¬ \nherit from Controller and specialize some of those base behaviors: \n\n// Parent class \n\nfunction Controlled ) { \nthis. errors = []; \n\n} \n\nController . prototype.showDialog(title,nsg) {","metadata":{"loc":{"lines":{"from":23886,"to":23914}}}}],["595",{"pageContent":"// Parent class \n\nfunction Controlled ) { \nthis. errors = []; \n\n} \n\nController . prototype.showDialog(title,nsg) { \n\n// display title & message to user in dialog \n\n}; \n\nController.prototype.success = function(nsg) { \nthis . showDialog( \"Success\", nsg ); \n\n}; \n\nController.prototype.failure = function(err) { \nthis. errors.push( err ); \nthis . showDialog( \"Error\", err ); \n\n}; \n\n\nSimpler Design | 131 \n\n\n\n\n// Child class \n\nfunction LoglnController( ) { \n\nController.call( this ); \n\n} \n\n// Link child class to parent \nLoginController.prototype = \n\nObject. create( Controller . prototype ); \n\nLoginController.prototype.getllser = functionQ { \n\nreturn document. getElementById( \"login_username\" ). value; \n\n}; \n\nLoginController.prototype.getPassword = functionQ { \n\nreturn document. getElementById( \"login_password\" ). value; \n\n}; \n\nLoginController.prototype.validateEntry = function(user,pw) { \nuser = user | | this.getUserQ; \npw = pw || this.getPasswordQ; \n\nif ( ! (user && pw)) {","metadata":{"loc":{"lines":{"from":23914,"to":23973}}}}],["596",{"pageContent":"}; \n\nLoginController.prototype.validateEntry = function(user,pw) { \nuser = user | | this.getUserQ; \npw = pw || this.getPasswordQ; \n\nif ( ! (user && pw)) { \n\nreturn this.failure( \n\n\"Please enter a username & password!\" \n\n); \n\n} \n\nelse if (user.length < 5) { \nreturn this.failure( \n\n\"Password must be 5+ characters!\" \n\n); \n\n} \n\n// got here? validated! \n\nreturn true; \n\n}; \n\n// Override to extend base 'failure()' \n\nLoginController.prototype.failure = function(err) { \n\n// \"super\" call \n\nController . prototype.failure.call( \nthis, \n\n\"Login invalid: \" + err \n\n); \n\n}; \n\n// Child class \n\nfunction AuthController(login) { \n\nController.call( this ); \n\n// in addition to inheritance, we also need composition \nthis. login = login; \n\n} \n\n// Link child class to parent \nAuthController . prototype = \n\nObject. create( Controller . prototype ); \n\nAuthController.prototype.server = function(url,data) { \nreturn $.ajax( { \n\n\n132 | Chapter 6: Behavior Delegation \n\n\n\n\nurl: url, \ndata: data \n\n} ); \n\n};","metadata":{"loc":{"lines":{"from":23973,"to":24049}}}}],["597",{"pageContent":"Object. create( Controller . prototype ); \n\nAuthController.prototype.server = function(url,data) { \nreturn $.ajax( { \n\n\n132 | Chapter 6: Behavior Delegation \n\n\n\n\nurl: url, \ndata: data \n\n} ); \n\n}; \n\nAuthController.prototype.checkAuth = functionQ { \nvar user = this. login.getUser(); \nvar pw = this. login.getPassword(); \n\nif (this. login.validateEntry( user, pw )) { \nthis.server( \"/check-auth\" ,{ \nuser: user, \npw: pw \n\n} ) \n\n,then( this. success.bind( this ) ) \n\n.fail( this. failure.bind( this ) ); \n\n} \n\n}; \n\n// Override to extend base 'success()' \n\nAuthController.prototype.success = functionQ { \n\n// \"super\" call \n\nController.prototype.success.call( this, \"Authenticated!\" ); \n\n}; \n\n// Override to extend base 'failure()' \n\nAuthController.prototype.failure = function(err) { \n\n// \"super\" call \n\nController . prototype.failure.call( \nthis, \n\n\"Auth Failed: \" + err \n\n); \n\n}; \n\nvar auth = new AuthControllerQ; \nauth.checkAuth(","metadata":{"loc":{"lines":{"from":24049,"to":24112}}}}],["598",{"pageContent":"// \"super\" call \n\nController . prototype.failure.call( \nthis, \n\n\"Auth Failed: \" + err \n\n); \n\n}; \n\nvar auth = new AuthControllerQ; \nauth.checkAuth( \n\n// in addition to inheritance, we also need composition \nnew LoginController( ) \n\n); \n\nWe have base behaviors that all controllers share, which are sue \ncess(..), failure(..), and showDialog(..). Our child classes Log \ninController and AuthController override failure(..) and sue \ncess(..) to augment the default base class behavior. Also note that \nAuthController needs an instance of LoginController to interact \nwith the login form, so that becomes a member data property. \n\nThe other thing to mention is that we chose some composition to \nsprinkle in on top of the inheritance. AuthController needs to know \nabout LoginController, so we instantiate it (new LoginControl \nlerQ) and keep a class member property called this.login to \n\n\nSimpler Design | 133 \n\n\n\nreference it, so that AuthController can invoke behavior on Log! \nnController.","metadata":{"loc":{"lines":{"from":24112,"to":24149}}}}],["599",{"pageContent":"Simpler Design | 133 \n\n\n\nreference it, so that AuthController can invoke behavior on Log! \nnController. \n\n\n\nThere might have been a slight temptation to make AuthCon \ntroller inherit from LoginController, or vice versa, such \nthat we had virtual composition through the inheritance chain. \nBut this is a clear example of what’s wrong with class inheri¬ \ntance as the model for the problem domain, because neither \nAuthController nor LoginController are specializing base \nbehavior of the other, so inheritance between them makes lit¬ \ntle sense except if classes are your only design pattern. In¬ \nstead, we layered in some simple composition and now they can \ncooperate, while still both benefiting from the inheritance from \nthe parent base Controller. \n\n\nIf you’re familiar with class-oriented (OO) design, this should all look \npretty familiar and natural. \n\nDe-class-ified","metadata":{"loc":{"lines":{"from":24149,"to":24174}}}}],["600",{"pageContent":"If you’re familiar with class-oriented (OO) design, this should all look \npretty familiar and natural. \n\nDe-class-ified \n\nBut, do we really need to model this problem with a parent Control \nler class, two child classes, and some composition? Is there a way to \ntake advantage of OLOO-style behavior delegation and have a much \nsimpler design? Yes! \n\nvar LoginController = { \nerrors: [], \ngetUser: function! ) { \n\nreturn document. getElementById ( \n\n\"login_username\" \n\n) .value; \n\n}. \n\ngetPassword: function!) { \n\nreturn document. getElementByld! \n\n\"login_password\" \n\n) .value; \n\n}. \n\nvalidateEntry : function(user,pw) { \nuser = user | | this.getUser(); \npw = pw || this. getPassword!); \n\nif (! (user && pw) ) { \n\nreturn this. failure! \n\n\"Please enter a username & password!\" \n\n); \n\n} \n\n\n134 | Chapter 6: Behavior Delegation \n\n\n\n\n\n\nelse if (user.length < 5) { \nreturn this.failure( \n\n\"Password nust be S+ characters!\" \n\n); \n\n} \n\n// got here? validated! \n\nreturn true; \n\n}.","metadata":{"loc":{"lines":{"from":24174,"to":24241}}}}],["601",{"pageContent":"); \n\n} \n\n\n134 | Chapter 6: Behavior Delegation \n\n\n\n\n\n\nelse if (user.length < 5) { \nreturn this.failure( \n\n\"Password nust be S+ characters!\" \n\n); \n\n} \n\n// got here? validated! \n\nreturn true; \n\n}. \n\nshowDialog: function(title,msg) { \n\n// display success message to user in dialog \n\n}, \n\nfailure: function(err) { \n\nthis. errors.push( err ); \n\nthis. showDialog ( \"Error\", \"Login invalid: \" + err ); \n\n} \n\n}; \n\n// Link 'AuthController ' to delegate to 'LoginController' \nvar AuthController = Object. create( LoginController ); \n\nAuthController.errors = []; \n\nAuthController.checkAuth = functionQ { \nvar user = this .gettlser( ); \nvar pw = this.getPassword(); \n\nif (this . validateEntry( user, pw )) { \nthis.server( \"/check-auth\" ,{ \nuser: user, \npw: pw \n\n} ) \n\n,then( this. accepted.bind( this ) ) \n\n.fail( this . rejected . bind( this ) ); \n\n} \n\n}; \n\nAuthController . server = function(url,data) { \nreturn $.ajax( { \nurl: url, \ndata: data \n\n} ); \n\n}; \n\nAuthController.accepted = functionQ {","metadata":{"loc":{"lines":{"from":24241,"to":24317}}}}],["602",{"pageContent":".fail( this . rejected . bind( this ) ); \n\n} \n\n}; \n\nAuthController . server = function(url,data) { \nreturn $.ajax( { \nurl: url, \ndata: data \n\n} ); \n\n}; \n\nAuthController.accepted = functionQ { \n\nthis . showDialog( \"Success\", \"Authenticated!\" ) \n\n}; \n\nAuthController . rejected = function(err) { \nthis.failure( \"Auth Failed: \" + err ); \n\n}; \n\nSince AuthController is just an object (so is LoginController), we \ndon’t need to instantiate (like new AuthController()) to perform our \ntask. All we need to do is: \n\n\nSimpler Design | 135 \n\n\n\nAuthController.checkAuth( ); \n\nOf course, with OLOO, if you do need to create one or more additional \nobjects in the delegation chain, that’s easy, and still doesn’t require \nanything like class instantiation: \n\nvar controlled = Object. create( AuthController ); \nvar controlled = Object. create( AuthController );","metadata":{"loc":{"lines":{"from":24317,"to":24359}}}}],["603",{"pageContent":"var controlled = Object. create( AuthController ); \nvar controlled = Object. create( AuthController ); \n\nWith behavior delegation, AuthController and LoglnController are \njust objects, horizontal peers of each other, and are not arranged or \nrelated as parents and children in class orientation. We somewhat ar¬ \nbitrarily chose to have AuthController delegate to LoginControl \nle r; it would have been just as valid for the delegation to go the reverse \ndirection. \n\nThe main takeaway from this second code listing is that we only have \ntwo entities (LoglnController and AuthController), not three as \nbefore.","metadata":{"loc":{"lines":{"from":24359,"to":24371}}}}],["604",{"pageContent":"The main takeaway from this second code listing is that we only have \ntwo entities (LoglnController and AuthController), not three as \nbefore. \n\nWe didn’t need a base Controller class to “share” behavior between \nthe two, because delegation is a powerful enough mechanism to give \nus the functionality we need. We also, as noted before, don’t need to \ninstantiate our classes to work with them, because there are no classes, \njust the objects themselves. Furthermore, there’s no need for compo¬ \nsition, as delegation gives the two objects the ability to cooperate dif¬ \nferentially as needed. \n\nLastly, we avoided the polymorphism pitfalls of class-oriented design \nby not having the names success (..) and fallure(..) be the same \non both objects, which would have required ugly explicit pseudopo¬ \nlymorphism. Instead, we called them accepted() and rejected(..) \non AuthController—slightly more descriptive names for their spe¬ \ncific tasks.","metadata":{"loc":{"lines":{"from":24371,"to":24388}}}}],["605",{"pageContent":"Bottom line: we end up with the same capability, but a (significantly) \nsimpler design. That’s the power of OLOO-style code and the power \nof the behavior delegation design pattern. \n\nNicer Syntax \n\nOne ofthe nicer things that makes ES6’s class so deceptively attractive \n(see Appendix A on why to avoid it!) is the shorthand syntax for de¬ \nclaring class methods: \n\n\n136 | Chapter 6: Behavior Delegation \n\n\n\n\n\nclass Foo { \n\nmethodName( ) { /* .. */ } \n\n} \n\nWe get to drop the word function from the declaration, which makes \nJS developers everywhere cheer! \n\nAnd you may have noticed and been frustrated that the previously \nsuggested OLOO syntax has lots of function appearances, which \nseems like a bit of a detractor to the goal of OLOO simplification. But \nit doesn’t have to be that way! \n\nAs of ES6, we can use concise method declarations in any object literal, \nso an object in OLOO style can be declared this way (same shorthand \nsugar as with the class body syntax):","metadata":{"loc":{"lines":{"from":24390,"to":24423}}}}],["606",{"pageContent":"As of ES6, we can use concise method declarations in any object literal, \nso an object in OLOO style can be declared this way (same shorthand \nsugar as with the class body syntax): \n\nvar LoginController = { \nerrors: [], \n\ngetUser() { // Look tna, no function'! \n\n// ... \n\n}, \n\ngetPassword( ) { \n\n// ... \n\n} \n\n// ... \n\n1 ; \n\nAbout the only difference is that object literals will still require , com¬ \nma separators between elements whereas class syntax doesn’t. Pretty \nminor concession in the whole scheme of things. \n\nMoreover, as of ES6, the clunkier syntax you use (like for the AuthCon \ntroller definition), where you’re assigning properties individually \nand not using an object literal, can be rewritten using an object literal \n(so that you can use concise methods), and you can just modify that \nobject’s [[Prototype]] with Object.setPrototypeOf(..), like this: \n\n// use nicer object literal syntax w/ concise methods! \nvar AuthController = { \nerrors: [], \ncheckAuthQ { \n\n// ... \n\n},","metadata":{"loc":{"lines":{"from":24423,"to":24463}}}}],["607",{"pageContent":"// use nicer object literal syntax w/ concise methods! \nvar AuthController = { \nerrors: [], \ncheckAuthQ { \n\n// ... \n\n}, \n\nserver(url,data) { \n\n// ... \n\n} \n\n// ... \n\n1 ; \n\n\nNicer Syntax | 137 \n\n\n\n\n//NOH, link 'AuthController' to delegate to 'LoginController' \nObject. setPrototypeOf( AuthController, LoginController ); \n\nOLOO style as of ES6, with concise methods, is a lot friendlier than it \nwas before (and even then, it was much simpler and nicer than classical \nprototype-style code). You don’t have to opt for class (complexity) to \nget nice clean object syntax! \n\nUnlexical \n\nThere is one drawback to concise methods that’s subtle but important \nto note. Consider this code: \n\nvar Foo = { \n\nbar() { /*..*/ }, \n\nbaz: function baz() { /*..*/ } \n\n}; \n\nHere’s the syntactic de-sugaring that expresses how that code will \noperate: \n\nvar Foo = { \n\nbar: functionQ { /*..*/ }, \nbaz: function baz() { /*..*/ } \n\n};","metadata":{"loc":{"lines":{"from":24463,"to":24517}}}}],["608",{"pageContent":"baz: function baz() { /*..*/ } \n\n}; \n\nHere’s the syntactic de-sugaring that expresses how that code will \noperate: \n\nvar Foo = { \n\nbar: functionQ { /*..*/ }, \nbaz: function baz() { /*..*/ } \n\n}; \n\nSee the difference? The bar() shorthand became an anonymous func¬ \ntion expression (function ()..) attached to the bar property, because \nthe function object itself has no name identifier. Compare that to the \nmanually specified named function expression (function baz()..), \nwhich has a lexical name identifier baz in addition to being attached \nto a .baz property. \n\nSo what? In the Scope & Closures title of this book series, we cover the \nthree main downsides of anonymous function expressions in detail. \nWe’ll just briefly repeat them so we can compare to the concise method \nshorthand. \n\nThe lack of a name identifier on an anonymous function: \n\n1. Makes debugging stack traces harder \n\n2. Makes self-referencing (recursion, event (un)binding, etc.) harder","metadata":{"loc":{"lines":{"from":24517,"to":24547}}}}],["609",{"pageContent":"The lack of a name identifier on an anonymous function: \n\n1. Makes debugging stack traces harder \n\n2. Makes self-referencing (recursion, event (un)binding, etc.) harder \n\n3. Makes code (a little bit) harder to understand \n\nItems 1 and 3 don’t apply to concise methods. \n\n\n138 | Chapter 6: Behavior Delegation \n\n\n\n\n\nEven though the de-sugaring uses an anonymous function expression, \nwhich normally would have no name in stack traces, concise methods \nare specified to set the internal name property of the function object \naccordingly, so stack traces should be able to use it (though that’s im¬ \nplementation dependent so not guaranteed). \n\nItem 2 is, unfortunately, still a drawback to concise methods. They will \nnot have a lexical identifier to use as a self-reference. Consider: \n\nvar Foo = { \n\nbar: function(x) { \ntf (x < 10) { \n\nreturn Foo.bar( x * 2 ); \n\n} \n\nreturn x; \n\n}. \n\nbaz: function baz(x) { \nif (x < 10) { \n\nreturn baz( x * 2 ); \n\n} \n\nreturn x; \n\n} \n\n};","metadata":{"loc":{"lines":{"from":24547,"to":24597}}}}],["610",{"pageContent":"var Foo = { \n\nbar: function(x) { \ntf (x < 10) { \n\nreturn Foo.bar( x * 2 ); \n\n} \n\nreturn x; \n\n}. \n\nbaz: function baz(x) { \nif (x < 10) { \n\nreturn baz( x * 2 ); \n\n} \n\nreturn x; \n\n} \n\n}; \n\nThe manual Foo. bar(x*2) reference kind of suffices in this example, \nbut there are many cases where a function wouldn’t necessarily be able \nto do that, such as cases where the function is being shared in delega¬ \ntion across different objects, using this binding, etc. You would want \nto use a real self-reference, and the function object’s name identifier is \nthe best way to accomplish that. \n\nJust be aware of this caveat for concise methods, and if you run into \nsuch issues with lack of self-reference, make sure to forego the concise \nmethod synta x just for that declaration in favor of the manual named \nfunction expression declaration form: baz: function baz(){..}. \n\nIntrospection","metadata":{"loc":{"lines":{"from":24597,"to":24635}}}}],["611",{"pageContent":"Introspection \n\nIf you’ve spent much time with class-oriented programming (either in \nJS or other languages), you’re probably familiar with type introspec¬ \ntion: inspecting an instance to find out what kind of object it is. The \nprimary goal of type introspection with class instances is to reason \nabout the structure/capabilities of the object based on how it was \ncreated. \n\n\nIntrospection | 1B9 \n\n\n\n\nConsider this code that uses instanceof (see Chapter 5) for intro¬ \nspecting on an object al to infer its capability: \n\nfunction Foo() { \n\n// ... \n\n} \n\nFoo.prototype.something = function(){ \n\n// ... \n\n} \n\nvar al = new Foo(); \n\n// later \n\nif (al instanceof Foo) { \nal.somethingQ; \n\n} \n\nBecause Foo. prototype (not Foo!) is in the [ [Prototype] ] chain (see \nChapter 5) of al, the instanceof operator (confusingly) pretends to \ntell us that al is an instance of the Foo “class.” With this knowledge, \nwe then assume that al has the capabilities described by the Foo “class.”","metadata":{"loc":{"lines":{"from":24635,"to":24677}}}}],["612",{"pageContent":"Of course, there is no Foo class, only a plain old normal function \nFoo, which happens to have a reference to an arbitrary object (Foo. pro \ntotype) that al happens to be delegation-linked to. By its syntax, \ninstanceof pretends to be inspecting the relationship between al and \nFoo, but it’s actually telling us whether al and (the arbitrary object \nreferenced by) Foo. prototype are related. \n\nThe semantic confusion (and indirection) of instanceof syntax \nmeans that to use instanceof-based introspection to ask if object al \nis related to the capabilities object in question, you have to have a \nfunction that holds a reference to that object—you can’t just directly \nask if the two objects are related. \n\nRecall the abstract Foo/Bar/bl example from earlier in this chapter, \nwhich we’ll abbreviate here: \n\nfunction Foo() { /* .. */ } \n\nFoo.prototype. .. \n\nfunction Bar() { /* .. */ } \n\nBar . prototype = Object. create( Foo.prototype ); \nvar bl = new Bar( \"bl\" );","metadata":{"loc":{"lines":{"from":24679,"to":24702}}}}],["613",{"pageContent":"function Foo() { /* .. */ } \n\nFoo.prototype. .. \n\nfunction Bar() { /* .. */ } \n\nBar . prototype = Object. create( Foo.prototype ); \nvar bl = new Bar( \"bl\" ); \n\n\n140 | Chapter 6: Behavior Delegation \n\n\n\n\n\nFor type introspection purposes on the entities in that example, using \ninstanceof and .prototype semantics, here are the various checks \nyou might need to perform: \n\n// relating 'Foo' and 'Bar' to each other \nBar . prototype instanceof Foo; // true \nObject.getPrototypeOf( Bar.prototype ) \n\n=== Foo.prototype; // true \n\nFoo.prototype.tsPrototypeOf ( Bar.prototype ); // true \n\n// relating 'bl' to both 'Foo' and 'Bar' \n\nbl instanceof Foo; // true \nbl instanceof Bar; // true \n\nObject.getPrototypeOf( bl ) === Bar . prototype; // true \nFoo.prototype.isPrototypeOf ( bl ); // true \nBar.prototype.tsPrototypeOf ( bl ); // true","metadata":{"loc":{"lines":{"from":24702,"to":24737}}}}],["614",{"pageContent":"Object.getPrototypeOf( bl ) === Bar . prototype; // true \nFoo.prototype.isPrototypeOf ( bl ); // true \nBar.prototype.tsPrototypeOf ( bl ); // true \n\nIt’s fair to say that some of that kinda sucks. For instance, intuitively \n(with classes) you might want to be able to say something like Bar \ninstanceof Foo (because it’s easy to mix up what “instance” means to \nthink it includes “inheritance”), but that’s not a sensible comparison \nin JS. You have to do Bar .prototype instanceof Foo instead. \n\nAnother common, but perhaps less robust, pattern for type introspec¬ \ntion, which many devs seem to prefer over instanceof, is called “duck \ntyping.” This term comes from the adage, “if it looks like a duck, and \nit quacks like a duck, it must be a duck.” \n\nExample: \n\nif (al. something) { \nal.somethingO; \n\n}","metadata":{"loc":{"lines":{"from":24737,"to":24757}}}}],["615",{"pageContent":"Example: \n\nif (al. something) { \nal.somethingO; \n\n} \n\nRather than inspecting for a relationship between al and an object \nthat holds the delegatable something() function, we assume that the \ntest for al.something passing means al has the capability to \ncall . something!) (regardless of if it found the method directly on al \nor delegated to some other object). In and of itself, that assumption \nisn’t so risky. \n\nBut “duck typing” is often extended to make other assumptions about \nthe object’s capabilities besides what’s being tested, which of course \nintroduces more risk (aka brittle design) into the test. \n\nOne notable example of “duck typing” comes with ES6 Promises \n(which as an earlier note explained, are not being covered in this book). \n\n\nIntrospection | 141","metadata":{"loc":{"lines":{"from":24757,"to":24779}}}}],["616",{"pageContent":"One notable example of “duck typing” comes with ES6 Promises \n(which as an earlier note explained, are not being covered in this book). \n\n\nIntrospection | 141 \n\n\n\nFor various reasons, there’s a need to determine if any arbitrary object \nreference is a Promise, but the way that test is done is to check if the \nobject happens to have a t hen () function present on it. In other words, \nif any object happens to have a then() method, ES6 Promises will \nassume unconditionally that the object is a “thenable” and therefore \nwill expect it to behave conformantly to all standard behaviors of \nPromises. \n\nIf you have any non-Promise object that happens for whatever reason \nto have a then( ) method on it, you are strongly advised to keep it far \naway from the ES6 Promise mechanism to avoid broken assumptions. \n\nThat example clearly illustrates the perils of “duck typing.” You should \nonly use such approaches sparingly and in controlled conditions.","metadata":{"loc":{"lines":{"from":24779,"to":24800}}}}],["617",{"pageContent":"That example clearly illustrates the perils of “duck typing.” You should \nonly use such approaches sparingly and in controlled conditions. \n\nTurning our attention once again back to OLOO-style code as pre¬ \nsented here in this chapter, type introspection turns out to be much \ncleaner. Let’s recall (and abbreviate) the Foo/Bar/bl OLOO example \nfrom earlier in the chapter: \n\nvar Foo ={/*.. */ }; \n\nvar Bar = Object. create( Foo ); \n\nBar ... \n\nvar bl = Object. create( Bar ); \n\nUsing this OLOO approach, where all we have are plain objects that \nare related via [ [Prototype]] delegation, here’s the quite simplified \ntype introspection we might use: \n\n// relating 'Foo' and 'Bar' to each other \nFoo.tsPrototypeOf( Bar ); // true \nObject.getPrototypeOf( Bar ) === Foo; // true \n\n// relating 'bl' to both 'Foo' and 'Bar' \n\nFoo.tsPrototypeOf( bl ); // true \nBar.isPrototypeOf( bl ); // true \nObject.getPrototypeOf( bl ) === Bar; // true","metadata":{"loc":{"lines":{"from":24800,"to":24828}}}}],["618",{"pageContent":"// relating 'bl' to both 'Foo' and 'Bar' \n\nFoo.tsPrototypeOf( bl ); // true \nBar.isPrototypeOf( bl ); // true \nObject.getPrototypeOf( bl ) === Bar; // true \n\nWe’re not using instanceof anymore, because it’s confusingly pre¬ \ntending to have something to do with classes. Now, we just ask the \n(informally stated) question, “Are you a prototype of me?” There’s no \nmore indirection necessary with stufflike Foo. prototype or the pain¬ \nfully verbose Foo.prototype.isPrototypeOf(..). \n\nI think it’s fair to say these checks are significantly less complicated/ \nconfusing that the previous set of introspection checks. Yet again, we \n\n\n142 | Chapter 6: Behavior Delegation \n\n\n\nsee that OLOO is simpler than (but with all the same power of) class- \nstyle coding in JavaScript. \n\nReview","metadata":{"loc":{"lines":{"from":24828,"to":24851}}}}],["619",{"pageContent":"142 | Chapter 6: Behavior Delegation \n\n\n\nsee that OLOO is simpler than (but with all the same power of) class- \nstyle coding in JavaScript. \n\nReview \n\nClasses and inheritance are a design pattern you can choose, or not \nchoose, in your software architecture. Most developers take for granted \nthat classes are the only (proper) way to organize code, but here we’ve \nseen there’s another less-commonly talked about pattern that’s actually \nquite powerful: behavior delegation. \n\nBehavior delegation suggests objects as peers of each other, which del¬ \negate among themselves, rather than parent and child class relation¬ \nships. JavaScript’s [ [Prototype] ] mechanism is, by its very designed \nnature, a behavior delegation mechanism. That means we can either \nchoose to struggle to implement class mechanics on top of JS (see \nChapters 4 and 5), or we can just embrace the natural state of [ [Pro \ntotype] ] as a delegation mechanism.","metadata":{"loc":{"lines":{"from":24851,"to":24872}}}}],["620",{"pageContent":"When you design code with objects only, not only does it simplify the \nsyntax you use, but it can actually lead to simpler code architecture \ndesign. \n\nOLOO (objects linked to other objects) is a code style that creates and \nrelates objects directly without the abstraction of classes. OLOO quite \nnaturally implements [ [Prototype] ]-based behavior delegation. \n\n\nReview | 143 \n\n\n\nAPPENDIX A \n\n\nES6 Class \n\n\nIf there’s any takeaway message from the second half of this book \n(Chapters 4-6), it’s that classes are an optional design pattern for code \n(not a necessary given), and that furthermore they are often quite \nawkward to implement in a [ [Prototype] ] language like JavaScript.","metadata":{"loc":{"lines":{"from":24874,"to":24896}}}}],["621",{"pageContent":"This awkwardness is not just about syntax, although that’s a big part \nof it. Chapters 4 and 5 examined quite a bit of syntactic ugliness, from \nthe verbosity of . prototype references cluttering the code, to explicit \npseudo-polymorphism (see Chapter 4) when you give methods the \nsame name at different levels of the chain and try to implement a pol¬ \nymorphic reference from a lower-level method to a higher-level meth¬ \nod. . constructor being wrongly interpreted as “was constructed by” \nand yet being unreliable for that definition is yet another syntactic \nugly. \n\nBut the problems with class design are much deeper. Chapter 4 points \nout that classes in traditional class-oriented languages actually pro¬ \nduce a copy action from parent to child to instance, whereas in [ [Pro \ntotype] ], the action is not a copy, but rather the opposite—a delega¬ \ntion link.","metadata":{"loc":{"lines":{"from":24898,"to":24912}}}}],["622",{"pageContent":"When compared to the simplicity of OLOO-style code and behavior \ndelegation (see Chapter 6), which embrace [[Prototype]] rather than \nhide from it, classes stand out as a sore thumb in JS. \n\n\n145 \n\n\n\n\n\nclass \n\nBut we don’t need to argue that case again. I remention those issues \nbriefly only so that you keep them fresh in your mind now that we \nturn our attention to the ES6 class mechanism. We’ll demonstrate \nhere how it works, and look at whether or not class does anything \nsubstantial to address any of those “class” concerns. \n\nLet’s revisit the Widget/Button example from Chapter 6: \n\nclass Widget { \n\nconstructor(wldth,height) { \nthis. width = width || 50; \nthis. height = height || 50; \nthis.$elem = null; \n\n} \n\nrender($where){ \n\nif (this.$elem) { \n\nthis.$elem.css( { \n\nwidth: this. width + \"px\", \nheight: this. height + \"px\" \n\n} ).appendTo( $where ); \n\n} \n\n} \n\n} \n\nclass Button extends Widget {","metadata":{"loc":{"lines":{"from":24914,"to":24961}}}}],["623",{"pageContent":"} \n\nrender($where){ \n\nif (this.$elem) { \n\nthis.$elem.css( { \n\nwidth: this. width + \"px\", \nheight: this. height + \"px\" \n\n} ).appendTo( $where ); \n\n} \n\n} \n\n} \n\nclass Button extends Widget { \n\nconstructor(width,height , label) { \nsuper( width, height ); \nthis. label = label || \"Default\"; \nthis.$elem = $( \"<button>\" ).text( this. label ); \n\n} \n\nrender($where) { \n\nsuper( $where ); \n\nthis.$elem.click( this.onClick.bind( this ) ); \n\n} \n\nonClick(evt) { \n\nconsole.log( \"Button + this. label + clicked!\" ); \n\n} \n\n} \n\nBeyond this syntax looking nicer, what problems does ES6 solve? \n\n1. There’s no more (well, sorta, see below!) references to .proto \ntype cluttering the code. \n\n2. Button is declared directly to “inherit from” (aka extends) Widg \net, instead of needing to use Object.create( ..) to replace \n\n\n146 | Appendix A: ES6 Class \n\n\n\n\na .prototype object that’s linked, or having to set with . _pro \n\nto _or Object.setPrototypeOf(..","metadata":{"loc":{"lines":{"from":24961,"to":25021}}}}],["624",{"pageContent":"146 | Appendix A: ES6 Class \n\n\n\n\na .prototype object that’s linked, or having to set with . _pro \n\nto _or Object.setPrototypeOf(.. \n\n3. super(. .) now gives us a very helpful relative polymorphism ca¬ \npability, so that any method at one level of the chain can refer \nrelatively one level up the chain to a method of the same name. \nThis includes a solution to the note from Chapter 4 about the \nweirdness of constructors not belonging to their class, and so be¬ \ning unrelated— super () works inside constructors exactly as \nyou’d expect. \n\n4. class literal syntax has no affordance for specifying properties \n(only methods). This might seem limiting to some, but it’s ex¬ \npected that the vast majority of cases where a property (state) ex¬ \nists elsewhere but the end-chain “instances” is usually a mistake \nand surprising (as it’s state that’s implicitly “shared” among all \n“instances”). So, one could say the class syntax is protecting you \nfrom mistakes.","metadata":{"loc":{"lines":{"from":25021,"to":25044}}}}],["625",{"pageContent":"5. extends lets you extend even built-in object (sub)types, like Ar \nray or RegExp, in a very natural way. Doing so without class .. \nextends has long been an exceedingly complex and frustrating \ntask, one that only the most adept of framework authors have ever \nbeen able to accurately tackle. Now, it will be rather trivial! \n\nIn all fairness, those are some substantial solutions to many of the most \nobvious (syntactic) issues and surprises people have with classical \nprototype-style code. \n\nclass Gotchas \n\nIt’s not all bubblegum and roses, though. There are still some deep and \nprofoundly troubling issues with using “classes” as a design pattern in \nJS. \n\nFirst, the class syntax may convince you a new “class” mechanism \nexists in JS as of ES6. Not so. class is, mostly, just syntactic sugar on \ntop of the existing [ [Prototype] ] (delegation!) mechanism.","metadata":{"loc":{"lines":{"from":25046,"to":25064}}}}],["626",{"pageContent":"That means class is not actually copying definitions statically at dec¬ \nlaration time the way it does in traditional class-oriented languages. If \nyou change/replace a method (on purpose or by accident) on the par¬ \nent “class,” the child “class” and/or instances will still be affected, in \n\n\nclass Gotchas | 147 \n\n\n\nthat they don’t get copies at declaration time; they are all still using the \nlive-delegation model based on [ [Prototype] ]: \n\nclass C { \n\nconstructorQ { \n\nthis. nun = Math. random( ); \n\n} \n\nrand() { \n\nconsole.log( \"Random: \" + this.num ); \n\n} \n\n} \n\nvar cl = new C(); \n\ncl.randQ; // \"Random: 0.4324299...\" \n\nC. prototype.rand = functionQ { \n\nconsole.log( \"Random: \" + Math.round( this.num * 1000 )); \n\n}; \n\n\nvar c2 = new C(); \nc2.rand(); // \"Random: 867\" \n\ncl.randQ; // \"Random: 432\" -- oops!!!","metadata":{"loc":{"lines":{"from":25066,"to":25109}}}}],["627",{"pageContent":"C. prototype.rand = functionQ { \n\nconsole.log( \"Random: \" + Math.round( this.num * 1000 )); \n\n}; \n\n\nvar c2 = new C(); \nc2.rand(); // \"Random: 867\" \n\ncl.randQ; // \"Random: 432\" -- oops!!! \n\nThis only seems like reasonable behavior if you already know about \nthe delegation nature of things, rather than expecting copies from “real \nclasses.” So the question to ask yourself is, why are you choosing class \nsyntax for something fundamentally different from classes? \n\nDoesn’t the ES6 class syntax just make it harder to see and understand \nthe difference between traditional classes and delegated objects? \n\nclass syntax does not provide a way to declare class member proper¬ \nties (only methods). So if you need to do that to track shared state \namong instances, then you end up going back to the ugly .proto \ntype syntax, like this: \n\nclass C { \n\nconstructorQ { \n\n// make sure to modify the shared state, \n\n// not set a shadowed property on the \n// instances! \n\nC. prototype .count++;","metadata":{"loc":{"lines":{"from":25109,"to":25143}}}}],["628",{"pageContent":"class C { \n\nconstructorQ { \n\n// make sure to modify the shared state, \n\n// not set a shadowed property on the \n// instances! \n\nC. prototype .count++; \n\n// here, 'this.count' works as expected \n// via delegation \n\nconsole.log( \"Hello: \" + this. count ); \n\n} \n\n} \n\n\n148 | Appendix A: ES6 Class \n\n\n\n\n// add a property for shared state directly to \n// prototype object \nC. prototype.count = 0; \n\nvar cl = new C(); \n\n// Hello: 1 \n\nvar c2 = new C(); \n\n// Hello: 2 \n\ncl.count === 2; // true \n\ncl.count === c2.count; // true \n\nThe biggest problem here is that it betrays the class syntax by expos¬ \ning (leakage!) . prototype as an implementation detail. \n\nBut, we also still have the surprise gotcha that thls.count++ would \nimplicitly create a separate shadowed . count property on both the cl \nand c2 objects, rather than updating the shared state, class offers us \nno consolation from that issue, except (presumably) to imply by lack \nof syntactic support that you shouldn’t be doing that at all.","metadata":{"loc":{"lines":{"from":25143,"to":25192}}}}],["629",{"pageContent":"Moreover, accidental shadowing is still a hazard: \n\nclass c { \n\nconstructor(id) { \n\n// oops, gotcha, we're shadowing 'id()~ nethod \n// with a property value on the instance \nthis. id = id; \n\n} \n\nid() { \n\nconsole.log( \"Id: \" + id ); \n\n} \n\n} \n\nvar cl = new C( \"cl\" ); \n\ncl.id(); // TypeError -- 'cl.id' is now the string \"cl\" \n\nThere’s also some very subtle nuanced issues with how super works. \nYou might assume that super would be bound in an analogous way to \nhow this gets bound (see Chapter 2), which is that super would always \nbe bound to one level higher than whatever the current method’s po¬ \nsition in the [[Prototype]] chain is. \n\nHowever, for performance reasons (this binding is already expen¬ \nsive), super is not bound dynamically. It’s bound sort of “statically” at \ndeclaration time. No big deal, right? \n\n\nclass Gotchas | 149","metadata":{"loc":{"lines":{"from":25194,"to":25229}}}}],["630",{"pageContent":"class Gotchas | 149 \n\n\n\n\n\nEhh...maybe, maybe not. If you, like most JS devs, start assigning \nfunctions around to different objects (which came from class defi¬ \nnitions), in various different ways, you probably won’t be very aware \nthat in all those cases, the super mechanism under the covers is having \nto be rebound each time. \n\nAnd depending on what sorts of syntactic approaches you take to these \nassignments, there may very well be cases where the super can’t be \nproperly bound (at least, not where you suspect), so you may (at the \ntime of writing, TC39 discussion is ongoing on the topic) have to \nmanually bind super with toMethod(..) (kinda like you have to do \nbind(..) for this—see Chapter 2). \n\nYou’re used to being able to assign around methods to different objects \nto automatically take advantage of the dynamicism of this via the \nimplicit binding rule (see Chapter 2). But the same will likely not be \ntrue with methods that use super.","metadata":{"loc":{"lines":{"from":25229,"to":25251}}}}],["631",{"pageContent":"Consider what super should do here (against D and E): \n\nclass p { \n\nfoo() { console. log( \"P.foo\" ); } \n\n} \n\nclass C extends P { \nfoo() { \n\nsuper(); \n\n} \n\n} \n\nvar cl = new C(); \ncl.foo(); // \"P.foo\" \n\nvar D = { \n\nfoo: functionQ { console. log( \"D.foo\" ); } \n\n}; \n\n\nvar E = { \n\nfoo: C. prototype.foo \n\n}; \n\n\n// Link E to D for delegation \nObject.setPrototypeOf( E, D ); \n\nE.fooQ; // \"P.foo\" \n\n\n150 | Appendix A: ES6 Class \n\n\n\n\nIf you were thinking (quite reasonably!) that super would be bound \ndynamically at call time, you might expect that super () would auto¬ \nmatically recognize that E delegates to D, so E.fooQ using superQ \nshould call to D . f oo(). \n\nNot so. For performance pragmatism reasons, super is not late \nbound (aka dynamically bound) like this is. Instead it’s derived at call \ntime from [ [HomeObject] ]. [ [Prototype] ], where [ [HomeObject] ] \nis statically bound at creation time.","metadata":{"loc":{"lines":{"from":25253,"to":25306}}}}],["632",{"pageContent":"In this particular case, super( ) is still resolving to P. foo( ), since the \nmethod’s [ [HomeObject] ] is still C and C. [ [Prototype] ] is P. \n\nThere will probably be ways to manually address such gotchas. Using \ntoMethod( ..) to bind/rebind a method’s [ [HomeObject] ] (along with \nsetting the [[Prototype]] of that object!) appears to work in this \nscenario: \n\nvar D = { \n\nfoo: functionQ { consote.log( \"D.foo\" ); } \n\n}; \n\n\n// Link E to D for delegation \nvar E = Object. create( D ); \n\n// manually bind foo's ' [[HomeObject ]]' as \n// , and ~E. [[Prototype ]]' is so thus \n\n// ~super()' is ~D.foo()' \n\nE.foo = C.prototype.foo.toMethod( E, \"foo\" ); \nE.fooQ; // \"D.foo\" \n\n\n\ntoMethod( ..) clones the method and takes homeObject as its \nfirst parameter (which is why we pass E), and the second pa¬ \nrameter (optionally) sets a name for the new method (which we \nkeep as “foo”).","metadata":{"loc":{"lines":{"from":25308,"to":25339}}}}],["633",{"pageContent":"It remains to be seen if there are other corner case gotchas that devs \nwill run into beyond this scenario. Regardless, you will have to be \ndiligent and stay aware of which places the engine automatically fig¬ \nures out super for you, and which places you have to manually take \ncare of it. Ugh! \n\n\nclass Gotchas | 151 \n\n\n\n\n\n\nStatic > Dynamic? \n\nBut the biggest problem of all for the ES6 class is that all these various \ngotchas mean class sorta opts you into a syntax that seems to imply \n(like traditional classes) that once you declare a class, it’s a static def¬ \ninition of a (future instantiated) thing. You completely lose sight of the \nfact C is an object, a concrete thing, which you can directly interact \nwith.","metadata":{"loc":{"lines":{"from":25342,"to":25363}}}}],["634",{"pageContent":"In traditional class-oriented languages, you never adjust the definition \nof a class later, so the class design pattern doesn’t suggest such capa¬ \nbilities. But one of the most powerful parts of JS is that it is dynamic, \nand the definition of any object is (unless you make it immutable) a \nfluid and mutable thing. \n\nclass seems to imply you shouldn’t do such things, by forcing you \ninto the uglier . prototype syntax to do so, or forcing you think about \nsuper gotchas, etc. It also offers very little support for any of the pitfalls \nthat this dynamicism can bring. \n\nIn other words, it’s as if class is telling you: “Dynamic is too hard, so \nit’s probably not a good idea. Here’s a static-looking syntax, so code \nyour stuff statically.” \n\nWhat a sad commentary on JavaScript: dynamic is too hard, let’s pre¬ \ntend to be (but not actually be!) static.","metadata":{"loc":{"lines":{"from":25365,"to":25381}}}}],["635",{"pageContent":"What a sad commentary on JavaScript: dynamic is too hard, let’s pre¬ \ntend to be (but not actually be!) static. \n\nThese are the reasons why the ES6 class is masquerading as a nice \nsolution to syntactic headaches, but it’s actually muddying the waters \nfurther and making things worse for JS and for clear and concise \nunderstanding. \n\n\n\nIf you use the .bind( ..) utility to make a hard-bound func¬ \ntion (see Chapter 2), the function created is not subclassable \nwith ES6 extend like normal functions are. \n\n\nReview \n\nclass does a very good job of pretending to fix the problems with the \nclass/inheritance design pattern in JS. But it actually does the opposite: \nit hides many of the problems and introduces other subtle but dan¬ \ngerous ones. \n\n\n152 | Appendix A: ES6 Class","metadata":{"loc":{"lines":{"from":25381,"to":25404}}}}],["636",{"pageContent":"152 | Appendix A: ES6 Class \n\n\n\n\nclass contributes to the ongoing confusion of “class” in JavaScript that \nhas plagued the language for nearly two decades. In some respects, it \nasks more questions than it answers, and it feels like a very unnatural \nfit on top of the elegant simplicity of the [ [Prototype] ] mechanism. \n\nBottom line: if the ES6 class makes it harder to robustly leverage \n[ [Prototype] ], and hides the most important nature of the JS object \nmechanism—the live delegation links between objects—shouldn’t we \nsee class as creating more troubles than it solves, and just relegate it \nto an antipattern? \n\nI can’t really answer that question for you. But I hope this book has \nfully explored the issue at a deeper level than you’ve ever gone before, \nand has given you the information you need to answer it yourself. \n\n\nReview | 153 \n\n\n\nAbout the Author","metadata":{"loc":{"lines":{"from":25404,"to":25429}}}}],["637",{"pageContent":"Review | 153 \n\n\n\nAbout the Author \n\n\nKyle Simpson is an Open Web Evangelist from Austin, TX. He’s pas¬ \nsionate about JavaScript, HTML5, real-time/peer-to-peer communi¬ \ncations, and web performance. Otherwise, he’s probably bored by it. \nKyle is an author, workshop trainer, tech speaker, and avid OSS com¬ \nmunity member. \n\n\n\n\nTypes & Grammar \n\n\nKyle Simpson \n\n\nBeijing • Cambridge • Farnham • Koln • Sebastopol • Tokyo \n\n\nO'REILLY \n\n\n\n\n\nTable of Contents \n\n\nForeword. v \n\nPreface.vii \n\n1. Types. 1 \n\nA Type by Any Other Name... 2 \n\nBuilt-in Types 3 \n\nValues as Types 5 \n\nReview 10 \n\n2. Values. 11 \n\nArrays 11 \n\nStrings 14 \n\nNumbers 16 \n\nSpecial Values 24 \n\nValue Versus Reference 33 \n\nReview 37 \n\n3. Natives. 39 \n\nInternal [[Class]] 41 \n\nBoxing Wrappers 42 \n\nUnboxing 43 \n\nNatives as Constructors 44 \n\nReview 55 \n\n4. Coercion. 57 \n\nConverting Values 57 \n\n\niii \n\n\n\n\n\n\n\n\n\n\nAbstract Value Operations \n\n59 \n\nExplicit Coercion \n\n71 \n\nImplicit Coercion \n\n85 \n\nLoose Equals Versus Strict Equals \n\n99","metadata":{"loc":{"lines":{"from":25429,"to":25533}}}}],["638",{"pageContent":"Review 55 \n\n4. Coercion. 57 \n\nConverting Values 57 \n\n\niii \n\n\n\n\n\n\n\n\n\n\nAbstract Value Operations \n\n59 \n\nExplicit Coercion \n\n71 \n\nImplicit Coercion \n\n85 \n\nLoose Equals Versus Strict Equals \n\n99 \n\nAbstract Relational Comparison \n\n116 \n\nReview \n\n119 \n\nGrammar. \n\n. 121 \n\nStatements & Expressions \n\n121 \n\nOperator Precedence \n\n137 \n\nAutomatic Semicolons \n\n146 \n\nErrors \n\n149 \n\nFunction Arguments \n\n151 \n\ntry..finally \n\n154 \n\nswitch \n\n157 \n\nReview \n\n160 \n\nMixed Environment JavaScript. \n\n.163 \n\n\niv | Table of Contents \n\n\n\n\n\nForeword \n\n\nIt was once said, “JavaScript is the only language developers don’t \nlearn to use before using it.”","metadata":{"loc":{"lines":{"from":25533,"to":25626}}}}],["639",{"pageContent":"Review \n\n160 \n\nMixed Environment JavaScript. \n\n.163 \n\n\niv | Table of Contents \n\n\n\n\n\nForeword \n\n\nIt was once said, “JavaScript is the only language developers don’t \nlearn to use before using it.” \n\nI laugh each time I hear that quote because it was true for me and I \nsuspect it was for many other developers. JavaScript, and maybe \neven CSS and HTML, were not among the core computer science \nlanguages taught at college in the Internet’s early days, so personal \ndevelopment was very much based on the budding developer’s \nsearch and “view source” abilities to piece together these basic web \nlanguages.","metadata":{"loc":{"lines":{"from":25626,"to":25653}}}}],["640",{"pageContent":"I still remember my first high school website project. The task was \nto create any type of web store, and me being a James Bond fan, I \ndecided to create a Goldeneye store. It had everything: the Golden¬ \neye MIDI theme song playing in the background, JavaScript- \npowered crosshairs following the mouse around the screen, and a \ngunshot sound that played upon every click. Q would have been \nproud of this masterpiece of a website. \n\nI tell that story because I did back then what many developers are \ndoing today: I copied-and-pasted chunks of JavaScript code into my \nproject without having a clue about what’s actually happening. The \nwidespread use of JavaScript toolkits like jQuery have, in their own \nsmall way, perpetuated this pattern of not learning of core Java¬ \nScript.","metadata":{"loc":{"lines":{"from":25655,"to":25668}}}}],["641",{"pageContent":"I’m not disparaging JavaScript toolkit use; after all, I’m a member of \nthe MooTools JavaScript team! But the reason JavaScript toolkits are \nas powerful as they are is because their developers know the funda¬ \nmentals, and their “gotchas,” and apply them magnificently. As use¬ \nful as these toolkits are, it’s still incredibly important to know the \n\n\n\n\nbasics of the language, and with books like Kyle Simpson’s You Don’t \nKnow JS series, there’s no excuse not to learn them. \n\nTypes & Grammar, the third installment of the series, is an excellent \nlook at the core JavaScript fundamentals that copy-and-paste and \nJavaScript toolkits don’t and could never teach you. Coercion and its \npitfalls, natives as constructors, and the whole gamut of JavaScript \nbasics are thoroughly explained with focused code examples. Like \nthe other books in this series, Kyle cuts straight to the point, with no \nfluff and wordsmithing—exactly the type of tech book I love.","metadata":{"loc":{"lines":{"from":25670,"to":25688}}}}],["642",{"pageContent":"Enjoy Types & Grammar and don’t let it get too far away from your \ndesk! \n\n\n—David Walsh (http://davidwalsh.name), \nSenior Web Developer at Mozilla \n\n\nvi | Foreword \n\n\n\nPreface \n\n\nI’m sure you noticed, but “JS” in the series title is not an abbrevia¬ \ntion for words used to curse about JavaScript, though cursing at the \nlanguage’s quirks is something we can probably all identify with! \n\nFrom the earliest days of the Web, JavaScript has been a founda¬ \ntional technology that drives interactive experience around the con¬ \ntent we consume. While flickering mouse trails and annoying pop¬ \nup prompts may be where JavaScript started, nearly two decades \nlater, the technology and capability of JavaScript has grown many \norders of magnitude, and few doubt its importance at the heart of \nthe world’s most widely available software platform: the Web.","metadata":{"loc":{"lines":{"from":25690,"to":25715}}}}],["643",{"pageContent":"But as a language, it has perpetually been a target for a great deal of \ncriticism, owing partly to its heritage but even more to its design \nphilosophy. Even the name evokes, as Brendan Eich once put it, \n“dumb kid brother” status next to its more mature older brother \nJava. But the name is merely an accident of politics and marketing. \nThe two languages are vastly different in many important ways. \n“JavaScript” is as related to “Java” as “Carnival” is to “Car.” \n\nBecause JavaScript borrows concepts and syntax idioms from sev¬ \neral languages, including proud C-style procedural roots as well as \nsubtle, less obvious Scheme/Lisp-style functional roots, it is exceed¬ \ningly approachable to a broad audience of developers, even those \nwith little to no programming experience. The “Hello World” of \nJavaScript is so simple that the language is inviting and easy to get \ncomfortable with in early exposure.","metadata":{"loc":{"lines":{"from":25717,"to":25731}}}}],["644",{"pageContent":"While JavaScript is perhaps one of the easiest languages to get up \nand running with, its eccentricities make solid mastery of the lan¬ \nguage a vastly less common occurrence than in many other lan- \n\n\nVII \n\n\n\n\nguages. Where it takes a pretty in-depth knowledge of a language \nlike C or C++ to write a full-scale program, full-scale production \nJavaScript can, and often does, barely scratch the surface of what the \nlanguage can do. \n\nSophisticated concepts that are deeply rooted into the language tend \ninstead to surface themselves in seemingly simplistic ways, such as \npassing around functions as callbacks, which encourages the Java¬ \nScript developer to just use the language as-is and not worry too \nmuch about what’s going on under the hood.","metadata":{"loc":{"lines":{"from":25733,"to":25752}}}}],["645",{"pageContent":"It is simultaneously a simple, easy-to-use language that has broad \nappeal, and a complex and nuanced collection of language mechan¬ \nics that without careful study will elude true understanding even for \nthe most seasoned of JavaScript developers. \n\nTherein lies the paradox of JavaScript, the Achilles’ heel of the lan¬ \nguage, the challenge we are presently addressing. Because JavaScript \ncan be used without understanding, the understanding of the lan¬ \nguage is often never attained. \n\nMission \n\nIf at every point that you encounter a surprise or frustration in Java¬ \nScript, your response is to add it to the blacklist (as some are accus¬ \ntomed to doing), you soon will be relegated to a hollow shell of the \nrichness of JavaScript. \n\nWhile this subset has been famously dubbed “The Good Parts,” I \nwould implore you, dear reader, to instead consider it the “The Easy \nParts,” “The Safe Parts,” or even “The Incomplete Parts.”","metadata":{"loc":{"lines":{"from":25752,"to":25771}}}}],["646",{"pageContent":"While this subset has been famously dubbed “The Good Parts,” I \nwould implore you, dear reader, to instead consider it the “The Easy \nParts,” “The Safe Parts,” or even “The Incomplete Parts.” \n\nThis You Don’t Know JS series offers a contrary challenge: learn and \ndeeply understand all of JavaScript, even and especially “The Tough \nParts.” \n\nHere, we address head-on the tendency of JS developers to learn \n“just enough” to get by, without ever forcing themselves to learn \nexactly how and why the language behaves the way it does. Further¬ \nmore, we eschew the common advice to retreat when the road gets \nrough. \n\nI am not content, nor should you be, at stopping once something \njust works and not really knowing why. I gently challenge you to \njourney down that bumpy “road less traveled” and embrace all that \n\n\nviii | Preface \n\n\n\nJavaScript is and can do. With that knowledge, no technique, no \nframework, no popular buzzword acronym of the week will be \nbeyond your understanding.","metadata":{"loc":{"lines":{"from":43764,"to":43789}}}}],["647",{"pageContent":"viii | Preface \n\n\n\nJavaScript is and can do. With that knowledge, no technique, no \nframework, no popular buzzword acronym of the week will be \nbeyond your understanding. \n\nThese books each take on specific core parts of the language that are \nmost commonly misunderstood or under-understood, and dive very \ndeep and exhaustively into them. You should come away from read¬ \ning with a firm confidence in your understanding, not just of the \ntheoretical, but the practical “what you need to know” bits. \n\nThe JavaScript you know right now is probably parts handed down \nto you by others who’ve been burned by incomplete understanding. \nThat JavaScript is but a shadow of the true language. You don’t really \nknow JavaScript, yet, but if you dig into this series, you will. Read \non, my friends. JavaScript awaits you. \n\nReview","metadata":{"loc":{"lines":{"from":43789,"to":43809}}}}],["648",{"pageContent":"Review \n\nJavaScript is awesome. It’s easy to learn partially, and much harder to \nlearn completely (or even sufficiently). When developers encounter \nconfusion, they usually blame the language instead of their lack of \nunderstanding. These books aim to fix that, inspiring a strong \nappreciation for the language you can now, and should, deeply know. \n\n\n\nMany of the examples in this book assume \nmodern (and future-reaching) JavaScript engine \nenvironments, such as ES6. Some code may not \nwork as described if run in older (pre-ES6) \nengines. \n\n\nConventions Used in This Book \n\nThe following typographical conventions are used in this book: \n\nItalic \n\nIndicates new terms, URLs, email addresses, filenames, and file \nextensions. \n\nConstant width \n\nUsed for program listings, as well as within paragraphs to refer \nto program elements such as variable or function names, data¬ \nbases, data types, environment variables, statements, and key¬ \nwords. \n\n\nPreface | ix \n\n\n\n\n\nConstant width bold","metadata":{"loc":{"lines":{"from":43809,"to":43849}}}}],["649",{"pageContent":"Preface | ix \n\n\n\n\n\nConstant width bold \n\nShows commands or other text that should be typed literally by \nthe user. \n\n\nConstant width italic \n\nShows text that should be replaced with user-supplied values or \nby values determined by context. \n\n\n\nThis element signifies a tip or suggestion. \n\n\n\nThis element signifies a general note. \n\n\n\nThis element indicates a warning or caution. \n\n\nUsing Code Examples \n\nSupplemental material (code examples, exercises, etc.) is available \nfor download at http://bit.ly/ydkjs-types-code.","metadata":{"loc":{"lines":{"from":43849,"to":43882}}}}],["650",{"pageContent":"This element indicates a warning or caution. \n\n\nUsing Code Examples \n\nSupplemental material (code examples, exercises, etc.) is available \nfor download at http://bit.ly/ydkjs-types-code. \n\nThis book is here to help you get your job done. In general, if exam¬ \nple code is offered with this book, you may use it in your programs \nand documentation. You do not need to contact us for permission \nunless you’re reproducing a significant portion of the code. For \nexample, writing a program that uses several chunks of code from \nthis book does not require permission. Selling or distributing a CD- \nROM of examples from O’Reilly books does require permission. \nAnswering a question by citing this book and quoting example code \ndoes not require permission. Incorporating a significant amount of \nexample code from this book into your product’s documentation \ndoes require permission. \n\n\nx | Preface","metadata":{"loc":{"lines":{"from":43882,"to":43903}}}}],["651",{"pageContent":"x | Preface \n\n\n\n\n\n\n\n\n\n\nWe appreciate, but do not require, attribution. An attribution usu¬ \nally includes the title, author, publisher, and ISBN. For example: \n“You Don’t Know JavaScript: Types & Grammar by Kyle Simpson \n(O’Reilly). Copyright 2015 Getify Solutions, Inc., \n978-1-491-90419-0.” \n\nIf you feel your use of code examples falls outside fair use or the per¬ \nmission given above, feel free to contact us at permis- \nsions@oreilly.com. \n\nSafari® Books Online \n\n\nSafari \n\n\nSafari Books Online is an on-demand digital \nlibrary that delivers expert content in both \nbook and video form from the world’s lead¬ \ning authors in technology and business. \n\n\nTechnology professionals, software developers, web designers, and \nbusiness and creative professionals use Safari Books Online as their \nprimary resource for research, problem solving, learning, and certif¬ \nication training.","metadata":{"loc":{"lines":{"from":43903,"to":43939}}}}],["652",{"pageContent":"Safari Books Online offers a range of plans and pricing for enter¬ \nprise, government, education, and individuals. \n\nMembers have access to thousands of books, training videos, and \nprepublication manuscripts in one fully searchable database from \npublishers like O’Reilly Media, Prentice Hall Professional, Addison- \nWesley Professional, Microsoft Press, Sams, Que, Peachpit Press, \nFocal Press, Cisco Press, John Wiley & Sons, Syngress, Morgan \nKaufmann, IBM Redbooks, Packt, Adobe Press, FT Press, Apress, \nManning, New Riders, McGraw-Hill, Jones & Bartlett, Course Tech¬ \nnology, and hundreds more. For more information about Safari \nBooks Online, please visit us online. \n\n\nPreface | xi \n\n\n\nHow to Contact Us \n\nPlease address comments and questions concerning this book to the \npublisher: \n\nO’Reilly Media, Inc. \n\n1005 Gravenstein Highway North \nSebastopol, CA 95472 \n\n800-998-9938 (in the United States or Canada) \n\n707-829-0515 (international or local) \n\n707-829-0104 (fax)","metadata":{"loc":{"lines":{"from":43939,"to":43971}}}}],["653",{"pageContent":"O’Reilly Media, Inc. \n\n1005 Gravenstein Highway North \nSebastopol, CA 95472 \n\n800-998-9938 (in the United States or Canada) \n\n707-829-0515 (international or local) \n\n707-829-0104 (fax) \n\nWe have a web page for this book, where we list errata, examples, \nand any additional information. You can access this page at http:// \nbit.ly/ydkjs_types-and-grammar. \n\nTo comment or ask technical questions about this book, send email \nto bookquestions@oreilly.com. \n\nFor more information about our books, courses, conferences, and \nnews, see our website at http://www.oreilly.com. \n\nFind us on Facebook: http://facebook.com/oreilly \n\nFollow us on Twitter: http://twitter.com/oreillymedia \n\nWatch us on YouTube: http://www.youtube.com/oreillymedia \n\n\nxii | Preface \n\n\n\nCHAPTER 1 \n\n\nTypes \n\n\nMost developers would say that a dynamic language (like JS) does \nnot have types. Let’s see what the ES5.1 specification has to say on \nthe topic:","metadata":{"loc":{"lines":{"from":61960,"to":62000}}}}],["654",{"pageContent":"xii | Preface \n\n\n\nCHAPTER 1 \n\n\nTypes \n\n\nMost developers would say that a dynamic language (like JS) does \nnot have types. Let’s see what the ES5.1 specification has to say on \nthe topic: \n\nAlgorithms within this specification manipulate values each of \nwhich has an associated type. The possible value types are exactly \nthose defined in this clause. Types are further sub-classified into \nECMAScript language types and specification types. \n\nAn ECMAScript language type corresponds to values that are \ndirectly manipulated by an ECMAScript programmer using the \nECMAScript language. The ECMAScript language types are Unde¬ \nfined, Null, Boolean, String, Number, and Object. \n\nNow, if you’re a fan of strongly typed (statically typed) languages, \nyou may object to this usage of the word “type.” In those languages, \n“type” means a whole lot more than it does here in JS. \n\nSome people say JS shouldn’t claim to have “types,” and they should \ninstead be called “tags” or perhaps “subtypes.”","metadata":{"loc":{"lines":{"from":62000,"to":62029}}}}],["655",{"pageContent":"Some people say JS shouldn’t claim to have “types,” and they should \ninstead be called “tags” or perhaps “subtypes.” \n\nBah! We’re going to use this rough definition (the same one that \nseems to drive the wording of the spec): a type is an intrinsic, built- \nin set of characteristics that uniquely identifies the behavior of a par¬ \nticular value and distinguishes it from other values, both to the \nengine and to the developer. \n\nIn other words, if both the engine and the developer treat value 42 \n(the number) differently than they treat value \"42\" (the string), then \nthose two values have different types —number and string, respec- \n\n\n1 \n\n\n\n\ntively. When you use 42, you are intending to do something numeric, \nlike math. But when you use \"42\", you are intending to do some¬ \nthing string’ish, like outputting to the page, etc. These two values \nhave different types.","metadata":{"loc":{"lines":{"from":62029,"to":62051}}}}],["656",{"pageContent":"That’s by no means a perfect definition. But it’s good enough for this \ndiscussion. And it’s consistent with how JS describes itself. \n\nA Type by Any Other Name... \n\nBeyond academic definition disagreements, why does it matter if \nJavaScript has types or not? \n\nHaving a proper understanding of each type and its intrinsic behav¬ \nior is absolutely essential to understanding how to properly and \naccurately convert values to different types (see Chapter 4). Nearly \nevery JS program ever written will need to handle value coercion in \nsome shape or form, so it’s important you do so responsibly and \nwith confidence. \n\nIf you have the number value 42, but you want to treat it like a \nstring, such as pulling out the \"2\" as a character in position 1, you \nobviously must first convert (coerce) the value from number to \nstring. \n\nThat seems simple enough.","metadata":{"loc":{"lines":{"from":62053,"to":62073}}}}],["657",{"pageContent":"That seems simple enough. \n\nBut there are many different ways that such coercion can happen. \nSome of these ways are explicit, easy to reason about, and reliable. \nBut if you’re not careful, coercion can happen in very strange and \nsurprising ways. \n\nCoercion confusion is perhaps one of the most profound frustra¬ \ntions for JavaScript developers. It has often been criticized as being \nso dangerous as to be considered a flaw in the design of the language, \nto be shunned and avoided. \n\nArmed with a full understanding of JavaScript types, we’re aiming to \nillustrate why coercion’s bad reputation is largely overhyped and \nsomewhat undeserved—to flip your perspective so you see coer¬ \ncion’s power and usefulness. But first, we have to get a much better \ngrip on values and types. \n\n\n2 | Chapter 1: Types \n\n\n\n\nBuilt-in Types \n\nJavaScript defines seven built-in types: \n\n• null \n\n• undefined \n\n• boolean \n\n• number \n\n• string \n\n• object \n\n• symbol—added in ES6!","metadata":{"loc":{"lines":{"from":62073,"to":62113}}}}],["658",{"pageContent":"2 | Chapter 1: Types \n\n\n\n\nBuilt-in Types \n\nJavaScript defines seven built-in types: \n\n• null \n\n• undefined \n\n• boolean \n\n• number \n\n• string \n\n• object \n\n• symbol—added in ES6! \n\n\n\nAll of these types except object are called \n“primitives.” \n\n\nThe typeof operator inspects the type of the given value, and always \nreturns one of seven string values—surprisingly, there’s not an exact \n1-to-l match with the seven built-in types we just listed: \n\n\ntypeof undefined \n\n=== \"undefined\". \n\n; // true \n\ntypeof true \n\n=== \"boolean\"; \n\n// true \n\ntypeof 42 \n\n=== \"number\"; \n\n// true \n\ntypeof \"42\" \n\n=== \"string\"; \n\n// true \n\ntypeof { life: 42 } \n\n=== \"object\"; \n\n// true \n\n// added In ES6! \ntypeof SymbolQ \n\n=== \"symbol\"; \n\n// true \n\n\nThese six listed types have values of the corresponding type and \nreturn a string value of the same name, as shown. Symbol is a new \ndata type as of ES6, and will be covered in Chapter 3.","metadata":{"loc":{"lines":{"from":62113,"to":62187}}}}],["659",{"pageContent":"These six listed types have values of the corresponding type and \nreturn a string value of the same name, as shown. Symbol is a new \ndata type as of ES6, and will be covered in Chapter 3. \n\nAs you may have noticed, I excluded null from the above listing. It’s \nspecial —special in the sense that it’s buggy when combined with the \ntypeof operator: \n\ntypeof null === \"object\"; // true \n\nIt would have been nice (and correct!) if it returned \"null\", but this \noriginal bug in JS has persisted for nearly two decades, and will \n\n\nBuilt-in Types | 3 \n\n\n\n\nlikely never be fixed because there’s so much existing web content \nthat relies on its buggy behavior that “fixing” the bug would create \nmore “bugs” and break a lot of web software. \n\nIf you want to test for a null value using its type, you need a com¬ \npound condition: \n\nvar a = null; \n\n\n(!a && typeof a === \"object\"); // true","metadata":{"loc":{"lines":{"from":62187,"to":62216}}}}],["660",{"pageContent":"If you want to test for a null value using its type, you need a com¬ \npound condition: \n\nvar a = null; \n\n\n(!a && typeof a === \"object\"); // true \n\nnull is the only primitive value that is “falsy” (aka false-like; see \nChapter 4) but which also returns \"object\" from the typeof check. \n\nSo what’s the seventh string value that typeof can return? \n\ntypeof function a(){ /* .. */ } === \"function\"; // true \n\nIt’s easy to think that function would be a top-level built-in type in \nJS, especially given this behavior of the typeof operator. However, if \nyou read the spec, you’ll see it’s actually somewhat of a “subtype” of \nobject. Specifically, a function is referred to as a “callable object”— \nan object that has an internal [ [Call] ] property that allows it to be \ninvoked. \n\nThe fact that functions are actually objects is quite useful. Most \nimportantly, they can have properties. For example: \n\nfunction a(b,c) { \n\n/*■•*/ \n\n}","metadata":{"loc":{"lines":{"from":62216,"to":62245}}}}],["661",{"pageContent":"The fact that functions are actually objects is quite useful. Most \nimportantly, they can have properties. For example: \n\nfunction a(b,c) { \n\n/*■•*/ \n\n} \n\nThe function object has a length property set to the number of for¬ \nmal parameters it is declared with: \n\na.length; // 2 \n\nSince you declared the function with two formal named parameters \n(b and c), the “length of the function” is 2. \n\nWhat about arrays? They’re native to JS, so are they a special type? \n\ntypeof [1,2,3] === \"object\"; // true \n\nNope, just objects. It’s most appropriate to think of them also as a \n“subtype” of object (see Chapter 3), in this case with the additional \ncharacteristics of being numerically indexed (as opposed to just \nbeing string-keyed like plain objects) and maintaining an automati¬ \ncally updated .length property. \n\n\n4 | Chapter 1: Types \n\n\n\n\nValues as Types \n\nIn JavaScript, variables don’t have types— values have types. Variables \ncan hold any value, at any time.","metadata":{"loc":{"lines":{"from":62245,"to":62281}}}}],["662",{"pageContent":"4 | Chapter 1: Types \n\n\n\n\nValues as Types \n\nIn JavaScript, variables don’t have types— values have types. Variables \ncan hold any value, at any time. \n\nAnother way to think about JS types is that JS doesn’t have “type \nenforcement,” in that the engine doesn’t insist that a variable always \nholds values of the same initial type that it starts out with. A variable \ncan, in one assignment statement, hold a string, and in the next \nhold a number, and so on. \n\nThe value 42 has an intrinsic type of number, and its type cannot be \nchanged. Another value, like \"42\" with the string type, can be cre- \nated from the number value 42 through a process called coercion (see \nChapter 4). \n\nIf you use typeof against a variable, it’s not asking “What’s the type \nof the variable?” as it may seem, since JS variables have no types. \nInstead, it’s asking “What’s the type of the value in the variable?” \n\nvar a = 42; \n\ntypeof a; // \"number\" \n\na = true; \n\ntypeof a; // \"bootean\"","metadata":{"loc":{"lines":{"from":62281,"to":62312}}}}],["663",{"pageContent":"var a = 42; \n\ntypeof a; // \"number\" \n\na = true; \n\ntypeof a; // \"bootean\" \n\nThe typeof operator always returns a string. So: \ntypeof typeof 42; // \"string\" \n\nThe first typeof 42 returns \"number\", and typeof \"number\" is \n\"string\". \n\nundefined Versus \"undeclared\" \n\nVariables that have no value currently actually have the undefined \nvalue. Calling typeof against such variables will return \"unde \nfined\": \n\nvar a; \n\ntypeof a; // \"undefined\" \n\nvar b = 42; \nvar c; \n\n// tater \nb = c; \n\n\nValues as Types | 5 \n\n\n\ntypeof b; // \"undefined\" \ntypeof c; // \"undefined\" \n\nIt’s tempting for most developers to think of the word “undefined” \nas a synonym for “undeclared.” However, in JS, these two concepts \nare quite different. \n\nAn “undefined” variable is one that has been declared in the accessi¬ \nble scope, but at the moment has no other value in it. By contrast, an \n“undeclared” variable is one that has not been formally declared in \nthe accessible scope. \n\nConsider: \n\nvar a; \n\na; // undefined","metadata":{"loc":{"lines":{"from":62312,"to":62363}}}}],["664",{"pageContent":"Consider: \n\nvar a; \n\na; // undefined \n\nb; // ReferenceError: b Is not defined \n\nAn annoying confusion is the error message that browsers assign to \nthis condition. As you can see, the message is “b is not defined,” \nwhich is of course very easy and reasonable to confuse with “b is \nundefined.” Yet again, “undefined” and “is not defined” are very dif¬ \nferent things. It’d be nice if the browsers said something like “b is \nnot found” or “b is not declared” to reduce the confusion! \n\nThere’s also a special behavior associated with typeof as it relates to \nundeclared variables that even further reinforces the confusion. \nConsider: \n\nvar a; \n\ntypeof a; // \"undefined\" \ntypeof b; // \"undefined\" \n\nThe typeof operator returns \"undefined\" even for “undeclared” (or \n“not defined”) variables. Notice that there was no error thrown \nwhen we executed typeof b, even though b is an undeclared vari¬ \nable. This is a special safety guard in the behavior of typeof.","metadata":{"loc":{"lines":{"from":62363,"to":62390}}}}],["665",{"pageContent":"Similar to above, it would have been nice if typeof used with an \nundeclared variable returned “undeclared” instead of conflating the \nresult value with the different “undefined” case. \n\n\n6 | Chapter 1: Types \n\n\n\n\ntypeof Undeclared \n\nNevertheless, this safety guard is a useful feature when dealing with \nJavaScript in the browser, where multiple script files can load vari¬ \nables into the shared global namespace. \n\n\n\nMany developers believe there should never be \nany variables in the global namespace, and that \neverything should be contained in modules and \nprivate/separate namespaces. This is great in \ntheory but nearly impossible in practice; still, it’s \na good goal to strive toward! Fortunately, ES6 \nadded first-class support for modules, which will \neventually make that much more practical.","metadata":{"loc":{"lines":{"from":62392,"to":62417}}}}],["666",{"pageContent":"As a simple example, imagine having a “debug mode” in your pro¬ \ngram that is controlled by a global variable (flag) called DEBUG. Youd \nwant to check if that variable was declared before performing a \ndebug task like logging a message to the console. A top-level global \nvar DEBUG = true declaration would only be included in a \n“debug.js” file, which you only load into the browser when you’re in \ndevelopment/testing, but not in production. \n\nHowever, you have to take care in how you check for the global \nDEBUG variable in the rest of your application code, so that you don’t \nthrow a ReferenceError. The safety guard on typeof is our friend \nin this case: \n\n// oops, this woutd throw an error! \n\nif (DEBUG) { \n\nconsole.log( \"Debugging is starting\" ); \n\n} \n\n// this is a safe existence check \n\nif (typeof DEBUG !== \"undefined\") { \n\nconsole.log( \"Debugging is starting\" ); \n\n}","metadata":{"loc":{"lines":{"from":62420,"to":62447}}}}],["667",{"pageContent":"if (DEBUG) { \n\nconsole.log( \"Debugging is starting\" ); \n\n} \n\n// this is a safe existence check \n\nif (typeof DEBUG !== \"undefined\") { \n\nconsole.log( \"Debugging is starting\" ); \n\n} \n\nThis sort of check is useful even if you’re not dealing with user- \ndefined variables (like DEBUG). If you are doing a feature check for a \nbuilt-in API, you may also find it helpful to check without throwing \nan error: \n\nif (typeof atob === \"undefined\") { \natob = functionQ { /*..*/ }; \n\n} \n\n\nValues as Types | 7","metadata":{"loc":{"lines":{"from":62447,"to":62472}}}}],["668",{"pageContent":"if (typeof atob === \"undefined\") { \natob = functionQ { /*..*/ }; \n\n} \n\n\nValues as Types | 7 \n\n\n\n\nIf you’re defining a “polyfill” for a feature if it \ndoesn’t already exist, you probably want to avoid \nusing var to make the atob declaration. If you \ndeclare var atob inside the if statement, this \ndeclaration is hoisted (see the Scope & Closures \ntitle in this series) to the top of the scope, even if \nthe if condition doesn’t pass (because the global \natob already exists!). In some browsers and for \nsome special types of global built-in variables \n(often called “host objects”), this duplicate dec¬ \nlaration may throw an error. Omitting the var \nprevents this hoisted declaration. \n\nAnother way of doing these checks against global variables but \nwithout the safety guard feature of typeof is to observe that all \nglobal variables are also properties of the global object, which in the \nbrowser is basically the window object. So, the above checks could \nhave been done (quite safely) as:","metadata":{"loc":{"lines":{"from":62472,"to":62500}}}}],["669",{"pageContent":"if (window.DEBUG) { \n\n// \n\n} \n\nif (!window.atob) { \n\n// ■■ \n\n1 \n\nUnlike referencing undeclared variables, there is no ReferenceEr \nror thrown if you try to access an object property (even on the \nglobal window object) that doesn’t exist. \n\nOn the other hand, manually referencing the global variable with a \nwindow reference is something some developers prefer to avoid, \nespecially if your code needs to run in multiple JS environments \n(not just browsers, but server-side node.js, for instance), where the \nglobal variable may not always be called window. \n\nTechnically, this safety guard on typeof is useful even if you’re not \nusing global variables, though these circumstances are less common, \nand some developers may find this design approach less desirable. \nImagine a utility function that you want others to copy-and-paste \ninto their programs or modules, in which you want to check to see if \nthe including program has defined a certain variable (so that you \ncan use it) or not:","metadata":{"loc":{"lines":{"from":62502,"to":62530}}}}],["670",{"pageContent":"8 | Chapter 1: Types \n\n\n\n\n\nfunction doSonethingCool() { \nvar helper = \n\n(typeof FeatureXYZ !== \"undefined\") ? \n\nFeatureXYZ : \n\nfunction() { /*.. default feature ..*/ }; \n\nvar val = helperQ; \n\n// •• \n\n} \n\ndoSomethingCoolQ tests for a variable called FeatureXYZ, and if \nfound, uses it, but if not, uses its own. Now, if someone includes this \nutility into their module/program, it safely checks if they’ve defined \nFeatureXYZ or not: \n\n//an IIFE (see the \"Immediately Invoked Function Expressions\" \n\n// discussion in the Scope & Closures title in this series) \n(function(){ \n\nfunction FeatureXYZQ { /*.. my XYZ feature ..*/ } \n\n// include 'doSomethingCool(..)' \nfunction doSomethingCool() { \nvar helper = \n\n(typeof FeatureXYZ !== \"undefined\") ? \n\nFeatureXYZ : \n\nfunctionQ { /*.. default feature ..*/ }; \n\nvar val = helperQ; \n\n// •• \n\n} \n\ndoSomethingCool(); \n\n}) 0 ;","metadata":{"loc":{"lines":{"from":62534,"to":62585}}}}],["671",{"pageContent":"(typeof FeatureXYZ !== \"undefined\") ? \n\nFeatureXYZ : \n\nfunctionQ { /*.. default feature ..*/ }; \n\nvar val = helperQ; \n\n// •• \n\n} \n\ndoSomethingCool(); \n\n}) 0 ; \n\nHere, FeatureXYZ is not at all a global variable, but we’re still using \nthe safety guard of typeof to make it safe to check for. And impor¬ \ntantly, here there is no object we can use (like we did for global vari¬ \nables with window._) to make the check, so typeof is quite \n\nhelpful. \n\nOther developers would prefer a design pattern called “dependency \ninjection,” where instead of doSomethingCoolQ inspecting implic¬ \nitly for FeatureXYZ to be defined outside/around it, it would need to \nhave the dependency explicitly passed in, like: \n\nfunction doSomethingCool(FeatureXYZ) { \nvar helper = FeatureXYZ || \n\nfunctionQ { /*.. default feature ..*/ }; \n\nvar val = helperQ; \n\n\nValues as Types | 9 \n\n\n\n// .. \n\n}","metadata":{"loc":{"lines":{"from":62585,"to":62627}}}}],["672",{"pageContent":"function doSomethingCool(FeatureXYZ) { \nvar helper = FeatureXYZ || \n\nfunctionQ { /*.. default feature ..*/ }; \n\nvar val = helperQ; \n\n\nValues as Types | 9 \n\n\n\n// .. \n\n} \n\nThere’s lots of options when designing such functionality. No one \npattern here is “correct” or “wrong”—there are various trade-offs to \neach approach. But overall, it’s nice that the typeof undeclared \nsafety guard gives us more options. \n\nReview \n\nJavaScript has seven built-in types: null, undefined, boolean, nun \nber, string, object, and symbol. They can be identified by the \ntypeof operator. \n\nVariables don’t have types, but the values in them do. These types \ndefine the intrinsic behavior of the values. \n\nMany developers will assume “undefined” and “undeclared” are \nroughly the same thing, but in JavaScript, they’re quite different, \nundefined is a value that a declared variable can hold. “Undeclared” \nmeans a variable has never been declared.","metadata":{"loc":{"lines":{"from":62627,"to":62660}}}}],["673",{"pageContent":"JavaScript unfortunately kind of conflates these two terms, not only \nin its error messages (“ReferenceError: a is not defined”) but also in \nthe return values of typeof, which is \"undefined\" for both cases. \n\nHowever, the safety guard (preventing an error) on typeof when \nused against an undeclared variable can be helpful in certain cases. \n\n\n10 | Chapter 1: Types \n\n\n\nCHAPTER 2 \n\n\nValues \n\n\narrays, strings, and numbers are the most basic building blocks of \nany program, but JavaScript has some unique characteristics with \nthese types that may either delight or confound you. \n\nLet’s look at several of the built-in value types in JS, and explore how \nwe can more fully understand and correctly leverage their behaviors. \n\nArrays \n\nAs compared to other type-enforced languages, JavaScript arrays \nare just containers for any type of value, from string to number to \nobject to even another array (which is how you get multidimen¬ \nsional arrays): \n\nvar a = [ 1 , \" 2 \", [3] ];","metadata":{"loc":{"lines":{"from":62662,"to":62694}}}}],["674",{"pageContent":"var a = [ 1 , \" 2 \", [3] ]; \n\na.length; // 3 \n\na[0] === 1; // true \n\na[2][0] === 3; // true \n\nYou don’t need to presize your arrays (see “Array(..)” on page 44), \nyou can just declare them and add values as you see fit: \n\n\n11 \n\n\n\n\nvar a = [ ]; \n\n\na.length; // 0 \n\na [0] = i; \na[l] = \"2\"; \na[2] = [ 3 ]; \n\na.length; // 3 \n\n\n\nUsing delete on an array value will remove \nthat slot from the array, but even if you remove \nthe final element, it does not update the length \nproperty, so be careful! We’ll cover the delete \noperator itself in more detail in Chapter 5. \n\n\nBe careful about creating “sparse” arrays (leaving or creating empty/ \nmissing slots): \n\nvar a = [ ]; \na[0] = 1; \n\n// no 'a[1]' slot set here \na[2] = [ 3 ]; \n\na[1]; // undefined \n\na.length; // 3","metadata":{"loc":{"lines":{"from":62694,"to":62742}}}}],["675",{"pageContent":"Be careful about creating “sparse” arrays (leaving or creating empty/ \nmissing slots): \n\nvar a = [ ]; \na[0] = 1; \n\n// no 'a[1]' slot set here \na[2] = [ 3 ]; \n\na[1]; // undefined \n\na.length; // 3 \n\nWhile that works, it can lead to some confusing behavior with the \n“empty slots” you leave in between. While the slot appears to have \nthe undefined value in it, it will not behave the same as if the slot is \nexplicitly set (a[l] = undefined). See “Array(..)” on page 44 for \nmore information. \n\narrays are numerically indexed (as youd expect), but the tricky \nthing is that they also are objects that can have string keys/proper¬ \nties added to them (but which don’t count toward the length of the \narray): \n\nvar a = [ ]; \n\n\na[0] = 1; \na[\"foobar\"] = 2; \n\na.length; // 1 \na[\"foobar\"]; // 2 \na.foobar; // 2 \n\n\n12 | Chapter 2: Values","metadata":{"loc":{"lines":{"from":62742,"to":62777}}}}],["676",{"pageContent":"var a = [ ]; \n\n\na[0] = 1; \na[\"foobar\"] = 2; \n\na.length; // 1 \na[\"foobar\"]; // 2 \na.foobar; // 2 \n\n\n12 | Chapter 2: Values \n\n\n\n\n\nHowever, a gotcha to be aware of is that if a string value intended \nas a key can be coerced to a standard base-10 number, then it is \nassumed that you wanted to use it as a number index rather than as a \nstring key! \n\nvar a = [ ]; \nariS\"] = 42; \na.length; // 14 \n\nGenerally, it’s not a great idea to add string keys/properties to \narrays. Use objects for holding values in keys/properties, and save \narrays for strictly numerically indexed values. \n\nArray-Likes \n\nThere will be occasions where you need to convert an array-like \nvalue (a numerically indexed collection of values) into a true array, \nusually so you can call array utilities (like indexOf (..), concat(..), \nforEach(..), etc.) against the collection of values.","metadata":{"loc":{"lines":{"from":62777,"to":62812}}}}],["677",{"pageContent":"For example, various DOM query operations return lists of DOM \nelements that are not true arrays but are array-like enough for our \nconversion purposes. Another common example is when functions \nexpose the arguments (array-like) object (as of ES6, deprecated) to \naccess the arguments as a list. \n\nOne very common way to make such a conversion is to borrow the \nslice(..) utility against the value: \n\nfunction foo() { \n\nvar arr = Array.prototype.slice.call( arguments ); \narr.push( \"bam\" ); \nconsole.log( arr ); \n\n} \n\nfoo( \"bar\", \"baz\" ); // [\"bar\",\"baz\",\"bam\"] \n\nIf slice() is called without any other parameters, as it effectively is \nin the above snippet, the default values for its parameters have the \neffect of duplicating the array (or, in this case, array-like). \n\nAs of ES6, there’s also a built-in utility called Array.from(..) that \ncan do the same task: \n\n\nArrays | 13 \n\n\n\n\n\nvar arr = Array.from( arguments );","metadata":{"loc":{"lines":{"from":62814,"to":62847}}}}],["678",{"pageContent":"As of ES6, there’s also a built-in utility called Array.from(..) that \ncan do the same task: \n\n\nArrays | 13 \n\n\n\n\n\nvar arr = Array.from( arguments ); \n\n\n\nArray .from( ..) has several powerful capabili¬ \nties, and will be covered in detail in the ES6 & \nBeyond title in this series. \n\n\nStrings \n\nIt’s a very common belief that strings are essentially just arrays of \ncharacters. While the implementation under the covers may or may \nnot use arrays, it’s important to realize that JavaScript strings are \nreally not the same as arrays of characters. The similarity is mostly \njust skin-deep. \n\nFor example, let’s consider these two values: \n\nvar a = \"foo\"; \n\nvar b = [\"f\",\"o\",\"o\"]; \n\nStrings do have a shallow resemblance to arrays —they are array- \nlikes, as above. For instance, both of them have a length property, \nan indexOf (..) method (array version only as of ES5), and a con \ncat( ..) method: \n\n[source,js] \n\n\na.length; \n\n// \n\n3 \n\nb.length; \n\n// \n\n3 \n\na.indexOf( \"o\" ); \n\n// \n\n1","metadata":{"loc":{"lines":{"from":62847,"to":62904}}}}],["679",{"pageContent":"[source,js] \n\n\na.length; \n\n// \n\n3 \n\nb.length; \n\n// \n\n3 \n\na.indexOf( \"o\" ); \n\n// \n\n1 \n\nb.indexOf( \"o\" ); \n\n// \n\n1 \n\nvar c = a.concat( \"bar\" ); \n\n// \n\n\"foobar \n\nvar d = b.concat( [\"b\",\"a\",\"r\"] ' \n\n); // \n\n\na === c; \n\n// \n\nfalse \n\n~o \n\nII \n\nII \n\nII \n\n_Q \n\n// \n\nfalse \n\na; \n\n// \n\n\"foo\" \n\nb; \n\n// \n\n[\"fV'o \n\n\nSo, they’re both basically just “arrays of characters,” right? Not \nexactly: \n\n\n14 | Chapter 2: Values \n\n\n\n\n\na[l] = \"0\"; \nb[l] = \"0\"; \n\n\na; // \"foo\" \n\nb; // [\"f\",\"0\",\"o\"] \n\nJavaScript strings are immutable, while arrays are quite mutable. \nMoreover, the a [ 1 ] character position access form was not always \nwidely valid JavaScript. Older versions of IE did not allow that syn¬ \ntax (but now they do). Instead, the correct approach has been \na.charAt(l).","metadata":{"loc":{"lines":{"from":62904,"to":62997}}}}],["680",{"pageContent":"A further consequence of immutable strings is that none of the \nstring methods that alter its contents can modify in-place, but \nrather must create and return new strings. By contrast, many of the \narray methods that change array contents actually do modify in- \nplace: \n\nc = a.totlpperCaseO; \na === c; // fatse \n\na; // \"foo\" \n\nc; // \"FOO\" \n\nb.push( \"!\" ); \n\nb; // [\"f\",\"0\",\"o\",\"!\"] \n\nAlso, many of the array methods that could be helpful when dealing \nwith strings are not actually available for them, but we can “bor¬ \nrow” nonmutation array methods against our string: \n\na.join; // undefined \n\na.map; // undefined \n\nvar c = Array.prototype.join.call( a, ); \nvar d = Array.prototype.map.calt( a, function(v){ \nreturn v.tolIpperCaseQ + \n\n} ).join( \"\" ); \n\nc; // \"f-o-o\" \n\nd; // \"F.0.0.\" \n\nLet’s take another example: reversing a string (incidentally, a com¬ \nmon JavaScript interview trivia question!), arrays have a reverseQ \nin-place mutator method, but strings do not:","metadata":{"loc":{"lines":{"from":62999,"to":63036}}}}],["681",{"pageContent":"Let’s take another example: reversing a string (incidentally, a com¬ \nmon JavaScript interview trivia question!), arrays have a reverseQ \nin-place mutator method, but strings do not: \n\na. reverse; // undefined \n\nb. reverse!); // ,\"o\",\"0\",\"f\"] \n\nb; // [\"!\",\"o\",\"0\",\"f\"] \n\n\nStrings | 15 \n\n\n\nUnfortunately, this “borrowing” doesn’t work with array mutators, \nbecause strings are immutable and thus can’t be modified in place: \n\nArray.prototype.reverse.calt( a ); \n\n// stilt returns a String object wrapper (see Chapter 3) \n\n// for \"foo\" :( \n\nAnother workaround (aka hack) is to convert the string into an \narray, perform the desired operation, then convert it back to a \nstring: \n\nvar c = a \n\n// split 'a' into an array of characters \n•split( \"\" ) \n\n// reverse the array of characters \n.reverse() \n\n// join the array of characters back to a string \n.join( \"\" ); \n\nc; // \"oof\"","metadata":{"loc":{"lines":{"from":63036,"to":63075}}}}],["682",{"pageContent":"var c = a \n\n// split 'a' into an array of characters \n•split( \"\" ) \n\n// reverse the array of characters \n.reverse() \n\n// join the array of characters back to a string \n.join( \"\" ); \n\nc; // \"oof\" \n\nIf that feels ugly, it is. Nevertheless, it works for simple strings, so if \nyou need something quick-n-dirty, often such an approach gets the \njob done. \n\n\n\nBe careful! This approach doesn’t work for \nstrings with complex (Unicode) characters in \nthem (astral symbols, multibyte characters, etc.). \nYou need more sophisticated library utilities that \nare unicode-aware for such operations to be \nhandled accurately. Consult Mathias Bynens’ \nwork on the subject: Esrever.","metadata":{"loc":{"lines":{"from":63075,"to":63100}}}}],["683",{"pageContent":"The other way to look at this is if you are more commonly doing \ntasks on your “strings” that treat them as basically arrays of charac¬ \nters, perhaps it’s better to just actually store them as arrays rather \nthan as strings. You’ll probably save yourself a lot of hassle of con¬ \nverting from string to array each time. You can always call \njoin( \"\") on the array of characters whenever you actually need the \nstring representation. \n\nNumbers \n\nJavaScript has just one numeric type: number. This type includes \nboth “integer” values and fractional decimal numbers. I say “integer” \n\n\n16 | Chapter 2: Values \n\n\n\n\nin quotes because it’s long been a criticism of JS that there’s not true \nintegers, as there are in other languages. That may change at some \npoint in the future, but for now, we just have numbers for everything. \n\nSo, in JS, an “integer” is just a value that has no fractional decimal \nvalue. That is, 42.0 is as much an “integer” as 42.","metadata":{"loc":{"lines":{"from":63103,"to":63127}}}}],["684",{"pageContent":"So, in JS, an “integer” is just a value that has no fractional decimal \nvalue. That is, 42.0 is as much an “integer” as 42. \n\nLike most modern languages, including practically all scripting lan¬ \nguages, the implementation of JavaScript’s numbers is based on the \n“IEEE 754” standard, often called “floating-point.” JavaScript specifi¬ \ncally uses the “double precision” format (aka “64-bit binary”) of the \nstandard. \n\nThere are many great write-ups on the Web about the nitty-gritty \ndetails of how binary floating-point numbers are stored in memory, \nand the implications of those choices. Because understanding bit \npatterns in memory is not strictly necessary to understand how to \ncorrectly use numbers in JS, we’ll leave it as an exercise for the inter¬ \nested reader if you’d like to dig further into IEEE 754 details. \n\nNumeric Syntax \n\nNumber literals are expressed in JavaScript generally as base-10 dec¬ \nimal literals. For example: \n\nvar a = 42; \nvar b = 42.3;","metadata":{"loc":{"lines":{"from":63127,"to":63149}}}}],["685",{"pageContent":"Numeric Syntax \n\nNumber literals are expressed in JavaScript generally as base-10 dec¬ \nimal literals. For example: \n\nvar a = 42; \nvar b = 42.3; \n\nThe leading portion of a decimal value, if 0, is optional: \n\nvar a = 0.42; \nvar b = .42; \n\nSimilarly, the trailing portion (the fractional) of a decimal value after \nthe ., if 0, is optional: \n\nvar a = 42.0; \nvar b = 42.; \n\n\n\n42. is pretty uncommon, and probably not a \ngreat idea if you’re trying to avoid confusion \nwhen other people read your code. But it is, nev¬ \nertheless, valid. \n\n\nBy default, most numbers will be outputted as base-10 decimals, with \ntrailing fractional 0s removed. So: \n\n\nNumbers | 17 \n\n\n\n\nvar a = 42.300; \nvar b = 42.0; \n\na; // 42.3 \nb; // 42 \n\nVery large or very small numbers will by default be outputted in \nexponent form, the same as the output of the toExponentialQ \nmethod, like: \n\nvar a = 5E10; \n\na; // 50000000000 \n\na.toExponentialQ; // \"5e+10\" \n\nvar b = a * a; \n\nb; // 2.5e+21 \n\nvar c = 1 / a; \n\nc; // 2e-ll","metadata":{"loc":{"lines":{"from":63149,"to":63207}}}}],["686",{"pageContent":"var a = 5E10; \n\na; // 50000000000 \n\na.toExponentialQ; // \"5e+10\" \n\nvar b = a * a; \n\nb; // 2.5e+21 \n\nvar c = 1 / a; \n\nc; // 2e-ll \n\nBecause number values can be boxed with the Number object wrapper \n(see Chapter 3), number values can access methods that are built into \nthe Number, prototype (see Chapter 3). For example, the \ntoFixed(..) method allows you to specify how many fractional \ndecimal places youd like the value to be represented with: \n\nvar a = 42.59; \n\na.toFixed( 0 ); // \"43\" \n\na.toFixed( 1 ); // \"42.6\" \n\na.toFixed( 2 ); // \"42.59\" \n\na.toFixed( 3 ); // \"42.590\" \n\na.toFlxed( 4 ); // \"42.5900\" \n\nNotice that the output is actually a string representation of the num \nber, and that the value is 0-padded on the righthand side if you ask \nfor more decimals than the value holds. \n\ntoPrecision(..) is similar, but specifies how many significant digits \nshould be used to represent the value: \n\nvar a = 42.59;","metadata":{"loc":{"lines":{"from":63207,"to":63246}}}}],["687",{"pageContent":"toPrecision(..) is similar, but specifies how many significant digits \nshould be used to represent the value: \n\nvar a = 42.59; \n\na.toPreclsion( 1 ); // \"4e+l\" \na.toPrecision( 2 ); // \"43\" \na.toPrecision( 3 ); // \"42.6\" \na.toPrecision( 4 ); // \"42.59\" \na.toPreclsion( 5 ); // \"42.590\" \na.toPrecision( 6 ); // \"42.5900\" \n\n\n18 | Chapter 2: Values \n\n\n\n\nYou don’t have to use a variable with the value in it to access these \nmethods; you can access these methods directly on number literals. \nBut you have to be careful with the . operator. Since . is a valid \nnumeric character, it will first be interpreted as part of the number \nliteral, if possible, instead of being interpreted as a property acces¬ \nsor: \n\n\n// Invalid syntax: \n\n42.toFixed( 3 ); // SyntaxError \n\n// these are all valid: \n\n(42).toFlxed( 3 ); // \"42.000\" \n\n0.42.toFlxed( 3 ); // \"0.420\" \n\n42..toFixed( 3 ); // \"42.000\"","metadata":{"loc":{"lines":{"from":63246,"to":63282}}}}],["688",{"pageContent":"// Invalid syntax: \n\n42.toFixed( 3 ); // SyntaxError \n\n// these are all valid: \n\n(42).toFlxed( 3 ); // \"42.000\" \n\n0.42.toFlxed( 3 ); // \"0.420\" \n\n42..toFixed( 3 ); // \"42.000\" \n\n42.toFixed(3) is invalid syntax, because the . is swallowed up as \npart of the 42. literal (which is valid—see above!), and so then \nthere’s no . property operator present to make the . to Fixed access. \n\n42. .toFtxed(3) works because the first . is part of the number and \nthe second . is the property operator. But it probably looks strange, \nand indeed it’s very rare to see something like that in actual Java¬ \nScript code. In fact, it’s pretty uncommon to access methods directly \non any of the primitive values. Uncommon doesn’t mean bad or \nwrong.","metadata":{"loc":{"lines":{"from":63282,"to":63303}}}}],["689",{"pageContent":"There are libraries that extend the built-in Num \nber. prototype (see Chapter 3) to provide extra \noperations on/with numbers, and so in those \ncases, it’s perfectly valid to use something like \n10. .makeltRainO to set off a 10-second money \nraining animation, or something else silly like \nthat. \n\n\nThis is also technically valid (notice the space): \n\n42 .toFixed(3); // \"42.000\" \n\nHowever, with the number literal specifically, this is a particularly \nconfusing coding style and will serve no other purpose but to con¬ \nfuse other developers (and your future self). Avoid it. \n\nnumbers can also be specified in exponent form, which is common \nwhen representing larger numbers, such as: \n\n\nNumbers | 19 \n\n\n\n\n\nvar onethousand = 1E3; // means 1 * 10*3 \n\nvar onemllllononehundredthousand = 1.1E6; // means 1.1 * 10 A 6 \n\n\nnumber literals can also be expressed in other bases, like binary, \noctal, and hexadecimal. \n\nThese formats work in current versions of JavaScript:","metadata":{"loc":{"lines":{"from":63307,"to":63342}}}}],["690",{"pageContent":"number literals can also be expressed in other bases, like binary, \noctal, and hexadecimal. \n\nThese formats work in current versions of JavaScript: \n\n0xf3; // hexadecimal for: 243 \n0Xf3; // ditto \n\n0363; // octal for: 243 \n\n\n\nStarting with ES6 + strict mode, the 0363 form \nof octal literals is no longer allowed (see below \nfor the new form). The 0363 form is still allowed \nin non-strict mode, but you should stop using \nit anyway, to be future-friendly (and because you \nshould be using strict mode by now!). \n\n\nAs of ES6, the following new forms are also valid: \n\n00363; // octal for: 243 \n\n00363; // ditto \n\n0bllll0011; // binary for: 243 \n0B11110011; // ditto \n\nPlease do your fellow developers a favor: never use the 00363 form. \n0 next to capital 0 is just asking for confusion. Always use the lower¬ \ncase predicates 0x, 0b, and 0o. \n\nSmall Decimal Values","metadata":{"loc":{"lines":{"from":63342,"to":63375}}}}],["691",{"pageContent":"Please do your fellow developers a favor: never use the 00363 form. \n0 next to capital 0 is just asking for confusion. Always use the lower¬ \ncase predicates 0x, 0b, and 0o. \n\nSmall Decimal Values \n\nThe most (in)famous side effect of using binary floating-point num¬ \nbers (which, remember, is true of all languages that use IEEE 754— \nnot just JavaScript as many assume/pretend) is: \n\n0.1 + 0.2 === 0.3; // false \n\nMathematically, we know that statement should be true. Why is it \nfalse? \n\nSimply put, the representations for 0.1 and 0.2 in binary floating \npoint are not exact, so when they are added, the result is not exactly \n0.3. It’s really close, 0.30000000000000004, but if your comparison \nfails, “close” is irrelevant. \n\n\n20 | Chapter 2:Values","metadata":{"loc":{"lines":{"from":63375,"to":63396}}}}],["692",{"pageContent":"20 | Chapter 2:Values \n\n\n\n\n\n\nShould JavaScript switch to a different number \nimplementation that has exact representations \nfor all values? Some think so. There have been \nmany alternatives presented over the years. \nNone of them have been accepted, and perhaps \nnone will ever be. As easy as it may seem to just \nwave a hand and say, “Fix that bug already!”, it’s \nnot nearly that easy. If it were, it most definitely \nwould have been changed a long time ago. \n\n\nNow, the question is, if some numbers can’t be trusted to be exact, \ndoes that mean we can’t use numbers at all? Of course not. \n\nThere are some applications where you need to be more careful, \nespecially when dealing with fractional decimal values. There are \nalso plenty of (maybe most?) applications that only deal with whole \nnumbers (“integers”), and moreover, only deal with numbers in the \nmillions or trillions at maximum. These applications have been, and \nalways will be, perfectly safe to use numeric operations in JS.","metadata":{"loc":{"lines":{"from":63396,"to":63422}}}}],["693",{"pageContent":"What if we did need to compare two numbers, like 0.1 + 0.2 to 0 . 3, \nknowing that the simple equality test fails? \n\nThe most commonly accepted practice is to use a tiny “rounding \nerror” value as the tolerance for comparison. This tiny value is often \ncalled “machine epsilon,” which is commonly 2 A -52 \n(2.220446049250313e-16) for the kind of numbers in JavaScript. \n\nAs of ES6, Number.EPSILON is predefined with this tolerance value, \nso you’d want to use it, but you can safely polyfill the definition for \npre-ES6: \n\nIf (INumber.EPSILON) { \n\nNumber.EPSILON = Math.pow(2,-52); \n\n} \n\nWe can use this Number.EPSILON to compare two numbers for \n“equality” (within the rounding error tolerance): \n\nfunction numbersCLoseEnoughToEqual(nl,n2) { \n\nreturn Math.abs( nl - n2 ) < Number.EPSILON; \n\n} \n\nvar a = 0.1 + 0.2; \nvar b = 0.3; \n\n\nNumbers | 21 \n\n\n\n\n\nnumbersCloseEnoughToEqual( a, b ); // true \n\nnumbersCloseEnoughToEqual( 0.0000001, 0.0000002 ); // false","metadata":{"loc":{"lines":{"from":63424,"to":63463}}}}],["694",{"pageContent":"} \n\nvar a = 0.1 + 0.2; \nvar b = 0.3; \n\n\nNumbers | 21 \n\n\n\n\n\nnumbersCloseEnoughToEqual( a, b ); // true \n\nnumbersCloseEnoughToEqual( 0.0000001, 0.0000002 ); // false \n\nThe maximum floating-point value that can be represented is \nroughly 1.798e+308 (which is really, really, really huge!), predefined \nfor you as Number.MAX_VALUE. On the small end, Number.MIN_VALUE \nis roughly 5e-324, which isn’t negative but is really close to zero! \n\nSafe Integer Ranges \n\nBecause of how numbers are represented, there is a range of “safe” \nvalues for the whole number “integers,” and it’s significantly less than \nNumber.MAX_VALUE. \n\nThe maximum integer that can “safely” be represented (that is, \nthere’s a guarantee that the requested value is actually representable \nunambiguously) is 2 A 53 - 1, which is 9007199254740991. If you \ninsert your commas, you’ll see that this is just over 9 quadrillion. So \nthat’s pretty darn big for numbers to range up to.","metadata":{"loc":{"lines":{"from":63463,"to":63494}}}}],["695",{"pageContent":"This value is actually automatically predefined in ES6, as Num \nber .MAX_SAFE_INTEGER. Unsurprisingly, there’s a minimum value, \n-9007199254740991, and it’s defined in ES6 as Num \nber.MIN_SAFE_INTEGER. \n\nThe main scenario in which JS programs are confronted with such \nlarge numbers is when dealing with 64-bit IDs from databases, etc. \n64-bit numbers cannot be represented accurately with the number \ntype, so they must be stored in (and transmitted to/from) JavaScript \nusing string representation. \n\nNumeric operations on such large ID number values (besides com¬ \nparison, which will be fine with strings) aren’t all that common, \nthankfully. But if you do need to perform math on these very large \nvalues, for now you’ll need to use a big number utility. Big numbers \nmay get official support in a future version of JavaScript. \n\nTesting for Integers \n\nTo test if a value is an integer, you can use the ES6-specified Num \nber.islnteger(..): \n\nNumber.lslnteger( 42 ); // true","metadata":{"loc":{"lines":{"from":63496,"to":63518}}}}],["696",{"pageContent":"Testing for Integers \n\nTo test if a value is an integer, you can use the ES6-specified Num \nber.islnteger(..): \n\nNumber.lslnteger( 42 ); // true \n\nNumber.islnteger( 42.000 ); // true \nNumber.islnteger( 42.3 ); // false \n\n\n22 | Chapter 2: Values \n\n\n\n\nTo polyfill Number. islnteger(..) for pre-ES6: \n\nIf ([Number.islnteger) { \n\nNumber.islnteger = functlon(num) { \n\nreturn typeof num == \"number\" && num % 1 == 0; \n\n}; \n\n} \n\nTo test if a value is a safe integer, use the ES6-specified Number. isSa \nfelnteger(..): \n\nNumber.isSafeInteger( Number.MAX_SAFE_INTEGER ); // true \n\nNumber.lsSafeInteger( Math.pow( 2, 53 ) ); // false \n\nNumber.lsSafeInteger( Math.pow( 2, 53 ) - 1 ); // true \n\nTo polyfill Number. isSafeInteger(..) in pre-ES6 browsers: \n\nIf ([Number.isSafelnteger) { \n\nNumber.isSafelnteger = function(num) { \nreturn Number.islnteger( num ) && \n\nMath.abs( num ) <= Number.MAX_SAFE_INTEGER; \n\n}; \n\n} \n\n32-Bit (Signed) Integers","metadata":{"loc":{"lines":{"from":63518,"to":63568}}}}],["697",{"pageContent":"If ([Number.isSafelnteger) { \n\nNumber.isSafelnteger = function(num) { \nreturn Number.islnteger( num ) && \n\nMath.abs( num ) <= Number.MAX_SAFE_INTEGER; \n\n}; \n\n} \n\n32-Bit (Signed) Integers \n\nWhile integers can range up to roughly 9 quadrillion safely (53 bits), \nthere are some numeric operations (like the bitwise operators) that \nare only defined for 32-bit numbers, so the “safe range” for numbers \nused in that way must be much smaller. \n\nThe range then is Math.pow(-2,31) (-2147483648, about -2.1 bil¬ \nlion) up to Math.pow(2,31)-l (2147483647, about +2.1 billion). \n\nTo force a number value in a to a 32-bit signed integer value, use a | \n0. This works because the | bitwise operator only works for 32-bit \ninteger values (meaning it can only pay attention to 32 bits and any \nother bits will be lost). Then, “or’ing” with zero is essentially a no-op \nbitwise speaking.","metadata":{"loc":{"lines":{"from":63568,"to":63593}}}}],["698",{"pageContent":"Certain special values (which we will cover in \nthe next section) such as NaN and Infinity are \nnot “32-bit safe,” in that those values when \npassed to a bitwise operator will pass through \nthe abstract operation ToInt32 (see Chapter 4) \nand become simply the +0 value for the purpose \nof that bitwise operation. \n\n\nNumbers | 23 \n\n\n\n\n\nSpecial Values \n\nThere are several special values spread across the various types that \nthe alert JS developer needs to be aware of, and use properly. \n\nThe Nonvalue Values \n\nFor the undefined type, there is one and only one value: undefined. \nFor the null type, there is one and only one value: null. So for both \nof them, the label is both its type and its value. \n\nBoth undefined and null are often taken to be interchangeable as \neither “empty” values or “non” values. Other developers prefer to \ndistinguish between them with nuance. For example: \n\n• null is an empty value. \n\n• undefined is a missing value. \n\n\nOr: \n\n\n• undefined hasn’t had a value yet.","metadata":{"loc":{"lines":{"from":63597,"to":63635}}}}],["699",{"pageContent":"• null is an empty value. \n\n• undefined is a missing value. \n\n\nOr: \n\n\n• undefined hasn’t had a value yet. \n\n• null had a value and doesn’t anymore. \n\nRegardless of how you choose to “define” and use these two values, \nnull is a special keyword, not an identifier, and thus you cannot \ntreat it as a variable to assign to (why would you!?). However, unde \nfined is (unfortunately) an identifier. Uh oh. \n\nUndefined \n\nIn non-strict mode, it’s actually possible (though incredibly ill- \nadvised!) to assign a value to the globally provided undefined iden¬ \ntifier: \n\nfunction foo() { \n\nundefined = 2; // really bad idea! \n\n} \n\nfoo(); \n\nfunction foo() { \n\n\"use strict\"; \n\nundefined = 2; // TypeError! \n\n} \n\n\n24 | Chapter 2: Values \n\n\n\n\nfoo(); \n\n\nIn both non-strict mode and strict mode, however, you can cre¬ \nate a local variable of the name undefined. But again, this is a terri¬ \nble idea! \n\nfunction foo() { \n\n\"use strict\"; \n\nvar undefined = 2; \n\nconsole.log( undefined ); // 2 \n\n} \n\nfoo();","metadata":{"loc":{"lines":{"from":63635,"to":63697}}}}],["700",{"pageContent":"function foo() { \n\n\"use strict\"; \n\nvar undefined = 2; \n\nconsole.log( undefined ); // 2 \n\n} \n\nfoo(); \n\nFriends don’t let friends override undefined. Ever. \n\nvoid operator \n\nWhile undefined is a built-in identifier that holds (unless modified \n—see above!) the built-in undefined value, another way to get this \nvalue is the void operator. \n\nThe expression void_“voids” out any value, so that the result of \n\nthe expression is always the undefined value. It doesn’t modify the \nexisting value; it just ensures that no value comes back from the \noperator expression: \n\nvar a = 42; \n\nconsole.log( void a, a ); // undefined 42 \n\nBy convention (mostly from C-language programming), to repre¬ \nsent the undefined value standalone by using void, you’d use void \n0 (though clearly even void true or any other void expression does \nthe same thing). There’s no practical difference between void 0, \nvoid 1, and undefined.","metadata":{"loc":{"lines":{"from":63697,"to":63731}}}}],["701",{"pageContent":"But the void operator can be useful in a few other circumstances, if \nyou need to ensure that an expression has no result value (even if it \nhas side effects). \n\nFor example: \n\nfunction doSomething() { \n\n// note: 'APP.ready' is provided by our application \nif (!APP.ready) { \n\n// try again later \n\nreturn void setTimeout( doSomething,100 ); \n\n\nSpecial Values | 25 \n\n\n\n\n} \n\n\nvar result; \n\n// do some other stuff \nreturn result; \n\n} \n\n// were we able to do it right away? \n\nIf (doSomethingO) { \n\n// handle next tasks right away \n\n} \n\nHere, the setTimeout(..) function returns a numeric value (the \nunique identifier of the timer interval, if you wanted to cancel it), \nbut we want to void that out so that the return value of our function \ndoesn’t give a false positive with the if statement. \n\nMany devs prefer to just do these actions separately, which works \nthe same but doesn’t use the void operator: \n\nif (!APP.ready) { \n\n// try again later \nsetTimeout( doSomething,100 ); \nreturn; \n\n}","metadata":{"loc":{"lines":{"from":63733,"to":63786}}}}],["702",{"pageContent":"Many devs prefer to just do these actions separately, which works \nthe same but doesn’t use the void operator: \n\nif (!APP.ready) { \n\n// try again later \nsetTimeout( doSomething,100 ); \nreturn; \n\n} \n\nIn general, if there’s ever a place where a value exists (from some \nexpression) and you’d find it useful for the value to be undefined \ninstead, use the void operator. That probably won’t be terribly com¬ \nmon in your programs, but in the rare cases you do need it, it can be \nquite helpful. \n\nSpecial Numbers \n\nThe number type includes several special values. We’ll take a look at \neach in detail. \n\nThe not number, number \n\nAny mathematic operation you perform without both operands \nbeing numbers (or values that can be interpreted as regular numbers \nin base 10 or base 16) will result in the operation failing to produce a \nvalid number, in which case you will get the NaN value.","metadata":{"loc":{"lines":{"from":63786,"to":63813}}}}],["703",{"pageContent":"NaN literally stands for “not a number,” though this label/description \nis very poor and misleading, as we’ll see shortly. It would be much \nmore accurate to think of NaN as being an “invalid number,” “failed \n\n\n26 | Chapter 2:Values \n\n\n\nnumber,” or even “bad number,” than to think of it as “not a num¬ \nber.” \n\nFor example: \n\nvar a = 2 / \"foo\"; // NaN \n\ntypeof a === \"number\"; // true \n\nIn other words, “the type of not-a-number is number !” Hooray for \nconfusing names and semantics. \n\nNaN is a kind of “sentinel value” (an otherwise normal value that’s \nassigned a special meaning) that represents a special kind of error \ncondition within the number set. The error condition is, in essence, \n“I tried to perform a mathematic operation but failed, so here’s the \nfailed number result instead.”","metadata":{"loc":{"lines":{"from":63815,"to":63840}}}}],["704",{"pageContent":"So, if you have a value in some variable and want to test to see if it’s \nthis special failed-number NaN, you might think you could directly \ncompare to NaN itself, as you can with any other value, like null or \nundefined. Nope. \n\nvar a = 2 / \"foo\"; \n\na == NaN; // false \na === NaN; // false \n\nNaN is a very special value in that it’s never equal to another NaN \nvalue (i.e., it’s never equal to itself). It’s the only value, in fact, that is \nnot reflexive (without the Identity characteristic x === x). So, NaN ! \n== NaN. A bit strange, huh? \n\nSo how do we test for it, if we can’t compare to NaN (since that com¬ \nparison would always fail)? \n\nvar a = 2 / \"foo\"; \nlsNaN( a ); // true \n\nEasy enough, right? We use the built-in global utility called \nisNaN(..) and it tells us if the value is NaN or not. Problem solved! \n\nNot so fast.","metadata":{"loc":{"lines":{"from":63842,"to":63866}}}}],["705",{"pageContent":"var a = 2 / \"foo\"; \nlsNaN( a ); // true \n\nEasy enough, right? We use the built-in global utility called \nisNaN(..) and it tells us if the value is NaN or not. Problem solved! \n\nNot so fast. \n\nThe isNaN(..) utility has a fatal flaw. It appears it tried to take the \nmeaning of NaN (“Not a Number”) too literally—that its job is basi¬ \ncally, “test if the thing passed in is either not a number or is a num \nber.” But that’s not quite accurate: \n\n\nSpedal Values | 27 \n\n\n\nvar a = 2 / \"foo\"; \nvar b = \"foo\"; \n\na; // NaN \nb; \"foo\" \n\nwindow.lsNaN( a ); // true \nwindow.lsNaN( b ); // true--ouch! \n\nClearly, \"foo\" is literally not a number, but it’s definitely not the NaN \nvalue either! This bug has been in JS since the very beginning (over \n19 years of ouch). \n\nAs of ES6, finally a replacement utility has been provided: Nun \nber.isNaN(.. ). A simple polyfill for it so that you can safely check \nNaN values now even in pre-ES6 browsers is: \n\nIf ([Number.IsNaN) {","metadata":{"loc":{"lines":{"from":63866,"to":63901}}}}],["706",{"pageContent":"If ([Number.IsNaN) { \n\nNumber.IsNaN = functlon(n) { \nreturn ( \n\ntypeof n === \"number\" && \nwindow.lsNaN( n ) \n\n); \n\n}; \n\n} \n\nvar a = 2 / \"foo\"; \nvar b = \"foo\"; \n\nNumber.lsNaN( a ); // true \nNumber.lsNaN( b ); // false--phew! \n\nActually, we can implement a Number. isNaN(.. ) polyfill even easier, \nby taking advantage of that peculiar fact that NaN isn’t equal to itself. \nNaN is the only value in the whole language where that’s true; every \nother value is always equal to itself. \n\nSo: \n\n\nIf ([Number.IsNaN) { \n\nNumber.IsNaN = functlon(n) { \nreturn n !== n; \n\n}; \n\n} \n\nWeird, huh? But it works! \n\nNaNs are probably a reality in a lot of real-world JS programs, either \non purpose or by accident. It’s a really good idea to use a reliable \n\n\n28 | Chapter 2:Values \n\n\n\n\ntest, like Number. isNaN(..) as provided (or polyfilled), to recognize \nthem properly.","metadata":{"loc":{"lines":{"from":63901,"to":63950}}}}],["707",{"pageContent":"28 | Chapter 2:Values \n\n\n\n\ntest, like Number. isNaN(..) as provided (or polyfilled), to recognize \nthem properly. \n\nIf you’re currently using just isNaN(..) in a program, the sad reality \nis your program has a bug, even if you haven’t been bitten by it yet! \n\n\nInfinities \n\n\nDevelopers from traditional compiled languages like C are probably \nused to seeing either a compiler error or runtime exception, like \n“divide by zero,” for an operation like: \n\nvar a = 1 / 0; \n\nHowever, in JS, this operation is well-defined and results in the \nvalue Infinity (aka Number.POSITIVE_INFINITY). Unsurprisingly: \n\nvar a = 1 / 0; // Infinity \n\nvar b = -1 / 0; // -Infinity \n\nAs you can see, - Infinity (aka Number. NEGATIVE_INFINITY) results \nfrom a divide-by-zero where either (but not both!) of the divide \noperands is negative.","metadata":{"loc":{"lines":{"from":63950,"to":63980}}}}],["708",{"pageContent":"var b = -1 / 0; // -Infinity \n\nAs you can see, - Infinity (aka Number. NEGATIVE_INFINITY) results \nfrom a divide-by-zero where either (but not both!) of the divide \noperands is negative. \n\nJS uses finite numeric representations (IEEE 754 floating-point, \nwhich we covered earlier), so contrary to pure mathematics, it seems \nit is possible to overflow even with an operation like addition or \nsubtraction, in which case you’d get Infinity or - Infinity. \n\nFor example: \n\n\nvar a = Number.MAX_VALUE; \na + a; \n\na + Math.pow( 2, 970 ); \na + Math.pow( 2, 969 ); \n\n\n// 1.7976931348623157e+308 \n// Infinity \n// Infinity \n\n// 1.7976931348623157e+308","metadata":{"loc":{"lines":{"from":63980,"to":64005}}}}],["709",{"pageContent":"For example: \n\n\nvar a = Number.MAX_VALUE; \na + a; \n\na + Math.pow( 2, 970 ); \na + Math.pow( 2, 969 ); \n\n\n// 1.7976931348623157e+308 \n// Infinity \n// Infinity \n\n// 1.7976931348623157e+308 \n\n\nAccording to the specification, if an operation like addition results \nin a value that’s too big to represent, the IEEE 754 “round-to- \nnearest” mode specifies what the result should be. So, in a crude \nsense, Number.MAX_VALUE + Math.pow( 2, 969 ) is closer to Num \nber .MAX_VALUE than to Infinity, so it “rounds down,” whereas Num \nber.MAX_VALUE + Math.pow( 2, 970 ) is closer to Infinity so it \n“rounds up.” \n\n\nIf you think too much about that, it’s going to make your head hurt. \nSo don’t. Seriously, stop! \n\n\nSpecial Values | 29 \n\n\n\n\nOnce you overflow to either one of the infinities, however, there’s no \ngoing back. In other words, in an almost poetic sense, you can go \nfrom finite to infinite but not from infinite back to finite.","metadata":{"loc":{"lines":{"from":64005,"to":64042}}}}],["710",{"pageContent":"It’s almost philosophical to ask: “What is infinity divided by infin¬ \nity?” Our naive brains would likely say “1” or maybe “infinity.” Turns \nout neither is true. Both mathematically and in JavaScript, Inf in \ntty / Infinity is not a defined operation. In JS, this results in NaN. \n\nBut what about any positive finite number divided by Infinity? \nThat’s easy! 0. And what about a negative finite number divided by \nInfinity? Keep reading! \n\nZeros \n\nWhile it may confuse the mathematics-minded reader, JavaScript \nhas both a normal zero 0 (otherwise known as a positive zero +0) \nand a negative zero -0. Before we explain why the -0 exists, we \nshould examine how JS handles it, because it can be quite confusing. \n\nBesides being specified literally as - 0, negative zero also results from \ncertain mathematic operations. For example: \n\nvar a = 0 / -3; // -0 \nvar b = 0 * -3; // -0 \n\nAddition and subtraction cannot result in a negative zero.","metadata":{"loc":{"lines":{"from":64044,"to":64066}}}}],["711",{"pageContent":"var a = 0 / -3; // -0 \nvar b = 0 * -3; // -0 \n\nAddition and subtraction cannot result in a negative zero. \n\nA negative zero when examined in the developer console will usu¬ \nally reveal -0, though that was not the common case until fairly \nrecently, so some older browsers you encounter may still report it as \n\n0 . \n\nHowever, if you try to stringify a negative zero value, it will always \nbe reported as \"0\", according to the spec: \n\nvar a = 0 / -3; \n\n\n// (some browser) consoles at least get it right \n\n\na; // -0 \n\n// but the spec insists on lying to you! \na.toStringO; // \"0\" \n\na + // \"0\" \n\nString? a ); // \"0\" \n\n\n// strangely, even JSON gets in on the deception \n3S0N.stringify( a ); // \"0\" \n\n\n30 | Chapter 2:Values \n\n\n\n\nInterestingly, the reverse operations (going from string to number) \ndon’t lie: \n\n+\"- 0 \"; // -0 \nNumber( \"-0\" ); // -0 \n\nISON.parse( \"-0\" ); // -0","metadata":{"loc":{"lines":{"from":64066,"to":64111}}}}],["712",{"pageContent":"30 | Chapter 2:Values \n\n\n\n\nInterestingly, the reverse operations (going from string to number) \ndon’t lie: \n\n+\"- 0 \"; // -0 \nNumber( \"-0\" ); // -0 \n\nISON.parse( \"-0\" ); // -0 \n\n\n\nThe JSON.stringify( -0 ) behavior of \"0\" is \nparticularly strange when you observe that it’s \ninconsistent with the reverse: \nJSON.parse( \"-0\" ) reports -0 as you’d cor¬ \nrectly expect. \n\n\nIn addition to stringification of negative zero being deceptive to hide \nits true value, the comparison operators are also (intentionally) con¬ \nfigured to lie: \n\nvar a = 0; \nvar b = 0 / -3; \n\n\na == b; \n\n// true \n\n-0 == 0; \n\n// true \n\na === b; \n\n// true \n\n-0 === 0; \n\n// true \n\n0 > -0; \n\n// false \n\na > b; \n\n// false \n\n\nClearly, if you want to distinguish a - 0 from a 0 in your code, you \ncan’t just rely on what the developer console outputs, so you’re going \nto have to be a bit more clever: \n\nfunction isNegZero(n) { \nn = Number( n ); \n\nreturn (n === 0) && (1 / n === -Infinity); \n\n} \n\nisNegZero( -0 ); // true","metadata":{"loc":{"lines":{"from":64111,"to":64177}}}}],["713",{"pageContent":"function isNegZero(n) { \nn = Number( n ); \n\nreturn (n === 0) && (1 / n === -Infinity); \n\n} \n\nisNegZero( -0 ); // true \n\nisNegZero( 0 / -3 ); // true \n\nisNegZero( 0 ); // false \n\nNow, why do we need a negative zero, besides academic trivia? \n\nThere are certain applications where developers use the magnitude \nof a value to represent one piece of information (like speed of move¬ \nment per animation frame) and the sign of that number to represent \nanother piece of information (like the direction of that movement). \n\n\nSpecial Values | 31 \n\n\n\n\nIn those applications, as one example, if a variable arrives at zero \nand it loses its sign, then you would lose the information of what \ndirection it was moving in before it arrived at zero. Preserving the \nsign of the zero prevents potentially unwanted information loss. \n\nSpecial Equality","metadata":{"loc":{"lines":{"from":64177,"to":64208}}}}],["714",{"pageContent":"Special Equality \n\nAs we saw above, the NaN value and the -0 value have special behav¬ \nior when it comes to equality comparison. NaN is never equal to \nitself, so you have to use ES6’s Number.isNaN(..) (or a polyfill). \nSimlarly, - 0 lies and pretends that it’s equal (even === strict equal— \nsee Chapter 4) to regular 0, so you have to use the somewhat hackish \nisNegZero(..) utility we suggested above. \n\nAs of ES6, there’s a new utility that can be used to test two values for \nabsolute equality, without any of these exceptions. It’s called \nObject.is(..): \n\nvar a = 2 / \"foo\"; \nvar b = -3 * 0; \n\nObject.ts( a, NaN ); // true \n\nObject.is( b, -0 ); // true \n\nObject.is( b, 0 ); // false \n\nThere’s a pretty simple polyfill for Object.is(..) for pre-ES6 envi¬ \n\nronments: \n\nIf ([Object.is) { \n\nObject.is = functional, v2) { \n\n// test for '-0' \nif (vl === 0 && v2 === 0) { \nreturn 1 / vl === 1 / v2; \n\n} \n\n// test for 'NaN' \nif (vl !== vl) { \n\nreturn v2 !== v2; \n\n}","metadata":{"loc":{"lines":{"from":64208,"to":64249}}}}],["715",{"pageContent":"If ([Object.is) { \n\nObject.is = functional, v2) { \n\n// test for '-0' \nif (vl === 0 && v2 === 0) { \nreturn 1 / vl === 1 / v2; \n\n} \n\n// test for 'NaN' \nif (vl !== vl) { \n\nreturn v2 !== v2; \n\n} \n\n// everything else \nreturn vl === v2; \n\n}; \n\n} \n\nObject. is(..) probably shouldn’t be used in cases where == or === \nare known to be safe (see Chapter 4), as the operators are likely \nmuch more efficient and certainly are more idiomatic/common. \nObject. ls(..) is mostly for these special cases of equality. \n\n\n32 | Chapter 2: Values \n\n\n\nValue Versus Reference \n\nIn many other languages, values can either be assigned/passed by \nvalue-copy or by reference-copy depending on the syntax you use.","metadata":{"loc":{"lines":{"from":64249,"to":64286}}}}],["716",{"pageContent":"32 | Chapter 2: Values \n\n\n\nValue Versus Reference \n\nIn many other languages, values can either be assigned/passed by \nvalue-copy or by reference-copy depending on the syntax you use. \n\nFor example, in C++ if you want to pass a number variable into a \nfunction and have that variable’s value updated, you can declare the \nfunction parameter like int& myNum, and when you pass in a vari¬ \nable like x, myNum will be a reference to x; references are like a special \nform of pointers, where you obtain a pointer to another variable \n(like an alias). If you don’t declare a reference parameter, the value \npassed in will always be copied, even if it’s a complex object. \n\nIn JavaScript, there are no pointers, and references work a bit differ¬ \nently. You cannot have a reference from one JS variable to another \nvariable. That’s just not possible.","metadata":{"loc":{"lines":{"from":64286,"to":64305}}}}],["717",{"pageContent":"In JavaScript, there are no pointers, and references work a bit differ¬ \nently. You cannot have a reference from one JS variable to another \nvariable. That’s just not possible. \n\nA reference in JS points at a (shared) value, so if you have 10 differ¬ \nent references, they are all always distinct references to a single \nshared value; none of them are references/pointers to each other. \n\nMoreover, in JavaScript, there are no syntactic hints that control \nvalue versus reference assignment/passing. Instead, the type of the \nvalue solely controls whether that value will be assigned by value- \ncopy or by reference-copy. \n\nLet’s illustrate: \n\nvar a = 2; \n\nvar b = a; // 'b' is always a copy of the value In 'a' \nb++; \na; // 2 \nb; // 3 \n\nvar c = [1,2,3]; \n\nvar d = c; // 'd' Is a reference to the shared '[1,2,3]' value \nd.push( 4 ); \nc; // [1,2,3,4] \nd; // [1,2,3,4]","metadata":{"loc":{"lines":{"from":64305,"to":64332}}}}],["718",{"pageContent":"var c = [1,2,3]; \n\nvar d = c; // 'd' Is a reference to the shared '[1,2,3]' value \nd.push( 4 ); \nc; // [1,2,3,4] \nd; // [1,2,3,4] \n\nSimple values (aka scalar primitives) are always assigned/passed by \nvalue-copy: null, undefined, string, number, boolean, and ES6’s \nsymbol. \n\nCompound values—objects (including arrays, and all boxed object \nwrappers—see Chapter 3) and functions— always create a copy of \nthe reference on assignment or passing. \n\n\nValue Versus Reference | 33 \n\n\n\nIn the above snippet, because 2 is a scalar primitive, a holds one ini¬ \ntial copy of that value, and b is assigned another copy of the value. \nWhen changing b, you are in no way changing the value in a.","metadata":{"loc":{"lines":{"from":64332,"to":64354}}}}],["719",{"pageContent":"But both c and d are separate references to the same shared value \n[1,2,3], which is a compound value. It’s important to note that nei¬ \nther c nor d more “owns” the [1,2,3] value — both are just equal \npeer references to the value. So, when using either reference to mod¬ \nify (.push(4)) the actual shared array value itself, it’s affecting just \nthe one shared value, and both references will reference the newly \nmodified value [ 1 , 2 , 3 ,4 ]. \n\nSince references point to the values themselves and not to the vari¬ \nables, you cannot use one reference to change where another refer¬ \nence is pointed: \n\nvar a = [1,2,3]; \nvar b = a; \na; // [1,2,3] \nb; // [1,2,3] \n\n// later \nb = [4,5,6]; \na; // [1,2,3] \nb; // [4,5,6] \n\nWhen we make the assignment b = [4,5,6], we are doing abso¬ \nlutely nothing to affect where a is still referencing ([1,2,3]). To do \nthat, b would have to be a pointer to a rather than a reference to the \narray— but no such capability exists in JS!","metadata":{"loc":{"lines":{"from":64356,"to":64381}}}}],["720",{"pageContent":"The most common way such confusion happens is with function \nparameters: \n\nfunction foo(x) { \nx.push( 4 ); \nx; // [1,2,3,4] \n\n// later \nx = [4,5,6]; \nx.push( 7 ); \nx; // [4,5,6,7] \n\n} \n\nvar a = [1,2,3]; \nfoo( a ); \n\n\n34 | Chapter 2:Values \n\n\n\na; // [1,2,3,4] not [4,5,6,7] \n\n\nWhen we pass in the argument a, it assigns a copy of the a reference \nto x. x and a are separate references pointing at the same [1,2,3] \nvalue. Now, inside the function, we can use that reference to mutate \nthe value itself (push(4)). But when we make the assignment x = \n[4,5,6], this is in no way affecting where the initial reference a is \npointing—it still points at the (now modified) [ 1,2,3, 4] value. \n\nThere is no way to use the x reference to change where a is pointing. \nWe could only modify the contents of the shared value that both a \nand x are pointing to.","metadata":{"loc":{"lines":{"from":64383,"to":64417}}}}],["721",{"pageContent":"There is no way to use the x reference to change where a is pointing. \nWe could only modify the contents of the shared value that both a \nand x are pointing to. \n\nTo accomplish changing a to have the [4,5,6,7] value contents, \nyou can’t create a new array and assign—you must modify the exist¬ \ning array value: \n\nfunction foo(x) { \nx.push( 4 ); \nx; // [1,2,3,4] \n\n// later \n\nx.length = 0; // empty existing array in-place \nx.push( 4, 5, 6, 7 ); \nx; // [4,5,6,7] \n\n} \n\nvar a = [1,2,3]; \nfoo( a ); \n\na; // [4,5,6,7] not [1,2,3,4] \n\nAs you can see, x. length = 0 and x.push(4,5,6,7) were not creat¬ \ning a new array, but modifying the existing shared array. So of \ncourse, a references the new [4 , 5 , 6 , 7] contents. \n\nRemember: you cannot directly control/override value-copy versus \nreference—those semantics are controlled entirely by the type of the \nunderlying value.","metadata":{"loc":{"lines":{"from":64417,"to":64448}}}}],["722",{"pageContent":"Remember: you cannot directly control/override value-copy versus \nreference—those semantics are controlled entirely by the type of the \nunderlying value. \n\nTo effectively pass a compound value (like an array) by value-copy, \nyou need to manually make a copy of it, so that the reference passed \ndoesn’t still point to the original. For example: \n\nfoo( a.slice() ); \n\n\nValue Versus Reference | 35 \n\n\n\n\nslice(..) with no parameters by default makes an entirely new \n(shallow) copy of the array. So, we pass in a reference only to the \ncopied array, and thus foo( ..) cannot affect the contents of a. \n\nTo do the reverse—pass a scalar primitive value in a way where its \nvalue updates can be seen, kinda like a reference—you have to wrap \nthe value in another compound value (object, array, etc.) that can \nbe passed by reference-copy: \n\nfunction foo(wrapper) { \nwrapper.a = 42; \n\n} \n\nvar obj = { \na: 2 \n\n}; \n\n\nfoo( obj ); \nobj.a; // 42","metadata":{"loc":{"lines":{"from":64448,"to":64485}}}}],["723",{"pageContent":"function foo(wrapper) { \nwrapper.a = 42; \n\n} \n\nvar obj = { \na: 2 \n\n}; \n\n\nfoo( obj ); \nobj.a; // 42 \n\nHere, obj acts as a wrapper for the scalar primitive property a. \nWhen passed to foo(..), a copy of the obj reference is passed in \nand set to the wrapper parameter. We now can use the wrapper ref¬ \nerence to access the shared object, and update its property. After the \nfunction finishes, obj. a will see the updated value 42. \n\nIt may occur to you that if you wanted to pass in a reference to a \nscalar primitive value like 2, you could just box the value in its Nun \nber object wrapper (see Chapter 3). \n\nIt is true a copy of the reference to this Number object will be passed \nto the function, but unfortunately, having a reference to the shared \nobject is not going to give you the ability to modify the shared prim¬ \nitive value, like you may expect: \n\nfunction foo(x) { \nx = x + 1; \n\nx; // 3 \n\n} \n\nvar a = 2; \n\nvar b = new Number( a ); // or equivalently 'Object(a)' \nfoo( b );","metadata":{"loc":{"lines":{"from":64485,"to":64524}}}}],["724",{"pageContent":"function foo(x) { \nx = x + 1; \n\nx; // 3 \n\n} \n\nvar a = 2; \n\nvar b = new Number( a ); // or equivalently 'Object(a)' \nfoo( b ); \n\nconsole.log( b ); // 2, not 3 \n\n\n36 | Chapter 2: Values \n\n\n\n\nThe problem is that the underlying scalar primitive value is not \nmutable (same goes for String and Boolean). If a Number object \nholds the scalar primitive value 2, that exact Number object can never \nbe changed to hold another value; you can only create a whole new \nNumber object with a different value. \n\nWhen x is used in the expression x + 1, the underlying scalar prim¬ \nitive value 2 is unboxed (extracted) from the Number object automat¬ \nically, so the line x = x + 1 very subtly changes x from being a \nshared reference to the Number object, to just holding the scalar \nprimitive value 3 as a result of the addition operation 2 + 1. There¬ \nfore, b on the outside still references the original unmodified/ \nimmutable Number object holding the value 2.","metadata":{"loc":{"lines":{"from":64524,"to":64556}}}}],["725",{"pageContent":"You can add properties on top of the Number object (just not change \nits inner primitive value), so you could exchange information indi¬ \nrectly via those additional properties. \n\nThis is not all that common, however; it probably would not be con¬ \nsidered a good practice by most developers. \n\nInstead of using the wrapper object Number in this way, it’s probably \nmuch better to use the manual object wrapper (ob j) approach in the \nearlier snippet. That’s not to say that there are no clever uses for the \nboxed object wrappers like Number—just that you should probably \nprefer the scalar primitive value form in most cases. \n\nReferences are quite powerful, but sometimes they get in your way, \nand sometimes you need them where they don’t exist. The only con¬ \ntrol you have over reference versus value-copy behavior is the type \nof the value itself, so you must indirectly influence the assignment/ \npassing behavior by which value types you choose to use. \n\nReview","metadata":{"loc":{"lines":{"from":64558,"to":64577}}}}],["726",{"pageContent":"Review \n\nIn JavaScript, arrays are simply numerically indexed collections of \nany value type, strings are somewhat \"array-like,” but they have \ndistinct behaviors and care must be taken if you want to treat them \nas arrays. Numbers in JavaScript include both “integers” and \nfloating-point values. \n\nSeveral special values are defined within the primitive types. \n\n\nReview | 37 \n\n\n\n\nThe null type has just one value, null, and likewise the undefined \ntype has just the undefined value, undefined is basically the default \nvalue in any variable or property if no other value is present. The \nvoid operator lets you create the undefined value from any other \nvalue. \n\nnumbers include several special values, like NaN (supposedly “Not a \nNumber,” but really more appropriately “invalid number”); +Infin \nity and - Infinity; and -0.","metadata":{"loc":{"lines":{"from":64577,"to":64601}}}}],["727",{"pageContent":"numbers include several special values, like NaN (supposedly “Not a \nNumber,” but really more appropriately “invalid number”); +Infin \nity and - Infinity; and -0. \n\nSimple scalar primitives (strings, numbers, etc.) are assigned/passed \nby value-copy, but compound values (objects, etc.) are assigned/ \npassed by reference-copy. References are not like references/pointers \nin other languages—they’re never pointed at other variables/refer¬ \nences, only at the underlying values. \n\n\n38 | Chapter 2: Values \n\n\n\nCHAPTER 3 \n\n\nNatives \n\n\nSeveral times in Chapters 1 and 2, we alluded to various built-ins, \nusually called “natives,” like String and Number. Let’s examine those \nin detail now. \n\nHere’s a list of the most commonly used natives: \n\n• String() \n\n• NumberQ \n\n• BooleanQ \n\n• ArrayO \n\n• Object() \n\n• FunctionQ \n\n• RegExp() \n\n• DateQ \n\n• Error() \n\n• Symbol () —added in ES6! \n\nAs you can see, these natives are actually built-in functions.","metadata":{"loc":{"lines":{"from":64601,"to":64648}}}}],["728",{"pageContent":"• NumberQ \n\n• BooleanQ \n\n• ArrayO \n\n• Object() \n\n• FunctionQ \n\n• RegExp() \n\n• DateQ \n\n• Error() \n\n• Symbol () —added in ES6! \n\nAs you can see, these natives are actually built-in functions. \n\nIf you’re coming to JS from a language like Java, JavaScript’s \nStringQ will look like the String(.. ) constructor you’re used to \nfor creating string values. So, you’ll quickly observe that you can do \nthings like: \n\n\n39 \n\n\n\n\n\n\n\nvar s = new String( \"Hello World!\" ); \n\n\nconsole.log( s.toStringO ); // \"Hello World!\" \n\nIt is true that each of these natives can be used as a native construc¬ \ntor. But what’s being constructed may be different than you think: \n\nvar a = new Strlng( \"abc\" ); \n\ntypeof a; // \"object\" ... not \"String\" \n\na instanceof String; // true \n\nObject.prototype.toString.call( a ); // \"[object String]\" \n\nThe result of the constructor form of value creation (new \nString(\"abc\")) is an object wrapper around the primitive (\"abc\") \nvalue.","metadata":{"loc":{"lines":{"from":64648,"to":64700}}}}],["729",{"pageContent":"Object.prototype.toString.call( a ); // \"[object String]\" \n\nThe result of the constructor form of value creation (new \nString(\"abc\")) is an object wrapper around the primitive (\"abc\") \nvalue. \n\nImportantly, typeof shows that these objects are not their own spe¬ \ncial types, but more appropriately they are subtypes of the object \ntype. \n\nThis object wrapper can further be observed with: \n\nconsole.log( a ); \n\nThe output of that statement varies depending on your browser, as \ndeveloper consoles are free to choose however they feel it’s appropri¬ \nate to serialize the object for developer inspection. \n\n\n\nAt the time of writing, the latest Chrome prints \nsomething like this: String {0: \"a\", 1: \"b\", \n2: \"c\", length: 3, [[PrinitiveValue]]:","metadata":{"loc":{"lines":{"from":64700,"to":64722}}}}],["730",{"pageContent":"At the time of writing, the latest Chrome prints \nsomething like this: String {0: \"a\", 1: \"b\", \n2: \"c\", length: 3, [[PrinitiveValue]]: \n\n\"abc\"}. But older versions of Chrome used to \njust print this: String {0: \"a\", 1: \"b\", 2: \n\"c\"}. The latest Firefox currently prints String \n[\" a \",\" b \",\" c \" ], but used to print \" abc \" in ital¬ \nics, which was clickable to open the object \ninspector. Of course, these results are subject to \nrapid change and your experience may vary. \n\n\nThe point is, new Strlng(\"abc\") creates a string wrapper object \naround \"abc\", not just the primitive \"abc\" value itself. \n\n\n40 | Chapter 3: Natives \n\n\n\n\n\nInternal [[Class]]","metadata":{"loc":{"lines":{"from":64722,"to":64745}}}}],["731",{"pageContent":"The point is, new Strlng(\"abc\") creates a string wrapper object \naround \"abc\", not just the primitive \"abc\" value itself. \n\n\n40 | Chapter 3: Natives \n\n\n\n\n\nInternal [[Class]] \n\nValues that are typeof of \"object\" (such as an array) are addition¬ \nally tagged with an internal [ [Class] ] property (think of this more \nas an internal classification rather than related to classes from tradi¬ \ntional class-oriented coding). This property cannot be accessed \ndirectly, but can generally can be revealed indirectly by borrowing \nthe default Object.prototype.toString(.. ) method called against \nthe value. For example: \n\nObject.prototype.toString.call( [1,2,3] ); \n\n// \"[object Array]\" \n\nObject.prototype.toString.call( /regex-literal/i ); \n\n// \"[object RegExp]\"","metadata":{"loc":{"lines":{"from":64745,"to":64771}}}}],["732",{"pageContent":"Object.prototype.toString.call( [1,2,3] ); \n\n// \"[object Array]\" \n\nObject.prototype.toString.call( /regex-literal/i ); \n\n// \"[object RegExp]\" \n\nSo, for the array in this example, the internal [[Class]] value is \n\"Array\", and for the regular expression, it’s \"RegExp\". In most cases, \nthis internal [Class]] value corresponds to the built-in native con¬ \nstructor (see below) that’s related to the value, but that’s not always \nthe case. \n\nWhat about primitive values? First, null and undefined: \n\nObject.prototype.toStrlng.call( null ); \n\n// \"[object Null]\" \n\nObject.prototype.toStrlng.call( undefined ); \n\n// \"[object Undefined]\" \n\nYou’ll note that there are no NullQ or Undefined() native con¬ \nstructors, but nevertheless \"Null\" and \"Undefined\" are the internal \n[ [Class] ] values exposed. \n\nBut for the other simple primitives like string, number, and \nboolean, another behavior actually kicks in, which is usually called \n“boxing” (see “Boxing Wrappers” on page 42):","metadata":{"loc":{"lines":{"from":64771,"to":64801}}}}],["733",{"pageContent":"But for the other simple primitives like string, number, and \nboolean, another behavior actually kicks in, which is usually called \n“boxing” (see “Boxing Wrappers” on page 42): \n\nObject.prototype.toStrlng.call( \"abc\" ); \n\n// \"[object String]\" \n\nObject.prototype.toStrlng.call( 42 ); \n\n// \"[object Number]\" \n\nObject.prototype.toStrlng.call( true ); \n\n// \"[object Boolean]\" \n\n\nInternal [[Class]] | 41 \n\n\n\n\n\nIn this snippet, each of the simple primitives are automatically \nboxed by their respective object wrappers, which is why \"String\", \n\"Number\", and \"Boolean\" are revealed as the respective internal \n[ [Class] ] values. \n\n\n\nThe behavior of toStringQ and [[Class]] as \nillustrated here has changed a bit from ES5 to \nES6, but we cover those details in the ES6 & \nBeyond title in this series. \n\n\nBoxing Wrappers","metadata":{"loc":{"lines":{"from":64801,"to":64837}}}}],["734",{"pageContent":"The behavior of toStringQ and [[Class]] as \nillustrated here has changed a bit from ES5 to \nES6, but we cover those details in the ES6 & \nBeyond title in this series. \n\n\nBoxing Wrappers \n\nThese object wrappers serve a very important purpose. Primitive \nvalues don’t have properties or methods, so to access .length \nor .toString() you need an object wrapper around the value. \nThankfully, JS will automatically box (aka wrap) the primitive value \nto fulfill such accesses: \n\nvar a = \"abc\"; \n\na.length; // 3 \na.toUpperCase(); // \"ABC\" \n\nSo, if you’re going to be accessing these properties/methods on your \nstring values regularly, like an 1 < a.length condition in a for loop \nfor instance, it might seem to make sense to just have the object \nform of the value from the start, so the JS engine doesn’t need to \nimplicitly create it for you.","metadata":{"loc":{"lines":{"from":64837,"to":64860}}}}],["735",{"pageContent":"But it turns out that’s a bad idea. Browsers long ago performance- \noptimized the common cases like . length, which means your pro¬ \ngram will actually go slower if you try to “preoptimize” by directly \nusing the object form (which isn’t on the optimized path). \n\nIn general, there’s basically no reason to use the object form directly. \nIt’s better to just let the boxing happen implicitly where necessary. In \nother words, never do things like new Strlng(\"abc\"), new Num \nber(42), etc.—always prefer using the literal primitive values \"abc\" \nand 42. \n\nObject Wrapper Gotchas \n\nThere are even gotchas with using the object wrappers directly that \nyou should be aware of if you do choose to ever use them. \n\n\n42 | Chapter 3: Natives \n\n\n\n\nFor example, consider Boolean wrapped values: \n\nvar a = new Boolean( false ); \n\nIf (!a) { \n\nconsole.log( \"Oops\" ); // never runs \n\n}","metadata":{"loc":{"lines":{"from":64862,"to":64892}}}}],["736",{"pageContent":"42 | Chapter 3: Natives \n\n\n\n\nFor example, consider Boolean wrapped values: \n\nvar a = new Boolean( false ); \n\nIf (!a) { \n\nconsole.log( \"Oops\" ); // never runs \n\n} \n\nThe problem is that you’ve created an object wrapper around the \nfalse value, but objects themselves are “truthy” (see Chapter 4), so \nusing the object behaves oppositely to using the underlying false \nvalue itself, which is quite contrary to normal expectation. \n\nIf you want to manually box a primitive value, you can use the \nObject(..) function (no new keyword): \n\nvar a = \"abc\"; \n\nvar b = new Strlng( a ); \n\nvar c = Object( a ); \n\ntypeof a; // \"string\" \ntypeof b; // \"object\" \ntypeof c; // \"object\" \n\nb instanceof String; // true \nc instanceof String; // true \n\nObject.prototype.toString.call( b ); // \"[object String]\" \n\nObject.prototype.toString.call( c ); // \"[object String]\"","metadata":{"loc":{"lines":{"from":64892,"to":64930}}}}],["737",{"pageContent":"b instanceof String; // true \nc instanceof String; // true \n\nObject.prototype.toString.call( b ); // \"[object String]\" \n\nObject.prototype.toString.call( c ); // \"[object String]\" \n\nAgain, using the boxed object wrapper directly (like b and c above) \nis usually discouraged, but there may be some rare occasions you’ll \nrun into where they may be useful. \n\nUnboxing \n\nIf you have an object wrapper and you want to get the underlying \nprimitive value out, you can use the valueOf () method: \n\nvar a = new String( \"abc\" ); \nvar b = new Nunber( 42 ); \nvar c = new Boolean( true ); \n\na. valueOfQ; // \"abc\" \n\nb. valueOfQ; // 42 \n\nc. valueOfQ; // true \n\n\nUnboxing | 43 \n\n\n\n\n\nUnboxing can also happen implicitly, when using an object wrapper \nvalue in a way that requires the primitive value. This process (coer¬ \ncion) will be covered in more detail in Chapter 4, but briefly: \n\nvar a = new String( \"abc\" ); \n\nvar b = a + // b' has the unboxed primitive value \"abc\" \n\ntypeof a; // \"object\"","metadata":{"loc":{"lines":{"from":64930,"to":64971}}}}],["738",{"pageContent":"var a = new String( \"abc\" ); \n\nvar b = a + // b' has the unboxed primitive value \"abc\" \n\ntypeof a; // \"object\" \n\ntypeof b; // \"string\" \n\nNatives as Constructors \n\nFor array, object, function, and regular-expression values, it’s \nalmost universally preferred that you use the literal form for creat¬ \ning the values, but the literal form creates the same sort of object as \nthe constructor form does (that is, there is no nonwrapped value). \n\nJust as we’ve seen above with the other natives, these constructor \nforms should generally be avoided, unless you really know you need \nthem, mostly because they introduce exceptions and gotchas that \nyou probably don’t really want to deal with. \n\nArray(-) \n\nvar a = new Array( 1, 2, 3 ); \na; // [1, 2, 3] \n\nvar b = [1, 2, 3]; \nb; // [1, 2, 3] \n\n\n\nThe Array( ..) constructor does not require the \nnew keyword in front of it. If you omit it, it will \nbehave as if you have used it anyway. So \nArray(1,2,3) is the same outcome as new \nArray(l,2,3).","metadata":{"loc":{"lines":{"from":64971,"to":65005}}}}],["739",{"pageContent":"The Array constructor has a special form where if only one number \nargument is passed, instead of providing that value as contents of the \narray, it’s taken as a length to “presize the array” (well, sorta). \n\nThis is a terrible idea. Firstly, you can trip over that form acciden¬ \ntally, as it’s easy to forget. \n\nBut more importantly, there’s no such thing as actually presizing the \narray. Instead, what you’re creating is an otherwise empty array, but \n\n\n44 | Chapter 3: Natives \n\n\n\n\nsetting the length property of the array to the numeric value speci¬ \nfied. \n\nAn array that has no explicit values in its slots, but has a length \nproperty that implies the slots exist, is a weird exotic type of data \nstructure in JS with some very strange and confusing behavior. The \ncapability to create such a value comes purely from old, deprecated, \nhistorical functionalities (“array-like objects” like the arguments \nobject).","metadata":{"loc":{"lines":{"from":65008,"to":65032}}}}],["740",{"pageContent":"An array with at least one “empty slot” in it is \noften called a “sparse array.” \n\n\nIt doesn’t help matters that this is yet another example where \nbrowser developer consoles vary on how they represent such an \nobject, which breeds more confusion. \n\nFor example: \n\nvar a = new Array( 3 ); \n\na.length; // 3 \na; \n\nThe serialization of a in Chrome is (at the time of writing) [ unde \nfined x 3 ]. This is really unfortunate. It implies that there are \nthree undefined values in the slots of this array, when in fact the \nslots do not exist (so-called “empty slots”—also a bad name!). \n\nTo visualize the difference, try this: \n\nvar a = new Array( 3 ); \n\nvar b = [ undefined, undefined, undefined ]; \nvar c = []; \nc.length = 3; \n\na; \n\nb; \n\nc; \n\n\nNatives as Constructors | 45","metadata":{"loc":{"lines":{"from":65036,"to":65071}}}}],["741",{"pageContent":"To visualize the difference, try this: \n\nvar a = new Array( 3 ); \n\nvar b = [ undefined, undefined, undefined ]; \nvar c = []; \nc.length = 3; \n\na; \n\nb; \n\nc; \n\n\nNatives as Constructors | 45 \n\n\n\n\n\nAs you can see with c in this example, empty \nslots in an array can happen after creation of the \narray. When changing the length of an array to \ngo beyond its number of actually defined slot \nvalues, you implicitly introduce empty slots. In \nfact, you could even call delete b[l] in the \nabove snippet, and it would introduce an empty \nslot into the middle of b. \n\n\nFor b (in Chrome, currently), you’ll find [ undefined, undefined, \nundefined ] as the serialization, as opposed to [ undefined x 3 ] \nfor a and c. Confused? Yeah, so is everyone else. \n\nWorse than that, at the time of writing, Firefox reports [ , , , ] \nfor a and c. Did you catch why that’s so confusing? Look closely. \nThree commas implies four slots, not three slots like we’d expect.","metadata":{"loc":{"lines":{"from":65071,"to":65108}}}}],["742",{"pageContent":"What!? Firefox puts an extra , on the end of their serialization here \nbecause as of ES5, trailing commas in lists (array values, property \nlists, etc.) are allowed (and thus dropped and ignored). So if you \nwere to type a [ , , , ] value into your program or the console, \nyou’d actually get the underlying value that’s like [ , , ] (that is, an \narray with three empty slots). This choice, while confusing if reading \nthe developer console, is defended as instead making copy-n-paste \nbehavior accurate. \n\nIf you’re shaking your head or rolling your eyes about now, you’re \nnot alone! Shrugs. \n\n\n\nFirefox appears to be changing their output in \nthis scenario to Array [ <3 empty slots> ], \nwhich is certainly a big improvement over \n\n\nUnfortunately, it gets worse. More than just confusing console out¬ \nput, a and b from the above code snippet actually behave the same \nin some cases but differently in others: \n\na. join( ); // \n\nb. joln( ); //","metadata":{"loc":{"lines":{"from":65110,"to":65135}}}}],["743",{"pageContent":"a. join( ); // \n\nb. joln( ); // \n\na. map(function(v,l){ return 1; }); // [ undefined x 3 ] \n\nb. map(functlon(v,l){ return 1; }); // [ 0, 1, 2 ] \n\n\n46 | Chapter 3: Natives \n\n\n\n\n\n\nUgh. \n\nThe a.map(..) call fails because the slots don’t actually exist, so \nmap(..) has nothing to iterate over. join(..) works differently. \nBasically, we can think of it implemented sort of like this: \n\nfunction fakeJoin(arr,connector) { \nvar str = \n\nfor (var 1=0; i < arr.length; i++) { \nif (i > 0) { \n\nstr += connector; \n\n} \n\nif (arr[i] !== undefined) { \nstr += arr[i]; \n\n} \n\n} \n\nreturn str; \n\n} \n\nvar a = new Array( 3 ); \nfakeJoin( a, ); // \n\nAs you can see, join(..) works by just assuming the slots exist and \nlooping up to the length value. Whatever map(..) does internally, it \n(apparently) doesn’t make such an assumption, so the result from \nthe strange “empty slots” array is unexpected and likely to cause fail¬ \nure.","metadata":{"loc":{"lines":{"from":65135,"to":65185}}}}],["744",{"pageContent":"So, if you wanted to actually create an array of actual undefined val¬ \nues (not just “empty slots”), how could you do it (besides manually)? \n\nvar a = Array.apply( null, { length: 3 } ); \na; // [ undefined, undefined, undefined ] \n\nConfused? Yeah. Here’s roughly how it works. \n\napply(..) is a utility available to all functions, which calls the func¬ \ntion it’s used with but in a special way. \n\nThe first argument is a this object binding (covered in the this & \nObject Prototypes title in this series), which we don’t care about here, \nso we set it to null. The second argument is supposed to be an array \n(or something like an array—aka an “array-like object”). The con¬ \ntents of this “array” are “spread” out as arguments to the function in \nquestion. \n\nSo, Array. apply(..) is calling the Array(..) function and spread¬ \ning out the values (of the { length: 3 } object value) as its argu¬ \nments. \n\n\nNatives as Constructors | 47","metadata":{"loc":{"lines":{"from":65187,"to":65210}}}}],["745",{"pageContent":"So, Array. apply(..) is calling the Array(..) function and spread¬ \ning out the values (of the { length: 3 } object value) as its argu¬ \nments. \n\n\nNatives as Constructors | 47 \n\n\n\nInside of apply( ..), we can envision there’s another for loop (kinda \nlike join(. .) from above) that goes from 0 up to, but not including, \nlength (3 in our case). \n\nFor each index, it retrieves that key from the object. So if the array- \nobject parameter was named arr internally inside of the apply(..) \nfunction, the property access would effectively be arr[0], arr[l], \nand arr[2]. Of course, none of those properties exist on the \n{ length: 3 } object value, so all three of those property accesses \nwould return the value undefined. \n\nIn other words, it ends up calling Array(..) basically like this: \nArray(undefined,undefined,undefined), which is how we end up \nwith an array filled with undefined values, and not just those (crazy) \nempty slots.","metadata":{"loc":{"lines":{"from":65210,"to":65233}}}}],["746",{"pageContent":"While Array .apply ( null, { length: 3 } ) is a strange and ver¬ \nbose way to create an array filled with undefined values, it’s vastly \nbetter and more reliable than what you get with the footgun’ish \nArray(3) empty slots. \n\nBottom line: never ever, under any circumstances, should you inten¬ \ntionally create and use these exotic empty-slot arrays. Just don’t do \nit. They’re nuts. \n\nObject!..), Function!..), and RegExp(..) \n\nThe Object(.. )/Function(.. )/RegExp(. .) constructors are also \ngenerally optional (and thus should usually be avoided unless specif¬ \nically called for): \n\nvar c = new Object(); \nc.foo = \"bar\"; \nc; // { foo: \"bar\" } \n\nvar d = { foo: \"bar\" }; \nd; // { foo: \"bar\" } \n\nvar e = new Function( \"a\", \"return a * 2;\" ); \nvar f = function(a) { return a * 2; } \nfunction g(a) { return a * 2; } \n\nvar h = new RegExp( \" A a*b+\", \"g\" ); \nvar 1 = / A a*b+/g; \n\n\n48 | Chapter 3: Natives","metadata":{"loc":{"lines":{"from":65235,"to":65265}}}}],["747",{"pageContent":"var h = new RegExp( \" A a*b+\", \"g\" ); \nvar 1 = / A a*b+/g; \n\n\n48 | Chapter 3: Natives \n\n\n\n\nThere’s practically no reason to ever use the new Ob ject( ) construc¬ \ntor form, especially since it forces you to add properties one by one \ninstead of many at once in the object literal form. \n\nThe Function constructor is helpful only in the rarest of cases, \nwhere you need to dynamically define a function’s parameters \nand/or its function body. Do not just treat Function( ..) as an alter¬ \nnate form of eval(.. ). You will almost never need to dynamically \ndefine a function in this way. \n\nRegular expressions defined in the literal form (/ A a*b+/g) are \nstrongly preferred, not just for ease of syntax but for performance \nreasons—the JS engine precompiles and caches them before code \nexecution. Unlike the other constructor forms we’ve seen so far, \nRegExp( ..) has some reasonable utility: to dynamically define the \npattern for a regular expression: \n\nvar name = \"Kyte\";","metadata":{"loc":{"lines":{"from":65265,"to":65291}}}}],["748",{"pageContent":"var name = \"Kyte\"; \n\nvar namePattern = new RegExp( \"\\\\b(?:\" + name + \")+\\\\b\", \"tg\" ); \n\nvar matches = someText.match( namePattern ); \n\nThis kind of scenario legitimately occurs in JS programs from time \nto time, so you’d need to use the new RegExp(\"pattern\", \"flags\") \nform. \n\nDate(..) and Error(..) \n\nThe Date(..) and Error(..) native constructors are much more \nuseful than the other natives, because there is no literal form for \neither. \n\nTo create a date object value, you must use new Date(). The \nDate(..) constructor accepts optional arguments to specify the \ndate/time to use, but if omitted, the current date/time is assumed. \n\nBy far the most common reason you construct a date object is to get \nthe current Unix timestamp value (an integer number of seconds \nsince Jan 1, 1970). You can do this by calling getTirneQ on a date \nobject instance.","metadata":{"loc":{"lines":{"from":65291,"to":65314}}}}],["749",{"pageContent":"But an even easier way is to just call the static helper function \ndefined as of ES5: Date.nowQ. And to polyfill that for pre-ES5 is \npretty easy: \n\n\nNatives as Constructors | 49 \n\n\n\n\nIf (!Date.now) { \n\nDate.now = function(){ \n\nreturn (new Date()).getTine(); \n\n}; \n\n} \n\n\n\nIf you call Date( ) without new, you’ll get back a \nstring representation of the date/time at that \nmoment. The exact form of this representation \nis not specified in the language spec, though \nbrowsers tend to agree on something close to \n\"Fri Jul 18 2014 00:31:02 GMT-0500 \n\n(CDT) \n\n\nThe Error( ..) constructor (much like ArrayQ above) behaves the \nsame with the new keyword present or omitted.","metadata":{"loc":{"lines":{"from":65316,"to":65349}}}}],["750",{"pageContent":"(CDT) \n\n\nThe Error( ..) constructor (much like ArrayQ above) behaves the \nsame with the new keyword present or omitted. \n\nThe main reason youd want to create an error object is that it cap¬ \ntures the current execution stack context into the object (in most JS \nengines, revealed as a read-only .stack property once constructed). \nThis stack context includes the function call stack and the line num¬ \nber where the error object was created, which makes debugging that \nerror much easier. \n\nYou would typically use such an error object with the throw opera¬ \ntor: \n\n\nfunction foo(x) { \nif (!x) { \n\nthrow new Error( \"x wasn't provided\" ); \n\n} \n\n// \n\n}","metadata":{"loc":{"lines":{"from":65349,"to":65375}}}}],["751",{"pageContent":"You would typically use such an error object with the throw opera¬ \ntor: \n\n\nfunction foo(x) { \nif (!x) { \n\nthrow new Error( \"x wasn't provided\" ); \n\n} \n\n// \n\n} \n\nError object instances generally have at least a message property, \nand sometimes other properties (which you should treat as read¬ \nonly), like type. However, other than inspecting the above- \nmentioned stack property, it’s usually best to just call toStringQ \non the error object (either explicitly, or implicitly through coercion \n—see Chapter 4) to get a friendly formatted error message. \n\n\n50 | Chapter 3: Natives \n\n\n\n\n\n\nTechnically, in addition to the general \nError(..) native, there are several other \nspecific-error-type natives: EvalError(..), Ran \ngeError(..), ReferenceError(..), SyntaxEr","metadata":{"loc":{"lines":{"from":65375,"to":65408}}}}],["752",{"pageContent":"Technically, in addition to the general \nError(..) native, there are several other \nspecific-error-type natives: EvalError(..), Ran \ngeError(..), ReferenceError(..), SyntaxEr \n\n\nror(..)> TypeError(..), and URIError(.. \nBut it’s very rare to manually use these specific \nerror natives. They are automatically used if \nyour program actually suffers from a real excep¬ \ntion (such as referencing an undeclared variable \nand getting a ReferenceError error). \n\n\nSymbol(..) \n\n\nNew as of ES6, an additional primitive value type has been added, \ncalled “Symbol.” Symbols are special “unique” (not strictly guaran¬ \nteed!) values that can be used as properties on objects with little fear \nof any collision. They’re primarily designed for special built-in \nbehaviors of ES6 constructs, but you can also define your own sym¬ \n\n\nbols.","metadata":{"loc":{"lines":{"from":65408,"to":65432}}}}],["753",{"pageContent":"bols. \n\n\nSymbols can be used as property names, but you cannot see or \naccess the actual value of a symbol from your program, nor from the \ndeveloper console. If you evaluate a symbol in the developer con¬ \nsole, what’s shown looks like Symbol(Symbol. create), for example. \n\nThere are several predefined symbols in ES6, accessed as static prop¬ \nerties of the Symbol function object, like Symbol.create, Sym \nbol.Iterator, etc. To use them, do something like: \n\nobj[Symbol.iterator] = functlon(){ /*..*/ }; \n\nTo define your own custom symbols, use the Symbol (..) native. \nThe Symbol(..) native “constructor” is unique in that you’re not \nallowed to use new with it, as doing so will throw an error: \n\nvar mysym = Symbol( \"my own symbol\" ); \nmysym; // Symbol(my own symbol) \n\nmysym.toStringO; // \"Symbol(my own symbol)\" \n\ntypeof mysym; // \"symbol\" \n\nvar a = { }; \na[mysym] = \"foobar\"; \n\nObject.getOwnPropertySymbols( a ); \n\n// [ Symbol(my own symbol) ] \n\n\nNatives as Constructors | 51","metadata":{"loc":{"lines":{"from":65432,"to":65465}}}}],["754",{"pageContent":"typeof mysym; // \"symbol\" \n\nvar a = { }; \na[mysym] = \"foobar\"; \n\nObject.getOwnPropertySymbols( a ); \n\n// [ Symbol(my own symbol) ] \n\n\nNatives as Constructors | 51 \n\n\n\n\n\nWhile symbols are not actually private (Object.getOwnPropertySym \nbols( ..) reflects on the object and reveals the symbols quite pub¬ \nlicly), using them for private or special properties is likely their \nprimary use case. For most developers, they may take the place of \nproperty names with underscore (_) prefixes, which are almost \nalways by convention signals to say, “Hey, this is a private/special/ \ninternal property, so leave it alone!” \n\n\n\nSymbols are not objects, they are simple scalar \nprimitives. \n\n\nNative Prototypes \n\nEach of the built-in native constructors has its own .prototype \nobject — Array.prototype, String.prototype, etc. \n\nThese objects contain behavior unique to their particular object sub- \ntype.","metadata":{"loc":{"lines":{"from":65465,"to":65501}}}}],["755",{"pageContent":"Each of the built-in native constructors has its own .prototype \nobject — Array.prototype, String.prototype, etc. \n\nThese objects contain behavior unique to their particular object sub- \ntype. \n\nFor example, all string objects, and by extension (via boxing) string \nprimitives, have access to default behavior as methods defined on \nthe String. prototype object. \n\n\n\nBy documentation convention, String.proto \ntype.XYZ is shortened to String#XYZ, and like¬ \nwise for all the other . prototypes. \n\n\nString#indexOf(..) \n\nFind the position in the string of another substring \nString#charAt(..) \n\nAccess the character at a position in the string \n\nString#substr(..), String#substring(..), and String#slice(..) \nExtract a portion of the string as a new string \n\nString#toUpperCase() and String#toLowerCase() \n\nCreate a new string that’s converted to either uppercase or low¬ \nercase \n\n\n52 | Chapter 3: Natives \n\n\n\n\n\n\nString#trim()","metadata":{"loc":{"lines":{"from":65501,"to":65541}}}}],["756",{"pageContent":"String#toUpperCase() and String#toLowerCase() \n\nCreate a new string that’s converted to either uppercase or low¬ \nercase \n\n\n52 | Chapter 3: Natives \n\n\n\n\n\n\nString#trim() \n\nCreate a new string that’s stripped of any trailing or leading \nwhitespace \n\nNone of the methods modify the string in place. Modifications (like \ncase conversion or trimming) create a new value from the existing \nvalue. \n\nBy virtue of prototype delegation (see the this & Object Prototypes \ntitle in this series), any string value can access these methods: \n\nvar a = \" abc \"; \n\na.tndexOf( \"c\" ); // 3 \na.toUpperCase(); // \" ABC \" \na.trin(); // \"abc\" \n\nThe other constructor prototypes contain behaviors appropriate to \ntheir types, such as Number#toFixed(. .) (stringifying a number \nwith a fixed number of decimal digits) and Array#concat(.. ) \n(merging arrays). All functions have access to apply(.. ), call(..), \nand bind( ..) because Function, prototype defines them.","metadata":{"loc":{"lines":{"from":65541,"to":65576}}}}],["757",{"pageContent":"But, some of the native prototypes aren’t just plain objects: \n\n\ntypeof Function.prototype; \nFunction.prototype(); \n\nRegExp.prototype.toString(); \n\"abc\".match( RegExp.prototype ); \n\n\n// \"function\" \n\n// it's an empty function! \n\n// \"/(?:)/\" -- empty regex \n// [\"\"] \n\n\nA particularly bad idea, you can even modify these native prototypes \n(not just adding properties as you’re probably familiar with): \n\nArray.isArray( Array.prototype ); // true \n\nArray.prototype.push( 1, 2, 3 ); // 3 \n\nArray.prototype; // [1,2,3] \n\n// don't leave it that way, though, or expect weirdness! \n\n// reset the ’Array.prototype' to empty \nArray.prototype.length = 0; \n\nAs you can see, Function.prototype is a function, RegExp.proto \ntype is a regular expression, and Array .prototype is an array. Inter¬ \nesting and cool, huh? \n\n\nNatives as Constructors | 53 \n\n\n\n\nPrototypes as defaults","metadata":{"loc":{"lines":{"from":65578,"to":65620}}}}],["758",{"pageContent":"Natives as Constructors | 53 \n\n\n\n\nPrototypes as defaults \n\nFunction.prototype being an empty function, RegExp.prototype \nbeing an “empty” (e.g., nonmatching) regex, and Array.prototype \nbeing an empty array make them all nice “default” values to assign to \nvariables if those variables wouldn’t already have had a value of the \nproper type. \n\nFor example: \n\nfunction isThisCool(vals,fn,rx) { \nvals = vals || Array.prototype; \nfn = fn || Function.prototype; \nrx = rx || RegExp.prototype; \n\n\nreturn rx.test( \n\nvals.map( fn ).join( \"\" ) \n\n); \n\n\nisThisCool(); // true \n\n\ntsThisCool( \n\n[\"a\",\"b\",\"c\"], \n\nfunction(v){ return v.tolIpperCaseQ; }, \n/D/ \n\n); // false \n\n\n\nAs of ES6, we don’t need to use the vals = vals \n|| .. default value syntax trick (see Chapter 4) \nanymore, because default values can be set for \nparameters via native syntax in the function dec¬ \nlaration (see Chapter 5).","metadata":{"loc":{"lines":{"from":65620,"to":65666}}}}],["759",{"pageContent":"One minor side benefit of this approach is that the . prototypes are \nalready created and built-in; thus they are created only once. By con¬ \ntrast, using [], function(){}, and /(?:)/ values themselves for \nthose defaults would (likely, depending on engine implementations) \nbe re-creating those values (and probably garbage-collecting them \nlater) for each call of isThisCool( ..). That could waste memory/ \nCPU. \n\nAlso, be very careful not to use Array.prototype as a default value \nthat will subsequently be modified. In this example, vals is used \nread-only, but if you were to instead make in-place changes to vals, \n\n\n54 | Chapter 3: Natives \n\n\n\n\n\nyou would actually be modifying Array.prototype itself, which \nwould lead to the gotchas mentioned earlier! \n\n\n\nWhile we’re pointing out these native prototypes \nand some usefulness, be cautious of relying on \nthem and even more wary of modifying them in \nany way. See “Native Prototypes” on page 167 in \nAppendix A for more discussion.","metadata":{"loc":{"lines":{"from":65669,"to":65697}}}}],["760",{"pageContent":"Review \n\nJavaScript provides object wrappers around primitive values, known \nas natives (String, Number, Boolean, etc). These object wrappers \ngive the values access to behaviors appropriate for each object sub- \ntype (String#trim( ) and Array#concat(..)). \n\nIf you have a simple scalar primitive value like \"abc\" and you access \nits length property or some String.prototype method, JS auto¬ \nmatically “boxes” the value (wraps it in its respective object wrap¬ \nper) so that the property/method accesses can be fulfilled. \n\n\nReview | 55 \n\n\n\n\nCHAPTER 4 \n\n\nCoercion \n\n\nNow that we much more fully understand JavaScript’s types and val¬ \nues, we turn our attention to a very controversial topic: coercion.","metadata":{"loc":{"lines":{"from":65700,"to":65725}}}}],["761",{"pageContent":"Review | 55 \n\n\n\n\nCHAPTER 4 \n\n\nCoercion \n\n\nNow that we much more fully understand JavaScript’s types and val¬ \nues, we turn our attention to a very controversial topic: coercion. \n\nAs we mentioned in Chapter 1, the debates over whether coercion is \na useful feature or a flaw in the design of the language (or some¬ \nwhere in between!) have raged since day one. If you’ve read other \npopular books on JS, you know that the overwhelmingly prevalent \nmessage out there is that coercion is magical, evil, confusing, and \njust downright a bad idea. \n\nIn the same overall spirit of this series, rather than running away \nfrom coercion because everyone else does, or because you get bitten \nby some quirk, I think you should run toward that which you don’t \nunderstand and seek to get it more fully. \n\nOur goal is to fully explore the pros and cons (yes, there are pros!) of \ncoercion, so that you can make an informed decision on its appro¬ \npriateness in your program. \n\nConverting Values","metadata":{"loc":{"lines":{"from":65725,"to":65755}}}}],["762",{"pageContent":"Our goal is to fully explore the pros and cons (yes, there are pros!) of \ncoercion, so that you can make an informed decision on its appro¬ \npriateness in your program. \n\nConverting Values \n\nConverting a value from one type to another is often called “type \ncasting,” when done explicitly, and “coercion” when done implicitly \n(forced by the rules of how a value is used). \n\n\n57 \n\n\n\n\n\n\n\nIt may not be obvious, but JavaScript coercions \nalways result in one of the scalar primitive (see \nChapter 2) values, like string, number, or \nboolean. There is no coercion that results in a \ncomplex value like object or function. Chap¬ \nter 3 covers “boxing,” which wraps scalar primi¬ \ntive values in their object counterparts, but this \nis not really coercion in an accurate sense.","metadata":{"loc":{"lines":{"from":65755,"to":65781}}}}],["763",{"pageContent":"Another way these terms are often distinguished is as follows: “type \ncasting” (or “type conversion”) occurs in statically typed languages \nat compile time, while “type coercion” is a runtime conversion for \ndynamically typed languages. \n\nHowever, in JavaScript, most people refer to all these types of con¬ \nversions as coercion, so the way I prefer to distinguish is to say \n“implicit coercion” versus “explicit coercion.” \n\nThe difference should be obvious: “explicit coercion” is when it is \nobvious from looking at the code that a type conversion is intention¬ \nally occurring, whereas “implicit coercion” is when the type conver¬ \nsion will occur as a less obvious side effect of some other intentional \noperation. \n\nFor example, consider these two approaches to coercion: \nvar a = 42; \n\nvar b = a + 11 // Implicit coercion \nvar c = String( a ); // explicit coercion","metadata":{"loc":{"lines":{"from":65784,"to":65803}}}}],["764",{"pageContent":"For example, consider these two approaches to coercion: \nvar a = 42; \n\nvar b = a + 11 // Implicit coercion \nvar c = String( a ); // explicit coercion \n\nFor b, the coercion that occurs happens implicitly, because the + \noperator combined with one of the operands being a string value \n(\"\") will insist on the operation being a string concatenation \n(adding two strings together), which as a (hidden) side effect will \nforce the 42 value in a to be coerced to its string equivalent: \"42\". \n\nBy contrast, the String! . •) function makes it pretty obvious that \nit’s explicitly taking the value in a and coercing ittoastring repre¬ \nsentation. \n\nBoth approaches accomplish the same effect: \"42\" comes from 42. \nBut it’s the how that is at the heart of the heated debates over Java¬ \nScript coercion. \n\n\n58 | Chapter 4: Coercion","metadata":{"loc":{"lines":{"from":65803,"to":65824}}}}],["765",{"pageContent":"Both approaches accomplish the same effect: \"42\" comes from 42. \nBut it’s the how that is at the heart of the heated debates over Java¬ \nScript coercion. \n\n\n58 | Chapter 4: Coercion \n\n\n\n\n\n\nTechnically, there’s some nuanced behavioral \ndifference here beyond the stylistic difference. \nWe cover that in more detail later in the chapter, \nin “Implicitly: Strings <—> Numbers” on page \n87. \n\n\nThe terms “explicit” and “implicit,” or “obvious” and “hidden side \neffect,” are relative. \n\nIf you know exactly what a + \"\" is doing and you’re intentionally \ndoing that to coerce to a string, you might feel the operation is suf¬ \nficiently “explicit.” Conversely, if you’ve never seen the String(..) \nfunction used for string coercion, its behavior might seem hidden \nenough as to feel “implicit” to you.","metadata":{"loc":{"lines":{"from":65824,"to":65850}}}}],["766",{"pageContent":"But we’re having this discussion of “explicit” versus “implicit” based \non the likely opinions of an average, reasonably informed, but not \nexpert or JS specification devotee developer. To whatever extent you \ndo or do not find yourself fitting neatly in that bucket, you will need \nto adjust your perspective on our observations here accordingly. \n\nJust remember: it’s often rare that we write our code and are the only \nones who ever read it. Even if you’re an expert on all the ins and outs \nof JS, consider how a less experienced teammate of yours will feel \nwhen they read your code. Will it be “explicit” or “implicit” to them \nin the same way it is for you? \n\nAbstract Value Operations","metadata":{"loc":{"lines":{"from":65852,"to":65864}}}}],["767",{"pageContent":"Abstract Value Operations \n\nBefore we can explore explicit versus implicit coercion, we need to \nlearn the basic rules that govern how values become either a string, \nnumber, or boolean. The ES5 spec in section 9 defines several \n“abstract operations” (fancy spec-speak for “internal-only opera¬ \ntion”) with the rules of value conversion. We will specifically pay \nattention to ToString, ToNumber, and ToBoolean, and to a lesser \nextent, ToPrimitive. \n\nToString \n\nWhen any non-string value is coerced to a string representation, \nthe conversion is handled by the ToString abstract operation in sec¬ \ntion 9.8 of the specification. \n\n\nAbstract Value Operations | 59 \n\n\n\n\nBuilt-in primitive values have natural stringification: null becomes \n\"null\", undefined becomes \"undefined\", and true becomes \n\"true\", numbers are generally expressed in the natural way youd \nexpect, but as we discussed in Chapter 2, very small or very large \nnumbers are represented in exponent form:","metadata":{"loc":{"lines":{"from":65864,"to":65890}}}}],["768",{"pageContent":"// multiplying '1.07' by '1000', seven times over \n\nvar a = 1.07 * 1000 * 1000 * 1000 * 1000 * 1000 * 1000 * 1000; \n\n// seven times three digits => 21 digits \na.toString(); // \"1.07e21\" \n\nFor regular objects, unless you specify your own, the default \ntoStringO (located in Object.prototype.toStringO) will return \nthe internal [[Class]] (see Chapter 3), like for instance \"[object \nObject]\". \n\nBut as shown earlier, if an object has its own toStringO method on \nit, and you use that object in a string-like way, its toString() will \nautomatically be called, and the string result of that call will be \nused instead. \n\n\n\nThe way an object is coerced to a string techni¬ \ncally goes through the ToPrimitive abstract \noperation (ES5 spec, section 9.1), but those \nnuanced details are covered in more detail in the \nToNumber section later in this chapter, so we will \nskip over them here.","metadata":{"loc":{"lines":{"from":65892,"to":65916}}}}],["769",{"pageContent":"Arrays have an overridden default toStringO that stringifies as the \n(string) concatenation of all its values (each stringified themselves), \nwith \",\" in between each value: \n\nvar a = [1,2,3]; \na.toStringO; // \"1,2,3\" \n\nAgain, toStringO can either be called explicitly, or it will automati¬ \ncally be called if a non-string is used in a string context. \n\nJSON stringification \n\nAnother task that seems awfully related to ToString is when you use \nthe JSON.stringify(..) utility to serialize a value to a JSON- \ncompatible string value. \n\n\n60 | Chapter 4: Coerdon \n\n\n\n\n\nIt’s important to note that this stringification is not exactly the same \nthing as coercion. But since it’s related to the ToString rules above, \nwe’ll take a slight diversion to cover JSON stringification behaviors \nhere. \n\nFor most simple values, JSON stringification behaves basically the \nsame as toStringQ conversions, except that the serialization result \nis always a string: \n\nJSON.stringify( 42 ); // \"42\"","metadata":{"loc":{"lines":{"from":65919,"to":65951}}}}],["770",{"pageContent":"For most simple values, JSON stringification behaves basically the \nsame as toStringQ conversions, except that the serialization result \nis always a string: \n\nJSON.stringify( 42 ); // \"42\" \n\nJSON.stringify( \"42\" ); // \"\" 42 \"\" (a string with a \n\n// quoted string value in it) \nJSON.stringify( null ); // \"null\" \n\nJSON.stringify( true ); // \"true\" \n\nAny JSON-safe value can be stringified by JSON. stringify (..). But \nwhat is JSON-safe ? . Any value that can be represented validly in a \nJSON representation. \n\nIt may be easier to consider values that are not JSON-safe. Some \nexamples are undefineds, functions, (ES6+) symbols, and objects \nwith circular references (where property references in an object \nstructure create a never-ending cycle through each other). These are \nall illegal values for a standard JSON structure, mostly because they \naren’t portable to other languages that consume JSON values.","metadata":{"loc":{"lines":{"from":65951,"to":65973}}}}],["771",{"pageContent":"The JSON. stringify(..) utility will automatically omit undefined, \nfunction, and symbol values when it comes across them. If such a \nvalue is found in an array, that value is replaced by null (so that the \narray position information isn’t altered). If found as a property of an \nobject, that property will simply be excluded. \n\nConsider: \n\n\nISON.stringify( undefined ); // undefined \n\nISON.stringify( function(){} ); // undefined \n\n\nJSON.stringify( \n\n[l,undefined,function(){},4] \n\n); // \"[1,null,null,4]\" \n\nJSON.stringify( \n\n{ a:2, b:function(){} } \n\n); // \"l\" a \":2}\" \n\nBut if you try to JSON. stringify (..) an object with circular refer¬ \nence^) in it, an error will be thrown. \n\n\nAbstract Value Operations | 61 \n\n\n\n\nJSON stringification has the special behavior that if an object value \nhas a toll SON () method defined, this method will be called first to \nget a value to use for serialization.","metadata":{"loc":{"lines":{"from":65975,"to":66012}}}}],["772",{"pageContent":"JSON stringification has the special behavior that if an object value \nhas a toll SON () method defined, this method will be called first to \nget a value to use for serialization. \n\nIf you intend to JSON stringify an object that may contain illegal \nJSON value(s), or if you just have values in the object that aren’t \nappropriate for the serialization, you should define a toJSONQ \nmethod for it that returns a JSON-safe version of the object. \n\nFor example: \nvar o = { }; \n\nvar a = { \nb: 42, \nc: o, \n\nd: functionOO \n\n}; \n\n\n// create a circutar reference Inside 'a' \no.e = a; \n\n// would throw an error on the circular reference \n// ISON.stringify( a ); \n\n// define a custom JSON value serialization \na.toJSON = functionO { \n\n// only include the 'b' property for serialization \nreturn { b: this.b }; \n\n}; \n\n\nJSON.stringify( a ); // \"{\"b\":42}\"","metadata":{"loc":{"lines":{"from":66012,"to":66048}}}}],["773",{"pageContent":"// define a custom JSON value serialization \na.toJSON = functionO { \n\n// only include the 'b' property for serialization \nreturn { b: this.b }; \n\n}; \n\n\nJSON.stringify( a ); // \"{\"b\":42}\" \n\nIt’s a very common misconception that toJSONQ should return a \nJSON stringification representation. That’s probably incorrect, \nunless you’re wanting to actually stringify the string itself (usually \nnot!). toJS0N() should return the actual regular value (of whatever \ntype) that’s appropriate, and JSON. stringify (..) itself will handle \nthe stringification. \n\nIn other words, toJSONQ should be interpreted as “to a JSON-safe \nvalue suitable for stringification,” not “to a JSON string” as many \ndevelopers mistakenly assume. \n\n\n62 | Chapter 4: Coercion \n\n\n\n\n\nConsider: \n\n\nvar a = { \n\nval: [1,2,3], \n\n\n// probably correct! \ntoJSON: functlon(){ \n\nreturn this.val.slice( 1 ); \n\n} \n\n\nvar b = { \n\nval: [1,2,3], \n\n\n// probably incorrect! \ntoJSON: function(){ \nreturn \"[\" + \n\nthis.val.slice( 1 ).join() + \n\n\"]\";","metadata":{"loc":{"lines":{"from":66048,"to":66104}}}}],["774",{"pageContent":"return this.val.slice( 1 ); \n\n} \n\n\nvar b = { \n\nval: [1,2,3], \n\n\n// probably incorrect! \ntoJSON: function(){ \nreturn \"[\" + \n\nthis.val.slice( 1 ).join() + \n\n\"]\"; \n\n} \n\n\n3S0N.stringify( a ); // \"[2,3]\" \n\n3S0N.stringify( b ); // \"\"[2,3]\"\" \n\nIn the second call, we stringified the returned string rather than the \narray itself, which was probably not what we wanted to do. \n\nWhile we’re talking about JSON.stringifyf ..), let’s discuss some \nlesser-known functionalities that can still be very useful. \n\nAn optional second argument can be passed to JSON. string \nify( ..) that is called replacer. This argument can either be an array \nor a function. It’s used to customize the recursive serialization of an \nobject by providing a filtering mechanism for which properties \nshould and should not be included, in a similar way to how \ntoJS0N( ) can prepare a value for serialization.","metadata":{"loc":{"lines":{"from":66104,"to":66140}}}}],["775",{"pageContent":"If replacer is an array, it should be an array of strings, each of \nwhich will specify a property name that is allowed to be included in \nthe serialization of the object. If a property exists that isn’t in this \nlist, it will be skipped. \n\nIf replacer is a function, it will be called once for the object itself, \nand then once for each property in the object, and each time is \npassed two arguments, key and value. To skip a key in the serializa¬ \ntion, return undefined. Otherwise, return the value provided. \n\n\nAbstract Value Operations | 63 \n\n\n\nvar a = { \nb: 42, \nc: \"42\", \nd: [1,2,3] \n\n\n3S0N.stringify( a, [\"b\",\"c\"] ); // \"{\"b\":42,\"c\":\"42\"} \n\n3S0N.stringify( a, function(k,v){ \nif (k !== \"c\") return v; \n\n} ); \n\n// \"{\"b\":42,\"d\":[1,2,3]}\"","metadata":{"loc":{"lines":{"from":66142,"to":66170}}}}],["776",{"pageContent":"var a = { \nb: 42, \nc: \"42\", \nd: [1,2,3] \n\n\n3S0N.stringify( a, [\"b\",\"c\"] ); // \"{\"b\":42,\"c\":\"42\"} \n\n3S0N.stringify( a, function(k,v){ \nif (k !== \"c\") return v; \n\n} ); \n\n// \"{\"b\":42,\"d\":[1,2,3]}\" \n\n\n\nIn the function replacer case, the key argument \nk is undefined for the first call (where the a \nobject itself is being passed in). The if statement \nfilters out the property named \"c\". Stringifica- \ntion is recursive, so the [1,2,3] array has each \nof its values (1, 2, and 3) passed as v to replacer, \nwith indexes (0, 1, and 2) as k. \n\n\nA third optional argument can also be passed to JSON.string \nify(..), called space, which is used as indentation for prettier \nhuman-friendly output, space can be a positive integer to indicate \nhow many space characters should be used at each indentation level. \nOr, space can be a string, in which case up to the first 10 characters \nof its value will be used for each indentation level: \n\nvar a = { \nb: 42, \nc: \"42\", \nd: [1,2,3]","metadata":{"loc":{"lines":{"from":66170,"to":66206}}}}],["777",{"pageContent":"var a = { \nb: 42, \nc: \"42\", \nd: [1,2,3] \n\n\n3S0N.stringify( a, null, 3 ); \n\n// \"{ \n\n// \"b\": 42, \n\n// \"c\": \"42\", \n\n// \"d\": [ \n\n// 1 , \n\nII 2, \n\nII 3 \n\n// ] \n\n// }\" \n\n3S0N.stringify( a, null, \".\" ); \n\n// \"{ \n\n// .\"b\": 42, \n\n\n64 | Chapter 4: Coerdon \n\n\n\n\n\n\n\n\n\n\n// .\"c\": \"42\", \n\n// .\"d\": [ \n\n// . 1 , \n\n// . 2 , \n\n// . 3 \n\n\n// -] \n\n// }\" \n\nRemember, JSON. stringify(..) is not directly a form of coercion. \nWe covered it here, however, for two reasons that relate its behavior \nto ToString coercion: \n\n\n1. string, number, boolean, and null values all stringify for JSON \nbasically the same as how they coerce to string values via the \nrules of the ToString abstract operation. \n\n2. If you pass an object value to JSON.stringify (..), and that \nobject has a toJSONQ method on it, toJSONQ is automatically \ncalled to (sort of) “coerce” the value to be JSON-safe before \nstringification. \n\n\nToNumber","metadata":{"loc":{"lines":{"from":66206,"to":66280}}}}],["778",{"pageContent":"ToNumber \n\nIf any non-number value is used in a way that requires it to be a num \nber, such as a mathematical operation, the ES5 spec defines the \nToNumber abstract operation in section 9.3. \n\nFor example, true becomes 1 and false becomes 0. undefined \nbecomes NaN, but (curiously) null becomes 0. \n\nToNumber for a string value essentially works for the most part like \nthe rules/syntax for numeric literals (see Chapter 3). If it fails, the \nresult is NaN (instead of a syntax error as with number literals). One \ndifference is that 0-prefixed octal numbers are not handled as octals \n(just as normal base-10 decimals) in this operation, though such \noctals are valid as number literals (see Chapter 2). \n\n\n\nThe differences between number literal grammar \nand ToNumber on a string value are subtle and \nhighly nuanced, and thus will not be covered \nfurther here. Consult section 9.3.1 of the ES5 \nspec for more information. \n\n\nAbstract Value Operations | 65","metadata":{"loc":{"lines":{"from":66280,"to":66305}}}}],["779",{"pageContent":"Abstract Value Operations | 65 \n\n\n\n\n\n\n\n\n\n\n\nObjects (and arrays) will first be converted to their primitive value \nequivalent, and the resulting value (if a primitive but not already a \nnumber) is coerced to a number according to the ToNumber rules just \nmentioned. \n\nTo convert to this primitive value equivalent, the ToPrlmitive \nabstract operation (ES5 spec, section 9.1) will consult the value in \nquestion (using the internal DefaultValue operation—ES5 spec, \nsection 8.12.8) to see if it has a valueOfQ method. If valueOfQ is \navailable and it returns a primitive value, that value is used for the \ncoercion. If not, toStrlngQ will provide the value for the coercion, \nif present. \n\nIf neither operation can provide a primitive value, a TypeError is \nthrown.","metadata":{"loc":{"lines":{"from":66305,"to":66331}}}}],["780",{"pageContent":"If neither operation can provide a primitive value, a TypeError is \nthrown. \n\nAs of ES5, you can create such a noncoercible object—one without \nvalueOfQ and toStrlngQ—if it has a null value for its [[Proto \ntype]], typically created with Object.create(null). See the this & \nObject Prototypes title in this series for more information on [[Pro \ntotype] ]s. \n\n\n\nWe cover how to coerce to numbers later in this \nchapter in detail, but for this next code snippet, \njust assume the Number( ..) function does so. \n\n\nConsider: \nvar a = { \n\nvalueOf: function(){ \nreturn \"42\"; \n\n} \n\n}; \n\nvar b = { \n\ntoString: function(){ \nreturn \"42\"; \n\n} \n\n}; \n\nvar c = [4,2]; \nc.toString = function(){ \n\nreturn this.joln( \"\" ); // \"42\" \n\n}; \n\n\n66 | Chapter 4: Coercion \n\n\n\n\n\nNumber( a ) \nNumber( b ) \nNumber( c ) \n\n\n// 42 \n// 42 \n// 42 \n// 0 \n// 0 \n// NaN \n\n\nNumber( \"\" ); \n\nNumber( [] ); \n\nNumber( [ \"abc\" ] ); \n\n\nToBoolean","metadata":{"loc":{"lines":{"from":66331,"to":66400}}}}],["781",{"pageContent":"}; \n\n\n66 | Chapter 4: Coercion \n\n\n\n\n\nNumber( a ) \nNumber( b ) \nNumber( c ) \n\n\n// 42 \n// 42 \n// 42 \n// 0 \n// 0 \n// NaN \n\n\nNumber( \"\" ); \n\nNumber( [] ); \n\nNumber( [ \"abc\" ] ); \n\n\nToBoolean \n\nNext, let’s have a little chat about how booleans behave in JS. There’s \nlots of confusion and misconception floating out there around this \ntopic, so pay close attention! \n\nFirst and foremost, JS has actual keywords true and false, and they \nbehave exactly as you’d expect of boolean values. It’s a common mis¬ \nconception that the values 1 and 0 are identical to true/false. \nWhile that may be true in other languages, in JS the numbers are nun \nbers and the booleans are booleans. You can coerce 1 to true (and \nvice versa) or 0 to false (and vice versa). But they’re not the same. \n\nFalsy values \n\nBut that’s not the end of the story. We need to discuss how values \nother than the two booleans behave whenever you coerce to their \nboolean equivalent.","metadata":{"loc":{"lines":{"from":66400,"to":66446}}}}],["782",{"pageContent":"Falsy values \n\nBut that’s not the end of the story. We need to discuss how values \nother than the two booleans behave whenever you coerce to their \nboolean equivalent. \n\nAll of JavaScript’s values can be divided into two categories: \n\n1. Values that will become false if coerced to boolean \n\n2. Everything else (which will obviously become true) \n\nI’m not just being facetious. The JS spec defines a specific, narrow \nlist of values that will coerce to false when coerced to a boolean \nvalue. \n\nHow do we know what the list of values is? In the ES5 spec, section \n9.2 defines a ToBoolean abstract operation, which says exactly what \nhappens for all the possible values when you try to coerce them “to \nboolean.” \n\nFrom that table, we get the following as the so-called “falsy” values \n\n\nlist: \n\n\n• undefined \n\n\n• null \n\n\nAbstract Value Operations | 67 \n\n\n\n\nfalse \n\n+0, -0, and NaN","metadata":{"loc":{"lines":{"from":66446,"to":66486}}}}],["783",{"pageContent":"From that table, we get the following as the so-called “falsy” values \n\n\nlist: \n\n\n• undefined \n\n\n• null \n\n\nAbstract Value Operations | 67 \n\n\n\n\nfalse \n\n+0, -0, and NaN \n\n\nThat’s it. If a value is on that list, it’s a “falsy” value, and it will coerce \nto false if you force a boolean coercion on it. \n\nBy logical conclusion, if a value is not on that list, it must be on \nanother list, which we call the “truthy” values list. But JS doesn’t \nreally define a “truthy” list per se. It gives some examples, such as \nsaying explicitly that all objects are truthy, but mostly the spec just \nimplies that anything not explicitly on the falsy list is therefore truthy. \n\nFalsy objects \n\nWait a minute, that section title even sounds contradictory. I literally \njust said the spec calls all objects truthy, right? There should be no \nsuch thing as a “falsy object.” \n\nWhat could that possibly even mean?","metadata":{"loc":{"lines":{"from":66486,"to":66523}}}}],["784",{"pageContent":"What could that possibly even mean? \n\nYou might be tempted to think it means an object wrapper (see \nChapter 3) around a falsy value (such as 0, or false). But don’t \nfall into that trap. \n\n\n\nThat’s a subtle specification joke some of you \nmay get. \n\n\nConsider: \n\nvar a = new Boolean( false ); \nvar b = new Number( 0 ); \nvar c = new Strlng( \"\" ); \n\nWe know all three values here are objects (see Chapter 3) wrapped \naround obviously falsy values. But do these objects behave as true \nor as false? That’s easy to answer: \n\nvar d = Boolean( a && b && c ); \nd; // true \n\n\n68 | Chapter 4: Coercion \n\n\n\n\n\nSo, all three behave as true, as that’s the only way d could end up as \n\n\nNotice the way the Boolean( .. ) wrapped \n\naround the a && b && c expression—you might \nwonder why that’s there. We’ll come back to that \nlater in this chapter, so make a mental note of it. \n\nFor a sneak peek (trivia-wise), try for yourself \nwhat d will be if you just do d = a && b && c \nwithout the Boolean (..) call!","metadata":{"loc":{"lines":{"from":66523,"to":66566}}}}],["785",{"pageContent":"For a sneak peek (trivia-wise), try for yourself \nwhat d will be if you just do d = a && b && c \nwithout the Boolean (..) call! \n\nSo, if “falsy objects” are not just objects wrapped around falsy values, \nwhat the heck are they? \n\nThe tricky part is that they can show up in your JS program, but \nthey’re not actually part of JavaScript itself. \n\nWhat!? \n\nThere are certain cases where browsers have created their own sort \nof exotic values behavior, namely this idea of “falsy objects,” on top \nof regular JS semantics. \n\nA “falsy object” is a value that looks and acts like a normal object \n(properties, etc.), but when you coerce it to a boolean, it coerces to a \nfalse value. \n\nWhy!? \n\nThe most well-known case is document.all, an array-like (object) \nprovided to your JS program by the DOM (not the JS engine itself), \nwhich exposes elements in your page to your JS program. It used to \nbehave like a normal object—it would act truthy. But not anymore.","metadata":{"loc":{"lines":{"from":66566,"to":66591}}}}],["786",{"pageContent":"document, all itself was never really “standard” and has long since \nbeen deprecated/abandoned. \n\n“Can’t they just remove it, then?” Sorry, nice try. Wish they could. \nBut there’s far too many legacy JS code bases out there that rely on \nusing it. \n\nSo, why make it act falsy? Because coercions of document.all to \nboolean (like in if statements) were almost always used as a means \nof detecting old, nonstandard IE. IE has long since come up to \nstandards compliance, and in many cases is pushing the Web for¬ \nward as much or more than any other browser. \n\n\n\nAbstract Value Operations | 69 \n\n\n\n\nBut all that old if (document.all) { /* it's IE */ }codeisstill \nout there, and much of it is probably never going away. All this leg¬ \nacy code is still assuming it’s running in decade-old IE, which just \nleads to a bad browsing experience for IE users.","metadata":{"loc":{"lines":{"from":66593,"to":66616}}}}],["787",{"pageContent":"So, we can’t remove document.all completely, but IE doesn’t want \nif (document. all) { .. } code to work anymore, so that users in \nmodern IE get new, standards-compliant code logic. \n\n“What should we do?” \n\n“I’ve got it! Let’s bastardize the JS type system and pretend that docu \nment.all is falsy!” \n\nUgh. That sucks. It’s a crazy gotcha that most JS developers don’t \nunderstand. But the alternative (doing nothing about the above no- \nwin problems) sucks just a little bit more. \n\nSo... that’s what we’ve got: crazy, nonstandard “falsy objects” added \nto JavaScript by the browsers. Yay! \n\nTruthy values \n\nBack to the truthy list. What exactly are the truthy values? Remem¬ \nber: a value is truthy if it’s not on the falsy list. \n\nConsider: \n\nvar a = \"false\"; \nvar b = \"0\"; \nvar c = \" 11 \"; \n\nvar d = Boolean( a && b && c ); \nd; \n\nWhat value do you expect d to have here? It’s gotta be either true or \nfalse.","metadata":{"loc":{"lines":{"from":66618,"to":66649}}}}],["788",{"pageContent":"Consider: \n\nvar a = \"false\"; \nvar b = \"0\"; \nvar c = \" 11 \"; \n\nvar d = Boolean( a && b && c ); \nd; \n\nWhat value do you expect d to have here? It’s gotta be either true or \nfalse. \n\nIt’s true. Why? Because despite the contents of those string values \nlooking like falsy values, the string values themselves are all truthy, \nbecause \"\" is the only string value on the falsy list. \n\nWhat about these? \n\nvar a = []; // empty array--truthy or falsy? \n\nvar b = {}; // empty object--truthy or falsy? \n\nvar c = function(){}; // empty functlon--truthy or falsy? \n\n\n70 | Chapter 4: Coerdon \n\n\n\nvar d = Boolean( a && b && c ); \n\n\nd; \n\nYep, you guessed it, d is still true here. Why? Same reason as before. \nDespite what it may seem like, [], {}, and function(){} are not on \nthe falsy list, and thus are truthy values. \n\nIn other words, the truthy list is infinitely long. It’s impossible to \nmake such a list. You can only make a finite falsy list and consult it.","metadata":{"loc":{"lines":{"from":66649,"to":66688}}}}],["789",{"pageContent":"In other words, the truthy list is infinitely long. It’s impossible to \nmake such a list. You can only make a finite falsy list and consult it. \n\nTake five minutes, write the falsy list on a Post-it note for your com¬ \nputer monitor, or memorize it if you prefer. Either way, you’ll easily \nbe able to construct a virtual truthy list whenever you need it by \nsimply asking if it’s on the falsy list or not. \n\nThe importance of truthy and falsy is in understanding how a value \nwill behave if you coerce it (either explicitly or implicitly) to a \nboolean value. Now that you have those two lists in mind, we can \ndive into coercion examples themselves. \n\nExplicit Coercion \n\nExplicit coercion refers to type conversions that are obvious and \nexplicit. There’s a wide range of type conversion usage that clearly \nfalls under the explicit coercion category for most developers.","metadata":{"loc":{"lines":{"from":66688,"to":66705}}}}],["790",{"pageContent":"The goal here is to identify patterns in our code where we can make \nit clear and obvious that we’re converting a value from one type to \nanother, so as to not leave potholes for future developers to trip into. \nThe more explicit we are, the more likely someone later will be able \nto read our code and understand without undue effort what our \nintent was. \n\nIt would be hard to find any salient disagreements with explicit coer¬ \ncion, as it most closely aligns with how the commonly accepted \npractice of type conversion works in statically typed languages. As \nsuch, we’ll take for granted (for now) that explicit coercion can be \nagreed upon to not be evil or controversial. We’ll revisit this later, \nthough. \n\n\nExplicit Coercion | 71 \n\n\n\n\nExplicitly: Strings <--> Numbers \n\nWe’ll start with the simplest and perhaps most common coercion \noperation: coercing values between string and number representa¬ \ntion.","metadata":{"loc":{"lines":{"from":66707,"to":66731}}}}],["791",{"pageContent":"Explicitly: Strings <--> Numbers \n\nWe’ll start with the simplest and perhaps most common coercion \noperation: coercing values between string and number representa¬ \ntion. \n\nTo coerce between strings and numbers, we use the built-in \nString(..) and Number(..) functions (which we referred to as \n“native constructors” in Chapter 3), but very importantly, we do not \nuse the new keyword in front of them. As such, we’re not creating \nobject wrappers. \n\nInstead, we’re actually explicitly coercing between the two types: \n\nvar a = 42; \n\nvar b = Strlng( a ); \n\nvar c = \"3.14\"; \nvar d = Number( c ); \n\nb; // \"42\" \nd; // 3.14 \n\nString(..) coerces from any other value to a primitive string \nvalue, using the rules of the ToString operation discussed earlier. \nNumber(..) coerces from any other value to a primitive number \nvalue, using the rules of the ToNumber operation discussed earlier.","metadata":{"loc":{"lines":{"from":66731,"to":66758}}}}],["792",{"pageContent":"I call this explicit coercion because in general, it’s pretty obvious to \nmost developers that the end result of these operations is the appli¬ \ncable type conversion. \n\nIn fact, this usage actually looks a lot like it does in some other stati¬ \ncally typed languages. \n\nFor example, in C/C++, you can say either (int)x or int(x), and \nboth will convert the value in x to an integer. Both forms are valid, \nbut many prefer the latter, which kinda looks like a function call. In \nJavaScript, when you say Number(x), it looks awfully similar. Does it \nmatter that it’s actually a function call in JS? Not really. \n\nBesides String(..) and Number(..)> there are other ways to \n“explicitly” convert these values between string and number: \n\nvar a = 42; \n\nvar b = a.toString(); \n\nvar c = \"3.14\"; \n\n\n72 | Chapter 4: Coercion \n\n\n\n\nvar d = +c; \n\n\nb; // \"42\" \nd; // 3.14","metadata":{"loc":{"lines":{"from":66760,"to":66792}}}}],["793",{"pageContent":"var a = 42; \n\nvar b = a.toString(); \n\nvar c = \"3.14\"; \n\n\n72 | Chapter 4: Coercion \n\n\n\n\nvar d = +c; \n\n\nb; // \"42\" \nd; // 3.14 \n\nCalling a.toString() is ostensibly explicit (pretty clear that \n“toString” means “to a string”), but there’s some hidden implicitness \nhere. toStringQ cannot be called on a primitive value like 42. So JS \nautomatically “boxes” (see Chapter 3) 42 in an object wrapper, so \nthat toString() can be called against the object. In other words, \nyou might call it “explicitly implicit.” \n\n+c here is showing the unary operator form (operator with only one \noperand) of the + operator. Instead of performing mathematic addi¬ \ntion (or string concatenation—see below), the unary + explicitly \ncoerces its operand (c) to a number value.","metadata":{"loc":{"lines":{"from":66792,"to":66820}}}}],["794",{"pageContent":"Is +c explicit coercion? Depends on your experience and perspective. \nIf you know (which you do, now!) that unary + is explicitly intended \nfor number coercion, then it’s pretty explicit and obvious. However, \nif you’ve never seen it before, it can seem awfully confusing, implicit, \nwith hidden side effects, etc. \n\n\n\nThe generally accepted perspective in the open \nsource JS community is that unary + is an \naccepted form of explicit coercion. \n\n\nEven if you really like the +c form, there are definitely places where \nit can look awfully confusing. Consider: \n\nvar c = \"3.14\"; \nvar d = 5+ +c; \n\nd; // 8.14 \n\nThe unary - operator also coerces like + does, but it also flips the \nsign of the number. However, you cannot put two (- - ) next to each \nother to unflip the sign, as that’s parsed as the decrement operator. \nInstead, you would need to do - - \"3.14\" with a space in between, \nand that would result in coercion to 3.14.","metadata":{"loc":{"lines":{"from":66822,"to":66847}}}}],["795",{"pageContent":"You can probably dream up all sorts of hideous combinations of \nbinary operators (like + for addition) next to the unary form of an \noperator. Here’s another crazy example: \n\n\nExplicit Coercion | 73 \n\n\n\n\n1 +-+++-+ 1; // 2 \n\n\nYou should strongly consider avoiding unary + (or -) coercion when \nit’s immediately adjacent to other operators. While the above works, \nit would almost universally be considered a bad idea. Even d = +c \n(or d =+ c for that matter!) can far too easily be confused for d += \nc, which is entirely different! \n\n\n\nAnother extremely confusing place for unary + \nto be used adjacent to another operator would \nbe the ++ increment operator and - - decrement \noperator. For example, consider a +++b, \na + ++b, and a + + +b. See “Expression Side \nEffects” on page 125 for more about ++. \n\n\nRemember, we’re trying to be explicit and reduce confusion, not \nmake it much worse! \n\n\nDate to number","metadata":{"loc":{"lines":{"from":66849,"to":66882}}}}],["796",{"pageContent":"Remember, we’re trying to be explicit and reduce confusion, not \nmake it much worse! \n\n\nDate to number \n\nAnother common usage of the unary + operator is to coerce a Date \nobject into a number, because the result is the Unix timestamp (milli¬ \nseconds elapsed since 1 January 1970 00:00:00 UTC) representation \nof the date/time value: \n\nvar d = new Date( \"Mon, 18 Aug 2014 08:53:06 CDT\" ); \n\n+d; // 1408369986000 \n\nThe most common usage of this idiom is to get the current now \nmoment as a timestamp, such as: \n\nvar timestamp = +new Date();","metadata":{"loc":{"lines":{"from":66882,"to":66900}}}}],["797",{"pageContent":"+d; // 1408369986000 \n\nThe most common usage of this idiom is to get the current now \nmoment as a timestamp, such as: \n\nvar timestamp = +new Date(); \n\n\n\nSome developers are aware of a peculiar syntac¬ \ntic “trick” in JavaScript, which is that the () set \non a constructor call (a function called with new) \nis optional only if there are no arguments to \npass. So you may run across the var timestamp \n= +new Date; form. However, not all developers \nagree that omitting the () improves readability, \nas it’s an uncommon syntax exception that only \napplies to the new fn() call form and not the \nregular fn( ) call form. \n\n\n74 | Chapter 4: Coerdon \n\n\n\n\n\n\nBut coercion is not the only way to get the timestamp out of a Date \nobject. A noncoercion approach is perhaps even preferable, as it’s \neven more explicit: \n\nvar timestamp = new DateQ .getTimeQ; \n\n// var timestamp = (new DateQ).getTimeQ; \n\n// var timestamp = (new Date) .getTimeQ;","metadata":{"loc":{"lines":{"from":66900,"to":66936}}}}],["798",{"pageContent":"var timestamp = new DateQ .getTimeQ; \n\n// var timestamp = (new DateQ).getTimeQ; \n\n// var timestamp = (new Date) .getTimeQ; \n\nBut an even more preferable noncoercion option is to use the \nDate. now() static function added in ES5: \n\nvar timestamp = Date.nowQ; \n\nAnd if you want to polyfill Date.nowQ into older browsers, it’s \npretty simple: \n\nif (IDate.now) { \n\nDate.now = functionQ { \nreturn +new DateQ; \n\n}; \n\n} \n\nI’d recommend skipping the coercion forms related to dates. Use \nDate.nowQ for current now timestamps, and new Date( .. ).get \nTineQ for getting a timestamp of a specific non-now date/time that \nyou need to specify. \n\nThe curious case of the-","metadata":{"loc":{"lines":{"from":66936,"to":66964}}}}],["799",{"pageContent":"The curious case of the- \n\nOne coercive JS operator that is often overlooked and usually very \nconfused is the tilde ~ operator (aka “bitwise NOT”). Many of those \nwho even understand what it does will often still want to avoid it. \nBut sticking to the spirit of our approach in this book and series, let’s \ndig into it to find out if ~ has anything useful to give us. \n\nIn “32-Bit (Signed) Integers” on page 23, we covered how bitwise \noperators in JS are defined only for 32-bit operations, which means \nthey force their operands to conform to 32-bit value representations. \nThe rules for how this happens are controlled by the ToInt32 \nabstract operation (ES5 spec, section 9.5). \n\nToInt32 first does a ToNumber coercion, which means if the value is \n\"123\", it’s going to first become 123 before the ToInt32 rules are \napplied. \n\nWhile not technically coercion itself (since the type doesn’t change!), \nusing bitwise operators (like | or ~) with certain special number val-","metadata":{"loc":{"lines":{"from":66964,"to":66983}}}}],["800",{"pageContent":"While not technically coercion itself (since the type doesn’t change!), \nusing bitwise operators (like | or ~) with certain special number val- \n\n\nExplicit Coercion | 75 \n\n\n\nues produces a coercive effect that results in a different number \nvalue. \n\nFor example, let’s first consider the | “bitwise OR” operator used in \nthe otherwise no-op idiom 0 | x, which (as Chapter 2 showed) \nessentially only does the ToInt32 conversion: \n\n0 | - 0 ; // 0 \n\n0 | NaN; // 0 \n\n0 | Infinity; // 0 \n\n0 | -Infinity; // 0 \n\nThese special numbers aren’t 32-bit representable (since they come \nfrom the 64-bit IEEE 754 standard—see Chapter 2), so ToInt32 just \nspecifies 0 as the result from these values. \n\nIt’s debatable if 0 |_is an explicit form of this coercive ToInt32","metadata":{"loc":{"lines":{"from":66983,"to":67010}}}}],["801",{"pageContent":"It’s debatable if 0 |_is an explicit form of this coercive ToInt32 \n\noperation or if it’s more implicit. From the spec perspective, it’s \nunquestionably explicit, but if you don’t understand bitwise opera¬ \ntions at this level, it can seem a bit more implicitly magical. Never¬ \ntheless, consistent with other assertions in this chapter, we will call it \nexplicit. \n\nSo, let’s turn our attention back to The ~ operator first “coerces” to \na 32-bit number value, and then performs a bitwise negation (flip¬ \nping each bit’s parity). \n\n\n\nThis is very similar to how ! not only coerces its \nvalue to boolean but also flips its parity (see the \ndiscussion of the “unary !\" operator in “Explic- \n\n\nitly: * —> Boolean” on page 83). \n\n\nBut... what!? Why do we care about bits being flipped? That’s some \npretty specialized, nuanced stuff. It’s pretty rare for JS developers to \nneed to reason about individual bits.","metadata":{"loc":{"lines":{"from":67010,"to":67034}}}}],["802",{"pageContent":"But... what!? Why do we care about bits being flipped? That’s some \npretty specialized, nuanced stuff. It’s pretty rare for JS developers to \nneed to reason about individual bits. \n\nAnother way of thinking about the definition of ~ comes from old- \nschool computer science/discrete mathematics: ~ performs two’s \ncomplement. Great, thanks, that’s totally clearer! \n\nLet’s try again: ~x is roughly the same as -(x+1). That’s weird, but \nslightly easier to reason about. So: \n\n—42; // -(42+1) ==> -43 \n\n\n76 | Chapter 4: Coercion \n\n\n\n\n\nYou’re probably still wondering what the heck all this ~ stuff is \nabout, or why it really matters for a coercion discussion. Let’s \nquickly get to the point.","metadata":{"loc":{"lines":{"from":67034,"to":67056}}}}],["803",{"pageContent":"76 | Chapter 4: Coercion \n\n\n\n\n\nYou’re probably still wondering what the heck all this ~ stuff is \nabout, or why it really matters for a coercion discussion. Let’s \nquickly get to the point. \n\nConsider -(x+1). What’s the only value that can you can perform \nthat operation on that will produce a 0 (or -0 technically!) result? -1. \nIn other words, ~ used with a range of number values will produce a \nfalsy (easily coercible to false) 0 value for the -1 input value, and \nany other truthy number otherwise. \n\nWhy is that relevant? \n\n-1 is commonly called a “sentinel value,” which basically means a \nvalue that’s given an arbitrary semantic meaning within the greater \nset of values of its same type (numbers). The C-language uses -1 sen¬ \ntinel values for many functions that return >= 0 values for “success” \nand -1 for “failure.”","metadata":{"loc":{"lines":{"from":67056,"to":67078}}}}],["804",{"pageContent":"JavaScript adopted this precedent when defining the string opera¬ \ntion indexOf (..), which searches for a substring and if found \nreturns its zero-based index position, or -1 if not found. \n\nIt’s pretty common to try to use indexOf (..) not just as an opera¬ \ntion to get the position, but as a boolean check of presence/absence \nof a substring in another string. Here’s how developers usually per¬ \nform such checks: \n\nvar a = \"Hello World\"; \n\nif (a.indexOf( \"lo\" ) >= 0) { // true \n\n// found it! \n\n1 \n\nif (a.indexOf( \"lo\" ) != -1) { // true \n\n// found it \n\n1 \n\nif (a.indexOf( \"ol\" ) < 0) { // true \n\n// not found! \n\n1 \n\nif (a.indexOf( \"ol\" ) == -1) { // true \n\n// not found! \n\n} \n\nI find it kind of gross to look at >= 0 or == -1. It’s basically a “leaky \nabstraction,” in that it’s leaking underlying implementation behavior \n—the usage of sentinel -1 for “failure”—into my code. I would prefer \nto hide such a detail. \n\n\nExplidtCoerdon | 77","metadata":{"loc":{"lines":{"from":67080,"to":67121}}}}],["805",{"pageContent":"ExplidtCoerdon | 77 \n\n\n\nAnd now, finally, we see why ~ could help us! Using ~ with \nindexOf () “coerces” (actually just transforms) the value to be appro¬ \npriately boolean-coercible: \n\n\nvar a = \"Hello World' \n\nt \n\n\n\n~a.lndexOf( \"lo\" \n\n); \n\n\n// -4 <-- \n\ntruthy \n\nIf (~a.IndexOf( 1 \n// found it! \n\n} \n\nTo\" \n\n)) { \n\n// true \n\n\n~a.indexOf( \"ol\" \n!~a.indexOf( \"ol 1 \n\n); \n\n' ); \n\n\n// O <-- \n// true \n\nfalsy! \n\nif (!~a.indexOf( \n\n\"ol' \n\n' )) { \n\n// true \n\n\n\n// not found! \n\n\n} \n\n~ takes the return value of IndexOf (..) and transforms it: for the \n“failure” -1 we get the falsy 0, and every other value is truthy. \n\n\n\nThe - (x+1) pseudo-algorithm for ~ would imply \nthat — 1 is -0, but actually it produces 0 because \nthe underlying operation is bitwise, not mathe¬ \nmatic.","metadata":{"loc":{"lines":{"from":67121,"to":67193}}}}],["806",{"pageContent":"The - (x+1) pseudo-algorithm for ~ would imply \nthat — 1 is -0, but actually it produces 0 because \nthe underlying operation is bitwise, not mathe¬ \nmatic. \n\n\nTechnically, if (~a.indexOf (..)) is still relying on implicit coer¬ \ncion of its resultant 0 to false or nonzero to true. But overall, ~ still \nfeels to me more like an explicit coercion mechanism, as long as you \nknow what it’s intended to do in this idiom. \n\nI find this to be cleaner code than the previous >= 0 / == -1 clutter. \n\nTruncating bits \n\nThere’s one more place ~ may show up in code you run accross: \nsome developers use the double tilde — to truncate the decimal part \nof a number (i.e., “coerce” it to a whole number integer). It’s com¬ \nmonly (though mistakenly) said that this is the same result as calling \n\nMath .floor(..).","metadata":{"loc":{"lines":{"from":67193,"to":67213}}}}],["807",{"pageContent":"Math .floor(..). \n\nHow — works is that the first ~ applies the ToInt32 “coercion” and \ndoes the bitwise flip, and then the second ~ does another bitwise flip, \nflipping all the bits back to the original state. The end result is just \nthe ToInt32 “coercion” (aka truncation). \n\n\n78 | Chapter 4: Coerdon \n\n\n\n\n\nThe bitwise double-flip of — is very similar to \nthe parity double-negate !! behavior, explained \nin “Explicitly: * --> Boolean” on page 83. \n\n\nHowever, — needs some caution/clarification. First, it only works \nreliably on 32-bit values. But more importantly, it doesn’t work the \nsame on negative numbers as Math. floor(..) does! \n\nMath.floorf -49.6 ); // -50 \n\n— -49.6; // -49 \n\nSetting the Math.floor(..) difference aside, —x can truncate to a \n(32-bit) integer. But so does x | 0, and seemingly with (slightly) less \neffort. \n\nSo, why might you choose —x over x | 0, then? Operator prece¬ \ndence (see Chapter 5): \n\n—1E20 / 10; // 166199296 \n\n1E20 | 0 / 10; // 1661992960","metadata":{"loc":{"lines":{"from":67213,"to":67249}}}}],["808",{"pageContent":"So, why might you choose —x over x | 0, then? Operator prece¬ \ndence (see Chapter 5): \n\n—1E20 / 10; // 166199296 \n\n1E20 | 0 / 10; // 1661992960 \n\n(1E20 | 0) / 10; // 166199296 \n\nJust as with all other advice here, use ~ and — as explicit mecha¬ \nnisms for “coercion” and value transformation only if everyone who \nreads/writes such code is properly aware of how these operators \nwork! \n\nExplicitly: Parsing Numeric Strings \n\nA similar outcome to coercing a string to a number can be achieved \nby parsing a number out of a string’s character contents. There are, \nhowever, distinct differences between this parsing and the type con¬ \nversion we examined above. \n\nConsider: \n\nvar a = \"42\"; \nvar b = \"42px\"; \n\nNumberf a ); // 42 \n\nparselnt( a ); // 42 \n\nNumberf b ); // NaN \n\nparselntf b ); // 42 \n\n\nExplidtCoerdon | 79","metadata":{"loc":{"lines":{"from":67249,"to":67284}}}}],["809",{"pageContent":"Consider: \n\nvar a = \"42\"; \nvar b = \"42px\"; \n\nNumberf a ); // 42 \n\nparselnt( a ); // 42 \n\nNumberf b ); // NaN \n\nparselntf b ); // 42 \n\n\nExplidtCoerdon | 79 \n\n\n\n\n\nParsing a numeric value out of a string is tolerant of non-numeric \ncharacters—it just stops parsing left-to-right when encountered— \nwhereas coercion is not tolerant and fails, resulting in the NaN value. \n\nParsing should not be seen as a substitute for coercion. These two \ntasks, while similar, have different purposes. Parse a string as a num \nber when you don’t know/care what other non-numeric characters \nthere may be on the right-hand side. Coerce a string (to a number) \nwhen the only acceptable values are numeric and something like \n\"42px\" should be rejected as a number. \n\n\n\nparselnt(..) has a twin, parseFloat(..), \nwhich (as it sounds) pulls out a floating-point \nnumber from a string.","metadata":{"loc":{"lines":{"from":67284,"to":67319}}}}],["810",{"pageContent":"parselnt(..) has a twin, parseFloat(..), \nwhich (as it sounds) pulls out a floating-point \nnumber from a string. \n\n\nDon’t forget that parselnt( ..) operates on string values. It makes \nabsolutely no sense to pass a number value to parselnt(. .). Nor \nwould it make sense to pass any other type of value, like true, func \ntion(){. .}, or [1,2,3]. \n\nIf you pass a non-string, the value you pass will automatically be \ncoerced to a string first (see “ToString” on page 59), which would \nclearly be a kind of hidden implicit coercion. It’s a really bad idea to \nrely upon such behavior in your program, so never use par \nselnt( ..) with a non-string value. \n\nPrior to ES5, another gotcha existed with parselnt( ..), which was \nthe source of many JS programs’ bugs. If you didn’t pass a second \nargument to indicate which numeric base (aka radix) to use for \ninterpreting the numeric string contents, parselnt(..) would \nlook at the first character to make a guess.","metadata":{"loc":{"lines":{"from":67319,"to":67339}}}}],["811",{"pageContent":"If the first character was x or X, the guess (by convention) was that \nyou wanted to interpret the string as a hexadecimal (base-16) num \nber. If the first character was 0, the guess (again, by convention) was \nthat you wanted to interpret the string as an octal (base-8) number. \n\nHexadecimal strings (with the leading x or X) aren’t terribly easy to \nget mixed up. But the octal number guessing proved devilishly com¬ \nmon. For example: \n\n\n80 | Chapter 4: Coercion \n\n\n\n\n\nvar hour = parselnt( selectedHour.value ); \nvar minute = parselnt( selectedMlnute.value ); \n\nconsole.log( \n\n\"The time you selected was: \" + hour + + minute \n\n); \n\nSeems harmless, right? Try selecting 08 for the hour and 09 for the \nminute. You’ll get 0:0. Why? because neither 8 nor 9 are valid char¬ \nacters in octal base-8. \n\nThe pre-ES5 fix was simple, but so easy to forget: always pass 10 as \nthe second argument. This was totally safe:","metadata":{"loc":{"lines":{"from":67341,"to":67371}}}}],["812",{"pageContent":"The pre-ES5 fix was simple, but so easy to forget: always pass 10 as \nthe second argument. This was totally safe: \n\nvar hour = parselnt( selectedHour.value, 10 ); \nvar minute = parselnt( selectedMlnlute.value, 10 ); \n\nAs of ES5, parselnt( ..) no longer guesses. Unless you say other¬ \nwise, it assumes base-10. That’s much nicer. Just be careful if your \ncode has to run in pre-ES5 environments, in which case you still \nneed to pass 10 for the radix. \n\nParsing non-strings \n\nOne somewhat infamous example of parselnt( .. )’s behavior is \nhighlighted in a sarcastic joke post a few years ago, poking fun at \nthis JS behavior: \n\nparselnt( 1/0, 19 ); // 18 \n\nThe assumptive (but totally invalid) assertion was, “If I pass in Infin¬ \nity, and parse an integer out of that, I should get Infinity back, not \n18.” Surely, JS must be crazy for this outcome, right?","metadata":{"loc":{"lines":{"from":67371,"to":67392}}}}],["813",{"pageContent":"Though this example is obviously contrived and unreal, let’s indulge \nthe madness for a moment and examine whether JS really is that \ncrazy. \n\nFirst off, the most obvious sin committed here is to pass a non¬ \nstring to parselnt(. .). That’s a no-no. Do it and you’re asking for \ntrouble. But even if you do, JS politely coerces what you pass in into \na string that it can try to parse. \n\nSome would argue that this is unreasonable behavior, and that par \nselnt(.. ) should refuse to operate on a non-string value. Should \nit perhaps throw an error? That would be very Java-like, frankly. I \nshudder at thinking JS should start throwing errors all over the place \nso that try.. catch is needed around almost every line. \n\n\nExplicit Coercion | 81 \n\n\n\nShould it return NaN? Maybe. But.. .what about: \nparselnt( new String( \"42\") );","metadata":{"loc":{"lines":{"from":67394,"to":67415}}}}],["814",{"pageContent":"Explicit Coercion | 81 \n\n\n\nShould it return NaN? Maybe. But.. .what about: \nparselnt( new String( \"42\") ); \n\nShould that fail, too? It’s a non-string value. If you want that \nString object wrapper to be unboxed to \"42\", then is it really so \nunusual for 42 to first become \"42\" so that 42 can be parsed back \nout? \n\nI would argue that this half- explicit, half-implicit coercion that can \noccur can often be a very helpful thing. For example: \n\nvar a = { \nnun: 21, \n\ntoString: function() { return String( this.nun * 2 ); } \n\n}; \n\n\nparselnt( a ); // 42 \n\nThe fact that parselntf ..) forcibly coerces its value to a string to \nperform the parse on is quite sensible. If you pass in garbage, and \nyou get garbage back out, don’t blame the trash can—it just did its \njob faithfully.","metadata":{"loc":{"lines":{"from":67415,"to":67443}}}}],["815",{"pageContent":"So, if you pass in a value like Infinity (the result of 1 / 0 obvi¬ \nously), what sort of string representation would make the most \nsense for its coercion? Only two reasonable choices come to mind: \n\"Infinity\" and JS chose \"Infinity\". I’m glad it did. \n\nI think it’s a good thing that all values in JS have some sort of default \nstring representation, so that they aren’t mysterious black boxes \nthat we can’t debug and reason about. \n\nNow, what about base-19? Obviously, completely bogus and con¬ \ntrived. No real JS programs use base-19. It’s absurd. But again, let’s \nindulge the ridiulousness. In base-19, the valid numeric characters \nare 0 - 9 and a - i (case insensitive).","metadata":{"loc":{"lines":{"from":67445,"to":67457}}}}],["816",{"pageContent":"So, back to our parselnt( 1/0, 19 ) example. It’s essentially par \nselnt( \"Infinity\", 19 ). How does it parse? The first character is \n\"I\", which is value 18 in the silly base-19. The second character \"n\" \nis not in the valid set of numeric characters, and as such the parsing \nsimply politely stops, just like when it ran across \"p\" in \"42px\". \n\nThe result? 18. Exactly like it sensibly should be. The behaviors \ninvolved to get us there, and not to an error or to Infinity itself, are \nvery important to JS, and should not be so easily discarded. \n\n\n82 | Chapter 4: Coercion \n\n\n\nOther examples of this behavior with parselnt(..) that may be \nsurprising but are quite sensible include: \n\n\nparselnt( 0.000008 \nparselnt( 0.0000008 \nparselnt( false, 16 \nparselnt( parselnt. \n\n\n; // 0 (\" 0 \" \n\n); // 8 (\" 8 \" \n\n); // 250 (\"fa \n\n16 ); // 15 (\"f\" \n\n\nfrom \"0.000008\") \nfrom \"8e-7\") \nfrom \"false\") \nfrom \"function..\") \n\n\nparselnt( \"0x10\" ); // 16 \n\nparselnt( \"103\", 2 ); // 2","metadata":{"loc":{"lines":{"from":67459,"to":67501}}}}],["817",{"pageContent":"; // 0 (\" 0 \" \n\n); // 8 (\" 8 \" \n\n); // 250 (\"fa \n\n16 ); // 15 (\"f\" \n\n\nfrom \"0.000008\") \nfrom \"8e-7\") \nfrom \"false\") \nfrom \"function..\") \n\n\nparselnt( \"0x10\" ); // 16 \n\nparselnt( \"103\", 2 ); // 2 \n\nparselnt(..) is actually pretty predictable and consistent in its \nbehavior. If you use it correctly, you’ll get sensible results. If you use \nit incorrectly, the crazy results you get are not the fault of JavaScript. \n\n\nExplicitly: * --> Boolean \n\nNow, let’s examine coercing from any non-boolean value to a \nboolean. \n\nJust like with String(..) and Number(..) above, Boolean(..) \n(without the new, of course!) is an explicit way of forcing the ToBoo \nlean coercion: \n\nvar a = \"0\"; \nvar b = []; \nvar c = {}; \n\nvar d = \nvar e = 0; \nvar f = null; \nvar g; \n\nBoolean( a ); // true \nBoolean! b ); // true \nBoolean! c ); // true \n\nBoolean! d ); // false \nBoolean! e ); // false \nBoolean! f ); // false \nBoolean! g ); // false \n\nWhile Boolean!..) is clearly explicit, it’s not at all common or \nidiomatic.","metadata":{"loc":{"lines":{"from":67501,"to":67553}}}}],["818",{"pageContent":"Boolean! d ); // false \nBoolean! e ); // false \nBoolean! f ); // false \nBoolean! g ); // false \n\nWhile Boolean!..) is clearly explicit, it’s not at all common or \nidiomatic. \n\nJust like the unary + operator coerces a value to a number (see \nabove), the unary ! negate operator explicitly coerces a value to a \nboolean. The problem is that it also flips the value from truthy to \nfalsy or vice versa. So, the most common way JS developers explic- \n\n\nExplicit Coercion | 83 \n\n\n\nitly coerce to boolean is to use the !! double-negate operator, \nbecause the second ! will flip the parity back to the original: \n\nvar a = \"0\"; \nvar b = []; \nvar c = {}; \n\nvar d = \nvar e = 0; \nvar f = null; \nvar g; \n\n!!a; // true \n\n!!b; // true \n\n!!c; // true \n\n!!d; // false \n\n!!e; // false \n\n!!f; // false \n\n!!g; // false \n\nAny of these ToBoolean coercions would happen implicitly without","metadata":{"loc":{"lines":{"from":67553,"to":67597}}}}],["819",{"pageContent":"!!a; // true \n\n!!b; // true \n\n!!c; // true \n\n!!d; // false \n\n!!e; // false \n\n!!f; // false \n\n!!g; // false \n\nAny of these ToBoolean coercions would happen implicitly without \n\nthe Boolean(..) or !!, if used in a boolean context such as an if \n(..) .. statement. But the goal here is to explicitly force the value \nto a boolean to make it clearer that the ToBoolean coercion is \nintended. \n\nAnother example use case for explicit ToBoolean coercion is if you \nwant to force a true/false value coercion in the JSON serialization \nof a data structure: \n\nvar a = [ \n\n1 , \n\nfunction(){ /*..*/ }, \n\n2 , \n\nfunction(){ /*. .*/ } \n\n1 ; \n\n\nJSON.stringifyC a ); // \"[1,null,2,null]\" \n\nJSON.strlngifyC a, function(key,val){ \n\nif (typeof val == \"function\") { \n\n// force 'ToBoolean' coercion of the function \nreturn !!val; \n\n} \n\nelse { \n\nreturn val; \n\n} \n\n} ); \n\n// \"[1,true,2,true]\" \n\n\n84 | Chapter 4: Coercion \n\n\n\n\n\nIf you come to JavaScript from Java, you may recognize this idiom: \nvar a = 42;","metadata":{"loc":{"lines":{"from":67597,"to":67664}}}}],["820",{"pageContent":"} \n\nelse { \n\nreturn val; \n\n} \n\n} ); \n\n// \"[1,true,2,true]\" \n\n\n84 | Chapter 4: Coercion \n\n\n\n\n\nIf you come to JavaScript from Java, you may recognize this idiom: \nvar a = 42; \n\nvar b = a ? true : false; \n\nThe ? : ternary operator will test a for truthiness, and based on that \ntest will either assign true or false to b, accordingly. \n\nOn its surface, this idiom looks like a form of explicit ToBoolean- \ntype coercion, since it’s obvious that only either true or false come \nout of the operation. \n\nHowever, there’s a hidden implicit coercion, in that the a expression \nhas to first be coerced to boolean to perform the truthiness test. I’d \ncall this idiom “explicitly implicit.” Furthermore, I’d suggest you \nshould avoid this idiom completely in JavaScript. It offers no real \nbenefit, and worse, masquerades as something it’s not. \n\nBoolean(a) and !! a are far better as explicit coercion options. \n\nImplicit Coercion","metadata":{"loc":{"lines":{"from":67664,"to":67703}}}}],["821",{"pageContent":"Boolean(a) and !! a are far better as explicit coercion options. \n\nImplicit Coercion \n\nImplicit coercion refers to type conversions that are hidden, with \nnonobvious side effects that implicitly occur from other actions. In \nother words, implicit coercions are any type conversions that aren’t \nobvious (to you). \n\nWhile it’s clear what the goal of explicit coercion is (making code \nexplicit and more understandable), it might be too obvious that \nimplicit coercion has the opposite goal: making code harder to \nunderstand. \n\nTaken at face value, I believe that’s where much of the ire towards \ncoercion comes from. The majority of complaints about “JavaScript \ncoercion” are actually aimed (whether they realize it or not) at \nimplicit coercion. \n\n\nImplicit Coercion | 85","metadata":{"loc":{"lines":{"from":67703,"to":67723}}}}],["822",{"pageContent":"Implicit Coercion | 85 \n\n\n\n\nDouglas Crockford, author of JavaScript: The \nGood Parts , has claimed in many conference \ntalks and writings that JavaScript coercion \nshould be avoided. But what he seems to mean is \nthat implicit coercion is bad (in his opinion). \nHowever, if you read his own code, you’ll find \nplenty of examples of coercion, both implicit and \nexplicit ! In truth, his angst seems to primarily be \ndirected at the == operation, but as you’ll see in \nthis chapter, that’s only part of the coercion \nmechanism. \n\n\nSo, is implicit coercion evil? Is it dangerous? Is it a flaw in JavaS¬ \ncript’s design? Should we avoid it at all costs? \n\nI bet most of you readers are inclined to enthusiastically cheer, \n“Yes!” \n\nNot so fast. Hear me out. \n\nLet’s take a different perspective on what implicit coercion is, and \ncan be, than just that it’s “the opposite of the good explicit kind of \ncoercion.” That’s far too narrow and misses an important nuance.","metadata":{"loc":{"lines":{"from":67723,"to":67751}}}}],["823",{"pageContent":"Let’s define the goal of implicit coercion as to reduce verbosity, boil¬ \nerplate, and/or unnecessary implementation detail that clutters up \nour code with noise that distracts from the more important intent. \n\nSimplifying Implicitly \n\nBefore we even get to JavaScript, let me suggest something pseudo- \ncode’ish from some theoretical strongly typed language to illustrate: \n\nSomeType x = SomeType( AnotherType( y ) ) \n\nIn this example, I have some arbitrary type of value in y that I want \nto convert to the SomeType type. The problem is, this language can’t \ngo directly from whatever y currently is to SomeType. It needs an \nintermediate step, where it first converts to AnotherType, and then \nfrom AnotherType to SomeType. \n\nNow, what if that language (or definition you could create yourself \nwith the language) did just let you say: \n\nSomeType x = SomeType( y ) \n\n\n86 | Chapter 4: Coerdon","metadata":{"loc":{"lines":{"from":67753,"to":67776}}}}],["824",{"pageContent":"Now, what if that language (or definition you could create yourself \nwith the language) did just let you say: \n\nSomeType x = SomeType( y ) \n\n\n86 | Chapter 4: Coerdon \n\n\n\n\n\nWouldn’t you generally agree that we simplified the type conversion \nhere to reduce the unnecessary “noise” of the intermediate conver¬ \nsion step? I mean, is it really all that important, right here at this \npoint in the code, to see and deal with the fact that y goes to Another \nType first before then going to SomeType? \n\nSome would argue, at least in some circumstances, yes. But I think \nan equal argument can be made of many other circumstances that \nhere, the simplification actually aids in the readability of the code by \nabstracting or hiding away such details, either in the language itself \nor in our own abstractions.","metadata":{"loc":{"lines":{"from":67776,"to":67798}}}}],["825",{"pageContent":"Undoubtedly, behind the scenes, somewhere, the intermediate con¬ \nversion step is still happening. But if that detail is hidden from view \nhere, we can just reason about getting y to type SomeType as an \ngeneric operation and hide the messy details. \n\nWhile not a perfect analogy, what I’m going to argue throughout the \nrest of this chapter is that JS implicit coercion can be thought of as \nproviding a similar aid to your code. \n\nBut, and this is very important, that is not an unbounded, absolute \nstatement. There are definitely plenty of evils lurking around implicit \ncoercion that will harm your code much more than any potential \nreadability improvements. Clearly, we have to learn how to avoid \nsuch constructs so we don’t poison our code with all manner of \nbugs. \n\nMany developers believe that if a mechanism can do some useful \nthing A but can also be abused or misused to do some awful thing Z, \nthen we should throw out that mechanism altogether, just to be safe.","metadata":{"loc":{"lines":{"from":67800,"to":67818}}}}],["826",{"pageContent":"My encouragement to you is: don’t settle for that. Don’t “throw the \nbaby out with the bathwater.” Don’t assume implicit coercion is all \nbad because all you think you’ve ever seen is its “bad parts.” I think \nthere are “good parts” here, and I want to help and inspire more of \nyou to find and embrace them! \n\nImplicitly: Strings <--> Numbers \n\nEarlier in this chapter, we explored explicitly coercing between \nstring and number values. Now, let’s explore the same task but with \nimplicit coercion approaches. But before we do, we have to examine \nsome nuances of operations that will implicitly force coercion. \n\n\nImplicit Coercion | 87 \n\n\n\nThe + operator is overloaded to serve the purposes of both number \naddition and string concatenation. So how does JS know which \ntype of operation you want to use? Consider: \n\nvar a = \"42\"; \nvar b = \"0\"; \n\nvar c = 42; \nvar d = 0; \n\na + b; // \"420\" \nc + d; // 42","metadata":{"loc":{"lines":{"from":67820,"to":67849}}}}],["827",{"pageContent":"var a = \"42\"; \nvar b = \"0\"; \n\nvar c = 42; \nvar d = 0; \n\na + b; // \"420\" \nc + d; // 42 \n\nWhat’s different that causes \"420\" versus 42? It’s a common miscon¬ \nception that the difference is whether one or both of the operands is \na string, as that means + will assume string concatenation. While \nthat’s partially true, it’s more complicated than that. \n\nConsider: \n\nvar a = [1,2]; \nvar b = [3,4]; \n\na + b; // \"1,23,4\" \n\nNeither of these operands is a string, but clearly they were both \ncoerced to strings and then the string concatenation kicked in. So \nwhat’s really going on? \n\n\n\nDeeply nitty gritty spec-speak coming, so skip \nthe next two paragraphs if that intimidates you!","metadata":{"loc":{"lines":{"from":67849,"to":67877}}}}],["828",{"pageContent":"Deeply nitty gritty spec-speak coming, so skip \nthe next two paragraphs if that intimidates you! \n\n\nAccording to the ES5 spec, section 11.6.1, the + algorithm (when an \nobject value is an operand) will concatenate if either operand is \neither already a string, or if the following steps produce a string \nrepresentation. So, when + receives an object (including array) for \neither operand, it first calls the ToPrimitive abstract operation (sec¬ \ntion 9.1) on the value, which then calls the [ [DefaultValue]] algo¬ \nrithm (section 8.12.8) with a context hint of number. \n\nIf you’re paying close attention, you’ll notice that this operation is \nnow identical to how the ToNumber abstract operation handles \nobjects (see “ToNumber” on page 65). The valueOfQ operation on \n\n\n88 | Chapter 4: Coercion","metadata":{"loc":{"lines":{"from":67877,"to":67894}}}}],["829",{"pageContent":"88 | Chapter 4: Coercion \n\n\n\n\nthe array will fail to produce a simple primitive, so it then falls to a \ntoStringQ representation. The two arrays thus become \"1,2\" and \n\"3,4\", respectively. Now, + concatenates the two strings as youd \nnormally expect: \"1,23,4\". \n\nLet’s set aside those messy details and go back to an earlier, simpli¬ \nfied explanation: if either operand to + is a string (or become one \nwith the above steps!), the operation will be string concatenation. \nOtherwise, it’s always numeric addition. \n\n\n\nA commonly cited coercion gotcha is [] + {} \nversus {} + [], as those two expressions result, \nrespectively, in \"[object Object]\" and 0. \nThere’s more to it, though, and we cover those \ndetails in “Blocks” on page 134. \n\n\nWhat’s that mean for implicit coercion? \n\nYou can coerce a number to a string simply by “adding” the number \nand the \"\" empty string: \n\nvar a = 42; \nvar b = a + 11 \n\nb; // \"42\"","metadata":{"loc":{"lines":{"from":67894,"to":67926}}}}],["830",{"pageContent":"What’s that mean for implicit coercion? \n\nYou can coerce a number to a string simply by “adding” the number \nand the \"\" empty string: \n\nvar a = 42; \nvar b = a + 11 \n\nb; // \"42\" \n\n\nNumeric addition with the + operator is com¬ \nmutative, which means 2 + 3 is the same as 3 \n+ 2. String concatenation with + is obviously not \ngenerally commutative, but with the specific \ncase of \"\", it’s effectively commutative, as a + \"\" \nand \" \" + a will produce the same result. \n\nIt’s extremely common/idiomatic to ( implicitly ) coerce number to \nstring with a + \"\" operation. In fact, interestingly, even some of the \nmost vocal crticics of implicit coercion still use that approach in \ntheir own code, instead of one of its explicit alternatives. \n\nI think this is a great example of a useful form in implicit coercion, \ndespite how frequently the mechanism gets criticized!","metadata":{"loc":{"lines":{"from":67926,"to":67950}}}}],["831",{"pageContent":"I think this is a great example of a useful form in implicit coercion, \ndespite how frequently the mechanism gets criticized! \n\nComparing this implicit coercion of a + \"\" to our earlier example of \nString(a) explicit coercion, there’s one additional quirk to be aware \nof. Because of how the ToPrimitive abstract operation works, \n\n\n\nImplicit Coercion | 89 \n\n\n\n\n\na + \"\" invokes valueOf() on the a value, whose return value is \nthen finally converted toastring via the internal ToString abstract \noperation. But String(a) just invokes toStringQ directly. \n\nBoth approaches ultimately result in a string, but if you’re using an \nobject instead of a regular primitive number value, you may not \nnecessarily get the same string value! \n\nConsider: \nvar a = { \n\nvalueOf: function() { return 42; }, \ntoString: function() { return 4; } \n\n}; \n\n\na + // \"42\" \n\nString( a ); // \"4\"","metadata":{"loc":{"lines":{"from":67950,"to":67984}}}}],["832",{"pageContent":"Consider: \nvar a = { \n\nvalueOf: function() { return 42; }, \ntoString: function() { return 4; } \n\n}; \n\n\na + // \"42\" \n\nString( a ); // \"4\" \n\nGenerally, this sort of gotcha won’t bite you unless you’re really try¬ \ning to create confusing data structures and operations, but you \nshould be careful if you’re defining both your own valueOfQ and \ntoStringO methods for some object, as how you coerce the value \ncould affect the outcome. \n\nWhat about the other direction? How can we implicitly coerce from \nstring to number? \n\nvar a = \"3.14\"; \nvar b = a - 0; \n\nb; // 3.14 \n\nThe - operator is defined only for numeric subtraction, so a - 0 \nforces as value to be coerced to a number. While far less common, a \n* 1 or a / 1 would accomplish the same result, as those operators \nare also only defined for numeric operations. \n\nWhat about object values with the - operator? Similar story as for + \nabove: \n\nvar a = [3]; \nvar b = [1]; \n\na - b; // 2","metadata":{"loc":{"lines":{"from":67984,"to":68022}}}}],["833",{"pageContent":"What about object values with the - operator? Similar story as for + \nabove: \n\nvar a = [3]; \nvar b = [1]; \n\na - b; // 2 \n\nBoth array values have to become numbers, but they end up first \nbeing coerced to strings (using the expected toStringO serializa- \n\n\n90 | Chapter 4: Coercion \n\n\n\ntion), and then are coerced to numbers, for the - subtraction to per¬ \nform on. \n\nSo, is implicit coercion of string and number values the ugly evil \nyou’ve always heard horror stories about? I don’t personally think so. \n\nCompare b = String(a) ( explicit ) to b = a + \"\" (implicit). I think \ncases can be made for both approaches being useful in your code. \nCertainly b = a + \"\" is quite a bit more common in JS programs, \nproving its own utility regardless of feelings about the merits or haz¬ \nards of implicit coercion in general. \n\nImplicitly: Booleans --> Numbers","metadata":{"loc":{"lines":{"from":68022,"to":68050}}}}],["834",{"pageContent":"Implicitly: Booleans --> Numbers \n\nI think a case where implicit coercion can really shine is in simplify¬ \ning certain types of complicated boolean logic into simple numeric \naddition. Of course, this is not a general-purpose technique, but a \nspecific solution for specific cases. \n\nConsider: \n\nfunction ontyOne(a,b,c) { \n\nreturn !!((a && !b && !c) || \n\n(!a && b && !c) || (!a && !b && c)); \n\n} \n\nvar a = true; \nvar b = false; \n\nonlyOne( a, b, b ); // true \n\nonlyOne( b, a, b ); // true \n\nonlyOne( a, b, a ); // false \n\nThis onlyOne(..) utility should only return true if exactly one of \n\nthe arguments is true / truthy. It’s using implicit coercion on the tru- \nthy checks and explicit coercion on the others, including the final \nreturn value. \n\nBut what if we needed that utility to be able to handle four, five, or \ntwenty flags in the same way? It’s pretty difficult to imagine imple¬ \nmenting code that would handle all those permutations of compari¬ \nsons.","metadata":{"loc":{"lines":{"from":68050,"to":68085}}}}],["835",{"pageContent":"But here’s where coercing the boolean values to numbers (0 or 1, \nobviously) can greatly help: \n\n\nImplicit Coercion | 91 \n\n\n\n\nfunction onlyOneQ { \nvar sun = 0; \n\nfor (var i=0; 1 < arguments.length; i++) { \n// skip falsy values, sane as treating \n// then as 0's, but avoids NaN's. \nif (arguments[i]) { \n\nsun += arguments[i]; \n\n} \n\n} \n\nreturn sun == 1; \n\n} \n\nvar a = true; \nvar b = false; \n\nonlyOne( b, a ); // true \n\nonlyOne( b, a, b, b, b ); // true \n\nonlyOne( b, b ); // false \n\nonlyOne( b, a, b, b, b, a ); // false \n\n\n\nOf course, instead of the for loop in \nonlyOne(..), you could more tersely use the \nES5 reduce(..) utility, but I didn’t want to \nobscure the concepts.","metadata":{"loc":{"lines":{"from":68087,"to":68130}}}}],["836",{"pageContent":"onlyOne( b, a, b, b, b, a ); // false \n\n\n\nOf course, instead of the for loop in \nonlyOne(..), you could more tersely use the \nES5 reduce(..) utility, but I didn’t want to \nobscure the concepts. \n\n\nWhat we’re doing here is relying on the 1 for true/truthy coercions, \nand numerically adding them all up. sum += arguments[i] uses \nimplicit coercion to make that happen. If one and only one value in \nthe arguments list is true, then the numeric sum will be 1, otherwise \nthe sum will not be 1 and thus the desired condition is not met. \n\nWe could of course do this with explicit coercion instead: \n\nfunction onlyOneQ { \nvar sun = 0; \n\nfor (var 1=0; l < arguments.length; i++) { \nsun += Nunber( !!argunents[l] ); \n\n} \n\nreturn sun === 1; \n\n}","metadata":{"loc":{"lines":{"from":68130,"to":68158}}}}],["837",{"pageContent":"function onlyOneQ { \nvar sun = 0; \n\nfor (var 1=0; l < arguments.length; i++) { \nsun += Nunber( !!argunents[l] ); \n\n} \n\nreturn sun === 1; \n\n} \n\nWe first use !! arguments[i] to force the coercion of the value to \ntrue or false. That’s so you could pass non-boolean values in, like \nonlyOne( \"42\", 0 ), and it would still work as expected (otherwise \nyou’d end up with string concatenation and the logic would be \nincorrect). \n\n\n92 | Chapter 4: Coerdon \n\n\n\n\n\nOnce we’re sure it’s a boolean, we do another explicit coercion with \nNumber(..) to make sure the value is 0 or 1. \n\nIs the explicit coercion form of this utility “better”? It does avoid the \nNaN trap as explained in the code comments. But, ultimately, it \ndepends on your needs. I personally think the former version, rely¬ \ning on implicit coercion, is more elegant (if you won’t be passing \nundefined or NaN), and the explicit version is needlessly more ver¬ \nbose.","metadata":{"loc":{"lines":{"from":68158,"to":68191}}}}],["838",{"pageContent":"But as with almost everything we’re discussing here, it’s a judgment \ncall. \n\n\n\nRegardless of implicit or explicit approaches, you \ncould easily make onlyTwo(..) or only \nFive(..) variations by simply changing the \nfinal comparison from 1, to 2 or 5, respectively. \nThat’s drastically easier than adding a bunch of \n&& and | | expressions. So, generally, coercion is \nvery helpful in this case. \n\n\nImplicitly: *--> Boolean \n\nNow, let’s turn our attention to implicit coercion to boolean values, \nas it’s by far the most common and also by far the most potentially \ntroublesome. \n\nRemember, implicit coercion is what kicks in when you use a value \nin such a way that it forces the value to be converted. For numeric \nand string operations, it’s fairly easy to see how the coercions can \noccur. \n\nBut, what sort of expression operations require/force ( implicitly ) a \nboolean coercion? \n\n1. The test expression in an if (..) statement \n\n2. The test expression (second clause) in a for \nheader","metadata":{"loc":{"lines":{"from":68193,"to":68224}}}}],["839",{"pageContent":"But, what sort of expression operations require/force ( implicitly ) a \nboolean coercion? \n\n1. The test expression in an if (..) statement \n\n2. The test expression (second clause) in a for \nheader \n\n3. The test expression in while (..) and do.. while(. .) loops \n\n4. The test expression (first clause) in ? : ternary expressions \n\n\nImplidt Coercion | 93 \n\n\n\n\n\n5. The lefthand operand (which serves as a test expression—see \nbelow!) to the | | (“logical or”) and && (“logical and”) operators \n\nAny value used in these contexts that is not already a boolean will be \nimplicitly coerced to a boolean using the rules of the ToBoolean \nabstract operation covered earlier in this chapter. \n\nLet’s look at some examples: \n\nvar a = 42; \nvar b = \"abc\"; \nvar c; \n\nvar d = null; \n\nIf (a) { \n\nconsole.log( \"yep\" ); // yep \n\n} \n\nwhile (c) { \n\nconsole.log( \"nope, never runs\" ); \n\n} \n\nc = d ? a : b; \n\nc; // \"abc\" \n\nif ((a && d) || c) { \n\nconsole.log( \"yep\" ); // yep \n\n}","metadata":{"loc":{"lines":{"from":68224,"to":68278}}}}],["840",{"pageContent":"If (a) { \n\nconsole.log( \"yep\" ); // yep \n\n} \n\nwhile (c) { \n\nconsole.log( \"nope, never runs\" ); \n\n} \n\nc = d ? a : b; \n\nc; // \"abc\" \n\nif ((a && d) || c) { \n\nconsole.log( \"yep\" ); // yep \n\n} \n\nIn all these contexts, the non-boolean values are implicitly coerced to \ntheir boolean equivalents to make the test decisions. \n\nOperators || and && \n\nIt’s quite likely that you have seen the | | (“logical or”) and && (“logi¬ \ncal and”) operators in most or all other languages you’ve used. So it’d \nbe natural to assume that they work basically the same in JavaScript \nas in other similar languages. \n\nThere’s some very little known, but very important, nuance here. \n\nIn fact, I would argue these operators shouldn’t even be called “logi¬ \ncal _operators,” as that name is incomplete in describing what \n\nthey do. If I were to give them a more accurate (if more clumsy) \nname, I’d call them “selector operators,” or more completely, \n“operand selector operators.” \n\n\n94 | Chapter 4: Coercion","metadata":{"loc":{"lines":{"from":68278,"to":68320}}}}],["841",{"pageContent":"they do. If I were to give them a more accurate (if more clumsy) \nname, I’d call them “selector operators,” or more completely, \n“operand selector operators.” \n\n\n94 | Chapter 4: Coercion \n\n\n\n\nWhy? Because they don’t actually result in a logic value (aka \nboolean) in JavaScript, as they do in some other languages. \n\nSo what do they result in? They result in the value of one (and only \none) of their two operands. In other words, they select one of the \ntwo operand’s values. \n\nQuoting the ES5 spec from section 11.11: \n\nThe value produced by a && or 11 operator is not necessarily of type \nBoolean. The value produced will always be the value of one of the \ntwo operand expressions. \n\nLet’s illustrate: \n\nvar a = 42; \nvar b = \"abc\"; \nvar c = null; \n\na || b; // 42 \n\na && b; // \"abc” \n\nc || b; // \"abc” \n\nc && b; // null","metadata":{"loc":{"lines":{"from":68320,"to":68355}}}}],["842",{"pageContent":"Let’s illustrate: \n\nvar a = 42; \nvar b = \"abc\"; \nvar c = null; \n\na || b; // 42 \n\na && b; // \"abc” \n\nc || b; // \"abc” \n\nc && b; // null \n\nWait, what!? Think about that. In languages like C and PHP, those \nexpressions result in true or false, but in JS (and Python and Ruby, \nfor that matter!), the result comes from the values themselves. \n\nBoth | | and && operators perform a boolean test on the first \noperand (a or c). If the operand is not already boolean (as it’s not, \nhere), a normal ToBoolean coercion occurs, so that the test can be \nperformed. \n\nFor the | | operator, if the test is true, the | | expression results in \nthe value of the first operand (a or c). If the test is false, the 11 \nexpression results in the value of the second operand (b). \n\nInversely, for the && operator, if the test is true, the && expression \nresults in the value of the second operand (b). If the test is false, the \n&& expression results in the value of the first operand (a or c).","metadata":{"loc":{"lines":{"from":68355,"to":68384}}}}],["843",{"pageContent":"The result of a | | or && expression is always the underlying value of \none of the operands, not the (possibly coerced) result of the test. In c \n&& b, c is null, and thus falsy. But the && expression itself results in \nnull (the value in c), not in the coerced false used in the test. \n\nDo you see how these operators act as “operand selectors,” now? \n\n\nImplidt Coercion | 95 \n\n\n\nAnother way of thinking about these operators: \na || b; \n\n// roughly equivalent to: \na ? a : b; \n\na && b; \n\n// roughly equivalent to: \na ? b : a;","metadata":{"loc":{"lines":{"from":68386,"to":68407}}}}],["844",{"pageContent":"Implidt Coercion | 95 \n\n\n\nAnother way of thinking about these operators: \na || b; \n\n// roughly equivalent to: \na ? a : b; \n\na && b; \n\n// roughly equivalent to: \na ? b : a; \n\n\n\nI call a | | b “roughly equivalent” to a ? a : b \nbecause the outcome is identical, but there’s a \nnuanced difference. In a ? a : b, if a was a \nmore complex expression (like for instance one \nthat might have side effects like calling a func \ntion, etc.), then the a expression would possibly \nbe evaluated twice (if the first evaluation was \ntruthy). By contrast, for a | | b, the a expression \nis evaluated only once, and that value is used \nboth for the coercive test as well as the result \nvalue (if appropriate). The same nuance applies \nto the a && b and a ? b : a expressions. \n\n\nAn extremely common and helpful usage of this behavior, which \nthere’s a good chance you may have used before and not fully under¬ \nstood, is: \n\nfunction foo(a,b) { \na = a || \"hello\"; \nb = b || \"world\"; \n\nconsole.log( a + \" \" + b );","metadata":{"loc":{"lines":{"from":68407,"to":68446}}}}],["845",{"pageContent":"function foo(a,b) { \na = a || \"hello\"; \nb = b || \"world\"; \n\nconsole.log( a + \" \" + b ); \n\n1 \n\nfoo(); // \"hello world\" \n\nfoo( \"yeah\", \"yeah!\" ); // \"yeah yeah!\" \n\nThe a = a | | \"hello\" idiom (sometimes said to be JavaScript’s \nversion of the C# “null coallescing operator”) acts to test a and if it \nhas no value (or only an undesired falsy value), provides a backup \ndefault value (\"hello\"). \n\nBe careful, though! \n\nfoo( \"That's it!\", \"\" ); // \"That's it! world\" <-- Oops! \n\nSee the problem? \"\" as the second argument is a falsy value (see \n“ToBoolean” on page 67), so the b = b | | \"world\" test fails, and \n\n\n96 | Chapter 4: Coerdon \n\n\n\n\nthe \"world\" default value is substituted, even though the intent \nprobably was to have the explicitly passed \"\" be the value assigned \nto b.","metadata":{"loc":{"lines":{"from":68446,"to":68478}}}}],["846",{"pageContent":"96 | Chapter 4: Coerdon \n\n\n\n\nthe \"world\" default value is substituted, even though the intent \nprobably was to have the explicitly passed \"\" be the value assigned \nto b. \n\nThis 11 idiom is extremely common, and quite helpful, but you have \nto use it only in cases where all falsy values should be skipped. \nOtherwise, you’ll need to be more explicit in your test, and probably \nuse a ? : ternary instead. \n\nThis default value assignment idiom is so common (and useful!) that \neven those who publicly and vehemently decry JavaScript coercion \noften use it in their own code! \n\nWhat about &&? \n\nThere’s another idiom that is quite a bit less commonly authored \nmanually, but which is used by JS minifiers frequently. The && oper¬ \nator “selects” the second operand if and only if the first operand tests \nas truthy, and this usage is sometimes called the “guard operator” \n(see also “Short Circuited” on page 140 in Chapter 5)--the first \nexpression test “guards” the second expression:","metadata":{"loc":{"lines":{"from":68478,"to":68503}}}}],["847",{"pageContent":"function foo() { \n\nconsole.log( a ); \n\n} \n\nvar a = 42; \na && foo(); // 42 \n\nfoo( ) gets called only because a tests as truthy. If that test failed, this \na && foo() expression statement would just silently stop (some¬ \ntimes called “short circuiting”) and never call foo( ). \n\nAgain, it’s not nearly as common for people to author such things. \nUsually, they’d do If (a) { foo(); } instead. But JS minifiers \nchoose a && foo( ) because it’s much shorter. So, if you ever have to \ndecipher such code, you’ll know what it’s doing and why. \n\nOK, so | | and && have some neat tricks up their sleeve, as long as \nyou’re willing to allow the implicit coercion into the mix. \n\n\n\nBoth the a = b || \"something\" and a && b() \nidioms rely on short circuiting behavior, which \nwe cover in more detail in “Short Circuited” on \npage 140 in Chapter 5. \n\n\nImplicit Coercion | 97","metadata":{"loc":{"lines":{"from":68505,"to":68534}}}}],["848",{"pageContent":"Both the a = b || \"something\" and a && b() \nidioms rely on short circuiting behavior, which \nwe cover in more detail in “Short Circuited” on \npage 140 in Chapter 5. \n\n\nImplicit Coercion | 97 \n\n\n\n\nThe fact that these operators don’t actually result in true and false \nis possibly messing with your head a little bit by now. You’re proba¬ \nbly wondering how all your if statements and for loops have been \nworking, if they’ve included compound logical expressions like a && \n(b || c). \n\nDon’t worry! The sky is not falling. Your code is (probably) just fine. \nIt’s just that you probably never realized before that there was an \nimplicit coercion to boolean going on after the compound expres¬ \nsion was evaluated. \n\nConsider: \n\nvar a = 42; \nvar b = null; \nvar c = \"foo\"; \n\nif (a && (b || c)) { \n\nconsole.log( \"yep\" ); \n\n}","metadata":{"loc":{"lines":{"from":68534,"to":68566}}}}],["849",{"pageContent":"Consider: \n\nvar a = 42; \nvar b = null; \nvar c = \"foo\"; \n\nif (a && (b || c)) { \n\nconsole.log( \"yep\" ); \n\n} \n\nThis code still works the way you always thought it did, except for \none subtle extra detail. The a && (b | | c) expression actually \nresults in \"foo\", not true. So, the if statement then forces the \"foo\" \nvalue to coerce to a boolean, which of course will be true. \n\nSee? No reason to panic. Your code is probably still safe. But now \nyou know more about how it does what it does. \n\nAnd now you also realize that such code is using implicit coercion. If \nyou’re in the “avoid (implicit) coercion camp” still, you’re going to \nneed to go back and make all of those tests explicit: \n\nif (!!a && (!!b I I ! !c)) { \nconsole.log( \"yep\" ); \n\n} \n\nGood luck with that! ... Sorry, just teasing. \n\nSymbol Coercion \n\nUp to this point, there’s been almost no observable outcome differ¬ \nence between explicit and implicit coercion—only the readability of \ncode has been at stake.","metadata":{"loc":{"lines":{"from":68566,"to":68601}}}}],["850",{"pageContent":"Symbol Coercion \n\nUp to this point, there’s been almost no observable outcome differ¬ \nence between explicit and implicit coercion—only the readability of \ncode has been at stake. \n\nBut ES6 Symbols introduce a gotcha into the coercion system that \nwe need to discuss briefly. For reasons that go well beyond the scope \nof what we’ll discuss in this book, explicit coercion of a symbol to a \n\n\n98 | Chapter 4: Coercion \n\n\n\nstring is allowed, but implicit coercion of the same is disallowed \nand throws an error. \n\nConsider: \n\nvar si = Symbol( \"cool\" ); \n\nString( si ); // \"Symbol(cool)\" \n\nvar s2 = Symbol( \"not cool\" ); \ns2 + // TypeError \n\nsymbol values cannot coerce to number at all (throws an error either \nway), but strangely they can both explicitly and implicitly coerce to \nboolean (always true). \n\nConsistency is always easier to learn, and exceptions are never fun \nto deal with, but we just need to be careful around the new ES6 sym \nbol values and how we coerce them.","metadata":{"loc":{"lines":{"from":68601,"to":68634}}}}],["851",{"pageContent":"Consistency is always easier to learn, and exceptions are never fun \nto deal with, but we just need to be careful around the new ES6 sym \nbol values and how we coerce them. \n\nThe good news: it’s probably going to be exceedingly rare for you to \nneed to coerce a symbol value. The way they’re typically used (see \nChapter 3) will probably not call for coercion on a normal basis. \n\nLoose Equals Versus Strict Equals \n\nLoose equals is the == operator, and strict equals is the === operator. \nBoth operators are used for comparing two values for “equality,” but \nthe “loose” versus “strict” indicates a very important difference in \nbehavior between the two, specifically in how they decide “equality.”","metadata":{"loc":{"lines":{"from":68634,"to":68647}}}}],["852",{"pageContent":"A very common misconception about these two operators is: \"== \nchecks values for equality and === checks both values and types for \nequality.” While that sounds nice and reasonable, it’s inaccurate. \nCountless well-respected JavaScript books and blogs have said \nexactly that, but unfortunately they’re all wrong. \n\nThe correct description is: \"== allows coercion in the equality com¬ \nparison and === disallows coercion.” \n\nEquality Performance \n\nStop and think about the difference between the first (inaccurate) \nexplanation and this second (accurate) one. \n\nIn the first explanation, it seems obvious that === is doing more work \nthan ==, because it has to also check the type. In the second explana- \n\n\nLoose Equals Versus Strict Equals | 99 \n\n\n\ntion, == is the one doing more work because it has to follow through \nthe steps of coercion if the types are different.","metadata":{"loc":{"lines":{"from":68649,"to":68672}}}}],["853",{"pageContent":"Loose Equals Versus Strict Equals | 99 \n\n\n\ntion, == is the one doing more work because it has to follow through \nthe steps of coercion if the types are different. \n\nDon’t fall into the trap, as many have, of thinking this has anything \nto do with performance, though, as if == is going to be slower than \n=== in any relevant way. While it’s measurable that coercion does \ntake a little bit of processing time, it’s mere microseconds (yes, that’s \nmillionths of a second!). \n\nIf you’re comparing two values of the same types, == and === use the \nidentical algorithm, and so other than minor differences in engine \nimplementation, they should do the same work. \n\nIf you’re comparing two values of different types, the performance \nisn’t the important factor. What you should be asking yourself is, \nwhen comparing these two values, do I want coercion or not? \n\nIf you want coercion, use == loose equality, but if you don’t want \ncoercion, use === strict equality.","metadata":{"loc":{"lines":{"from":68672,"to":68694}}}}],["854",{"pageContent":"If you want coercion, use == loose equality, but if you don’t want \ncoercion, use === strict equality. \n\n\n\nThe implication here then is that both == and \n=== check the types of their operands. The dif¬ \nference is in how they respond if the types don’t \nmatch. \n\n\nAbstract Equality \n\nThe == operator’s behavior is defined as “The Abstract Equality \nComparison Algorithm” in section 11.9.3 of the ES5 spec. What’s lis¬ \nted there is a comprehensive but simple algorithm that explicitly \nstates every possible combination of types, and how the coercions (if \nnecessary) should happen for each combination. \n\n\n100 | Chapter 4: Coercion","metadata":{"loc":{"lines":{"from":68694,"to":68714}}}}],["855",{"pageContent":"100 | Chapter 4: Coercion \n\n\n\n\n\nWhen ( implicit ) coercion is maligned as being \ntoo complicated and too flawed to be a useful \ngood part, it is these rules of “abstract equality” \nthat are being condemned. Generally, they are \nsaid to be too complex and too unintuitive for \ndevelopers to practically learn and use, and that \nthey are prone more to causing bugs in JS pro¬ \ngrams than to enabling greater code readability. \nI believe this is a flawed premise—that you read¬ \ners are competent developers who write (and \nread and understand!) algorithms (aka code) all \nday long. So, what follows is a plain exposition \nof the “abstract equality” in simple terms. But I \nimplore you to also read section 11.9.3 of the \nES5 spec. I think you’ll be surprised at just how \nreasonable it is.","metadata":{"loc":{"lines":{"from":68714,"to":68735}}}}],["856",{"pageContent":"Basically, the first clause (11.9.3.1) says that if the two values being \ncompared are of the same type, they are simply and naturally com¬ \npared via Identity as youd expect. For example, 42 is only equal to \n42, and \"abc\" is only equal to \"abc\". \n\nSome minor exceptions to normal expectation to be aware of: \n\n• NaN is never equal to itself (see Chapter 2). \n\n• +0 and -0 are equal to each other (see Chapter 2). \n\nThe final provision in clause 11.9.3.1 is for == loose equality com¬ \nparison with objects (including functions and arrays). Two such \nvalues are only equal if they are both references to the exact same \nvalue. No coercion occurs here. \n\n\n\nThe === strict equality comparison is defined \nidentically to 11.9.3.1, including the provision \nabout two object values. It’s a very little known \nfact that == and === behave identically in the \ncase where two objects are being compared!","metadata":{"loc":{"lines":{"from":68738,"to":68760}}}}],["857",{"pageContent":"The rest of the algorithm in 11.9.3 specifies that if you use == loose \nequality to compare two values of different types, one or both of the \nvalues will need to be implicitly coerced. This coercion happens so \nthat both values eventually end up as the same type, which can then \ndirectly be compared for equality using simple value Identity. \n\n\nLoose Equals Versus Strict Equals | 101 \n\n\n\n\n\n\nThe != loose not-equality operation is defined \nexactly as youd expect, in that it’s literally the == \noperation comparison performed in its entirety, \nthen the negation of the result. The same goes \nfor the ! == strict not-equality operation. \n\n\nComparing: strings to numbers \n\nTo illustrate == coercion, let’s first build off the string and number \nexamples earlier in this chapter: \n\nvar a = 42; \nvar b = \"42\"; \n\na === b; // false \na == b; // true \n\nAs we’d expect, a === b fails, because no coercion is allowed, and \nindeed the 42 and \"42\" values are different.","metadata":{"loc":{"lines":{"from":68763,"to":68796}}}}],["858",{"pageContent":"var a = 42; \nvar b = \"42\"; \n\na === b; // false \na == b; // true \n\nAs we’d expect, a === b fails, because no coercion is allowed, and \nindeed the 42 and \"42\" values are different. \n\nHowever, the second comparison a == b uses loose equality, which \nmeans that if the types happen to be different, the comparison algo¬ \nrithm will perform implicit coercion on one or both values. \n\nBut exactly what kind of coercion happens here? Does the a value of \n42 become a string, or does the b value of \"42\" become a number? \n\nIn the ES5 spec, clauses 11.9.3.4-5 say: \n\n1. If Type(x) is Number and Type(y) is String, return the result of \nthe comparison x == ToNumber(y). \n\n2. If Type(x) is String and Type(y) is Number, return the result of \nthe comparison ToNumber(x) == y.","metadata":{"loc":{"lines":{"from":68796,"to":68818}}}}],["859",{"pageContent":"2. If Type(x) is String and Type(y) is Number, return the result of \nthe comparison ToNumber(x) == y. \n\n\n\nThe spec uses Number and String as the formal \nnames for the types, while this book prefers num \nber and string for the primitive types. Do not \nlet the capitalization of Number in the spec con¬ \nfuse you for the Number() native function. For \nour purposes, the capitalization of the type name \nis irrelevant—they have basically the same \nmeaning. \n\n\nClearly, the spec says the \"42\" value is coerced to a number for the \ncomparison. The how of that coercion has already been covered ear- \n\n\n102 | Chapter 4: Coercion \n\n\n\n\n\nHer, specifically with the ToNumber abstract operation. In this case, \nit’s quite obvious then that the resulting two 42 values are equal. \n\nComparing: anything to boolean \n\nOne of the biggest gotchas with the implicit coercion of == loose \nequality pops up when you try to compare a value directly to true \nor false. \n\nConsider: \n\nvar a = \"42\"; \nvar b = true;","metadata":{"loc":{"lines":{"from":68818,"to":68855}}}}],["860",{"pageContent":"One of the biggest gotchas with the implicit coercion of == loose \nequality pops up when you try to compare a value directly to true \nor false. \n\nConsider: \n\nvar a = \"42\"; \nvar b = true; \n\na == b; // false \n\nWait, what happened here!? We know that \"42\" is a truthy value (see \nearlier in this chapter). So, how come it’s not == loose equal to true? \n\nThe reason is both simple and deceptively tricky. It’s so easy to mis¬ \nunderstand, many JS developers never pay close enough attention to \nfully grasp it. \n\nLet’s again quote the spec, clauses 11.9.3.6-7: \n\n1. If Type(x) is Boolean, return the result of the comparison \nToNumber(x) == y. \n\n2. If Type(y) is Boolean, return the result of the comparison x == \nToNumber(y). \n\nLet’s break that down. First: \n\nvar x = true; \nvar y = \"42\"; \n\nx == y; // false","metadata":{"loc":{"lines":{"from":68855,"to":68886}}}}],["861",{"pageContent":"2. If Type(y) is Boolean, return the result of the comparison x == \nToNumber(y). \n\nLet’s break that down. First: \n\nvar x = true; \nvar y = \"42\"; \n\nx == y; // false \n\nThe Type(x) is indeed Boolean, so it performs ToNumber(x), which \ncoerces true to 1. Now, 1 == \"42\" is evaluated. The types are still \ndifferent, so (essentially recursively) we reconsult the algorithm, \nwhich just as above will coerce \"42\" to 42, and 1 == 42 is clearly \nfalse. \n\nReverse it, and we still get the same outcome: \n\nvar x = \"42\"; \nvar y = false; \n\nx == y; // false \n\n\nLoose Equals Versus Strict Equals | 103 \n\n\n\nThe Type(y) is Boolean this time, so ToNumber(y) yields 0. \"42\" == \n0 recursively becomes 42 == 0, which is of course false. \n\nIn other words, the value \"42\" is neither == true nor == false. At \nfirst, that statement might seem crazy. How can a value be neither \ntruthy nor falsy?","metadata":{"loc":{"lines":{"from":68886,"to":68919}}}}],["862",{"pageContent":"In other words, the value \"42\" is neither == true nor == false. At \nfirst, that statement might seem crazy. How can a value be neither \ntruthy nor falsy? \n\nBut that’s the problem! You’re asking the wrong question, entirely. \nIt’s not your fault, really. Your brain is tricking you. \n\n\"42\" is indeed truthy, but \"42\" == true is not performing a \nboolean test/coercion at all, no matter what your brain says. \"42\" is \nnot being coerced to a boolean (true), but instead true is being \ncoerced to a 1, and then \"42\" is being coerced to 42. \n\nWhether we like it or not, ToBoolean is not even involved here, so \nthe truthiness or falsiness of \"42\" is irrelevant to the == operation! \n\nWhat is relevant is to understand how the == comparison algorithm \nbehaves with all the different type combinations. As it regards a \nboolean value on either side of the ==, a boolean always coerces to a \nnumber/zrsf.","metadata":{"loc":{"lines":{"from":68919,"to":68937}}}}],["863",{"pageContent":"If that seems strange to you, you’re not alone. I personally would \nrecommend to never, ever, under any circumstances, use == true or \n== false. Ever. \n\nBut remember, I’m only talking about == here. === true and === \nfalse wouldn’t allow the coercion, so they’re safe from this hidden \nToNumber coercion. \n\nConsider: \n\nvar a = \"42\"; \n\n// bad (will fail!): \nif (a == true) { \n\n// ■■ \n\n} \n\n// also bad (will fail!): \nif (a === true) { \n\n// •• \n\n} \n\n// good enough (works implicitly): \nif (a) { \n\n// \n\n\n104 | Chapter 4: Coercion \n\n\n\n\n} \n\n\n// better (works explicitly): \nif (! ! a) { \n\n// •• \n\n} \n\n// also great (works explicitly): \nif (Boolean( a )) { \n\n// ■■ \n\n} \n\nIf you avoid ever using == true or == false (aka loose equality \nwith booleans) in your code, you’ll never have to worry about this \ntruthiness/falsiness mental gotcha. \n\nComparing: nulls to undefineds","metadata":{"loc":{"lines":{"from":68939,"to":68997}}}}],["864",{"pageContent":"Comparing: nulls to undefineds \n\nAnother example of implicit coercion can be seen with == loose \nequality between null and undefined values. Yet again quoting the \nES5 spec, clauses 11.9.3.2-3: \n\n1. If x is null and y is undefined, return true. \n\n2. If x is undefined and y is null, return true. \n\nnull and undefined, when compared with == loose equality, equate \nto (aka coerce to) each other (as well as themselves, obviously), and \nno other values in the entire language. \n\nWhat this means is that null and undefined can be treated as indis¬ \ntinguishable for comparison purposes, if you use the == loose equal¬ \nity operator to allow their mutual implicit coercion: \n\nvar a = null; \nvar b; \n\na == b; // true \na == null; // true \nb == null; // true \n\na == false; // false \nb == false; // false \na == // false \n\nb == // false \n\na == 0; // false \n\nb == 0; // false \n\n\nLoose Equals Versus Strict Equals | 105","metadata":{"loc":{"lines":{"from":68997,"to":69033}}}}],["865",{"pageContent":"a == false; // false \nb == false; // false \na == // false \n\nb == // false \n\na == 0; // false \n\nb == 0; // false \n\n\nLoose Equals Versus Strict Equals | 105 \n\n\n\n\nThe coercion between null and undefined is safe and predictable, \nand no other values can give false positives in such a check. I recom¬ \nmend using this coercion to allow null and undefined to be indis¬ \ntinguishable and thus treated as the same value. \n\nFor example: \n\nvar a = doSomethingQ; \n\nif (a == null) { \n\n// ■■ \n\n} \n\nThe a == null check will pass only if doSoniething() returns either \nnull or undefined, and will fail with any other value, even other \nfalsy values like 0, false, and \" \n\nThe explicit form of the check, which disallows any such coercion, is \n(I think) unnecessarily much uglier (and perhaps a tiny bit less per- \nformant!): \n\nvar a = doSomethingQ; \n\n\nif (a === undefined || a === null) { \n\n// \n\n}","metadata":{"loc":{"lines":{"from":69033,"to":69079}}}}],["866",{"pageContent":"var a = doSomethingQ; \n\n\nif (a === undefined || a === null) { \n\n// \n\n} \n\nIn my opinion, the form a == null is yet another example where \nimplicit coercion improves code readability, but does so in a reliably \nsafe way. \n\nComparing: objects to nonobjects \n\nIf an object/function/array is compared to a simple scalar primi¬ \ntive (string, number, or boolean), the ES5 spec says in clauses \n11.9.3.8-9: \n\n1. If Type(x) is either String or Number and Type(y) is Object, \nreturn the result of the comparison x == To Primitive (y). \n\n2. If Type(x) is Object and Type(y) is either String or Number, \nreturn the result of the comparison ToPrimitive(x) == y. \n\n\n106 | Chapter 4: Coercion \n\n\n\n\nYou may notice that these clauses only mention \nString and Number, but not Boolean. That’s \nbecause, as quoted earlier, clauses 11.9.3.6-7 take \ncare of coercing any Boolean operand presented \nto a Number first. \n\n\nConsider: \n\nvar a = 42; \nvar b = [ 42 ]; \n\na == b; // true","metadata":{"loc":{"lines":{"from":69079,"to":69122}}}}],["867",{"pageContent":"Consider: \n\nvar a = 42; \nvar b = [ 42 ]; \n\na == b; // true \n\nThe [ 42 ] value has its ToPrimitive abstract operation called (see \n“Abstract Value Operations” on page 59), which results in the \"42\" \nvalue. From there, it’s just \"42\" == 42, which as we’ve already cov¬ \nered becomes 42 == 42, so a and b are found to be coercively equal. \n\nAll the quirks of the ToPrimitive abstract oper¬ \nation that we discussed earlier in this chapter \n(toString(), valueOfQ) apply here as you’d \nexpect. This can be quite useful if you have a \ncomplex data structure that you want to define a \ncustom valueOfQ method on, to provide a sim¬ \nple value for equality comparison purposes. \n\nIn Chapter 3, we covered “unboxing,” where an object wrapper \naround a primitive value (like from new String(\"abc\"), for \ninstance) is unwrapped, and the underlying primitive value (\"abc\") \nis returned. This behavior is related to the ToPripiitive coercion in \nthe == algorithm: \n\nvar a = \"abc\";","metadata":{"loc":{"lines":{"from":69122,"to":69148}}}}],["868",{"pageContent":"var a = \"abc\"; \n\nvar b = Object( a ); // same as 'new Strlng( a )' \n\na === b; // false \n\na == b; // true \n\na == b is true because b is coerced (aka “unboxed,” unwrapped) via \nToPrimitive to its underlying \"abc\" simple scalar primitive value, \nwhich is the same as the value in a. \n\nThere are some values where this is not the case, though, because of \nother overriding rules in the == algorithm. Consider: \n\n\n\nLoose Equals Versus Strict Equals | 107 \n\n\n\n\n\n\nvar a = null; \n\nvar b = Object( a ); \n\na == b; \n\nvar c = undefined; \n\nvar d = Object( c ); \n\nc == d; \n\n\n// sane as 'Object!)' \n// false \n\n\n// sane as 'Object()' \n// false \n\n\nvar e = NaN; \n\nvar f = Object( e ); // sane as 'new Nunber( e )' \n\ne == f; // false \n\nThe null and undefined values cannot be boxed—they have no \nobject wrapper equivalent—so Object(null) is just like ObjectQ in \nthat both just produce a normal object.","metadata":{"loc":{"lines":{"from":69148,"to":69201}}}}],["869",{"pageContent":"e == f; // false \n\nThe null and undefined values cannot be boxed—they have no \nobject wrapper equivalent—so Object(null) is just like ObjectQ in \nthat both just produce a normal object. \n\nNaN can be boxed to its Number object wrapper equivalent, but when \n== causes an unboxing, the NaN == NaN comparison fails because \nNaN is never equal to itself (see Chapter 2). \n\n\nEdge Cases \n\nNow that we’ve thoroughly examined how the implicit coercion of \n== loose equality works (in both sensible and surprising ways), let’s \ntry to call out the worst, craziest corner cases so we can see what we \nneed to avoid to not get bitten with coercion bugs. \n\nFirst, let’s examine how modifying the built-in native prototypes can \nproduce crazy results: \n\n\nA number by any other value would... \n\nNumber.prototype.valueOf = function!) f \nreturn 3; \n\n}; \n\n\nnew Number! 2 ) == 3; // true","metadata":{"loc":{"lines":{"from":69201,"to":69231}}}}],["870",{"pageContent":"A number by any other value would... \n\nNumber.prototype.valueOf = function!) f \nreturn 3; \n\n}; \n\n\nnew Number! 2 ) == 3; // true \n\n\n\n2 == 3 would not have fallen into this trap, \nbecause neither 2 nor 3 would have invoked the \nbuilt-in Number.prototype.valueOf() method \nbecause both are already primitive number val¬ \nues and can be compared directly. However, new \nNumber(2) must go through the ToPrimitive \ncoercion, and thus invoke valueOf (). \n\n\n108 | Chapter 4: Coercion \n\n\n\n\n\nEvil, huh? Of course it is. No one should ever do such a thing. The \nfact that you can do this is sometimes used as a criticism of coercion \nand ==. But that’s misdirected frustration. JavaScript is not bad \nbecause you can do such things, a developer is bad if they do such \nthings. Don’t fall into the “my programming language should pro¬ \ntect me from myself” fallacy. \n\nNext, let’s consider another tricky example, which takes the evil \nfrom the previous example to another level: \n\ntf (a == 2 && a == 3) {","metadata":{"loc":{"lines":{"from":69231,"to":69268}}}}],["871",{"pageContent":"Next, let’s consider another tricky example, which takes the evil \nfrom the previous example to another level: \n\ntf (a == 2 && a == 3) { \n\n// ■■ \n\n1 \n\nYou might think this would be impossible, because a could never be \nequal to both 2 and 3 at the same time. But “at the same time” is \ninaccurate, since the first expression a == 2 happens strictly before a \n== 3. \n\nSo, what if we make a.valueOfQ have side effects each time it’s \ncalled, such that the first time it returns 2 and the second time it’s \ncalled it returns 3? Pretty easy: \n\nvar i = 2; \n\nNumber.prototype.valueOf = function() { \nreturn i++; \n\n1 ; \n\n\nvar a = new Number? 42 ); \n\n\ntf (a == 2 && a == 3) { \n\nconsole.log? \"Yep, this happened.\" ); \n\n1 \n\nAgain, these are evil tricks. Don’t do them. But also don’t use them \nas complaints against coercion. Potential abuses of a mechanism are \nnot sufficient evidence to condemn the mechanism. Just avoid these \ncrazy tricks, and stick only with valid and proper usage of coercion.","metadata":{"loc":{"lines":{"from":69268,"to":69306}}}}],["872",{"pageContent":"Falsy comparisons \n\nThe most common complaint against implicit coercion in == com¬ \nparisons comes from how falsy values behave surprisingly when \ncompared to each other. \n\n\nLoose Equals Versus Strict Equals | 109 \n\n\n\n\nTo illustrate, let’s look at a list of the corner cases around falsy value \ncomparisons, to see which ones are reasonable and which are trou¬ \nblesome: \n\n\n\"0\" == null; \n\n// false \n\n\n\n\"0\" == undefined; \n\n// false \n\n\n\n\"0\" == false; \n\n// true -- \n\nUH \n\nOH! \n\n\"0\" == NaN; \n\n// false \n\n\n\n\"0\" == 0; \n\n// true \n\n\n\n\"0\" == \n\n// false \n\n\n\nfalse == null; \n\n// false \n\n\n\nfalse == undefined; \n\n// false \n\n\n\nfalse == NaN; \n\n// false \n\n\n\nfalse == 0; \n\n// true -- \n\nUH \n\nOH! \n\nfalse == \"\"; \n\n// true -- \n\nUH \n\nOH! \n\nfalse == []; \n\n// true -- \n\nUH \n\nOH! \n\nfalse == {}; \n\n// false \n\n\n\n\"\" == null; \n\n// false \n\n\n\n\"\" == undefined; \n\n// false \n\n\n\n\"\" == NaN; \n\n// false \n\n\n\n\"\" == 0; \n\n// true -- \n\nUH \n\nOH! \n\n\"\" == □; \n\n// true -- \n\nUH \n\nOH! \n\n\"\" == {}; \n\n// false \n\n\n\n0 == null; \n\n// false","metadata":{"loc":{"lines":{"from":69308,"to":69453}}}}],["873",{"pageContent":"// false \n\n\n\n\"\" == undefined; \n\n// false \n\n\n\n\"\" == NaN; \n\n// false \n\n\n\n\"\" == 0; \n\n// true -- \n\nUH \n\nOH! \n\n\"\" == □; \n\n// true -- \n\nUH \n\nOH! \n\n\"\" == {}; \n\n// false \n\n\n\n0 == null; \n\n// false \n\n\n\n0 == undefined; \n\n// false \n\n\n\n0 == NaN; \n\n// false \n\n\n\n0 == []; \n\n// true -- \n\nUH \n\nOH! \n\n0 == {}; \n\n// false \n\n\n\n\nIn this list of 24 comparisons, 17 of them are quite reasonable and \npredictable. For example, we know that \"\" and NaN are not at all \nequatable values, and indeed they don’t coerce to be loose equals, \nwhereas \"0\" and 0 are reasonably equitable and do coerce as loose \nequals. \n\nHowever, seven of the comparisons are marked with “UH OH!” \nbecause as false positives, they are much more likely gotchas that \ncould trip you up. \"\" and 0 are definitely distinctly different values, \nand it’s rare you’d want to treat them as equitable, so their mutual \ncoercion is troublesome. Note that there aren’t any false negatives \nhere. \n\n\n110 | Chapter 4: Coercion \n\n\n\n\n\n\n\nThe crazy ones","metadata":{"loc":{"lines":{"from":69453,"to":69546}}}}],["874",{"pageContent":"110 | Chapter 4: Coercion \n\n\n\n\n\n\n\nThe crazy ones \n\nWe don’t have to stop there, though. We can keep looking for even \nmore troublesome coercions: \n\n[]==![]; //true \n\nOooo, that seems at a higher level of crazy, right!? Your brain may \nlikely trick you that you’re comparing a truthy to a falsy value, so the \ntrue result is surprising, as we know a value can never be truthy and \nfalsy at the same time! \n\nBut that’s not what’s actually happening. Let’s break it down. What \ndo we know about the ! unary operator? It explicitly coerces to a \nboolean using the ToBoolean rules (and it also flips the parity). So \nbefore [ ] == ! [ ] is even processed, it’s actually already translated to \n[ ] == false. We already saw that form in our above list (false == \n[ ]), so its surprise result is not new to us. \n\nHow about other corner cases? \n\n2 == [2]; // true \n\n\"\" == [null]; // true","metadata":{"loc":{"lines":{"from":69546,"to":69577}}}}],["875",{"pageContent":"How about other corner cases? \n\n2 == [2]; // true \n\n\"\" == [null]; // true \n\nAs we said earlier in our ToNumber discussion, the righthand side \n[2] and [null] values will go through a ToPrimitive coercion so \nthey can be more readily compared to the simple primitives (2 and \n\"\", respectively) on the lefthand side. Since the valueOfQ for array \nvalues just returns the array itself, coercion falls to stringifying the \narray. \n\n[2] will become \"2\", which then is ToNumber coerced to 2 for the \nrighthand side value in the first comparison, [null] just straight \nbecomes \n\nSo, 2 == 2 and \"\" == \"\" are completely understandable. \n\nIf your instinct is to still dislike these results, your frustration is not \nactually with coercion like you probably think it is. It’s actually a \ncomplaint against the default array values’ ToPrimitive behavior of \ncoercing to a string value. More likely, you’d just wish that \n[2] .toString() didn’t return \"2\", or that [null] .toStringQ \ndidn’t return","metadata":{"loc":{"lines":{"from":69577,"to":69601}}}}],["876",{"pageContent":"But what exactly should these string coercions result in? I can’t \nreally think of any other appropriate string coercion of [2] than \n\n\nLoose Equals Versus Strict Equals | 111 \n\n\n\n\"2\", except perhaps \" [2]\"—but that could be very strange in other \ncontexts! \n\nYou could rightly make the case that since String(null) becomes \n\"null\", then String([null]) should also become \"null\". That’s a \nreasonable assertion. So, that’s the real culprit. \n\nImplicit coercion itself isn’t the evil here. Even an explicit coercion of \n[null] to a string results in What’s at odds is whether it’s sensi¬ \nble at all for array values to stringify to the equivalent of their con¬ \ntents, and exactly how that happens. So, direct your frustration at \nthe rules for String( [..] ), because that’s where the craziness \nstems from. Perhaps there should be no stringification coercion of \narrays at all? But that would have lots of other downsides in other \nparts of the language. \n\nAnother famously cited gotcha:","metadata":{"loc":{"lines":{"from":69603,"to":69627}}}}],["877",{"pageContent":"Another famously cited gotcha: \n\n0 == \"\\n\"; // true \n\nAs we discussed earlier with empty \"\\n\" (or \" \" or any other \nwhitespace combination) is coerced via ToNumber, and the result is \n0. What other number value would you expect whitespace to coerce \nto? Does it bother you that explicit Number(\" \") yields 0? \n\nReally the only other reasonable number value that empty strings or \nwhitespace strings could coerce to is NaN. But would that really be \nbetter? The comparison \" \" == NaN would of course fail, but it’s \nunclear that we’d have really fixed any of the underlying concerns. \n\nThe chances that a real-world JS program fails because 0 == \"\\n\" \nare awfully rare, and such corner cases are easy to avoid. \n\nType conversions always have corner cases, in any language—noth¬ \ning specific to coercion. The issues here are about second-guessing a \ncertain set of corner cases (and perhaps rightly so!?), but that’s not a \nsalient argument against the overall coercion mechanism.","metadata":{"loc":{"lines":{"from":69627,"to":69647}}}}],["878",{"pageContent":"Bottom line: almost any crazy coercion between normal values that \nyou’re likely to run into (aside from intentionally tricky valueOfQ \nor toStrlngO hacks as earlier) will boil down to the short seven- \nitem list of gotcha coercions we’ve identified above. \n\nTo contrast against these 24 likely suspects for coercion gotchas, \nconsider another list like this: \n\n\n112 | Chapter 4: Coercion \n\n\n\n\n42 == \n\n\"43\"; \n\n// \n\nfalse \n\n\"foo\" \n\n== 42; \n\n// \n\nfalse \n\n\"true\" \n\n== true; \n\n// \n\nfalse \n\n42 == \n\n\"42\"; \n\n// \n\ntrue \n\n\"foo\" \n\n== 1 \"too\" ]; \n\n// \n\ntrue \n\n\nIn these nonfalsy, noncorner cases (and there are literally an infinite \nnumber of comparisons we could put on this list), the coercion \nresults are totally safe, reasonable, and explainable. \n\n\nSanity check \n\nOK, we’ve definitely found some crazy stuff when we’ve looked \ndeeply into implicit coercion. No wonder that most developers claim \ncoercion is evil and should be avoided, right!? \n\nBut let’s take a step back and do a sanity check.","metadata":{"loc":{"lines":{"from":69649,"to":69715}}}}],["879",{"pageContent":"But let’s take a step back and do a sanity check. \n\nBy way of magnitude comparison, we have a list of seven trouble¬ \nsome gotcha coercions, but we have another list of (at least 17, but \nactually infinite) coercions that are totally sane and explainable. \n\nIf you’re looking for a textbook example of “throwing the baby out \nwith the bathwater,” this is it: discarding the entirety of coercion (the \ninfinitely large list of safe and useful behaviors) because of a list of \nliterally just seven gotchas. \n\nThe more prudent reaction would be to ask, “How can I use the \ncountless good parts of coercion, but avoid the few bad parts?” \n\nLet’s look again at the bad list: \n\n\n\"0\" == false; \nfalse == 0; \nfalse == \nfalse == []; \n\"\" == 0 ; \n\n\"\" == []; \n\n0 == []; \n\n\n// true -- UH OH! \n// true -- UH OH! \n// true -- UH OH! \n// true -- UH OH! \n// true -- UH OH! \n// true -- UH OH! \n// true -- UH OH!","metadata":{"loc":{"lines":{"from":69715,"to":69749}}}}],["880",{"pageContent":"\"\" == []; \n\n0 == []; \n\n\n// true -- UH OH! \n// true -- UH OH! \n// true -- UH OH! \n// true -- UH OH! \n// true -- UH OH! \n// true -- UH OH! \n// true -- UH OH! \n\n\nFour of the seven items on this list involve == false comparison, \nwhich we said earlier you should always, always avoid. That’s a \npretty easy rule to remember. \n\nNow the list is down to three. \n\n\n\"\" == 0; // true -- UH OH! \n\"\" == []; // true -- UH OH! \n0 == []; // true -- UH OH! \n\n\nLoose Equals Versus Strict Equals | 113 \n\n\n\nAre these reasonable coercions you’d do in a normal JavaScript pro¬ \ngram? Under what conditions would they really happen? \n\nI don’t think it’s terribly likely that you’d literally use == [] in a \nboolean test in your program, at least not if you know what you’re \ndoing. You’d probably instead be doing == \"\" or == 0, like: \n\nfunction doSomething(a) { \nif (a == \"\") { \n\n// •• \n\n} \n\n} \n\nYou’d have an oops if you accidentally called doSomething(O) or doS \noniething([]). Another scenario:","metadata":{"loc":{"lines":{"from":69749,"to":69796}}}}],["881",{"pageContent":"function doSomething(a) { \nif (a == \"\") { \n\n// •• \n\n} \n\n} \n\nYou’d have an oops if you accidentally called doSomething(O) or doS \noniething([]). Another scenario: \n\nfunction doSomething(a,b) { \nif (a == b) { \n\n// •• \n\n} \n\n} \n\nAgain, this could break if you did something like doSomething(\"\", \n0) or doSomething([], \n\nSo, while the situations can exist where these coercions will bite you, \nand you’ll want to be careful around them, they’re probably not \nsuper common on the whole of your code base. \n\nSafely using implicit coercion \n\nThe most important advice I can give you: examine your program \nand reason about what values can show up on either side of an == \ncomparison. To effectively avoid issues with such comparisons, \nhere’s some heuristic rules to follow: \n\n• If either side of the comparison can have true or false values, \ndon’t ever, EVER use ==. \n\n• If either side of the comparison can have [], or 0 values, \nseriously consider not using ==.","metadata":{"loc":{"lines":{"from":69796,"to":69835}}}}],["882",{"pageContent":"• If either side of the comparison can have true or false values, \ndon’t ever, EVER use ==. \n\n• If either side of the comparison can have [], or 0 values, \nseriously consider not using ==. \n\nIn these scenarios, it’s almost certainly better to use === instead of \n==, to avoid unwanted coercion. Follow those two simple rules and \npretty much all the coercion gotchas that could reasonably hurt you \nwill effectively be avoided. \n\n\n114 | Chapter 4: Coercion \n\n\n\n\nBeing more explicit/verbose in these cases will save you from a lot of \nheadaches. \n\nThe question of == versus === is really appropriately framed as: \nshould you allow coercion for a comparison or not? \n\nThere’s lots of cases where such coercion can be helpful, allowing \nyou to more tersely express some comparison logic (like with null \nand undefined, for example). \n\nIn the overall scheme of things, there’s relatively few cases where \nimplicit coercion is truly dangerous. But in those places, for safety \nsake, definitely use ===.","metadata":{"loc":{"lines":{"from":69835,"to":69864}}}}],["883",{"pageContent":"In the overall scheme of things, there’s relatively few cases where \nimplicit coercion is truly dangerous. But in those places, for safety \nsake, definitely use ===. \n\nAnother place where coercion is guaranteed not \nto bite you is with the typeof operator, typeof is \nalways going to return you one of seven strings \n(see Chapter 1), and none of them are the empty \n\"\" string. As such, there’s no case where check¬ \ning the type of some value is going to run afoul \nof implicit coercion, typeof x == \"function\" is \n100% as safe and reliable as typeof x === \n\"function\". Literally, the spec says the algo¬ \nrithm will be identical in this situation. So, don’t \njust blindly use === everywhere simply because \nthat’s what your code tools tell you to do, or \n(worst of all) because you’ve been told in some \nbook to not think about it. You own the quality \nof your code. \n\nIs implicit coercion evil and dangerous? In a few cases, yes, but over¬ \nwhelmingly, no.","metadata":{"loc":{"lines":{"from":69864,"to":69885}}}}],["884",{"pageContent":"Is implicit coercion evil and dangerous? In a few cases, yes, but over¬ \nwhelmingly, no. \n\nBe a responsible and mature developer. Learn how to use the power \nof coercion (both explicit and implicit) effectively and safely. And \nteach those around you to do the same. \n\nFigure 4-1 shows a handy table made by GitHub user Alex Dorey \n(@dorey on GitHub) to visualize a variety of comparisons. \n\n\n\nLoose Equals Versus Strict Equals | 115 \n\n\n\n\n\n□ 0 \n\n'“ 0000 “ \n\n\nI 0 \n\n‘Q B \n- 0 ■ \n\n‘ [ \n\n\n0 0 \n\n0 \n\n0 0 \n\n000000000000 \n\n\n□ \n\n0 00 \n\n\n100001 s 0 \n\n0 00 \n\n\ne equality \n| m | Often gives \"fa, \n\n\ns \n\n■ \n\n•o 0 I 0 \n\n■0 0 0 0 \n\n0 B \n\n■0 0 0 0 0 \n\n\nStrict equality \nMostly evaluates as \none would expect. \n\n\n\n\n0 0 \n\n0 000000000000000000 \n_ 00000000000 \n\n0 0 0 \n\n000000000G \n\n\nFigure 4-1. Equality in JavaScript \n\n\nAbstract Relational Comparison","metadata":{"loc":{"lines":{"from":69885,"to":69972}}}}],["885",{"pageContent":"Strict equality \nMostly evaluates as \none would expect. \n\n\n\n\n0 0 \n\n0 000000000000000000 \n_ 00000000000 \n\n0 0 0 \n\n000000000G \n\n\nFigure 4-1. Equality in JavaScript \n\n\nAbstract Relational Comparison \n\nWhile this part of implicit coercion often gets a lot less attention, it’s \nimportant nonetheless to think about what happens with a < b \ncomparisons (similar to how we just examined a == b in depth). \n\nThe “Abstract Relational Comparison” algorithm in ES5 section \n11.8.5 essentially divides itself into two parts: what to do if the com¬ \nparison involves both string values (second half), or anything else \n(first half). \n\n\n\nThe algorithm is only defined for a < b. So, a > \nb is handled as b < a. \n\n\nThe algorithm first calls ToPrimitive coercion on both values, and \nif the return result of either call is not a string, then both values are \ncoerced to number values using the ToNumber operation rules, and \ncompared numerically. \n\n\n116 | Chapter 4: Coercion \n\n\n\n\n\n\n\n\n\n\n\n\nFor example:","metadata":{"loc":{"lines":{"from":69972,"to":70028}}}}],["886",{"pageContent":"116 | Chapter 4: Coercion \n\n\n\n\n\n\n\n\n\n\n\n\nFor example: \n\nvar a = [ 42 ]; \nvar b = [ \"43\" ]; \n\na < b; // true \nb < a; // false \n\n\n\nSimilar caveats for -0 and NaN apply here as they \ndid in the == algorithm discussed earlier. \n\n\nHowever, if both values are strings for the < comparison, simple \nlexicographic (natural alphabetic) comparison on the characters is \nperformed: \n\nvar a = [ \"42\" ]; \nvar b = [ \"043\" ]; \n\na < b; // false \n\na and b are not coerced to numbers, because both of them end up as \nstrings after the ToPrimitive coercion on the two arrays. So, \"42\" \nis compared character by character to \"043\", starting with the first \ncharacters \"4\" and \"0\", respectively. Since \"0\" is lexicographically \nless than \"4\", the comparison returns false. \n\nThe exact same behavior and reasoning goes for: \n\nvar a = [ 4, 2 ]; \nvar b = [ 0, 4, 3 ]; \n\na < b; // false \n\nHere, a becomes \"4,2\" and b becomes \"0,4,3\", and those lexico¬ \ngraphically compare identically to the previous snippet. \n\nWhat about:","metadata":{"loc":{"lines":{"from":70028,"to":70080}}}}],["887",{"pageContent":"var a = [ 4, 2 ]; \nvar b = [ 0, 4, 3 ]; \n\na < b; // false \n\nHere, a becomes \"4,2\" and b becomes \"0,4,3\", and those lexico¬ \ngraphically compare identically to the previous snippet. \n\nWhat about: \n\nvar a = { b: 42 }; \nvar b = { b: 43 }; \n\na < b; // ?? \n\na < b is also false, because a becomes [object Object] and b \nbecomes [object Object], and so clearly a is not lexicographically \nless than b. \n\n\nAbstract Relational Comparison | 117 \n\n\n\n\n\nBut strangely: \n\nvar a = { b: 42 }; \nvar b = { b: 43 }; \n\na < b; // false \na == b; // false \na > b; // false \n\na <= b; // true \na >= b; // true \n\nWhy is a == b not true? They’re the same string value (\" [object \nObject] \"), so it seems they should be equal, right? Nope. Recall the \nprevious discussion about how == works with object references. \n\nBut then how are a <= b and a >= b resulting in true, if a < b and \na == b and a > b are all false?","metadata":{"loc":{"lines":{"from":70080,"to":70123}}}}],["888",{"pageContent":"But then how are a <= b and a >= b resulting in true, if a < b and \na == b and a > b are all false? \n\nBecause the spec says for a <= b, it will actually evaluate b < a first, \nand then negate that result. Since b < a is also false, the result of a \n<= b is true. \n\nThat’s probably awfully contrary to how you might have explained \nwhat <= does up to now, which would likely have been the literal \n“less than or equal to.” JS more accurately considers <= as “not \ngreater than” (!( a > b), which JS treats as ! (b < a)). Moreover, a \n>= b is explained by first considering it as b <= a, and then apply¬ \ning the same reasoning. \n\nUnfortunately, there is no “strict relational comparison” as there is \nfor equality. In other words, there’s no way to prevent implicit coer¬ \ncion from occurring with relational comparisons like a < b, other \nthan to ensure that a and b are of the same type explicitly before \nmaking the comparison.","metadata":{"loc":{"lines":{"from":70123,"to":70141}}}}],["889",{"pageContent":"Use the same reasoning from our earlier == versus === sanity check \ndiscussion. If coercion is helpful and reasonably safe, like in a 42 < \n\"43\" comparison, use it. On the other hand, if you need to be safe \nabout a relational comparison, explicitly coerce the values first, \nbefore using < (or its counterparts): \n\nvar a = [ 42 ]; \nvar b = \"043\"; \n\na < b; // false -- string comparison! \n\nNumber( a ) < Number( b ); // true -- number comparison! \n\n\n118 | Chapter 4: Coercion \n\n\n\nReview \n\nIn this chapter, we turned our attention to how JavaScript type con¬ \nversions happen, called coercion, which can be characterized as \neither explicit or implicit. \n\nCoercion gets a bad rap, but it’s actually quite useful in many cases. \nAn important task for the responsible JS developer is to take the \ntime to learn all the ins and outs of coercion to decide which parts \nwill help improve their code, and which parts they really should \navoid.","metadata":{"loc":{"lines":{"from":70143,"to":70171}}}}],["890",{"pageContent":"Explicit coercion is code where it is obvious that the intent is to con¬ \nvert a value from one type to another. The benefit is improvement in \nreadability and maintainability of code by reducing confusion. \n\nImplicit coercion is coercion that is “hidden” as a side effect of some \nother operation, where it’s not as obvious that the type conversion \nwill occur. While it may seem that implicit coercion is the opposite \nof explicit and is thus bad (and indeed, many think so!), actually \nimplicit coercion is also about improving the readability of code. \n\nEspecially for the implicit type, coercion must be used responsibly \nand consciously. Know why you’re writing the code you’re writing, \nand how it works. Strive to write code that others will easily be able \nto learn from and understand as well. \n\n\nReview | 119 \n\n\n\nCHAPTER 5 \n\n\nGrammar","metadata":{"loc":{"lines":{"from":70173,"to":70196}}}}],["891",{"pageContent":"Review | 119 \n\n\n\nCHAPTER 5 \n\n\nGrammar \n\n\nThe last major topic we want to tackle is how JavaScript’s language \nsyntax works (aka its grammar). You may think you know how to \nwrite JS, but there’s an awful lot of nuance to various parts of the \nlanguage grammar that lead to confusion and misconception, so we \nwant to dive into those parts and clear some things up.","metadata":{"loc":{"lines":{"from":70196,"to":70210}}}}],["892",{"pageContent":"The term “grammar” may be a little less familiar \nto readers than the term “syntax.” In many ways, \nthey are similar terms, describing the rules for \nhow the language works. There are nuanced dif¬ \nferences, but they mostly don’t matter for our \ndiscussion here. The grammar for JavaScript is a \nstructured way to describe how the syntax \n(operators, keywords, etc.) fits together into \nwell-formed, valid programs. In other words, \ndiscussing syntax without grammar would leave \nout a lot of the important details. So our focus \nhere in this chapter is most accurately described \nas grammar, even though the raw syntax of the \nlanguage is what developers directly interact \nwith. \n\n\nStatements & Expressions \n\nIt’s fairly common for developers to assume that the term “state¬ \nment” and “expression” are roughly equivalent. But here we need to \n\n\n121 \n\n\n\n\n\n\ndistinguish between the two, because there are some very important \ndifferences in our JS programs.","metadata":{"loc":{"lines":{"from":70214,"to":70245}}}}],["893",{"pageContent":"121 \n\n\n\n\n\n\ndistinguish between the two, because there are some very important \ndifferences in our JS programs. \n\nTo draw the distinction, let’s borrow from terminology you may be \nmore familiar with: the English language. \n\nA “sentence” is one complete formation of words that expresses a \nthought. It’s comprised of one or more “phrases,” each of which can \nbe connected with punctuation marks or conjunctions (“and,” “or,” \netc.). A phrase can itself be made up of smaller phrases. Some \nphrases are incomplete and don’t accomplish much by themselves, \nwhile other phrases can stand on their own. These rules are collec¬ \ntively called the grammar of the English language. \n\nAnd so it goes with JavaScript grammar. Statements are sentences, \nexpressions are phrases, and operators are conjunctions/punctua¬ \ntion. \n\nEvery expression in JS can be evaluated down to a single, specific \nvalue result. For example: \n\nvar a = 3 * 6; \nvar b = a; \nb;","metadata":{"loc":{"lines":{"from":70245,"to":70275}}}}],["894",{"pageContent":"Every expression in JS can be evaluated down to a single, specific \nvalue result. For example: \n\nvar a = 3 * 6; \nvar b = a; \nb; \n\nIn this snippet, 3 * 6 is an expression (evaluates to the value 18). \nBut a on the second line is also an expression, as is b on the third \nline. The a and b expressions both evaluate to the values stored in \nthose variables at that moment, which also happens to be 18. \n\nMoreover, each of the three lines is a statement containing expres¬ \nsions. var a = 3 * 6 and var b = a are called “declaration state¬ \nments” because they each declare a variable (and optionally assign a \nvalue to it). The a = 3 * 6 and b = a assignments (minus the vars) \nare called assignment expressions. \n\nThe third line contains just the expression b, but it’s also a statement \nall by itself (though not a terribly interesting one!). As such, this is \ngenerally referred to as an “expression statement.” \n\nStatement Completion Values","metadata":{"loc":{"lines":{"from":70275,"to":70297}}}}],["895",{"pageContent":"Statement Completion Values \n\nIt’s a fairly little known fact that statements all have completion val¬ \nues (even if that value is just undefined). \n\n\n122 | Chapter 5: Grammar \n\n\n\n\nHow would you even go about seeing the completion value of a \nstatement? \n\nThe most obvious answer is to type the statement into your brows¬ \ner’s developer console, because when you execute it, the console by \ndefault reports the completion value of the most recent statement it \nexecuted. \n\nLet’s consider var b = a. What’s the completion value of that state¬ \nment? \n\nThe b = a assignment expression results in the value that was \nassigned (18 above), but the var statement itself results in unde \nfined. Why? Because var statements are defined that way in the \nspec. If you put var a = 42; into your console, you’ll see undefined \nreported back instead of 42.","metadata":{"loc":{"lines":{"from":70297,"to":70323}}}}],["896",{"pageContent":"Technically, it’s a little more complex than that. \nIn the ES5 spec, section 12.2 “Variable State¬ \nment,” the VariableDecla ration algorithm \nactually does return a value (a string containing \nthe name of the variable declared—weird, \nhuh!?), but that value is basically swallowed up \n(except for use by the for.. in loop) by the Vari \nableStatenent algorithm, which forces an \nempty (aka undefined) completion value. \n\n\nIn fact, if you’ve done much code experimenting in your console (or \nin a JavaScript environment REPL—read/evaluate/print/loop tool), \nyou’ve probably seen undefined reported after many different stat- \nments, and perhaps never realized why or what that was. Put simply, \nthe console is reporting the statement’s completion value. \n\nBut what the console prints out for the completion value isn’t some¬ \nthing we can use inside our program. So how can we capture the \ncompletion value?","metadata":{"loc":{"lines":{"from":70327,"to":70346}}}}],["897",{"pageContent":"But what the console prints out for the completion value isn’t some¬ \nthing we can use inside our program. So how can we capture the \ncompletion value? \n\nThat’s a much more complicated task. Before we explain how, let’s \nexplore why would you want to do that. \n\nWe need to consider other types of statement completion values. For \nexample, any regular { .. } block has a completion value of the \ncompletion value of its last contained statement/expression. \n\nConsider: \n\n\nStatements & Expressions | 123 \n\n\n\n\n\nvar b; \n\n\nIf (true) { \n\nb = 4 + 38; \n\n} \n\nIf you typed that into your console/REPL, you’d probably see 42 \nreported, since 42 is the completion value of the if block, which \ntook on the completion value of its last expression statement b = 4 \n+ 38. \n\nIn other words, the completion value of a block is like an implicit \nreturn of the last statement value in the block.","metadata":{"loc":{"lines":{"from":70346,"to":70381}}}}],["898",{"pageContent":"In other words, the completion value of a block is like an implicit \nreturn of the last statement value in the block. \n\n\n\nThis is conceptually familiar in languages like \nCoffeeScript, which have implicit return values \nfrom functions that are the same as the last \nstatement value in the function. \n\n\nBut there’s an obvious problem. This kind of code doesn’t work: \nvar a, b; \n\na = if (true) { \nb = 4 + 38; \n\n}; \n\nWe can’t capture the completion value of a statement and assign it \ninto another variable in any easy syntactic/grammatical way (at least \nnot yet!). \n\nSo, what can we do? \n\n\n\nFor demo purposes only—don’t actually do the \nfollowing in your real code! \n\n\nWe could use the much maligned eval(..) (sometimes pronounced \n“evil”) function to capture this completion value: \n\nvar a, b; \n\na = evat( \"if (true) { b = 4 + 38; }\" ); \na; // 42 \n\n\n124 | Chapter 5: Grammar","metadata":{"loc":{"lines":{"from":70381,"to":70421}}}}],["899",{"pageContent":"var a, b; \n\na = evat( \"if (true) { b = 4 + 38; }\" ); \na; // 42 \n\n\n124 | Chapter 5: Grammar \n\n\n\n\n\n\nYeeeaaahhhh. That’s terribly ugly. But it works! And it illustrates the \npoint that statement completion values are a real thing that can be \ncaptured not just in our console but in our programs. \n\nThere’s a proposal for ES7 called the “do expression.” Here’s how it \nmight work: \n\nvar a, b; \n\na = do { \n\nIf (true) { \n\nb = 4 + 38; \n\n} \n\n}; \n\na; // 42 \n\nThe do { .. } expression executes a block (with one or many state¬ \nments in it), and the final statement completion value inside the \nblock becomes the completion value of the do expression, which can \nthen be assigned to a as shown. \n\nThe general idea is to be able to treat statements as expressions— \nthey can show up inside other statements—without needing to wrap \nthem in an inline function expression and perform an explicit \n\nreturn ...","metadata":{"loc":{"lines":{"from":70421,"to":70464}}}}],["900",{"pageContent":"return ... \n\nFor now, statement completion values are not much more than \ntrivia. But they’re probably going to take on more significance as JS \nevolves, and hopefully do { .. } expressions will reduce the temp¬ \ntation to use stuff like eval(..). \n\n\n\nRepeating my earlier admonition: avoid \neval(..). Seriously. See the Scope & Closures \ntitle in this series for more explanation. \n\n\nExpression Side Effects \n\nMost expressions don’t have side effects. For example: \n\nvar a = 2; \nvar b = a + 3; \n\n\nStatements & Expressions | 125 \n\n\n\n\n\n\nThe expression a + 3 did not itself have a side effect, like for \ninstance changing a. It had a result, which is 5, and that result was \nassigned to b in the statement b = a + 3. \n\nThe most common example of an expression with (possible) side \neffects is a function call expression: \n\nfunction foo() { \na = a + 1; \n\n} \n\nvar a = 1; \n\nfoo(); // result: 'undefined', side effect: changed 'a' \n\nThere are other side-effecting expressions, though. For example:","metadata":{"loc":{"lines":{"from":70464,"to":70509}}}}],["901",{"pageContent":"function foo() { \na = a + 1; \n\n} \n\nvar a = 1; \n\nfoo(); // result: 'undefined', side effect: changed 'a' \n\nThere are other side-effecting expressions, though. For example: \n\nvar a = 42; \nvar b = a++; \n\nThe expression a++ has two separate behaviors. First, it returns the \ncurrent value of a, which is 42 (which then gets assigned to b). But \nnext, it changes the value of a itself, incrementing it by one: \n\nvar a = 42; \nvar b = a++; \n\na; // 43 \nb; // 42 \n\nMany developers would mistakenly believe that b has value 43 just \nlike a does. But the confusion comes from not fully considering the \nwhen of the side effects of the ++ operator. \n\nThe ++ increment operator and the - - decrement operator are both \nunary operators (see Chapter 4), which can be used in either a post¬ \nfix (“after”) position or prefix (“before”) position: \n\nvar a = 42; \n\na++; // 42 \n\na; // 43 \n\n++a; // 44 \n\na; // 44","metadata":{"loc":{"lines":{"from":70509,"to":70549}}}}],["902",{"pageContent":"var a = 42; \n\na++; // 42 \n\na; // 43 \n\n++a; // 44 \n\na; // 44 \n\nWhen ++ is used in the prefix position as ++a, its side effect (incre¬ \nmenting a) happens before the value is returned from the expression, \nrather than after as with a++. \n\n\n126 | Chapter 5: Grammar \n\n\n\n\n\nWould you think ++a++ was legal syntax? If you \ntry it, you’ll get a ReferenceError error, but \nwhy? Because side-effecting operators require a \nvariable reference to target their side effects to. \nFor ++a++, the a++ part is evaluated first \n(because of operator precedence—see below), \nwhich gives back the value of a before the incre¬ \nment. But then it tries to evaluate ++42, which (if \nyou try it) gives the same ReferenceError error, \nsince ++ cant have a side effect directly on a \nvalue like 42. \n\n\nIt is sometimes mistakenly thought that you can encapsulate the \nafter side effect of a++ by wrapping it in a ( ) pair, like: \n\nvar a = 42; \nvar b = (a++); \n\na; // 43 \nb; // 42","metadata":{"loc":{"lines":{"from":70549,"to":70590}}}}],["903",{"pageContent":"It is sometimes mistakenly thought that you can encapsulate the \nafter side effect of a++ by wrapping it in a ( ) pair, like: \n\nvar a = 42; \nvar b = (a++); \n\na; // 43 \nb; // 42 \n\nUnfortunately, ( ) itself doesn’t define a new wrapped expression \nthat would be evaluated after the after side effect of the a++ expres¬ \nsion, as we might have hoped. In fact, even if it did, a++ returns 42 \nfirst, and unless you have another expression that reevaluates a after \nthe side effect of ++, you’re not going to get 43 from that expression, \nso b will not be assigned 43. \n\nThere’s an option, though: the , statement-series comma operator. \nThis operator allows you to string together multiple standalone \nexpression statements into a single statement: \n\nvar a = 42, b; \nb = ( a++, a ); \n\n\na; // 43 \nb; // 43 \n\n\n\nThe ( .. ) around a++, a is required here. The \nreason is operator precedence, which we’ll cover \nlater in this chapter. \n\n\nStatements & Expressions | 127","metadata":{"loc":{"lines":{"from":70590,"to":70624}}}}],["904",{"pageContent":"a; // 43 \nb; // 43 \n\n\n\nThe ( .. ) around a++, a is required here. The \nreason is operator precedence, which we’ll cover \nlater in this chapter. \n\n\nStatements & Expressions | 127 \n\n\n\n\n\n\n\nThe expression a++, a means that the second a statement expres¬ \nsion gets evaluated after the after side effects of the a++ expression, \nwhich means it returns the 43 value for assignment to b. \n\nAnother example of a side-effecting operator is delete. As we \nshowed in Chapter 2, delete is used to remove a property from an \nobject or a slot from an array. But it’s usually just called as a stand¬ \nalone statement: \n\nvar obj = { \na: 42 \n\n}; \n\n\nobj.a; \n\ndelete obj.a; \nobj.a; \n\n\n// 42 \n// true \n// undefined \n\n\nThe result value of the delete operator is true if the requested \noperation is valid/allowable, or false otherwise. But the side effect \nof the operator is that it removes the property (or array slot).","metadata":{"loc":{"lines":{"from":70624,"to":70670}}}}],["905",{"pageContent":"What do we mean by valid/allowable? Nonexis¬ \ntent properties, or properties that exist and are \nconfigurable (see Chapter 3 of the this & Object \nPrototypes title in this series) will return true \nfrom the delete operator. Otherwise, the result \nwill be false or an error. \n\n\nOne last example of a side-effecting operator, which may at once be \nboth obvious and nonobvious, is the = assignment operator. \n\nConsider: \nvar a; \n\na = 42; // 42 \n\na; // 42 \n\nIt may not seem like = in a = 42 is a side-effecting operator for the \nexpression. But if we examine the result value of the a = 42 state¬ \nment, it’s the value that was just assigned (42), so the assignment of \nthat same value into a is essentially a side effect. \n\n\n128 | Chapter 5: Grammar \n\n\n\n\n\n\nThe same reasoning about side effects goes for \nthe compound-assignment operators like +=, - =, \netc. For example, a = b += 2 is processed first \nas b += 2 (which is b = b + 2), and the result \nof that = assignment is then assigned to a.","metadata":{"loc":{"lines":{"from":70674,"to":70709}}}}],["906",{"pageContent":"This behavior that an assignment expression (or statement) results \nin the assigned value is primarily useful for chained assignments, \nsuch as: \n\nvar a, b, c; \na = b = c = 42; \n\nHere, c = 42 is evaluated to 42 (with the side effect of assigning 42 \nto c), then b = 42 is evaluated to 42 (with the side effect of assigning \n42 to b), and finally a = 42 is evaluated (with the side effect of \nassigning 42 to a). \n\n\n\nA common mistake developers make with \nchained assignments is like var a = b = 42. \nWhile this looks like the same thing, it’s not. If \nthat statement were to happen without there \nalso being a separate var b (somewhere in the \nscope) to formally declare b, then var a = b = \n42 would not declare b directly. Depending on \nstrict mode, that would either throw an error \nor create an accidental global (see the Scope dr \nClosures title in this series). \n\n\nAnother scenario to consider: \n\nfunction vowels(str) { \nvar matches; \n\nif (str) {","metadata":{"loc":{"lines":{"from":70712,"to":70743}}}}],["907",{"pageContent":"Another scenario to consider: \n\nfunction vowels(str) { \nvar matches; \n\nif (str) { \n\n// puli out ail the vowels \nmatches = str.match( /[aeiou]/g ); \n\nif (matches) { \n\nreturn matches; \n\n} \n\n} \n\n} \n\nvowe!s( \"Hello World\" ); // [\"e\",\"o\",\"o\"] \n\n\nStatements & Expressions | 129 \n\n\n\n\n\nThis works, and many developers prefer such. But using an idiom \nwhere we take advantage of the assignment side effect, we can sim¬ \nplify by combining the two if statements into one: \n\nfunction vowels(str) { \nvar matches; \n\n\n// pull out all the vowels \n\nIf (str && (matches = str.match( /[aetou]/g ))) { \nreturn matches; \n\n} \n\n\nvowels( \"Hello World\" ); // [\"e\",\"o\",\"o\"] \n\n\n\nThe ( .. ) around matches = str.match. . is \nrequired. The reason is operator precedence, \nwhich we’ll cover in “Operator Precedence” on \npage 137.","metadata":{"loc":{"lines":{"from":70743,"to":70795}}}}],["908",{"pageContent":"vowels( \"Hello World\" ); // [\"e\",\"o\",\"o\"] \n\n\n\nThe ( .. ) around matches = str.match. . is \nrequired. The reason is operator precedence, \nwhich we’ll cover in “Operator Precedence” on \npage 137. \n\n\nI prefer this shorter style, as I think it makes it clearer that the two \nconditionals are in fact related rather than separate. But as with \nmost stylistic choices in JS, it’s purely opinion which one is better. \n\nContextual Rules \n\nThere are quite a few places in the JavaScript grammar rules where \nthe same syntax means different things depending on where/how it’s \nused. This kind of thing can, in isolation, cause quite a bit of confu¬ \nsion. \n\nWe won’t exhaustively list all such cases here, but just call out a few \nof the common ones. \n\nCurly braces \n\nThere’s two main places (and more coming as JS evolves!) that a pair \nof curly braces { .. } will show up in your code. Let’s take a look at \neach of them. \n\nObject literals \n\nFirst, as an object literal:","metadata":{"loc":{"lines":{"from":70795,"to":70827}}}}],["909",{"pageContent":"Object literals \n\nFirst, as an object literal: \n\n// assume there's a ’bar()' function defined \n\n\n130 | Chapter 5: Grammar \n\n\n\n\n\nvar a = { \n\nfoo: bar() \n\n}; \n\nHow do we know this is an object literal? Because the { .. } pair \nis a value that’s getting assigned to a. \n\n\n\nThe a reference is called an “1-value” (aka left- \nhand value) since it’s the target of an assign¬ \nment. The { .. } pair is an “r-value” (aka right- \nhand value) since it’s used just as a value (in this \ncase as the source of an assignment). \n\n\nLabels \n\nWhat happens if we remove the var a = part of the above snippet? \n\n// assume there's a 'bar()' function defined \n\n{ \n\nfoo: bar() \n\n1 \n\nA lot of developers assume that the { .. } pair is just a standalone \nobject literal that doesn’t get assigned anywhere. But it’s actually \nentirely different.","metadata":{"loc":{"lines":{"from":70827,"to":70872}}}}],["910",{"pageContent":"{ \n\nfoo: bar() \n\n1 \n\nA lot of developers assume that the { .. } pair is just a standalone \nobject literal that doesn’t get assigned anywhere. But it’s actually \nentirely different. \n\nHere, { .. } is just a regular code block. It’s not very idiomatic in \nJavaScript (much more so in other languages!) to have a standalone \n{ .. } block like that, but it’s perfectly valid JS grammar. It can be \nespecially helpful when combined with let block-scoping declara¬ \ntions (see the Scope & Closures title in this series). \n\nThe { .. } code block here is functionally pretty much identical to \nthe code block being attached to some statement, like a for/whlle \nloop, if conditional, etc. \n\nBut if it’s a normal block of code, what’s that bizarre looking foo: \nba r () syntax, and how is that legal?","metadata":{"loc":{"lines":{"from":70872,"to":70893}}}}],["911",{"pageContent":"But if it’s a normal block of code, what’s that bizarre looking foo: \nba r () syntax, and how is that legal? \n\nIt’s because of a little known (and, frankly, discouraged) feature in \nJavaScript called “labeled statements.” foo is a label for the statement \nbar() (that has omitted its trailing ;—see “Automatic Semicolons” \non page 146 later in this chapter). But what’s the point of a labeled \nstatement? \n\n\nStatements & Expressions | 131 \n\n\n\n\n\n\nIf JavaScript had a goto statement, you’d theoretically be able to say \ngoto foo and have execution jump to that location in code, gotos \nare usually considered terrible coding idioms as they make code \nmuch harder to understand (aka “spaghetti code”), so it’s a very good \nthing that JavaScript doesn’t have a general goto.","metadata":{"loc":{"lines":{"from":70893,"to":70914}}}}],["912",{"pageContent":"However, JS does support a limited, special form of goto: labeled \njumps. Both the continue and break statements can optionally \naccept a specified label, in which case the program flow “jumps” \nkind of like a goto. Consider: \n\n// 'foo' labeled-toop \nfoo: for (var 1=0; i<4; 1++) { \nfor (var j=0; j<4; j++) { \n\n// whenever the loops meet, continue outer loop \n\nif (j == i) { \n\n// jump to the next Iteration of \n// the 'foo' labeled-loop \ncontinue foo; \n\n} \n\n// skip odd multiples \n\nIf ((j * 1) % 2 == 1) { \n\n// normal (nonlabeled) 'continue' of Inner loop \ncontinue; \n\n} \n\nconsole.log( 1, j ); \n\n} \n\n} \n\n// 1 0 \n// 2 0 \n// 2 1 \n// 3 0 \n// 3 2 \n\n\n\ncontinue foo does not mean “go to the foo \nlabeled position to continue,” but rather, “con¬ \ntinue the loop that is labeled foo with its next \niteration.” So, it’s not really an arbitrary goto. \n\n\nAs you can see, we skipped over the odd-multiple 3 1 iteration, but \nthe labeled-loop jump also skipped iterations 1 1 and 2 2.","metadata":{"loc":{"lines":{"from":70916,"to":70965}}}}],["913",{"pageContent":"As you can see, we skipped over the odd-multiple 3 1 iteration, but \nthe labeled-loop jump also skipped iterations 1 1 and 2 2. \n\nPerhaps a slightly more useful form of the labeled-loop jump is with \nbreak_from inside an inner loop where you want to break out of \n\n\n132 | Chapter 5: Grammar \n\n\n\n\nthe outer loop. Without a labeled break, this same logic could some¬ \ntimes be rather awkward to write: \n\n// 'foo' labeled-toop \nfoo: for (var 1=0; i<4; i++) { \nfor (var j=0; j<4; j++) { \nif ((i * j) >= 3) { \n\nconsole.log( \"stopping!\", i, j ); \nbreak foo; \n\n} \n\nconsole.log( i, j ); \n\n} \n\n} \n\n// 0 0 \n// 0 1 \n// 0 2 \n// O 3 \n// 1 0 \n// 1 1 \n// 1 2 \n\n// stopping! 1 3 \n\n\n\nbreak foo does not mean “go to the foo labeled \nposition to continue,” but rather, “break out of \nthe loop/block that is labeled foo and continue \nafter it.” Not exactly a goto in the traditional \nsense, huh?","metadata":{"loc":{"lines":{"from":70965,"to":71012}}}}],["914",{"pageContent":"The nonlabeled break alternative to the above would probably need \nto involve one or more functions, shared scope variable access, etc. \nIt would quite likely be more confusing than labeled break, so here \nusing a labeled break is perhaps the better option. \n\nA label can apply to a nonloop block, but only break can reference \n\nsuch a nonloop label. You can do a labeled break _out of any \n\nlabeled block, but you cannot continue _a nonloop label, nor \n\ncan you do a nonlabeled break out of a block: \n\n// 'bar' labeled-block \nfunction foo() { \nbar: { \n\nconsole.log( \"Hello\" ); \nbreak bar; \n\nconsole.log( \"never runs\" ); \n\n} \n\nconsole.log( \"World\" ); \n\n} \n\n\nStatements & Expressions | 133 \n\n\n\n\nfoo(); \n\n// Hello \n// World","metadata":{"loc":{"lines":{"from":71015,"to":71052}}}}],["915",{"pageContent":"console.log( \"Hello\" ); \nbreak bar; \n\nconsole.log( \"never runs\" ); \n\n} \n\nconsole.log( \"World\" ); \n\n} \n\n\nStatements & Expressions | 133 \n\n\n\n\nfoo(); \n\n// Hello \n// World \n\nLabeled loops/blocks are extremely uncommon, and often frowned \nupon. It’s best to avoid them if possible; for example, by using func¬ \ntion calls instead of the loop jumps. But there are perhaps some \nlimited cases where they might be useful. If you’re going to use a \nlabeled jump, make sure to document what you’re doing with plenty \nof comments! \n\nIt’s a very common belief that JSON is a proper subset of JS, so a \nstring of JSON (like (\"a\":42} —notice the quotes around the prop¬ \nerty name as JSON requires!) is thought to be a valid JavaScript pro¬ \ngram. Not true! Try putting {\"a\":42} into your JS console, and \nyou’ll get an error. \n\nThat’s because statement labels cannot have quotes around them, so \n\" a\" is not a valid label, and thus : can’t come right after it.","metadata":{"loc":{"lines":{"from":71052,"to":71088}}}}],["916",{"pageContent":"That’s because statement labels cannot have quotes around them, so \n\" a\" is not a valid label, and thus : can’t come right after it. \n\nSo, JSON is truly a subset of JS syntax, but JSON is not valid JS \ngrammar by itself. \n\nOne extremely common misconception along these lines is that if \nyou were to load a JS file into a <script src=. .> tag that only has \nJSON content in it (like from an API call), the data would be read as \nvalid JavaScript but just be inaccessible to the program. JSON-P (the \npractice of wrapping the JSON data in a function call, like \nfoo({\"a\" :42})) is usually said to solve this inaccessibility by send¬ \ning the value to one of your program’s functions.","metadata":{"loc":{"lines":{"from":71088,"to":71100}}}}],["917",{"pageContent":"Not true! The totally valid JSON value {\"a\":42} by itself would \nactually throw a JS error because it’d be interpreted as a statement \nblock with an invalid label. But foo({\"a\": 42} ) is valid JS because in \nit, {\"a\":42} is an object literal value being passed to foo( ..). So, \nproperly said, JSON-P makes JSON into valid JS grammar! \n\nBlocks \n\nAnother commonly cited JS gotcha (related to coercion—see Chap¬ \nter 4) is: \n\n11 + {}; // \"[object Object]\" \n\nO + []; // 0 \n\n\n134 | Chapter 5: Grammar \n\n\n\n\nThis seems to imply the + operator gives different results depending \non whether the first operand is the [ ] or the {}. But that actually has \nnothing to do with it! \n\nOn the first line, {} appears in the + operators expression, and is \ntherefore interpreted as an actual value (an empty object). Chap¬ \nter 4 explained that [] is coerced to \"\" and thus {} is coerced to a \nstring value as well: \"[object Object]\".","metadata":{"loc":{"lines":{"from":71102,"to":71130}}}}],["918",{"pageContent":"But on the second line, {} is interpreted as a standalone {} empty \nblock (which does nothing). Blocks don’t need semicolons to termi¬ \nnate them, so the lack of one here isn’t a problem. Finally, + [ ] is an \nexpression that explicitly coerces (see Chapter 4) the [] to a number, \nwhich is the 0 value. \n\nObject destructuring \n\nStarting with ES6, another place that you’ll see { .. } pairs showing \nup is with “destructuring assignments” (see the ES6 & Beyond title in \nthis series for more info), specifically object destructuring. Con¬ \nsider: \n\nfunction getData() { \n\n\n// ■■ \nreturn { \n\n\na: 42, \nb: \"foo \n\n\n}; \n\n\n} \n\n\nvar { a, b } = getData(); \nconsole.log( a, b ); // 42 \"foo\" \n\nAs you can probably tell, var{a,b}=..isa form of ES6 \ndestructuring assignment, which is rougly equivalent to: \n\nvar res = getDataQ; \nvar a = res.a; \nvar b = res.b; \n\n\n\nbe become the preferred form.","metadata":{"loc":{"lines":{"from":71132,"to":71174}}}}],["919",{"pageContent":"var res = getDataQ; \nvar a = res.a; \nvar b = res.b; \n\n\n\nbe become the preferred form. \n\n\n{ a, b } is actually ES6 destructuring short¬ \nhand for { a: a, b: b }, so either will work, \nbut it’s expected that the shorter { a, b } will \n\n\nStatements & Expressions | 135 \n\n\n\n\n\n\nObject destructuring with a { .. } pair can also be used for named \nfunction arguments, which is sugar for this same sort of implicit \nobject property assignment: \n\nfunction foo({ a, b, c }) { \n\n// no need for: \n\n// var a = obj.a, b = obj.b, c = obj.c \nconsole.log( a, b, c ); \n\n} \n\nfoo( { \n\nc: [1,2,3], \na: 42, \nb: \"foo\" \n\n} ); // 42 \"foo\" [1, 2, 3] \n\nSo, the context we use { .. } pairs in entirely determines what they \nmean, which illustrates the difference between syntax and grammar. \nIt’s very important to understand these nuances to avoid unexpected \ninterpretations by the JS engine. \n\nelse if and optional blocks \n\nIt’s a common misconception that JavaScript has an else If clause, \nbecause you can do: \n\nif (a) {","metadata":{"loc":{"lines":{"from":71174,"to":71226}}}}],["920",{"pageContent":"else if and optional blocks \n\nIt’s a common misconception that JavaScript has an else If clause, \nbecause you can do: \n\nif (a) { \n\n// ■■ \n\n} \n\nelse if (b) { \n\n// \n\n} \n\nelse { \n\n// •• \n\n} \n\nBut there’s a hidden characteristic of the JS grammar here: there is \nno else If. But If and else statements are allowed to omit the { } \naround their attached block if they only contain a single statement. \nYou’ve seen this many times before, undoubtedly: \n\nif (a) doSomething( a ); \n\nMany JS style guides will insist that you always use { } around a sin¬ \ngle statement block, like: \n\nif (a) { doSonething( a ); } \n\nHowever, the exact same grammar rule applies to the else clause, so \nthe else if form you’ve likely always coded is actually parsed as: \n\n\n136 | Chapter 5: Grammar \n\n\n\nIf (a) { \n\n// ■■ \n\n} \n\nelse { \n\nif (b) { \n\n// •• \n\n} \n\nelse { \n\n// •• \n\n} \n\n}","metadata":{"loc":{"lines":{"from":71226,"to":71289}}}}],["921",{"pageContent":"136 | Chapter 5: Grammar \n\n\n\nIf (a) { \n\n// ■■ \n\n} \n\nelse { \n\nif (b) { \n\n// •• \n\n} \n\nelse { \n\n// •• \n\n} \n\n} \n\nThe if (b) { .. } else { .. } is a single statement that follows \nthe else, so you can either put the surrounding { } in or not. In \nother words, when you use else if, you’re technically breaking that \ncommon style guide rule and just defining your else with a single \nif statement. \n\nOf course, the else if idiom is extremely common and results in \none less level of indentation, so it’s attractive. Whichever way you do \nit, just call out explicitly in your own style guide/rules and don’t \nassume things like else if are direct grammar rules. \n\nOperator Precedence \n\nAs we covered in Chapter 4, JavaScript’s version of && and | | are \ninteresting in that they select and return one of their operands, \nrather than just resulting in true or false. That’s easy to reason \nabout if there are only two operands and one operator: \n\nvar a = 42; \nvar b = \"foo\";","metadata":{"loc":{"lines":{"from":71289,"to":71334}}}}],["922",{"pageContent":"var a = 42; \nvar b = \"foo\"; \n\na && b; // \"foo\" \na || b; // 42 \n\nBut what about when there’s two operators involved, and three \noperands? \n\nvar a = 42; \nvar b = \"foo\"; \nvar c = [1,2,3]; \n\na && b || c; // ??? \na || b && c; // ??? \n\n\nOperator Precedence | 137 \n\n\n\n\nTo understand what those expressions result in, we’re going to need \nto understand what rules govern how the operators are processed \nwhen there’s more than one present in an expression. \n\nThese rules are called “operator precedence.” \n\nI bet most readers feel they have a decent grasp on operator prece¬ \ndence. But as with everything else we’ve covered in this series, we’re \ngoing to poke and prod at that understanding to see just how solid it \nreally is, and hopefully learn a few new things along the way. \n\nRecall the example from above: \n\nvar a = 42 , b; \nb = ( a++, a ); \n\na; // 43 \nb; // 43 \n\nBut what would happen if we remove the ( ) ? \n\nvar a = 42 , b; \nb = a++, a; \n\na; // 43 \nb; // 42","metadata":{"loc":{"lines":{"from":71334,"to":71381}}}}],["923",{"pageContent":"Recall the example from above: \n\nvar a = 42 , b; \nb = ( a++, a ); \n\na; // 43 \nb; // 43 \n\nBut what would happen if we remove the ( ) ? \n\nvar a = 42 , b; \nb = a++, a; \n\na; // 43 \nb; // 42 \n\nWait! Why did that change the value assigned to b? \n\nBecause the , operator has a lower precedence than the = operator. \nSo, b = a++, a is interpreted as (b = a++), a. Because (as we \nexplained earlier) a++ has after side effects, the assigned value to b is \nthe value 42 before the ++ changes a. \n\nThis is just a simple matter of needing to understand operator \nprecedence. If you’re going to use , as a statement-series operator, \nit’s important to know that it actually has the lowest precedence. \nEvery other operator will more tightly bind than , will. \n\nNow, recall this example from above: \n\nIf (str && (matches = str.match( /[aeiou]/g ))) { \n\n// \n\n}","metadata":{"loc":{"lines":{"from":71381,"to":71415}}}}],["924",{"pageContent":"Now, recall this example from above: \n\nIf (str && (matches = str.match( /[aeiou]/g ))) { \n\n// \n\n} \n\nWe said the ( ) around the assignment is required, but why? \nBecause && has higher precedence than =, so without the ( ) to force \nthe binding, the expression would instead be treated as (str && \nmatches) = str.match... But this would be an error, because the \n\n\n138 | Chapter 5: Grammar \n\n\n\nresult of (str && matches) isn’t going to be a variable, but instead a \nvalue (in this case undefined), and so it can’t be the lefthand side of \nan = assignment! \n\nOK, so you probably think you’ve got this operator precedence thing \ndown. \n\nLet’s move on to a more complex example (which we’ll carry \nthroughout the next several sections of this chapter) to really test \nyour understanding: \n\nvar a = 42; \nvar b = \"foo\"; \nvar c = false; \n\nvar d=a&&b||c?c||b?a:c&&b:a; \nd; // ??","metadata":{"loc":{"lines":{"from":71415,"to":71449}}}}],["925",{"pageContent":"var a = 42; \nvar b = \"foo\"; \nvar c = false; \n\nvar d=a&&b||c?c||b?a:c&&b:a; \nd; // ?? \n\nOK, evil, I admit it. No one would write a string of expressions like \nthat, right? Probably not, but we’re going to use it to examine various \nissues around chaining multiple operators together, which is a very \ncommon task. \n\nThe result above is 42. But that’s not nearly as interesting as how we \ncan figure out that answer without just plugging it into a JS program \nto let JavaScript sort it out. \n\nLet’s dig in. \n\nThe first question—it may not have even occurred to you to ask—is, \ndoes the first part (a && b | | c) behave like (a && b) || cor like \na && (b || c)? Do you know for certain? Can you even convince \nyourself they are actually different? \n\n(false && true) || true; // true \nfalse && (true || true); // false \n\nSo, there’s proof they’re different. But still, how does false && true \n| | true behave? The answer: \n\nfalse && true || true; // true \n\n(false && true) || true; // true","metadata":{"loc":{"lines":{"from":71449,"to":71480}}}}],["926",{"pageContent":"So, there’s proof they’re different. But still, how does false && true \n| | true behave? The answer: \n\nfalse && true || true; // true \n\n(false && true) || true; // true \n\nSo we have our answer. The && operator is evaluated first and the | | \noperator is evaluated second. \n\nBut is that just because of left-to-right processing? Let’s reverse the \norder of operators: \n\n\nOperator Precedence | 1B9 \n\n\n\ntrue || false && false; \n\n\n// true \n\n\n(true || false) && false; // false--nope \n\ntrue || (false && false); // true--winner, winner! \n\nNow we’ve proved that && is evaluated first and then | |, and in this \ncase that was actually counter to generally expected left-to-right pro¬ \ncessing. \n\nSo what caused the behavior? Operator precedence. \n\nEvery language defines its own operator precedence list. It’s dismay¬ \ning, though, just how uncommon it is that JS developers have read \nJS’s list.","metadata":{"loc":{"lines":{"from":71480,"to":71516}}}}],["927",{"pageContent":"Every language defines its own operator precedence list. It’s dismay¬ \ning, though, just how uncommon it is that JS developers have read \nJS’s list. \n\nIf you knew it well, the above examples wouldn’t have tripped you \nup in the slightest, because you’d already know that && is more prec¬ \nedent than | |. But I bet a fair amount of readers had to think about \nit a little bit. \n\n\n\nUnfortunately, the JS spec doesn’t really have its \noperator precedence list in a convenient, single \nlocation. You have to parse through and under¬ \nstand all the grammar rules. So we’ll try to lay \nout the more common and useful bits here in a \nmore convenient format. For a complete list of \noperator precedence, see “Operator Precedence” \non the MDN site. \n\n\nShort Circuited \n\nIn Chapter 4, we mentioned the “short circuiting” nature of opera¬ \ntors like && and | | in a sidenote. Let’s revisit that in more detail now.","metadata":{"loc":{"lines":{"from":71516,"to":71540}}}}],["928",{"pageContent":"Short Circuited \n\nIn Chapter 4, we mentioned the “short circuiting” nature of opera¬ \ntors like && and | | in a sidenote. Let’s revisit that in more detail now. \n\nFor both && and | | operators, the righthand operand will not be \nevaluated if the lefthand operand is sufficient to determine the out¬ \ncome of the operation. Hence, the name “short circuited” (in that if \npossible, it will take an early shortcut out). \n\nFor example, with a && b, b is not evaluated if a is falsy, because the \nresult of the && operand is already certain, so there’s no point in \nbothering to check b. Likewise, with a | | b, if a is truthy, the result \nof the operand is already certain, so there’s no reason to check b. \n\nThis short circuiting can be very helpful and is commonly used: \n\n\n140 | Chapter 5: Grammar \n\n\n\n\n\nfunction doSonething(opts) { \nif (opts && opts.cool) { \n\n// •• \n\n} \n\n}","metadata":{"loc":{"lines":{"from":71540,"to":71571}}}}],["929",{"pageContent":"This short circuiting can be very helpful and is commonly used: \n\n\n140 | Chapter 5: Grammar \n\n\n\n\n\nfunction doSonething(opts) { \nif (opts && opts.cool) { \n\n// •• \n\n} \n\n} \n\nThe opts part of the opts && opts. cool test acts as sort of a guard, \nbecause if opts is unset (or is otherwise not an object), the expres¬ \nsion opts. cool would throw an error. The opts test failing plus the \nshort circuiting means that opts.cool won’t even be evaluated, thus \nno error! \n\nSimilarly, you can use | | short circuiting: \n\nfunction doSomething(opts) { \n\nif (opts.cache | | primeCacheQ) { \n\n// •• \n\n} \n\n} \n\nHere, we’re checking for opts.cache first, and if it’s present, we \ndon’t call the primeCacheQ function, thus avoiding potentially \nunnecessary work. \n\nTighter Binding","metadata":{"loc":{"lines":{"from":71571,"to":71611}}}}],["930",{"pageContent":"// •• \n\n} \n\n} \n\nHere, we’re checking for opts.cache first, and if it’s present, we \ndon’t call the primeCacheQ function, thus avoiding potentially \nunnecessary work. \n\nTighter Binding \n\nBut let’s turn our attention back to that earlier complex statement \nexample with all the chained operators, specifically the ? : ternary \noperator parts. Does the ? : operator have more or less precedence \nthan the && and | | operators? \n\na&&b||c?c||b?a:c&&b:a \nIs that more like this? \n\na && b || (c ? c || (b ? a : c) && b : a) \n\nOr more like this? \n\n(a && b || c) ? (c || b) ? a : (c && b) : a \nThe answer is the second one. But why? \n\nBecause && is more precedent than | |, and | | is more precedent \nthan ? :. \n\nSo, the expression (a && b | | c) is evaluated first before the ? : it \nparticipates in. Another way this is commonly explained is that && \nand | | “bind more tightly” than ? :. If the reverse was true, then \n\n\nOperator Precedence | 141","metadata":{"loc":{"lines":{"from":71611,"to":71646}}}}],["931",{"pageContent":"Operator Precedence | 141 \n\n\n\nc ? c... would bind more tightly, and it would behave (as the first \nchoice) like a && b || (c ? c..). \n\nAssociativity \n\nSo, the && and | | operators bind first, then the ? : operator. But \nwhat about multiple operators of the same precedence? Do they \nalways process left-to-right or right-to-left? \n\nIn general, operators are either left-associative or right-associative, \nreferring to whether grouping happens from the left or from the \nright. \n\nIt’s important to note that associativity is not the same thing as left- \nto-right or right-to-left processing. \n\nBut why does it matter whether processing is left-to-right or right- \nto-left? Because expressions can have side effects, like for instance \nwith function calls: \n\nvar a = foo() && bar(); \n\nHere, foo() is evaluated first, and then possibly bar( ) depending on \nthe result of the foo() expression. That definitely could result in dif¬ \nferent program behavior than if bar( ) was called before foo().","metadata":{"loc":{"lines":{"from":71646,"to":71674}}}}],["932",{"pageContent":"But this behavior is just left-to-right processing (the default behavior \nin JavaScript!)—it has nothing to do with the associativity of &&. In \nthat example, since there’s only one && and thus no relevant group¬ \ning here, associativity doesn’t even come into play. \n\nBut with an expression like a && b && c, grouping will happen \nimplicitly, meaning that either a && b or b && c will be evaluated \nfirst. \n\nTechnically, a && b && c will be handled as (a && b) && c, \nbecause && is left-associative (so is | |, by the way). However, the \nright-associative alternative a && ( b && c) behaves observably the \nsame way. For the same values, the same expressions are evaluated \nin the same order. \n\n\n142 | Chapter 5: Grammar","metadata":{"loc":{"lines":{"from":71676,"to":71692}}}}],["933",{"pageContent":"142 | Chapter 5: Grammar \n\n\n\n\nIf hypothetically && was right-associative, it \nwould be processed the same as if you manually \nused ( ) to create a grouping like a && (b && \nc). But that still doesn’t mean that c would be \nprocessed before b. Right-associativity does not \nmean right-to-left evaluation, it means right-to- \nleft grouping. Either way, regardless of the \ngrouping/associativity, the strict ordering of \nevaluation will be a, then b, then c (aka left-to- \nright). \n\n\nSo it doesn’t really matter that much that && and | | are left- \nassociative, other than to be accurate in how we discuss their defini¬ \ntions. \n\nBut that’s not always the case. Some operators would behave very \ndifferently depending on left-associativity versus right-associativity. \n\nConsider the ? : (“ternary” or “conditional”) operator: \n\na ? b : c ? d : e; \n\n? : is right-associative, so which grouping represents how it will be \nprocessed? \n\n• a ? b : (c ? d : e) \n\n• (a ? b : c) ? d : e","metadata":{"loc":{"lines":{"from":71692,"to":71725}}}}],["934",{"pageContent":"a ? b : c ? d : e; \n\n? : is right-associative, so which grouping represents how it will be \nprocessed? \n\n• a ? b : (c ? d : e) \n\n• (a ? b : c) ? d : e \n\nThe answer is a ? b : (c?d:e). Unlike with && and | | above, \nthe right-associativity here actually matters, as (a ? b : c) ? d : \ne will behave differently for some (but not all!) combinations of val¬ \nues. \n\nOne such example: \n\ntrue ? false : true ? true : true; // false \n\ntrue ? false : (true ? true : true); // false \n\n(true ? false : true) ? true : true; // true \n\nEven more nuanced differences lurk with other value combinations, \neven if the end result is the same. Consider: \n\ntrue ? false : true ? true : false; // false \n\ntrue ? false : (true ? true : false); // false \n\n(true ? false : true) ? true : false; // false \n\n\nOperator Precedence | 143 \n\n\n\n\nFrom that scenario, the same end result implies that the grouping is \nmoot. However: \n\nvar a = true, b = false, c = true, d = true, e = false;","metadata":{"loc":{"lines":{"from":71725,"to":71765}}}}],["935",{"pageContent":"Operator Precedence | 143 \n\n\n\n\nFrom that scenario, the same end result implies that the grouping is \nmoot. However: \n\nvar a = true, b = false, c = true, d = true, e = false; \n\na ? b : (c ? d : e); // false, evaluates only 'a' and b' \n\n(a ? b : c) ? d : e; // false, evaluates 'a', 'b' AND 'e' \n\nSo, we’ve clearly proved that ? : is right-associative, and that it \nactually matters with respect to how the operator behaves if chained \nwith itself. \n\nAnother example of right-associativity (grouping) is the = operator. \nRecall the chained assignment example from earlier in the chapter: \n\nvar a, b, c; \na = b = c = 42; \n\nWe asserted earlier that a = b = c = 42 is processed by first evalu¬ \nating the c = 42 assignment, then b = .. , and finally a = ... Why? \nBecause of the right-associativity, which actually treats the statement \nlike this: a = (b = (c = 42)). \n\nRemember our running complex assignment expression example \nfrom earlier in the chapter?","metadata":{"loc":{"lines":{"from":71765,"to":71795}}}}],["936",{"pageContent":"Remember our running complex assignment expression example \nfrom earlier in the chapter? \n\nvar a = 42; \nvar b = \"foo\"; \nvar c = false; \n\nvar d=a&&b||c?c||b?a:c&&b:a; \nd; // 42 \n\nArmed with our knowledge of precedence and associativity, we \nshould now be able to break the code down into its grouping behav¬ \nior like this: \n\n((a && b) || c) ? ((c || b) ? a : (c && b)) : a \nOr, to present it indented if that’s easier to understand: \n\n( \n\n(a && b) \n\nII \n\nc \n\n) \n\n? \n\n( \n\n(C II b) \n\n\n144 | Chapter 5: Grammar \n\n\n\n\n7 \n\n\na \n\n(c && b) \n\n) \n\na \n\nLet’s solve it now: \n\n1. (a && b) is \"foo\". \n\n2. \"foo\" || c is \"foo\". \n\n3. For the first ? test, \"foo\" is truthy. \n\n4. (c | | b) is \"foo\". \n\n5. For the second ? test, \"foo\" is truthy. \n\n6. a is 42. \n\nThat’s it, we’re done! The answer is 42, just as we saw earlier. That \nactually wasn’t so hard, was it? \n\nDisambiguation","metadata":{"loc":{"lines":{"from":71795,"to":71862}}}}],["937",{"pageContent":"5. For the second ? test, \"foo\" is truthy. \n\n6. a is 42. \n\nThat’s it, we’re done! The answer is 42, just as we saw earlier. That \nactually wasn’t so hard, was it? \n\nDisambiguation \n\nYou should now have a much better grasp on operator precedence \n(and associativity) and feel much more comfortable understanding \nhow code with multiple chained operators will behave. \n\nBut an important question remains: should we all write code under¬ \nstanding and perfectly relying on all the rules of operator prece¬ \ndence/associativity? Should we only use ( ) manual grouping when \nit’s necessary to force a different processing binding/order? \n\nOr, on the other hand, should we recognize that even though such \nrules are in fact learnable, there’s enough gotchas to warrant ignor¬ \ning automatic precedence/associativity? If so, should we thus always \nuse ( ) manual grouping and remove all reliance on these auto¬ \nmatic behaviors?","metadata":{"loc":{"lines":{"from":71862,"to":71884}}}}],["938",{"pageContent":"This debate is highly subjective, and heavily symmetrical to the \ndebate in Chapter 4 over implicit coercion. Most developers feel the \nsame way about both debates: either they accept both behaviors and \ncode expecting them, or they discard both behaviors and stick to \nmanual/explicit idioms. \n\n\nOperator Precedence | 145 \n\n\n\n\nOf course, I cannot answer this question definitively for the reader \nhere anymore than I could in Chapter 4. But I’ve presented you the \npros and cons, and hopefully encouraged enough deeper under¬ \nstanding that you can make informed rather than hype-driven deci¬ \nsions. \n\nIn my opinion, there’s an important middle ground. We should mix \nboth operator precedence/associativity and ( ) manual grouping \ninto our programs—I argue the same way in Chapter 4 for healthy/ \nsafe usage of implicit coercion, but certainly don’t endorse it exclu¬ \nsively without bounds.","metadata":{"loc":{"lines":{"from":71886,"to":71908}}}}],["939",{"pageContent":"For example, if (a && b && c) .. is perfectly OK to me, and I \nwouldn’t do if ((a && b) && c) .. just to explicitly call out the \nassociativity, because I think it’s overly verbose. \n\nOn the other hand, if I needed to chain two ? : conditional opera¬ \ntors together, I’d certainly use ( ) manual grouping to make it abso¬ \nlutely clear what my intended logic is. \n\nThus, my advice here is similar to that of Chapter 4: use operator \nprecedence/associativity where it leads to shorter and cleaner code, \nbut use ( ) manual grouping in places where it helps create clarity \nand reduce confusion. \n\nAutomatic Semicolons \n\nASI (Automatic Semicolon Insertion) is when JavaScript assumes a ; \nin certain places in your JS program even if you didn’t put one there. \n\nWhy would it do that? Because if you omit even a single required ; \nyour program would fail. Not very forgiving. ASI allows JS to be tol¬ \nerant of certain places where ; isn’t commonly thought to be neces¬ \nsary.","metadata":{"loc":{"lines":{"from":71910,"to":71931}}}}],["940",{"pageContent":"It’s important to note that ASI will only take effect in the presence of \na newline (aka line break). Semicolons are not inserted in the mid¬ \ndle of a line. \n\nBasically, if the JS parser parses a line where a parser error would \noccur (a missing expected ;), and it can reasonably insert one, it \ndoes so. What’s reasonable for insertion? Only if there’s nothing but \nwhitespace and/or comments between the end of some statement \nand that line’s newline/line break. \n\n\n146 | Chapter 5: Grammar \n\n\n\n\nConsider: \n\n\nvar a = 42, b \nc; \n\nShould JS treat the c on the next line as part of the var statement? It \ncertainly would if a , had come anywhere (even another line) \nbetween b and c. But since there isn’t one, JS assumes instead that \nthere’s an implied ; (at the newline) after b. Thus, c; is left as a \nstandalone expression statement. \n\nSimilarly: \n\nvar a = 42, b = \"foo\"; \na \n\nb // \"foo\" \n\nThat’s still a valid program without error, because expression state¬ \nments also accept ASI.","metadata":{"loc":{"lines":{"from":71933,"to":71969}}}}],["941",{"pageContent":"Similarly: \n\nvar a = 42, b = \"foo\"; \na \n\nb // \"foo\" \n\nThat’s still a valid program without error, because expression state¬ \nments also accept ASI. \n\nThere’s certain places where ASI is helpful, like for instance: \nvar a = 42; \ndo { \n\n// ■■ \n\n} while (a) // <-- ; expected here! \na; \n\nThe grammar requires a ; after a do..while loop, but not after \nwhile or for loops. But most developers don’t remember that! So, \nASI helpfully steps in and inserts one. \n\nAs we said earlier in the chapter, statement blocks do not require ; \ntermination, so ASI isn’t necessary: \n\nvar a = 42; \n\nwhile (a) { \n\n// ■■ \n\n}//<-- no ; expected here \na; \n\nThe other major case where ASI kicks in is with the break, con \ntinue, return, and (ES6) yield keywords: \n\nfunction foo(a) { \nif (!a) return \na *= 2; \n\n\nAutomatic Semicolons | 147 \n\n\n\n\n// .. \n\n}","metadata":{"loc":{"lines":{"from":71969,"to":72019}}}}],["942",{"pageContent":"The other major case where ASI kicks in is with the break, con \ntinue, return, and (ES6) yield keywords: \n\nfunction foo(a) { \nif (!a) return \na *= 2; \n\n\nAutomatic Semicolons | 147 \n\n\n\n\n// .. \n\n} \n\nThe return statement doesn’t carry across the newline to the a *= 2 \nexpression, as ASI assumes the ; terminating the return statement. \nOf course, return statements can easily break across multiple lines, \njust not when there’s nothing after return but the newline/line \nbreak: \n\nfunction foo(a) { \nreturn ( \n\na * 2 + 3 / 12 \n\n); \n\n} \n\nIdentical reasoning applies to break, continue, and yield. \n\nError Correction \n\nOne of the most hotly contested religious wars in the JS community \n(besides tabs versus spaces) is whether to rely heavily/exclusively on \nASI or not. \n\nMost, but not all, semicolons are optional, but the two ;s in the for \nloop header are required.","metadata":{"loc":{"lines":{"from":72019,"to":72060}}}}],["943",{"pageContent":"Most, but not all, semicolons are optional, but the two ;s in the for \nloop header are required. \n\nOn the pro side of this debate, many developers believe that ASI is a \nuseful mechanism that allows them to write more terse (and more \n“beautiful”) code by omitting all but the strictly required ; s (which \nare very few). It is often asserted that ASI makes many ;s optional, \nso a correctly written program without them is no different than a \ncorrectly written program with them. \n\nOn the con side of the debate, many other developers will assert that \nthere are too many places that can be accidental gotchas, especially \nfor newer, less experienced developers, where unintended ;s being \nmagically inserted change the meaning. Similarly, some developers \nwill argue that if they omit a semicolon, it’s a flat-out mistake, and \nthey want their tools (linters, etc.) to catch it before the JS engine \ncorrects the mistake under the covers.","metadata":{"loc":{"lines":{"from":72060,"to":72076}}}}],["944",{"pageContent":"Let me just share my perspective. A strict reading of the spec implies \nthat ASI is an “error correction” routine. What kind of error, you \nmay ask? Specifically, a parser error. In other words, in an attempt to \nhave the parser fail less, ASI lets it be more tolerant. \n\n\n148 | Chapter 5: Grammar \n\n\n148 \n\n\n\n\nBut tolerant of what? In my view, the only way a parser error occurs \nis if it’s given an incorrect/errored program to parse. So, while ASI is \nstrictly correcting parser errors, the only way it can get such errors is \nif there were first program authoring errors—omitting semicolons \nwhere the grammar rules require them. \n\nSo, to put it more bluntly, when I hear someone claim that they want \nto omit “optional semicolons,” my brain translates that claim to “I \nwant to write the most parser-broken program I can that will still \nwork.” \n\nI find that to be a ludicrous position to take and the arguments of \nsaving keystrokes and having more “beautiful code” to be weak at \nbest.","metadata":{"loc":{"lines":{"from":72078,"to":72105}}}}],["945",{"pageContent":"I find that to be a ludicrous position to take and the arguments of \nsaving keystrokes and having more “beautiful code” to be weak at \nbest. \n\nFurthermore, I don’t agree that this is the same thing as the spaces \nversus tabs debate—that it’s purely cosmetic—but rather I believe it’s \na fundamental question of writing code that adheres to grammar \nrequirements versus code that relies on grammar exceptions to just \nbarely skate through. \n\nAnother way of looking at it is that relying on ASI is essentially con¬ \nsidering newlines to be significant “whitespace.” Other languages \nlike Python have true significant whitespace. But is it really appro¬ \npriate to think of JavaScript as having significant newlines as it \nstands today? \n\nMy take: use semicolons wherever you know they are “required,” \nand limit your assumptions about ASI to a minimum. \n\nBut don’t just take my word for it. Back in 2012, Brendan Eich, the \ncreator of JavaScript, said the following:","metadata":{"loc":{"lines":{"from":72105,"to":72125}}}}],["946",{"pageContent":"But don’t just take my word for it. Back in 2012, Brendan Eich, the \ncreator of JavaScript, said the following: \n\nThe moral of this story: ASI is (formally speaking) a syntactic error \ncorrection procedure. If you start to code as if it were a universal \nsignificant-newline rule, you will get into trouble....I wish I had \nmade newlines more significant in JS back in those ten days in May, \n\n1995.. ..Be careful not to use ASI as if it gave JS significant newlines. \n\nErrors \n\nNot only does JavaScript have different subtypes of errors (TypeEr \nror, ReferenceError, SyntaxError, etc.), but also the grammar \ndefines certain errors to be enforced at compile time, as compared \nto all other errors that happen during runtime. \n\n\nErrors | 149","metadata":{"loc":{"lines":{"from":72125,"to":72143}}}}],["947",{"pageContent":"Errors | 149 \n\n\n\nIn particular, there have long been a number of specific conditions \nthat should be caught and reported as “early errors” (during compi¬ \nlation). Any straight-up syntax error is an early error (e.g., a = ,), \nbut also the grammar defines things that are syntactically valid but \ndisallowed nonetheless. \n\nSince execution of your code has not begun yet, these errors are not \ncatchable with try. .catch; instead, they will just fail the parsing/ \ncompilation of your program. \n\nThere’s no requirement in the spec about exactly \nhow browsers (and developer tools) should \nreport errors. So you may see variations across \nbrowsers in the following error examples, in the \nspecific subtype of error that is reported or what \nthe included error message text will be. \n\nOne simple example is with syntax inside a regular expression lit¬ \neral. There’s nothing wrong with the JS syntax here, but the invalid \nregex will throw an early error: \n\nvar a = /+foo/; // Error!","metadata":{"loc":{"lines":{"from":72143,"to":72168}}}}],["948",{"pageContent":"var a = /+foo/; // Error! \n\nThe target of an assignment must be an identifier (or an ES6 \ndestructuring expression that produces one or more identifiers), so \na value like 42 in that position is illegal and can be reported right \naway: \n\nvar a; \n\n42 = a; // Error! \n\nES5’s strict mode defines even more early errors. For example, in \nstrict mode, function parameter names cannot be duplicated: \n\nfunction foo(a,b,a) { } // just fine \n\nfunction bar(a,b,a) { \"use strict\"; } // Error! \n\nAnother strict mode early error is an object literal having more \nthan one property of the same name: \n\n(function(){ \n\n\"use strict\"; \n\nvar a = { \nb: 42, \nb: 43 \n\n\n\n150 | Chapter 5: Grammar \n\n\n\n\n\n}; \n\n})(); \n\n\n// Error! \n\n\n\nSemantically speaking, such errors aren’t techni¬ \ncally syntax errors but more grammar errors— \nthe above snippets are syntactically valid. But \nsince there is no GrannarError type, some \nbrowsers use SyntaxError instead. \n\n\nUsing Variables Too Early","metadata":{"loc":{"lines":{"from":72168,"to":72221}}}}],["949",{"pageContent":"Using Variables Too Early \n\nES6 defines a (frankly confusingly named) new concept called the \nTDZ (“Temporal Dead Zone”). \n\nThe TDZ refers to places in code where a variable reference cannot \nyet be made, because it hasn’t reached its required initialization. \n\nThe most clear example of this is with ES6 let block-scoping: \n\n{ \n\na = 2; // ReferenceError! \n\nlet a; \n\n} \n\nThe assigment a = 2 is accessing the a variable (which is indeed \nblock-scoped to the { .. } block) before it’s been initialized by the \nlet a declaration, so it’s in the TDZ for a and throws an error. \n\nInterestingly, while typeof has an exception to be safe for unde¬ \nclared variables (see Chapter 1), no such safety exception is made \nfor TDZ references: \n\n{ \n\ntypeof a; // undefined \n\ntypeof b; // ReferenceError! (TDZ) \n\nlet b; \n\n} \n\nFunction Arguments \n\nAnother example of a TDZ violation can be seen with ES6 default \nparameter values (see the ES6 & Beyond title in this series): \n\nvar b = 3;","metadata":{"loc":{"lines":{"from":72221,"to":72262}}}}],["950",{"pageContent":"let b; \n\n} \n\nFunction Arguments \n\nAnother example of a TDZ violation can be seen with ES6 default \nparameter values (see the ES6 & Beyond title in this series): \n\nvar b = 3; \n\nfunction foo( a = 42, b=a+b+5){ \n\n// \n\n} \n\n\nFunction Arguments | 151 \n\n\n\n\n\nThe b reference in the assignment would happen in the TDZ for the \nparameter b (not pull in the outer b reference), so it will throw an \nerror. However, the a is fine since by that time it’s past the TDZ for \nparameter a. \n\nWhen using ES6’s default parameter values, the default value is \napplied to the parameter if you either omit an argument, or you pass \nan undefined value in its place: \n\nfunction foo( a = 42, b = a + 1 ) { \nconsole.log( a, b ); \n\n} \n\n\nfoo(); // 42 43 \n\nfoo( undefined ); // 42 43 \n\nfoo( 5 ); // 5 6 \n\nfoo( void 0, 7 ); // 42 7 \n\nfoo( null ); // null 1 \n\n\n\nnull is coerced to a 0 value in the a + 1 expres¬ \nsion. See Chapter 4 for more info.","metadata":{"loc":{"lines":{"from":72262,"to":72314}}}}],["951",{"pageContent":"foo( undefined ); // 42 43 \n\nfoo( 5 ); // 5 6 \n\nfoo( void 0, 7 ); // 42 7 \n\nfoo( null ); // null 1 \n\n\n\nnull is coerced to a 0 value in the a + 1 expres¬ \nsion. See Chapter 4 for more info. \n\n\nFrom the ES6 default parameter values perspective, there’s no differ¬ \nence between omitting an argument and passing an undefined \nvalue. However, there is a way to detect the difference in some cases: \n\nfunction foo( a = 42, b = a + 1 ) { \nconsole.log( \n\narguments.length, a, b, \narguments[0], argumentsfl] \n\n); \n\n} \n\nfoo(); // 0 42 43 undefined undefined \n\nfoo( 10 ); // 1 10 11 10 undefined \n\nfoo( 10, undefined ); // 2 10 11 10 undefined \n\nfoo( 10, null ); // 2 10 null 10 null \n\nEven though the default parameter values are applied to the a and b \nparameters, if no arguments were passed in those slots, the argu \nments array will not have entries. \n\nConversely, if you pass an undefined argument explicitly, an entry \nwill exist in the arguments array for that argument, but it will be","metadata":{"loc":{"lines":{"from":72314,"to":72355}}}}],["952",{"pageContent":"Conversely, if you pass an undefined argument explicitly, an entry \nwill exist in the arguments array for that argument, but it will be \n\n\n152 | Chapter 5: Grammar \n\n\n\n\nundefined and not (necessarily) the same as the default value that \nwas applied to the named parameter for that same slot. \n\nWhile ES6 default parameter values can create divergence between \nthe arguments array slot and the corresponding named parameter \nvariable, this same disjointedness can also occur in tricky ways in \nES5: \n\n\nfunction foo(a) { \na = 42; \n\nconsole.log( arguments[0] ); \n\n1 \n\nfoo( 2 ); // 42 (linked) \n\nfoo(); // undefined (not linked) \n\nIf you pass an argument, the arguments slot and the named parame¬ \nter are linked to always have the same value. If you omit the argu¬ \nment, no such linkage occurs. \n\nBut in strict mode, the linkage doesn’t exist regardless: \n\nfunction foo(a) { \n\n\"use strict\"; \na = 42; \n\nconsole.log( arguments[0] ); \n\n1 \n\nfoo( 2 ); // 2 (not linked) \n\nfoo(); // undefined (not linked)","metadata":{"loc":{"lines":{"from":72355,"to":72401}}}}],["953",{"pageContent":"function foo(a) { \n\n\"use strict\"; \na = 42; \n\nconsole.log( arguments[0] ); \n\n1 \n\nfoo( 2 ); // 2 (not linked) \n\nfoo(); // undefined (not linked) \n\nIt’s almost certainly a bad idea to ever rely on any such linkage, and \nin fact the linkage itself is a leaky abstraction that’s exposing an \nunderlying implementation detail of the engine, rather than a prop¬ \nerly designed feature. \n\nUse of the arguments array has been deprecated (especially in favor \nof ES6 ... rest parameters—see the ES6 & Beyond title in this ser¬ \nies), but that doesn’t mean that it’s all bad.","metadata":{"loc":{"lines":{"from":72401,"to":72421}}}}],["954",{"pageContent":"Use of the arguments array has been deprecated (especially in favor \nof ES6 ... rest parameters—see the ES6 & Beyond title in this ser¬ \nies), but that doesn’t mean that it’s all bad. \n\nPrior to ES6, arguments is the only way to get an array of all passed \narguments to pass along to other functions, which turns out to be \nquite useful. You can also mix named parameters with the argu \nments array and be safe, as long as you follow one simple rule: never \nrefer to a named parameter and its corresponding arguments slot at \nthe same time. If you avoid that bad practice, you’ll never expose the \nleaky linkage behavior: \n\n\nFunction Arguments | 153 \n\n\n\n\nfunction foo(a) { \n\nconsole.log( a + arguments[l] ); // safe! \n\n} \n\nfoo( 10, 32 ); // 42 \n\ntry..finally","metadata":{"loc":{"lines":{"from":72421,"to":72447}}}}],["955",{"pageContent":"Function Arguments | 153 \n\n\n\n\nfunction foo(a) { \n\nconsole.log( a + arguments[l] ); // safe! \n\n} \n\nfoo( 10, 32 ); // 42 \n\ntry..finally \n\nYou’re probably familiar with how the try.. catch block works. But \nhave you ever stopped to consider the finally clause that can be \npaired with it? In fact, were you aware that try only requires either \ncatch or finally, though both can be present if needed? \n\nThe code in the finally clause always runs (no matter what), and it \nalways runs right after the try (and catch if present) finish, before \nany other code runs. In one sense, you can kind of think of the code \nin a finally clause as being in a callback function that will always \nbe called regardless of how the rest of the block behaves. \n\nSo what happens if there’s a return statement inside a try clause? It \nobviously will return a value, right? But does the calling code that \nreceives that value run before or after the finally? \n\nfunction foo() { \ntry { \n\nreturn 42; \n\n} \n\nfinally {","metadata":{"loc":{"lines":{"from":72447,"to":72484}}}}],["956",{"pageContent":"function foo() { \ntry { \n\nreturn 42; \n\n} \n\nfinally { \n\nconsole.log( \"Hello\" ); \n\n} \n\nconsole.log( \"never runs\" ); \n\n} \n\nconsole.log( foo() ); \n\n// Hello \n// 42 \n\nThe return 42 runs right away, which sets up the completion value \nfrom the foo() call. This action completes the try clause and the \nfinally clause immediately runs next. Only then is the foo() func¬ \ntion complete, so that its completion value is returned back for the \nconsole.log(.. ) statement to use. \n\nThe exact same behavior is true of a throw inside try: \n\nfunction fooQ { \ntry { \n\n\n154 | Chapter 5: Grammar \n\n\n\n\nthrow 42; \n\n\n} \n\nfinally { \n\nconsole.log( \"Hello\" ); \n\n} \n\nconsole.log( \"never runs\" ); \n\n} \n\nconsole.log( foo() ); \n\n// Hello \n\n// Uncaught Exception: 42","metadata":{"loc":{"lines":{"from":72484,"to":72542}}}}],["957",{"pageContent":"154 | Chapter 5: Grammar \n\n\n\n\nthrow 42; \n\n\n} \n\nfinally { \n\nconsole.log( \"Hello\" ); \n\n} \n\nconsole.log( \"never runs\" ); \n\n} \n\nconsole.log( foo() ); \n\n// Hello \n\n// Uncaught Exception: 42 \n\nNow, if an exception is thrown (accidentally or intentionally) inside \na finally clause, it will override as the primary completion of that \nfunction. If a previous return in the try block had set a completion \nvalue for the function, that value will be abandoned: \n\nfunction foo() { \ntry { \n\nreturn 42; \n\n} \n\nfinally { \n\nthrow \"Oops!\"; \n\n} \n\nconsole.log( \"never runs\" ); \n\n} \n\nconsole.log( foo() ); \n\n// Uncaught Exception: Oops! \n\nIt shouldn’t be surprising that other nonlinear control statements \nlike continue and break exhibit similar behavior to return and \nthrow: \n\nfor (var i=0; i<10; i++) { \ntry { \n\ncontinue; \n\n} \n\nfinally { \n\nconsole.log( i ); \n\n} \n\n} \n\n// 0 123456789","metadata":{"loc":{"lines":{"from":72542,"to":72613}}}}],["958",{"pageContent":"for (var i=0; i<10; i++) { \ntry { \n\ncontinue; \n\n} \n\nfinally { \n\nconsole.log( i ); \n\n} \n\n} \n\n// 0 123456789 \n\nThe console.log(l) statement runs at the end of the loop iteration, \nwhich is caused by the continue statement. However, it still runs \nbefore the i++ iteration update statement, which is why the values \nprinted are 0.. 9 instead of 1.. 10. \n\n\ntry..finally | 155 \n\n\n\n\nES6 adds a yield statement, in generators (see \nthe Async & Performance title in this series) \nwhich in some ways can be seen as an inter¬ \nmediate return statement. However, unlike a \nreturn, a yield isn’t complete until the genera¬ \ntor is resumed, which means a try { \nyield .. } has not completed. So an attached \nfinally clause will not run right after the yield \nlike it does with return. \n\n\nA return inside a finally has the special ability to override a previ¬ \nous return from the try or catch clause, but only if return is \nexplicitly called: \n\nfunction foo() { \ntry { \n\nreturn 42; \n\n} \n\nfinally {","metadata":{"loc":{"lines":{"from":72613,"to":72663}}}}],["959",{"pageContent":"function foo() { \ntry { \n\nreturn 42; \n\n} \n\nfinally { \n\n// no 'return ..' here, so no override \n\n} \n\n} \n\nfunction bar() { \ntry { \n\nreturn 42; \n\n} \n\nfinally { \n\n// override previous 'return 42' \nreturn; \n\n} \n\n} \n\nfunction baz() { \ntry { \n\nreturn 42; \n\n} \n\nfinally { \n\n// override previous 'return 42' \nreturn \"Hello\"; \n\n} \n\n} \n\nfoo(); // 42 \n\nbar(); // undefined \n\nbaz(); // Hello \n\n\n156 | Chapter 5: Grammar \n\n\n\n\n\nNormally, the omission of return in a function is the same as \nreturn; or even return undefined;, but inside a finally block the \nomission of return does not act like an overriding return unde \nfined; it just lets the previous return stand. \n\nIn fact, we can really up the craziness if we combine finally with \nlabeled break (see “Labels” on page 131): \n\nfunction foo() { \nbar: { \n\ntry { \n\nreturn 42; \n\n} \n\nfinally { \n\n// break out of 'bar' labeled block \nbreak bar; \n\n} \n\n} \n\nconsole.log( \"Crazy\" ); \nreturn \"Hello\"; \n\n1 \n\nconsole.log( foo() ); \n\n// Crazy \n// Hello","metadata":{"loc":{"lines":{"from":72663,"to":72757}}}}],["960",{"pageContent":"try { \n\nreturn 42; \n\n} \n\nfinally { \n\n// break out of 'bar' labeled block \nbreak bar; \n\n} \n\n} \n\nconsole.log( \"Crazy\" ); \nreturn \"Hello\"; \n\n1 \n\nconsole.log( foo() ); \n\n// Crazy \n// Hello \n\nBut... don’t do this. Seriously. Using a finally + labeled break to \neffectively cancel a return is doing your best to create the most con¬ \nfusing code possible. I’d wager no amount of comments will redeem \nthis code. \n\nswitch \n\nLet’s briefly explore the switch statement, a sort-of syntactic short¬ \nhand for an if.. else if.. else.. statement chain: \n\nswitch (a) { \n\ncase 2: \n\n// do something \nbreak; \n\ncase 42: \n\n// do another thing \nbreak; \n\ndefault: \n\n// fallback to here \n\n\n1 \n\n\n\n\nAs you can see, it evaluates a once, then matches the resulting value \nto each case expression (just simple value expressions here). If a \nmatch is found, execution will begin in that matched case, and will \neither go until a break is encountered or until the end of the switch \nblock is found.","metadata":{"loc":{"lines":{"from":72757,"to":72818}}}}],["961",{"pageContent":"That much may not surprise you, but there are several quirks about \nswitch you may not have noticed before. \n\nFirst, the matching that occurs between the a expression and each \ncase expression is identical to the === algorithm (see Chapter 4). \nOften times switches are used with absolute values in case state¬ \nments, as shown above, so strict matching is appropriate. \n\nHowever, you may wish to allow coercive equality (aka ==, see Chap¬ \nter 4), and to do so you’ll need to sort of “hack” the switch state¬ \nment a bit: \n\nvar a = \"42\"; \n\nswitch (true) { \n\ncase a == 10: \n\nconsole.tog( \"10 or '10'\" ); \nbreak; \n\ncase a == 42: \n\nconsole.tog( \"42 or '42'\" ); \nbreak; \n\ndefault: \n\n// never gets here \n\n} \n\n// 42 or '42' \n\nThis works because the case clause can have any expression (not \njust simple values), which means it will strictly match that expres¬ \nsion’s result to the test expression (true). Since a == 42 results in \ntrue here, the match is made.","metadata":{"loc":{"lines":{"from":72820,"to":72857}}}}],["962",{"pageContent":"Despite ==, the switch matching itself is still strict, between true \nand true here. If the case expression resulted in something that was \ntruthy but not strictly true (see Chapter 4), it wouldn’t work. This \ncan bite you if you’re for instance using a “logical operator” like 11 \nor && in your expression: \n\nvar a = \"hello world\"; \nvar b = 10; \n\nswitch (true) { \n\n\n158 | Chapter 5: Grammar \n\n\n\n\ncase (a || b == 10): \n\n// never gets here \nbreak; \n\ndefault: \n\nconsole.log( \"Oops\" ); \n\n} \n\n// Oops \n\nSince the result of (a | | b == 10) is \"hello world\" and not true, \nthe strict match fails. In this case, the fix is to force the expression \nexplicitly to be a true or false, such as case !! (a | | b == 10): \n(see Chapter 4). \n\nLastly, the default clause is optional, and it doesn’t necessarily have \nto come at the end (although that’s the strong convention). Even in \nthe default clause, the same rules apply about encountering a break \nor not: \n\nvar a = 10; \n\nswitch (a) { \n\ncase 1: \ncase 2:","metadata":{"loc":{"lines":{"from":72859,"to":72904}}}}],["963",{"pageContent":"var a = 10; \n\nswitch (a) { \n\ncase 1: \ncase 2: \n\n// never gets here \n\ndefault: \n\nconsole.log( \"default\" ); \n\ncase 3: \n\nconsole.log( \"3\" ); \nbreak; \n\ncase 4: \n\nconsole.log( \"4\" ); \n\n} \n\n// default \n\n// 3 \n\n\n\nAs discussed previously about labeled breaks, \nthe break inside a case clause can also be \nlabeled. \n\n\nThe way this snippet processes is that it passes through all the case \nclause matching first, finds no match, then goes back up to the \ndefault clause and starts executing. Since there’s no break there, it \ncontinues executing in the already skipped over case 3 block, \nbefore stopping once it hits that break. \n\n\nswitch | 159 \n\n\n\n\n\nWhile this sort of roundabout logic is clearly possible in JavaScript, \nthere’s almost no chance that it’s going to make for reasonable or \nunderstandable code. Be very skeptical if you find yourself wanting \nto create such circular logic flow, and if you really do, make sure you \ninclude plenty of code comments to explain what you’re up to! \n\nReview","metadata":{"loc":{"lines":{"from":72904,"to":72958}}}}],["964",{"pageContent":"Review \n\nJavaScript grammar has plenty of nuance that we as developers \nshould spend a little more time paying closer attention to than we \ntypically do. A little bit of effort goes a long way to solidifying your \ndeeper knowledge of the language. \n\nStatements and expressions have analogs in English language— \nstatements are like sentences and expressions are like phrases. \nExpressions can be pure/self-contained, or they can have side \neffects. \n\nThe JavaScript grammar layers semantic usage rules (aka context) \non top of the pure syntax. For example, { } pairs used in various \nplaces in your program can mean statement blocks, object literals, \n(ES6) destructuring assignments, or (ES6) named function argu¬ \nments.","metadata":{"loc":{"lines":{"from":72958,"to":72974}}}}],["965",{"pageContent":"JavaScript operators all have well-defined rules for precedence \n(which ones bind first before others) and associativity (how multiple \noperator expressions are implicitly grouped). Once you learn these \nrules, it’s up to you to decide if precedence/associativity are too \nimplicit for their own good, or if they will aid in writing shorter, \nclearer code. \n\nASI (Automatic Semicolon Insertion) is a parser-error-correction \nmechanism built into the JS engine, which allows it under certain \ncircumstances to insert an assumed ; in places where it is required, \nwas omitted, and where insertion fixes the parser error. The debate \nrages over whether this behavior implies that most ;s are optional \n(and can/should be omitted for cleaner code) or whether it means \nthat omitting them is making mistakes that the JS engine merely \ncleans up for you.","metadata":{"loc":{"lines":{"from":72976,"to":72990}}}}],["966",{"pageContent":"JavaScript has several types of errors, but it’s less known that it has \ntwo classifications for errors: “early” (compiler thrown, uncatchable) \nand “runtime” (try. .catchable). All syntax errors are obviously \n\n\n160 | Chapter 5: Grammar \n\n\n\nearly errors that stop the program before it runs, but there are oth¬ \ners, too. \n\nFunction arguments have an interesting relationship to their formal \ndeclared named parameters. Specifically, the arguments array has a \nnumber of gotchas of leaky abstraction behavior if you’re not care¬ \nful. Avoid arguments if you can, but if you must use it, by all means \navoid using the positional slot in arguments at the same time as \nusing a named parameter for that same argument.","metadata":{"loc":{"lines":{"from":72992,"to":73009}}}}],["967",{"pageContent":"The finally clause attached to a try (or try. .catch) offers some \nvery interesting quirks in terms of execution processing order. Some \nof these quirks can be helpful, but it’s possible to create lots of con¬ \nfusion, especially if combined with labeled blocks. As always, use \nfinally to make code better and clearer, not more clever or confus¬ \ning. \n\nThe switch offers some nice shorthand for if..else if., state¬ \nments, but beware of many common simplifying assumptions about \nits behavior. There are several quirks that can trip you up if you’re \nnot careful, but there’s also some neat hidden tricks that switch has \nup its sleeve! \n\n\nReview | 161 \n\n\n\nAPPENDIX A \n\n\nMixed Environment JavaScript","metadata":{"loc":{"lines":{"from":73011,"to":73032}}}}],["968",{"pageContent":"Review | 161 \n\n\n\nAPPENDIX A \n\n\nMixed Environment JavaScript \n\n\nBeyond the core language mechanics we’ve fully explored in this \nbook, there are several ways that your JS code can behave differently \nwhen it runs in the real world. If JS was executing purely inside an \nengine, it’d be entirely predictable based on nothing but the black- \nand-white of the spec. But JS pretty much always runs in the context \nof a hosting environment, which exposes your code to some degree \nof unpredictability. \n\nFor example, when your code runs alongside code from other sour¬ \nces, or when your code runs in different types of JS engines (not just \nbrowsers), there are some things that may behave differently. \n\nWe’ll briefly explore some of these concerns. \n\nAnnex B (ECMAScript)","metadata":{"loc":{"lines":{"from":73032,"to":73056}}}}],["969",{"pageContent":"We’ll briefly explore some of these concerns. \n\nAnnex B (ECMAScript) \n\nIt’s a little known fact that the official name of the language is \nECMAScript (referring to the ECMA standards body that manages \nit). What then is “JavaScript”? JavaScript is the common tradename \nof the language, of course, but more appropriately, JavaScript is basi¬ \ncally the browser implementation of the spec. \n\nThe official ECMAScript specification includes “Annex B,” which \ndiscusses specific deviations from the official spec for the purposes \nof JS compatibility in browsers. \n\nThe proper way to consider these deviations is that they are only \nreliably present/valid if your code is running in a browser. If your \n\n\n163 \n\n\n\n\ncode always runs in browsers, you won’t see any observable differ¬ \nence. If not (like if it can run in node.js, Rhino, etc.), or you’re not \nsure, tread carefully. \n\nThe main compatibility differences:","metadata":{"loc":{"lines":{"from":73056,"to":73083}}}}],["970",{"pageContent":"The main compatibility differences: \n\n• Octal number literals are allowed, such as 0123 (decimal 83) in \nnon-strict mode. \n\n• window.escape( ..) and window.unescape( ..) allow you to \n\nescape or unescape strings with %-delimited hexadecimal \nescape sequences. For example: window.escape( \"? \nfoo=97%&bar=3%\" ) produces \"°/o3Ffoo%3D97%25%26bar \n\n%3D3%25\". \n\n• String.prototype.substr is quite similar to String.proto \ntype.substring, except that instead of the second parameter \nbeing the ending index (noninclusive), the second parameter is \nthe length (number of characters to include). \n\n\nWeb ECMAScript \n\nThe Web ECMAScript specification covers the differences between \nthe official ECMAScript specification and the current JavaScript \nimplementations in browsers. \n\nIn other words, these items are “required” of browsers (to be com¬ \npatible with each other) but are not (as of the time of writing) listed \nin the “Annex B” section of the official spec:","metadata":{"loc":{"lines":{"from":73083,"to":73110}}}}],["971",{"pageContent":"In other words, these items are “required” of browsers (to be com¬ \npatible with each other) but are not (as of the time of writing) listed \nin the “Annex B” section of the official spec: \n\n• <! - - and - - > are valid single-line comment delimiters. \n\n• String.prototype additions for returning HTML-formatted \nstrings: anchor(..), big(..), blink(..), bold(..), fixed(..), \nfontcolor(..), fontsize(..), italics(..), llnk(..), \nsmall! • • )> strike(..), and sub(..). \n\n\n\nThese are very rarely used in practice, and \nare generally discouraged in favor of other \nbuilt-in DOM APIs or user-defined utilit¬ \nies. \n\n\n164 | Appendix A: Mixed Environment JavaScript \n\n\n\n\n\n• RegExp extensions: RegExp.$1 .. RegExp.$9 (match groups) and \nRegExp.lastMatch/RegExp[ \"$&\"] (most recent match). \n\n• Function, prototype additions: Function.prototype.argu \nments (aliases internal arguments object) and Function.caller \n(aliases internal arguments. caller).","metadata":{"loc":{"lines":{"from":73110,"to":73140}}}}],["972",{"pageContent":"• Function, prototype additions: Function.prototype.argu \nments (aliases internal arguments object) and Function.caller \n(aliases internal arguments. caller). \n\n\n\narguments and thus arguments.caller are \ndeprecated, so you should avoid using them \nif possible. That goes doubly so for these \naliases—don’t use them! \n\n\n\nSome other minor and rarely used deviations are \nnot included in our list here. See the external \n“Annex B” and “Web ECMAScript” documents \nfor more detailed information as needed. \n\n\nGenerally speaking, all these differences are rarely used, so the devi¬ \nations from the specification are not significant concerns. Just be \ncareful if you rely on any of them. \n\nHost Objects","metadata":{"loc":{"lines":{"from":73140,"to":73163}}}}],["973",{"pageContent":"Generally speaking, all these differences are rarely used, so the devi¬ \nations from the specification are not significant concerns. Just be \ncareful if you rely on any of them. \n\nHost Objects \n\nThe well-covered rules for how variables behave in JS have excep¬ \ntions to them when it comes to variables that are auto-defined, or \notherwise created and provided to JS by the environment that hosts \nyour code (browser, etc.)—so-called “host objects” (which include \nboth built-in objects and functions). \n\nFor example: \n\nvar a = document.createElement( \"dtv\" ); \n\ntypeof a; // \"object\"--as expected \n\nObject.prototype.toString.call( a ); // \"[object HTMLDivElement] \n\na.tagName; // \"DIV\" \n\na is not just an object, but a special host object because it’s a DOM \nelement. It has a different internal [[Class]] value (\"HTMLDivEle \nment\") and comes with predefined (and often unchangeable) prop¬ \nerties. \n\n\nMixed Environment JavaScript | 165","metadata":{"loc":{"lines":{"from":73163,"to":73191}}}}],["974",{"pageContent":"Mixed Environment JavaScript | 165 \n\n\n\n\n\nAnother such quirk has already been covered, in the “Falsy Objects” \nsection in Chapter 4: some objects can exist but when coerced to \nboolean they (confoundingly) will coerce to false instead of the \nexpected true. \n\nOther behavior variations with host objects to be aware of can \ninclude: \n\n• Not having access to normal object built-ins like toString() \n\n• Not being overwritable \n\n• Having certain predefined read-only properties \n\n• Having methods that cannot be this-overridden to other \nobjects \n\n• And more... \n\nHost objects are critical to making our JS code work with its sur¬ \nrounding environment. But it’s important to note when you’re inter¬ \nacting with a host object and to be careful assuming its behaviors, as \nthey will quite often not conform to regular JS objects.","metadata":{"loc":{"lines":{"from":73191,"to":73219}}}}],["975",{"pageContent":"One notable example of a host object that you probably interact with \nregularly is the console object and its various functions (log(..), \nerror(..)> etc.). The console object is provided by the hosting \nenvironment specifically so your code can interact with it for vari¬ \nous development-related output tasks. \n\nIn browsers, console hooks up to the developer tools’ console dis¬ \nplay, whereas in node.js and other server-side JS environments, con \nsole is generally connected to the standard-output (stdout) and \nstandard-error (stderr) streams of the JavaScript environment sys¬ \ntem process. \n\nGlobal DOM Variables \n\nYou’re probably aware that declaring a variable in the global scope \n(with or without var) creates not only a global variable, but also its \nmirror: a property of the same name on the global object (window \nin the browser).","metadata":{"loc":{"lines":{"from":73221,"to":73238}}}}],["976",{"pageContent":"But what may be less common knowledge is that (because of legacy \nbrowser behavior) creating DOM elements with id attributes creates \nglobal variables of those same names. For example: \n\n\n166 | Appendix A: Mixed Environment JavaScript \n\n\n\n<dlv id=\"foo\"x/div> \n\nAnd: \n\nif (typeof foo == \"undefined\") { \n\nfoo = 42; // wiii never run \n\n} \n\nconsole.log( foo ); // HTMf element \n\nYou’re perhaps used to managing global variable tests (using typeof \nor .. in window checks) under the assumption that only JS code \ncreates such variables, but as you can see, the contents of your host¬ \ning HTML page can also create them, which can easily throw off \nyour existence check logic if you’re not careful. \n\nThis is yet one more reason why you should, if at all possible, avoid \nusing global variables, and if you have to, use variables with unique \nnames that won’t likely collide. But you also need to make sure not \nto collide with the HTML content as well as any other code. \n\nNative Prototypes","metadata":{"loc":{"lines":{"from":73240,"to":73272}}}}],["977",{"pageContent":"Native Prototypes \n\nOne of the most widely known and classic pieces of JavaScript best \npractice wisdom is: never extend native prototypes. \n\nWhatever method or property name you come up with to add to \nArray. prototype that doesn’t (yet) exist, if it’s a useful addition, \nwell-designed, and properly named, there’s a strong chance it could \neventually end up being added to the spec—in which case your \nextension is now in conflict. \n\nHere’s a real example that actually happened to me that illustrates \nthis point well. \n\nI was building an embeddable widget for other websites, and my \nwidget relied on jQuery (though pretty much any framework would \nhave suffered this gotcha). It worked on almost every site, but we \nran across one where it was totally broken. \n\nAfter almost a week of analysis/debugging, I found that the site in \nquestion had, buried deep in one of its legacy files, code that looked \nlike this:","metadata":{"loc":{"lines":{"from":73272,"to":73293}}}}],["978",{"pageContent":"After almost a week of analysis/debugging, I found that the site in \nquestion had, buried deep in one of its legacy files, code that looked \nlike this: \n\n// Netscape 4 doesn't have Array.push \nArray.prototype.push = function(item) { \nthisfthis.length-1] = item; \n\n1 ; \n\n\nMixed Environment JavaScript | 167 \n\n\n\nAside from the crazy comment (who cares about Netscape 4 any¬ \nmore!?), this looks reasonable, right? \n\nThe problem is, Array.prototype.push was added to the spec \nsometime subsequent to this Netscape 4 era coding, but what was \nadded is not compatible with this code. The standard push(..) \nallows multiple items to be pushed at once. This hacked one ignores \nthe subsequent items. \n\nBasically all JS frameworks have code that relies on push(..) with \nmultiple elements. In my case, it was code around the CSS selector \nengine that was completely busted. But there could conceivably be \ndozens of other places susceptible.","metadata":{"loc":{"lines":{"from":73293,"to":73320}}}}],["979",{"pageContent":"The developer who originally wrote that push(..) hack had the \nright instinct to call it push, but didn’t foresee pushing multiple ele¬ \nments. They were certainly acting in good faith, but they created a \nlandmine that didn’t go off until almost 10 years later when I unwit¬ \ntingly came along. \n\nThere’s multiple lessons to take away on all sides. \n\nFirst, don’t extend the natives unless you’re absolutely sure your \ncode is the only code that will ever run in that environment. If you \ncan’t say that 100%, then extending the natives is dangerous. You \nmust weigh the risks. \n\nNext, don’t unconditionally define extensions (because you can \noverwrite natives accidentally). For this particular example, consider \nthe following code: \n\ntf (!Array.prototype.push) { \n\n// Netscape 4 doesn't have Array.push \nArray.prototype.push = function(iten) { \nthls[thls.length-1] = item; \n\n}; \n\n}","metadata":{"loc":{"lines":{"from":73322,"to":73347}}}}],["980",{"pageContent":"tf (!Array.prototype.push) { \n\n// Netscape 4 doesn't have Array.push \nArray.prototype.push = function(iten) { \nthls[thls.length-1] = item; \n\n}; \n\n} \n\nHere, the if statement guard would have only defined this hacked \npush() for JS environments where it didn’t exist. In my case, that \nprobably would have been OK. But even this approach is not \nwithout risk: \n\n\n168 | Appendix A: Mixed Environment JavaScript \n\n\n\n1. If the site’s code (for some crazy reason!) was relying on a \npush(..) that ignored multiple items, that code would have \nbeen broken years ago when the standard push(.. ) was rolled \nout. \n\n2. If any other library had come in and hacked in a push(..) \nahead of this if guard, and it did so in an incompatible way, \nthat would have broken the site at that time.","metadata":{"loc":{"lines":{"from":73347,"to":73374}}}}],["981",{"pageContent":"2. If any other library had come in and hacked in a push(..) \nahead of this if guard, and it did so in an incompatible way, \nthat would have broken the site at that time. \n\nWhat that highlights is an interesting question that, frankly, doesn’t \nget enough attention from JS developers: should you ever rely on \nnative built-in behavior if your code is running in any environment \nwhere it’s not the only code present? \n\nThe strict answer is no, but that’s awfully impractical. Your code \nusually can’t redefine its own private untouchable versions of all \nbuilt-in behavior relied on. Even if you could, that’s pretty wasteful. \n\nSo, should you feature-test for the built-in behavior as well as \ncompliance-test that it does what you expect? And what if that test \nfails—should your code just refuse to run? \n\n// don't trust Array.prototype.push \n(function(){ \n\nIf (Array.prototype.push) { \nvar a = []; \na.push(l,2); \n\nIf (a[0] === 1 && a[1] === 2) { \n\n// tests passed, safe to use! \nreturn; \n\n}","metadata":{"loc":{"lines":{"from":73374,"to":73403}}}}],["982",{"pageContent":"// don't trust Array.prototype.push \n(function(){ \n\nIf (Array.prototype.push) { \nvar a = []; \na.push(l,2); \n\nIf (a[0] === 1 && a[1] === 2) { \n\n// tests passed, safe to use! \nreturn; \n\n} \n\n} \n\nthrow Error( \n\n\"Array#push() is missing/broken!\" \n\n); \n\n})(); \n\nIn theory, that sounds plausible, but it’s also pretty impractical to \ndesign tests for every single built-in method. \n\nSo, what should we do? Should we trust but verify (feature- and \ncompliance-test) everything? Should we just assume existence is \ncompliance and let breakage (caused by others) bubble up as it will? \n\nThere’s no great answer. The only fact that can be observed is that \nextending native prototypes is the only way these things bite you. \n\n\nMixed Environment JavaScript | 169 \n\n\n\nIf you don’t do it, and no one else does in the code in your applica¬ \ntion, you’re safe. Otherwise, you should build in at least a little bit of \nskepticism, pessimism, and expectation of possible breakage.","metadata":{"loc":{"lines":{"from":73403,"to":73444}}}}],["983",{"pageContent":"Having a full set of unit/regression tests of your code that runs in all \nknown environments is one way to surface some of these issues ear¬ \nlier, but it doesn’t do anything to actually protect you from these \nconflicts. \n\nShims/Polyfills \n\nIt’s usually said that the only safe place to extend a native is in an \nolder (non-spec-compliant) environment, since that’s unlikely to \never change—new browsers with new spec features replace older \nbrowsers rather than amending them. \n\nIf you could see into the future, and know for sure what a future \nstandard was going to be, like for Array.prototype.foobar, it’d be \ntotally safe to make your own compatible version of it to use now, \nright? \n\ntf (!Array.prototype.foobar) { \n\n// silty, silly \n\nArray.prototype.foobar = function!) { \nthis.push( \"foo\", \"bar\" ); \n\n}; \n\n}","metadata":{"loc":{"lines":{"from":73446,"to":73472}}}}],["984",{"pageContent":"tf (!Array.prototype.foobar) { \n\n// silty, silly \n\nArray.prototype.foobar = function!) { \nthis.push( \"foo\", \"bar\" ); \n\n}; \n\n} \n\nIf there’s already a spec for Array, prototype, foobar, and the speci¬ \nfied behavior is equal to this logic, you’re pretty safe in defining such \na snippet, and in that case it’s generally called a “polyfill” (or “shim”). \n\nSuch code is very useful to include in your code base to “patch” \nolder browser environments that aren’t updated to the newest specs. \nUsing polyfills is a great way to create predictable code across all \nyour supported environments. \n\nES5-Shim is a comprehensive collection of \nshims/polyfills for bringing a project up to ES5 \nbaseline, and similarly, ES6-Shim provides \nshims for new APIs added as of ES6. While APIs \ncan be shimmed/polyfilled, new syntax generally \ncannot. To bridge the syntactic divide, you’ll \nwant to also use an ES6-to-ES5 transpiler like \nTraceur. \n\n\n\n170 | Appendix A: Mixed Environment JavaScript","metadata":{"loc":{"lines":{"from":73472,"to":73503}}}}],["985",{"pageContent":"170 | Appendix A: Mixed Environment JavaScript \n\n\n\n\n\nIf there’s likely a coming standard, and most discussions agree what \nit’s going to be called and how it will operate, creating the ahead-of- \ntime polyfill for future-facing standards compliance is called “prol- \nlyfill” (probably fill). \n\nThe real catch is if some new standard behavior can’t be (fully) poly- \nfilled/prollyfilled. \n\nThere’s debate in the community if a partial polyfill for the common \ncases is acceptable (documenting the parts that cannot be polyfil- \nled), or if a polyfill should be avoided if it can’t be 100% compliant to \nthe spec. \n\nMany developers at least accept some common partial polyfills (like \nfor instance Object.create( ..)), because the parts that aren’t cov¬ \nered are not parts they intend to use anyway.","metadata":{"loc":{"lines":{"from":73503,"to":73524}}}}],["986",{"pageContent":"Many developers at least accept some common partial polyfills (like \nfor instance Object.create( ..)), because the parts that aren’t cov¬ \nered are not parts they intend to use anyway. \n\nSome developers believe that the if guard around a polyfill/shim \nshould include some form of conformance test, replacing the exist¬ \ning method either if it’s absent or fails the tests. This extra layer of \ncompliance testing is sometimes used to distinguish a “shim” (com¬ \npliance tested) from a “polyfill” (existence checked). \n\nThe only absolute takeaway is that there is no absolute right answer \nhere. Extending natives, even when done “safely” in older environ¬ \nments, is not 100% safe. The same goes for relying upon (possibly \nextended) natives in the presence of others’ code. \n\nEither should always be done with caution, defensive code, and lots \nof obvious documentation about the risks. \n\n<script>s","metadata":{"loc":{"lines":{"from":73524,"to":73542}}}}],["987",{"pageContent":"Either should always be done with caution, defensive code, and lots \nof obvious documentation about the risks. \n\n<script>s \n\nMost browser-viewed websites/applications have more than one file \nthat contains their code, and it’s common to have a few or several \n<script src=. .></script> elements in the page that load these \nfiles separately, and even a few inline-code <script> .. </script> \nelements as well. \n\nBut do these separate files/code snippets constitute separate pro¬ \ngrams or are they collectively one JS program? \n\nThe (perhaps surprising) reality is they act more like independent JS \nprograms in most, but not all, respects. \n\n\nMixed Environment JavaScript | 171 \n\n\n\n\nThe one thing they share is the single global object (window in the \nbrowser), which means multiple files can append their code to that \nshared namespace and they can all interact.","metadata":{"loc":{"lines":{"from":73542,"to":73567}}}}],["988",{"pageContent":"The one thing they share is the single global object (window in the \nbrowser), which means multiple files can append their code to that \nshared namespace and they can all interact. \n\nSo, if one script element defines a global function foo(), when a \nsecond script later runs, it can access and call foo( ) just as if it had \ndefined the function itself. \n\nBut global variable scope hoisting (see the Scope & Closures title of \nthis series) does not occur across these boundaries, so the following \ncode would not work (because foo( )’s declaration isn’t yet declared), \nregardless of if they are (as shown) inline <scrlpt> .. </scrlpt> \nelements or externally loaded <scrlpt src=. .></scrlpt> files: \n\n<scrlpt>foo();</scrlpt> \n\n<script> \n\nfunction foo() { .. } \n\n</script> \n\nBut either of these would work instead: \n\n<script> \n\nfoo(); \n\nfunction foo() { .. } \n\n</scrlpt> \n\nOr: \n\n<scrlpt> \n\nfunction foo() { .. } \n\n</scrlpt> \n\n<scrlpt>foo();</scrlpt>","metadata":{"loc":{"lines":{"from":73567,"to":73607}}}}],["989",{"pageContent":"</script> \n\nBut either of these would work instead: \n\n<script> \n\nfoo(); \n\nfunction foo() { .. } \n\n</scrlpt> \n\nOr: \n\n<scrlpt> \n\nfunction foo() { .. } \n\n</scrlpt> \n\n<scrlpt>foo();</scrlpt> \n\nAlso, if an error occurs in a script element (inline or external), as a \nseparate standalone JS program it will fail and stop, but any subse¬ \nquent scripts will run (still with the shared global) unimpeded. \n\nYou can create script elements dynamically from your code, and \ninject them into the DOM of the page, and the code in them will \nbehave basically as if loaded normally in a separate file: \n\nvar greeting = \"Hello World\"; \n\nvar el = document.createElement( \"script\" ); \n\nel.text = \"function foo(){ alert( greeting );\\ \n\n} setTlmeout( foo, 1000 \n\n\n172 | Appendix A: Mixed Environment JavaScript \n\n\n\n\ndocument.body.appendChlld( el );","metadata":{"loc":{"lines":{"from":73607,"to":73651}}}}],["990",{"pageContent":"el.text = \"function foo(){ alert( greeting );\\ \n\n} setTlmeout( foo, 1000 \n\n\n172 | Appendix A: Mixed Environment JavaScript \n\n\n\n\ndocument.body.appendChlld( el ); \n\n\n\nOf course, if you tried the above snippet but set \nel.src to some file URL instead of setting \nel. text to the code contents, youd be dynami¬ \ncally creating an externally loaded <script \nsrc=. .x/script> element. \n\n\nOne difference between code in an inline code block and that same \ncode in an external file is that in the inline code block, the sequence \nof characters </script> cannot appear together, as (regardless of \nwhere it appears) it would be interpreted as the end of the code \nblock. So, beware of code like: \n\n<script> \n\nvar code = \"<script>alert( 'Hello World' )</script>\"; \n\n</script> \n\nIt looks harmless, but the </script> appearing inside the string \nliteral will terminate the script block abnormally, causing an error. \nThe most common workaround is: \n\n\"</sc\" + \"ript>\";","metadata":{"loc":{"lines":{"from":73651,"to":73688}}}}],["991",{"pageContent":"It looks harmless, but the </script> appearing inside the string \nliteral will terminate the script block abnormally, causing an error. \nThe most common workaround is: \n\n\"</sc\" + \"ript>\"; \n\nAlso, beware that code inside an external file will be interpreted in \nthe character set (UTF-8, ISO-8859-8, etc.) the file is served with (or \nthe default), but that same code in an inline script element in your \nHTML page will be interpreted by the character set of the page (or \nits default). \n\n\n\nThe charset attribute will not work on inline \nscript elements. \n\n\nAnother deprecated practice with inline script elements is includ¬ \ning HTML-style or X(HT)ML-style comments around inline code, \nlike: \n\n\n<script> \n\n<!-- \n\nalert( \"Hello\" ); \n\n//--> \n\n</script> \n\n\nMixed Environment JavaScript | 173 \n\n\n\n\n\n<script> \n\n<!--//-■><![CDATA[//><!- - \nalert( \"World\" ); \n//--><!]]> \n\n</script> \n\n\nBoth of these are totally unnecessary now, so if you’re still doing \nthat, stop it!","metadata":{"loc":{"lines":{"from":73688,"to":73738}}}}],["992",{"pageContent":"<script> \n\n<!--//-■><![CDATA[//><!- - \nalert( \"World\" ); \n//--><!]]> \n\n</script> \n\n\nBoth of these are totally unnecessary now, so if you’re still doing \nthat, stop it! \n\n\n\nBoth <! - - and - -> (HTML-style comments) are \nactually specified as valid single-line comment \ndelimiters (var x = 2; <!-- valid connent \nand --> another valid line connent) in \nJavaScript (see the “Web ECMAScript” section \nearlier), purely because of this old technique. \nBut never use them. \n\n\nReserved Words \n\nThe ES5 spec defines a set of “reserved words” in Section 7.6.1 that \ncannot be used as standalone variable names. Technically, there are \nfour categories: “keywords,” “future reserved words,” the null literal, \nand the true/false boolean literals.","metadata":{"loc":{"lines":{"from":73738,"to":73766}}}}],["993",{"pageContent":"Keywords are the obvious ones like function and switch. Future \nreserved words include things like enum, though many of the rest of \nthem (class, extends, etc.) are all now actually used by ES6; there \nare other strict mode-only reserved words like interface. \n\nStackOverflow user “art4theSould” creatively worked all these \nreserved words into a fun little poem: \n\nLet this long package float, \n\nGoto private class if short. \n\nWhile protected with debugger case, \n\nContinue volatile interface. \n\nInstanceof super synchronized throw, \n\nExtends final export throws. \n\nTry import double enum? \n\n- False, boolean, abstract function, \n\nImplements typeof transient break! \n\nVoid static, default do, \n\n\n174 | Appendix A: Mixed Environment JavaScript \n\n\n\n\nSwitch int native new. \n\nElse, delete null public var \nIn return for const, true, char \n...Finally catch byte. \n\n\n\nThis poem includes words that were reserved in \nES3 (byte, long, etc.) that are no longer reserved \nas of ES5.","metadata":{"loc":{"lines":{"from":73768,"to":73812}}}}],["994",{"pageContent":"This poem includes words that were reserved in \nES3 (byte, long, etc.) that are no longer reserved \nas of ES5. \n\n\nPrior to ES5, the reserved words also could not be property names \nor keys in object literals, but that restriction no longer exists. \n\nSo, this is not allowed: \n\nvar import = \"42\"; \n\nBut this is allowed: \n\nvar obj = { import: \"42\" }; \nconsole.log( obj.import ); \n\nYou should be aware though that some older browser versions \n(mainly older IE) weren’t completely consistent on applying these \nrules, so there are places where using reserved words in object prop¬ \nerty name locations can still cause issues. Carefully test all supported \nbrowser environments. \n\nImplementation Limits \n\nThe JavaScript spec does not place arbitrary limits on things such as \nthe number of arguments to a function or the length of a string lit¬ \neral, but these limits exist nonetheless, because of implementation \ndetails in different engines. \n\nFor example: \n\nfunction addAHQ { \nvar sum = 0;","metadata":{"loc":{"lines":{"from":73812,"to":73845}}}}],["995",{"pageContent":"For example: \n\nfunction addAHQ { \nvar sum = 0; \n\nfor (var 1=0; i < arguments.length; i++) { \nsum += arguments[i]; \n\n} \n\nreturn sum; \n\nI \n\nvar nums = []; \n\n\nMixed Environment JavaScript | 175 \n\n\n\n\nfor (var 1=1; 1 < 100000; 1++) { \nnums.push(t); \n\n} \n\naddAll( 2, 4, 6 ); // 12 \n\naddAll.apply( null, nuns ); // should be: 499950000 \n\nIn some JS engines, you’ll get the correct 499950000 answer, but in \nothers (like Safari 6.x), you’ll get the error “RangeError: Maximum \ncall stack size exceeded.” \n\nExamples of other limits known to exist: \n\n• Maximum number of characters allowed in a string literal (not \njust a string value) \n\n• Size (bytes) of data that can be sent in arguments to a function \ncall (aka stack size) \n\n• Number of parameters in a function declaration \n\n• Maximum depth of nonoptimized call stack (i.e., with recur¬ \nsion): how long a chain of function calls from one to the other \ncan be \n\n• Number of seconds a JS program can run continuously blocking \nthe browser","metadata":{"loc":{"lines":{"from":73845,"to":73895}}}}],["996",{"pageContent":"• Number of seconds a JS program can run continuously blocking \nthe browser \n\n• Maximum length allowed for a variable name \n\nIt’s not very common at all to run into these limits, but you should \nbe aware that limits can and do exist, and importantly that they vary \nbetween engines. \n\nReview \n\nWe know and can rely upon the fact that the JS language itself has \none standard and is predictably implemented by all the modern \nbrowsers/engines. This is a very good thing! \n\nBut JavaScript rarely runs in isolation. It runs in an environment \nmixed in with code from third-party libraries, and sometimes it \neven runs in engines/environments that differ from those found in \nbrowsers. \n\nPaying close attention to these issues improves the reliability and \nrobustness of your code. \n\n\n176 | Appendix A: Mixed Environment JavaScript \n\n\n\n\nAbout the Author","metadata":{"loc":{"lines":{"from":73895,"to":73924}}}}],["997",{"pageContent":"Paying close attention to these issues improves the reliability and \nrobustness of your code. \n\n\n176 | Appendix A: Mixed Environment JavaScript \n\n\n\n\nAbout the Author \n\n\nKyle Simpson is an Open Web Evangelist from Austin, TX. He’s pas¬ \nsionate about JavaScript, HTML5, real-time/peer-to-peer communi¬ \ncations, and web performance. Otherwise, he’s probably bored by it. \nKyle is an author, workshop trainer, tech speaker, and avid OSS \ncommunity member. \n\n\n\n\nAsync & Performance \n\n\nKyle Simpson \n\n\nBeijing • Cambridge • Farnham • Koln • Sebastopol • Tokyo \n\n\nO'REILLY \n\n\n\n\n\nTable of Contents \n\n\nForeword. v \n\nPreface.vii \n\n1. Asynchrony: Now & Later. 1 \n\nA Program in Chunks 2 \n\nEvent Loop 5 \n\nParallel Threading 8 \n\nConcurrency 13 \n\nJobs 23 \n\nStatement Ordering 24 \n\nReview 27 \n\n2. Callbacks. 29 \n\nContinuations 30 \n\nSequential Brain 31 \n\nTrust Issues 39 \n\nTrying to Save Callbacks 44 \n\nReview 48 \n\n3. Promises. 51 \n\nWhat Is a Promise? 52 \n\nThenable Duck Typing 64 \n\nPromise Trust 67","metadata":{"loc":{"lines":{"from":73924,"to":74001}}}}],["998",{"pageContent":"Continuations 30 \n\nSequential Brain 31 \n\nTrust Issues 39 \n\nTrying to Save Callbacks 44 \n\nReview 48 \n\n3. Promises. 51 \n\nWhat Is a Promise? 52 \n\nThenable Duck Typing 64 \n\nPromise Trust 67 \n\nChain Flow 76 \n\nError Handling 87 \n\nPromise Patterns 94 \n\n\niii \n\n\n\n\n\n\n\n\n\nPromise API Recap 102 \n\nPromise Limitations 106 \n\nReview 119 \n\n4. Generators. 121 \n\nBreaking Run-to-Completion 121 \n\nGenerator-ing Values 133 \n\nIterating Generators Asynchronously 141 \n\nGenerators + Promises 146 \n\nGenerator Delegation 156 \n\nGenerator Concurrency 165 \n\nThunks 170 \n\nPre-ES6 Generators 177 \n\nReview 184 \n\n5. Program Performance. 187 \n\nWeb Workers 188 \n\nSIMD 195 \n\nasm.js 197 \n\nReview 201 \n\n6. Benchmarkings Tuning.203 \n\nBenchmarking 203 \n\nContext Is King 208 \n\njsPerf.com 211 \n\nWriting Good Tests 216 \n\nMicroperformance 216 \n\nTail Call Optimization (TCO) 225 \n\nReview 228 \n\nA. asynquence Library. 229 \n\nB. Advanced Async Patterns. 253 \n\n\niv | Table of Contents \n\n\n\n\n\n\n\n\nForeword","metadata":{"loc":{"lines":{"from":74001,"to":74102}}}}],["999",{"pageContent":"Microperformance 216 \n\nTail Call Optimization (TCO) 225 \n\nReview 228 \n\nA. asynquence Library. 229 \n\nB. Advanced Async Patterns. 253 \n\n\niv | Table of Contents \n\n\n\n\n\n\n\n\nForeword \n\n\nOver the years, my employer has trusted me enough to conduct \ninterviews. If we’re looking for someone with JavaScript skills, my \nfirst line of questioning...well, actually, is to check if the candidate \nneeds the bathroom and/or a drink, because comfort is important. \nBut once I’m past the bit about the candidate’s fluid intake/output, I \nset about determining if the candidate knows JavaScript, or just \nj Query. \n\nNot that there’s anything wrong with jQuery. It lets you do a lot \nwithout really knowing JavaScript, and that’s a feature—not a bug. \nBut if the job calls for advanced skills in JavaScript performance and \nmaintainability, you need someone who knows how libraries such as \njQuery are put together. You need to be able to harness the core of \nJavaScript the same way they do.","metadata":{"loc":{"lines":{"from":74102,"to":74138}}}}],["1000",{"pageContent":"If I want to get a picture of someone’s core JavaScript skill, I’m most \ninterested in what they make of closures (you’ve read the You Don’t \nKnow JS: Scope & Closures title of this series already, right?) and \nhow to get the most out of asynchronicity, which brings us to this \nbook. \n\nFor starters, you’ll be taken through callbacks, the bread and butter \nof asynchronous programming. Of course, bread and butter does \nnot make for a particularly satisfying meal, but the next course is full \nof tasty, tasty Promises! \n\nIf you don’t know Promises, now is the time to learn. Promises are \nnow the official way to provide async return values in both Java¬ \nScript and the DOM. All future async DOM APIs will use them, and \nmany already do, so be prepared! At the time of writing, Promises \nhave shipped in most major browsers, with IE shipping soon. Once \n\n\n\n\nyou’ve finished savoring Promises, I hope you left room for the next \ncourse, Generators.","metadata":{"loc":{"lines":{"from":74140,"to":74161}}}}],["1001",{"pageContent":"you’ve finished savoring Promises, I hope you left room for the next \ncourse, Generators. \n\nGenerators snuck their way into stable versions of Chrome and \nFirefox without too much pomp and ceremony, because, frankly, \nthey’re more complicated than they are interesting. Or, that’s what I \nthought until I saw them combined with Promises. There, they \nbecome an important tool in readability and maintenance. \n\nFor dessert, well, I won’t spoil the surprise, but prepare to gaze into \nthe future of JavaScript! This book covers features that give you \nmore and more control over concurrency and asynchronicity. \n\nWell, I won’t block your enjoyment of the book any longer—on \nwith the show! If you’ve already read part of the book before reading \nthis foreword, give yourself 10 asynchronous points! You deserve \nthem! \n\n\n—Jake Archibald (http://jakearchibald.com, @jaffathecake), \nDeveloper Advocate at Google Chrome \n\n\nvi | Foreword \n\n\n\nPreface","metadata":{"loc":{"lines":{"from":74161,"to":74188}}}}],["1002",{"pageContent":"—Jake Archibald (http://jakearchibald.com, @jaffathecake), \nDeveloper Advocate at Google Chrome \n\n\nvi | Foreword \n\n\n\nPreface \n\n\nI’m sure you noticed, but “JS” in the series title is not an abbrevia¬ \ntion for words used to curse about JavaScript, though cursing at the \nlanguage’s quirks is something we can probably all identify with! \n\nFrom the earliest days of the Web, JavaScript has been a founda¬ \ntional technology that drives interactive experience around the con¬ \ntent we consume. While flickering mouse trails and annoying pop¬ \nup prompts may be where JavaScript started, nearly two decades \nlater, the technology and capability of JavaScript has grown many \norders of magnitude, and few doubt its importance at the heart of \nthe world’s most widely available software platform: the Web.","metadata":{"loc":{"lines":{"from":74188,"to":74209}}}}],["1003",{"pageContent":"But as a language, it has perpetually been a target for a great deal of \ncriticism, owing partly to its heritage but even more to its design \nphilosophy. Even the name evokes, as Brendan Eich once put it, \n“dumb kid brother” status next to its more mature older brother \nJava. But the name is merely an accident of politics and marketing. \nThe two languages are vastly different in many important ways. \n“JavaScript” is as related to “Java” as “Carnival” is to “Car.” \n\nBecause JavaScript borrows concepts and syntax idioms from sev¬ \neral languages, including proud C-style procedural roots as well as \nsubtle, less obvious Scheme/Lisp-style functional roots, it is exceed¬ \ningly approachable to a broad audience of developers, even those \nwith little to no programming experience. The “Hello World” of \nJavaScript is so simple that the language is inviting and easy to get \ncomfortable with in early exposure.","metadata":{"loc":{"lines":{"from":74209,"to":74223}}}}],["1004",{"pageContent":"While JavaScript is perhaps one of the easiest languages to get up \nand running with, its eccentricities make solid mastery of the lan¬ \nguage a vastly less common occurrence than in many other lan- \n\n\nVII \n\n\n\n\nguages. Where it takes a pretty in-depth knowledge of a language \nlike C or C++ to write a full-scale program, full-scale production \nJavaScript can, and often does, barely scratch the surface of what the \nlanguage can do. \n\nSophisticated concepts that are deeply rooted into the language tend \ninstead to surface themselves in seemingly simplistic ways, such as \npassing around functions as callbacks, which encourages the Java¬ \nScript developer to just use the language as-is and not worry too \nmuch about what’s going on under the hood.","metadata":{"loc":{"lines":{"from":74225,"to":74244}}}}],["1005",{"pageContent":"It is simultaneously a simple, easy-to-use language that has broad \nappeal, and a complex and nuanced collection of language mechan¬ \nics that without careful study will elude true understanding even for \nthe most seasoned of JavaScript developers. \n\nTherein lies the paradox of JavaScript, the Achilles’ heel of the lan¬ \nguage, the challenge we are presently addressing. Because JavaScript \ncan be used without understanding, the understanding of the lan¬ \nguage is often never attained. \n\nMission \n\nIf at every point that you encounter a surprise or frustration in Java¬ \nScript, your response is to add it to the blacklist (as some are accus¬ \ntomed to doing), you soon will be relegated to a hollow shell of the \nrichness of JavaScript. \n\nWhile this subset has been famously dubbed “The Good Parts,” I \nwould implore you, dear reader, to instead consider it the “The Easy \nParts,” “The Safe Parts,” or even “The Incomplete Parts.”","metadata":{"loc":{"lines":{"from":74244,"to":74263}}}}],["1006",{"pageContent":"While this subset has been famously dubbed “The Good Parts,” I \nwould implore you, dear reader, to instead consider it the “The Easy \nParts,” “The Safe Parts,” or even “The Incomplete Parts.” \n\nThis You Don’t Know JS series offers a contrary challenge: learn and \ndeeply understand all of JavaScript, even and especially “The Tough \nParts.” \n\nHere, we address head-on the tendency of JS developers to learn \n“just enough” to get by, without ever forcing themselves to learn \nexactly how and why the language behaves the way it does. Further¬ \nmore, we eschew the common advice to retreat when the road gets \nrough. \n\n\nviii | Preface \n\n\n\n\nI am not content, nor should you be, at stopping once something \njust works and not really knowing why. I gently challenge you to \njourney down that bumpy “road less traveled” and embrace all that \nJavaScript is and can do. With that knowledge, no technique, no \nframework, no popular buzzword acronym of the week will be \nbeyond your understanding.","metadata":{"loc":{"lines":{"from":103062,"to":103087}}}}],["1007",{"pageContent":"These books each take on specific core parts of the language that are \nmost commonly misunderstood or under-understood, and dive very \ndeep and exhaustively into them. You should come away from read¬ \ning with a firm confidence in your understanding, not just of the \ntheoretical, but the practical “what you need to know” bits. \n\nThe JavaScript you know right now is probably parts handed down \nto you by others who’ve been burned by incomplete understanding. \nThat JavaScript is but a shadow of the true language. You don’t \nreally know JavaScript yet, but if you dig into this series, you will. \nRead on, my friends. JavaScript awaits you. \n\n\nReview \n\nJavaScript is awesome. It’s easy to learn partially, and much harder \nto learn completely (or even sufficiently). When developers \nencounter confusion, they usually blame the language instead of \ntheir lack of understanding. These books aim to fix that, inspiring a \nstrong appreciation for the language you can now, and should, \ndeeply know.","metadata":{"loc":{"lines":{"from":103089,"to":103109}}}}],["1008",{"pageContent":"Many of the examples in this book assume \nmodern (and future-reaching) JavaScript engine \nenvironments, such as ES6. Some code may not \nwork as described if run in older (pre-ES6) \nengines. \n\n\nConventions Used in This Book \n\nThe following typographical conventions are used in this book: \n\nItalic \n\nIndicates new terms, URLs, email addresses, filenames, and file \nextensions. \n\n\nPreface | ix \n\n\n\n\n\n\nConstant width \n\nUsed for program listings, as well as within paragraphs to refer \nto program elements such as variable or function names, data¬ \nbases, data types, environment variables, statements, and key¬ \nwords. \n\nConstant width bold \n\nShows commands or other text that should be typed literally by \nthe user. \n\n\nConstant width italic \n\nShows text that should be replaced with user-supplied values or \nby values determined by context. \n\n\n\nThis element signifies a tip or suggestion. \n\n\nThis element signifies a general note. \n\n\nThis element indicates a warning or caution.","metadata":{"loc":{"lines":{"from":103113,"to":103163}}}}],["1009",{"pageContent":"This element signifies a tip or suggestion. \n\n\nThis element signifies a general note. \n\n\nThis element indicates a warning or caution. \n\n\nUsing Code Examples \n\nSupplemental material (code examples, exercises, etc.) is available \nfor download at http://bit.ly/ydkjs-async-code. \n\nThis book is here to help you get your job done. In general, if exam¬ \nple code is offered with this book, you may use it in your programs \nand documentation. You do not need to contact us for permission \nunless you’re reproducing a significant portion of the code. For \nexample, writing a program that uses several chunks of code from \nthis book does not require permission. Selling or distributing a CD- \nROM of examples from O’Reilly books does require permission. \nAnswering a question by citing this book and quoting example code \n\n\nx | Preface \n\n\n\n\n\n\ndoes not require permission. Incorporating a significant amount of \nexample code from this book into your product’s documentation \ndoes require permission.","metadata":{"loc":{"lines":{"from":103163,"to":103196}}}}],["1010",{"pageContent":"x | Preface \n\n\n\n\n\n\ndoes not require permission. Incorporating a significant amount of \nexample code from this book into your product’s documentation \ndoes require permission. \n\nWe appreciate, but do not require, attribution. An attribution usu¬ \nally includes the title, author, publisher, and ISBN. For example: \n“You Don’t Know JavaScript: Async & Performance by Kyle Simpson \n(O’Reilly). Copyright 2015 Getify Solutions, Inc., \n978-1-491-90422-0.” \n\nIf you feel your use of code examples falls outside fair use or the per¬ \nmission given above, feel free to contact us at permis- \nsions@oreilly.com. \n\nSafari® Books Online \n\n\n^Safari \n\n\nSafari Books Online is an on-demand digital \nlibrary that delivers expert content in both \nbook and video form from the world’s lead¬ \ning authors in technology and business.","metadata":{"loc":{"lines":{"from":103196,"to":103226}}}}],["1011",{"pageContent":"^Safari \n\n\nSafari Books Online is an on-demand digital \nlibrary that delivers expert content in both \nbook and video form from the world’s lead¬ \ning authors in technology and business. \n\n\nTechnology professionals, software developers, web designers, and \nbusiness and creative professionals use Safari Books Online as their \nprimary resource for research, problem solving, learning, and certif¬ \nication training. \n\nSafari Books Online offers a range of plans and pricing for enter¬ \nprise, government, education, and individuals.","metadata":{"loc":{"lines":{"from":103226,"to":103241}}}}],["1012",{"pageContent":"Safari Books Online offers a range of plans and pricing for enter¬ \nprise, government, education, and individuals. \n\nMembers have access to thousands of books, training videos, and \nprepublication manuscripts in one fully searchable database from \npublishers like O’Reilly Media, Prentice Hall Professional, Addison- \nWesley Professional, Microsoft Press, Sams, Que, Peachpit Press, \nFocal Press, Cisco Press, John Wiley & Sons, Syngress, Morgan \nKaufmann, IBM Redbooks, Packt, Adobe Press, FT Press, Apress, \nManning, New Riders, McGraw-Hill, Jones & Bartlett, Course Tech¬ \nnology, and hundreds more. For more information about Safari \nBooks Online, please visit us online. \n\n\nPreface | xi \n\n\n\n\n\nHow to Contact Us \n\nPlease address comments and questions concerning this book to the \npublisher: \n\nO’Reilly Media, Inc. \n\n1005 Gravenstein Highway North \nSebastopol, CA 95472 \n\n800-998-9938 (in the United States or Canada) \n\n707-829-0515 (international or local) \n\n707-829-0104 (fax)","metadata":{"loc":{"lines":{"from":103241,"to":103275}}}}],["1013",{"pageContent":"O’Reilly Media, Inc. \n\n1005 Gravenstein Highway North \nSebastopol, CA 95472 \n\n800-998-9938 (in the United States or Canada) \n\n707-829-0515 (international or local) \n\n707-829-0104 (fax) \n\nWe have a web page for this book, where we list errata, examples, \nand any additional information. You can access this page at http:// \nbit.ly/ydkjs-async-performance. \n\nTo comment or ask technical questions about this book, send email \nto bookquestions@oreilly.com. \n\nFor more information about our books, courses, conferences, and \nnews, see our website at http://www.oreilly.com. \n\nFind us on Facebook: http://facebook.com/oreilly \n\nFollow us on Twitter: http://twitter.com/oreillymedia \n\nWatch us on YouTube: http://www.youtube.com/oreillymedia \n\n\nxii | Preface \n\n\n\nCHAPTER 1 \n\n\nAsynchrony: Now & Later \n\n\nOne of the most important and yet often misunderstood parts of \nprogramming in a language like JavaScript is how to express and \nmanipulate program behavior spread out over a period of time.","metadata":{"loc":{"lines":{"from":103275,"to":103315}}}}],["1014",{"pageContent":"One of the most important and yet often misunderstood parts of \nprogramming in a language like JavaScript is how to express and \nmanipulate program behavior spread out over a period of time. \n\nThis is not just about what happens from the beginning of a for \nloop to the end of a for loop, which of course takes some time \n(microseconds to milliseconds) to complete. It’s about what hap¬ \npens when part of your program runs now, and another part of your \nprogram runs later —there’s a gap between now and later where \nyour program isn’t actively executing.","metadata":{"loc":{"lines":{"from":103315,"to":103324}}}}],["1015",{"pageContent":"Practically all nontrivial programs ever written (especially in JS) \nhave in some way or another had to manage this gap, whether that \nbe in waiting for user input, requesting data from a database or file \nsystem, sending data across the network and waiting for a response, \nor performing a repeated task at a fixed interval of time (like anima¬ \ntion). In all these various ways, your program has to manage state \nacross the gap in time. As they famously say in London (of the \nchasm between the subway door and the platform): “mind the gap.” \n\nIn fact, the relationship between the now and later parts of your pro¬ \ngram is at the heart of asynchronous programming. \n\nAsynchronous programming has been around since the beginning \nof JS, for sure. But most JS developers have never really carefully \nconsidered exactly how and why it crops up in their programs, or \nexplored various other ways to handle it. The good enough approach \n\n\n1","metadata":{"loc":{"lines":{"from":103326,"to":103344}}}}],["1016",{"pageContent":"1 \n\n\n\n\n\nhas always been the humble callback function. Many to this day will \ninsist that callbacks are more than sufficient. \n\nBut as JS continues to grow in both scope and complexity, to meet \nthe ever-widening demands of a first-class programming language \nthat runs in browsers and servers and every conceivable device in \nbetween, the pains by which we manage asynchrony are becoming \nincreasingly crippling, and they cry out for approaches that are both \nmore capable and more reason-able. \n\nWhile this all may seem rather abstract right now, I assure you we’ll \ntackle it more completely and concretely as we go on through this \nbook. We’ll explore a variety of emerging techniques for async Java¬ \nScript programming over the next several chapters. \n\nBut before we can get there, we’re going to have to understand \nmuch more deeply what asynchrony is and how it operates in JS. \n\nA Program in Chunks","metadata":{"loc":{"lines":{"from":103344,"to":103368}}}}],["1017",{"pageContent":"But before we can get there, we’re going to have to understand \nmuch more deeply what asynchrony is and how it operates in JS. \n\nA Program in Chunks \n\nYou may write your JS program in one .js file, but your program is \nalmost certainly comprised of several chunks, only one of which is \ngoing to execute now, and the rest of which will execute later. The \nmost common unit of each chunk is the function. \n\nThe problem most developers new to JS seem to have is that later \ndoesn’t happen strictly and immediately after now. In other words, \ntasks that cannot complete now are, by definition, going to complete \nasynchronously, and thus we will not have blocking behavior as you \nmight intuitively expect or want. \n\nConsider: \n\n// ajax(..) is some arbitrary Ajax function given by a library \nvar data = ajax( \"http://sone.url.1\" ); \n\nconsole.log( data ); \n\n// Oops! 'data' generally won't have the Ajax results","metadata":{"loc":{"lines":{"from":103368,"to":103391}}}}],["1018",{"pageContent":"Consider: \n\n// ajax(..) is some arbitrary Ajax function given by a library \nvar data = ajax( \"http://sone.url.1\" ); \n\nconsole.log( data ); \n\n// Oops! 'data' generally won't have the Ajax results \n\nYou’re probably aware that standard Ajax requests don’t complete \nsynchronously, which means the ajax(..) function does not yet \nhave any value to return back to be assigned to the data variable. If \na jax( ..) could block until the response came back, then the data \n= .. assignment would work fine. \n\n\n2 | Chapter 1: Asynchrony: Now & Later \n\n\n\n\nBut that’s not how we do Ajax. We make an asynchronous Ajax \nrequest now, and we won’t get the results back until later. \n\nThe simplest (but definitely not only, or necessarily even best!) way \nof “waiting” from now until later is to use a function, commonly \ncalled a callback function: \n\n// ajax(..) is some arbitrary Ajax function given by a library \najax( \"http://some.url. 1\" , function myCallbackFunction(data){","metadata":{"loc":{"lines":{"from":103391,"to":103420}}}}],["1019",{"pageContent":"// ajax(..) is some arbitrary Ajax function given by a library \najax( \"http://some.url. 1\" , function myCallbackFunction(data){ \n\nconsole.log( data ); // Yay, I gots me some 'data'! \n\n\n} ); \n\n\n\nYou may have heard that it’s possible to make \nsynchronous Ajax requests. While that’s techni¬ \ncally true, you should never, ever do it, under \nany circumstances, because it locks the browser \nUI (buttons, menus, scrolling, etc.) and prevents \nany user interaction whatsoever. This is a terri¬ \nble idea, and should always be avoided. \n\n\nBefore you protest in disagreement, no, your desire to avoid the \nmess of callbacks is not justification for blocking, synchronous Ajax. \n\nFor example, consider this code: \n\nfunction now() { \nreturn 21; \n\n} \n\nfunction laterQ { \n\nanswer = answer * 2; \n\nconsole.log( \"Meaning of life:\", answer ); \n\n} \n\nvar answer = now(); \n\nsetTimeout( later, 1000 ); // Meaning of life: 42","metadata":{"loc":{"lines":{"from":103420,"to":103459}}}}],["1020",{"pageContent":"} \n\nfunction laterQ { \n\nanswer = answer * 2; \n\nconsole.log( \"Meaning of life:\", answer ); \n\n} \n\nvar answer = now(); \n\nsetTimeout( later, 1000 ); // Meaning of life: 42 \n\nThere are two chunks to this program: the stuff that will run now, \nand the stuff that will run later. It should be fairly obvious what \nthose two chunks are, but let’s be super explicit: \n\nNow: \n\nfunction now() { \nreturn 21; \n\n} \n\n\nA Program in Chunks | 3 \n\n\n\n\n\nfunction laterQ { .. } \n\n\nvar answer = now(); \n\nsetTlmeout( later, 1000 ); \n\nLater: \n\nanswer = answer * 2; \n\nconsole.log( \"Meaning of life:\", answer ); \n\nThe now chunk runs right away, as soon as you execute your pro¬ \ngram. But setTimeoutf..) also sets up an event (a timeout) to hap¬ \npen later, so the contents of the later () function will be executed at \na later time (1,000 milliseconds from now).","metadata":{"loc":{"lines":{"from":103459,"to":103507}}}}],["1021",{"pageContent":"Any time you wrap a portion of code into a function and specify \nthat it should be executed in response to some event (timer, mouse \nclick, Ajax response, etc.), you are creating a later chunk of your \ncode, and thus introducing asynchrony to your program. \n\nAsync Console \n\nThere is no specification or set of requirements around how the \nconsole.* methods work—they are not officially part of JavaScript, \nbut are instead added to JS by the hosting environment (see the \nTypes & Grammar title of this series). \n\nSo, different browsers and JS environments do as they please, which \ncan sometimes lead to confusing behavior.","metadata":{"loc":{"lines":{"from":103509,"to":103522}}}}],["1022",{"pageContent":"So, different browsers and JS environments do as they please, which \ncan sometimes lead to confusing behavior. \n\nIn particular, there are some browsers and some conditions that \nconsole.log(..) does not actually immediately output what it’s \ngiven. The main reason this may happen is because I/O is a very \nslow and blocking part of many programs (not just JS). So, it may \nperform better (from the page/UI perspective) for a browser to han¬ \ndle console I/O asynchronously in the background, without you \nperhaps even knowing that occurred. \n\nA not terribly common, but possible, scenario where this could be \nobservable (not from code itself but from the outside): \n\n\n4 | Chapter 1: Asynchrony: Now & Later \n\n\n\n\nvar a = { \nindex: \n\n\n}; \n\n\n1 \n\n\n// later \n\nconsole.log ( a ); // ?? \n\n// even later \na.index++;","metadata":{"loc":{"lines":{"from":103522,"to":103557}}}}],["1023",{"pageContent":"4 | Chapter 1: Asynchrony: Now & Later \n\n\n\n\nvar a = { \nindex: \n\n\n}; \n\n\n1 \n\n\n// later \n\nconsole.log ( a ); // ?? \n\n// even later \na.index++; \n\nWe’d normally expect to see the a object be snapshotted at the exact \nmoment of the console. log (..) statement, printing something like \n{ index: 1 }, such that in the next statement when a.index++ \nhappens, it’s modifying something different than, or just strictly \nafter, the output of a. \n\nMost of the time, the preceding code will probably produce an \nobject representation in your developer tools’ console that’s what \nyou’d expect. But it’s possible this same code could run in a situa¬ \ntion where the browser felt it needed to defer the console I/O to the \nbackground, in which case it’s possible that by the time the object is \nrepresented in the browser console, the a .index++ has already hap¬ \npened, and it shows { index: 2 }.","metadata":{"loc":{"lines":{"from":103557,"to":103591}}}}],["1024",{"pageContent":"It’s a moving target under what conditions exactly console I/O will \nbe deferred, or even whether it will be observable. Just be aware of \nthis possible asynchronicity in I/O in case you ever run into \nissues in debugging where objects have been modified after a \nconsole. log(..) statement and yet you see the unexpected modifi¬ \ncations show up. \n\n\n\nIf you run into this rare scenario, the best option \nis to use breakpoints in your JS debugger instead \nof relying on console output. The next best \noption would be to force a “snapshot” of the \nobject in question by serializing it to a string, \nlike with JSON.strlnglfyf..). \n\n\nEvent Loop \n\nLet’s make a (perhaps shocking) claim: despite your clearly being \nable to write asynchronous JS code (like the timeout we just looked \nat), up until recently (ES6), JavaScript itself has actually never had \nany direct notion of asynchrony built into it. \n\n\nEvent Loop | 5","metadata":{"loc":{"lines":{"from":103593,"to":103618}}}}],["1025",{"pageContent":"Event Loop | 5 \n\n\n\n\nWhat!? That seems like a crazy claim, right? In fact, it’s quite true. \nThe JS engine itself has never done anything more than execute a \nsingle chunk of your program at any given moment, when asked to. \n\n“Asked to.” By whom? That’s the important part! \n\nThe JS engine doesn’t run in isolation. It runs inside a hosting envi¬ \nronment, which is for most developers the typical web browser. \nOver the last several years (but by no means exclusively), JS has \nexpanded beyond the browser into other environments, such as \nservers, via things like Node.js. In fact, JavaScript gets embedded \ninto all kinds of devices these days, from robots to lightbulbs. \n\nBut the one common “thread” (that’s a not-so-subtle asynchronous \njoke, for what it’s worth) of all these environments is that they have \na mechanism in them that handles executing multiple chunks of \nyour program over time, at each moment invoking the JS engine, \ncalled the event loop.","metadata":{"loc":{"lines":{"from":103618,"to":103640}}}}],["1026",{"pageContent":"In other words, the JS engine has had no innate sense of time, but \nhas instead been an on-demand execution environment for any \narbitrary snippet of JS. It’s the surrounding environment that has \nalways scheduled “events” (JS code executions). \n\nSo, for example, when your JS program makes an Ajax request to \nfetch some data from a server, you set up the response code in a \nfunction (commonly called a callback), and the JS engine tells the \nhosting environment, “Hey, I’m going to suspend execution for \nnow, but whenever you finish with that network request, and you \nhave some data, please call this function back.” \n\nThe browser is then set up to listen for the response from the net¬ \nwork, and when it has something to give you, it schedules the call¬ \nback function to be executed by inserting it into the event loop. \n\nSo what is the event loop? \n\nLet’s conceptualize it first through some fake-ish code:","metadata":{"loc":{"lines":{"from":103642,"to":103660}}}}],["1027",{"pageContent":"So what is the event loop? \n\nLet’s conceptualize it first through some fake-ish code: \n\n// 'eventLoop' is an array that acts as a queue \n// (first-in, first-out) \nvar eventLoop = [ ]; \nvar event; \n\n// keep going \"forever\" \nwhile (true) { \n\n// perform a \"tick\" \nif (eventLoop.length > 0) { \n\n\n6 | Chapter 1: Asynchrony: Now & Later \n\n\n\n\n// get the next event in the queue \nevent = eventLoop.shiftQ; \n\n// now, execute the next event \n\ntry { \n\nevent( ); \n\n} \n\ncatch (err) { \n\nreportError(err) ; \n\n} \n\n} \n\n} \n\nThis is, of course, vastly simplified pseudocode to illustrate the con¬ \ncepts. But it should be enough to help get a better understanding. \n\nAs you can see, there’s a continuously running loop represented by \nthe while loop, and each iteration of this loop is called a tick. For \neach tick, if an event is waiting on the queue, it’s taken off and exe¬ \ncuted. These events are your function callbacks.","metadata":{"loc":{"lines":{"from":103660,"to":103708}}}}],["1028",{"pageContent":"It’s important to note that setTimeout(..) doesn’t put your call¬ \nback on the event loop queue. What it does is set up a timer; when \nthe timer expires, the environment places your callback into the \nevent loop, such that some future tick will pick it up and execute it. \n\nWhat if there are already 20 items in the event loop at that moment? \nYour callback waits. It gets in line behind the others—there’s not \nnormally a path for preempting the queue and skipping ahead in \nline. This explains why setTimeout(..) timers may not fire with \nperfect temporal accuracy. You’re guaranteed (roughly speaking) \nthat your callback won’t fire before the time interval you specify, but \nit can happen at or after that time, depending on the state of the \nevent queue.","metadata":{"loc":{"lines":{"from":103710,"to":103722}}}}],["1029",{"pageContent":"So, in other words, your program is generally broken up into lots of \nsmall chunks, which happen one after the other in the event loop \nqueue. And technically, other events not related directly to your \nprogram can be interleaved within the queue as well. \n\n\nEvent Loop | 7 \n\n\n\n\nWe mentioned “up until recently” in relation to \nES6 changing the nature of where the event loop \nqueue is managed. It’s mostly a formal techni¬ \ncality, but ES6 now specifies exactly how the \nevent loop works, which means technically it’s \nwithin the purview of the JS engine, rather than \njust the hosting environment. One main reason \nfor this change is the introduction of ES6 Prom¬ \nises, which we’ll discuss in Chapter 3, because \nthey require the ability to have direct, fine¬ \ngrained control over scheduling operations on \nthe event loop queue (see the discussion of set \nTineout(. .0) in “Cooperation” on page 21). \n\n\nParallel Threading","metadata":{"loc":{"lines":{"from":103724,"to":103750}}}}],["1030",{"pageContent":"Parallel Threading \n\nIt’s very common to conflate the terms “async” and “parallel,” but \nthey are actually quite different. Remember, async is about the gap \nbetween now and later. But parallel is about things being able to \noccur simultaneously. \n\nThe most common tools for parallel computing are processes and \nthreads. Processes and threads execute independently and may exe¬ \ncute simultaneously: on separate processors, or even separate com¬ \nputers, but multiple threads can share the memory of a single \nprocess. \n\nAn event loop, by contrast, breaks its work into tasks and executes \nthem in serial, disallowing parallel access and changes to shared \nmemory. Parallelism and serialism can coexist in the form of coop¬ \nerating event loops in separate threads. \n\nThe interleaving of parallel threads of execution and the interleaving \nof asynchronous events occur at very different levels of granularity. \n\nFor example: \n\nfunction later() { \n\nanswer = answer * 2;","metadata":{"loc":{"lines":{"from":103750,"to":103775}}}}],["1031",{"pageContent":"For example: \n\nfunction later() { \n\nanswer = answer * 2; \n\nconsole.log( \"Meaning of life:\", answer ); \n\n1 \n\nWhile the entire contents of laterQ would be regarded as a single \nevent loop queue entry, when thinking about a thread this code \nwould run on, there’s actually perhaps a dozen different low-level \noperations. For example, answer = answer * 2 requires first load- \n\n\n8 | Chapter 1: Asynchrony: Now & Later \n\n\n\n\ning the current value of answer, then putting 2 somewhere, then \nperforming the multiplication, then taking the result and storing it \nback into answer. \n\nIn a single-threaded environment, it really doesn’t matter that the \nitems in the thread queue are low-level operations, because nothing \ncan interrupt the thread. But if you have a parallel system, where \ntwo different threads are operating in the same program, you could \nvery likely have unpredictable behavior. \n\nConsider: \n\nvar a = 20; \n\nfunction foo() { \na = a + 1; \n\n} \n\nfunction bar() { \na = a * 2; \n\n}","metadata":{"loc":{"lines":{"from":103775,"to":103818}}}}],["1032",{"pageContent":"Consider: \n\nvar a = 20; \n\nfunction foo() { \na = a + 1; \n\n} \n\nfunction bar() { \na = a * 2; \n\n} \n\n// ajax(..) is some arbitrary Ajax function given by a library \najax( \"http://some. url. 1\" , foo ); \najax( \"http://some.url.2\" , bar ); \n\nIn JavaScript’s single-threaded behavior, if foo( ) runs before bar( ), \nthe result is that a has 42, but if bar() runs before foo() the result \nin a will be 41. \n\nIf JS events sharing the same data executed in parallel, though, the \nproblems would be much more subtle. Consider these two lists of \npseudocode tasks as the threads that could respectively run the code \nin foo() and bar(), and consider what happens if they are running \nat exactly the same time: \n\nThread 1 (X and Y are temporary memory locations): \nf°°() : \n\na. load value of 'a' in 'X' \n\nb. store '1' in 'Y' \n\nc. add 'X' and 'Y', store result in 'X' \n\nd. store value of 'X' in 'a' \n\nThread 2 (X and Y are temporary memory locations): \nbar(): \n\na. load value of 'a' in 'X' \n\nb. store '2' in 'Y'","metadata":{"loc":{"lines":{"from":103818,"to":103862}}}}],["1033",{"pageContent":"c. add 'X' and 'Y', store result in 'X' \n\nd. store value of 'X' in 'a' \n\nThread 2 (X and Y are temporary memory locations): \nbar(): \n\na. load value of 'a' in 'X' \n\nb. store '2' in 'Y' \n\n\nParallel Threading | 9 \n\n\n\nc. multiply 'X' and 'Y', store result in 'X' \n\nd. store value of 'X' in 'a' \n\nNow, let’s say that the two threads are running truly in parallel. You \ncan probably spot the problem, right? They use shared memory \nlocations X and Y for their temporary steps. \n\nWhat’s the end result in a if the steps happen like this? \n\nla (load value of 'a' in 'X' ==> '20') \n\n2a (load value of 'a' in 'X' ==> '20') \n\nlb (store '1' in 'Y' ==> '1') \n\n2b (store '2' in 'Y' ==> '2') \n\nlc (add 'X' and 'Y', store result in 'X' ==> '22') \n\nId (store value of 'X' in 'a' ==> '22') \n\n2c (multiply 'X' and 'Y', store result in 'X' ==> '44') \n\n2d (store value of 'X' in 'a' ==> '44') \n\nThe result in a will be 44. But what about this ordering? \n\nla (load value of 'a' in 'X' ==> '20')","metadata":{"loc":{"lines":{"from":103862,"to":103906}}}}],["1034",{"pageContent":"2d (store value of 'X' in 'a' ==> '44') \n\nThe result in a will be 44. But what about this ordering? \n\nla (load value of 'a' in 'X' ==> '20') \n\n2a (load value of 'a' in 'X' ==> '20') \n\n2b (store '2' in 'Y' ==> '2') \n\nlb (store '1' in 'Y' ==> '1') \n\n2c (multiply 'X' and 'Y', store result in 'X' ==> '20') \n\nlc (add 'X' and 'Y', store result in 'X' ==> '21') \n\nId (store value of 'X' in 'a' ==> '21') \n\n2d (store value of 'X' in 'a' ==> '21') \n\nThe result in a will be 21. \n\nSo, threaded programming is very tricky, because if you don’t take \nspecial steps to prevent this kind of interruption/interleaving from \nhappening, you can get very surprising, nondeterministic behavior \nthat frequently leads to headaches. \n\nJavaScript never shares data across threads, which means that level \nof nondeterminism isn’t a concern. But that doesn’t mean JS is \nalways deterministic. Remember earlier, where the relative ordering \nof foo() and bar() produces two different results (41 or 42)?","metadata":{"loc":{"lines":{"from":103906,"to":103936}}}}],["1035",{"pageContent":"It may not be obvious yet, but not all nondeter¬ \nminism is bad. Sometimes it’s irrelevant, and \nsometimes it’s intentional. We’ll see more exam¬ \nples of that throughout this and the next few \nchapters. \n\n\n10 | Chapter 1: Asynchrony: Now & Later \n\n\n\n\n\nRun-to-Completion \n\nBecause of JavaScript’s single-threading, the code inside of foo() \n(and barQ) is atomic, which means that once foo() starts running, \nthe entirety of its code will finish before any of the code in bar() \ncan run, or vice versa. This is called run-to-completion behavior. \n\nIn fact, the run-to-completion semantics are more obvious when \nfoo() and bar( ) have more code in them, such as: \n\nvar a = 1; \nvar b = 2; \n\nfunction foo() { \na++; \n\nb = b * a; \na = b + 3; \n\n} \n\nfunction bar() { \n\nb--; \n\na = 8 + b; \nb = a * 2; \n\n} \n\n// ajax(..) is some arbitrary Ajax function given by a library \najax( \"http://some.url.1\" , foo ); \najax( \"http://some.url.2\" , bar );","metadata":{"loc":{"lines":{"from":103940,"to":103985}}}}],["1036",{"pageContent":"} \n\nfunction bar() { \n\nb--; \n\na = 8 + b; \nb = a * 2; \n\n} \n\n// ajax(..) is some arbitrary Ajax function given by a library \najax( \"http://some.url.1\" , foo ); \najax( \"http://some.url.2\" , bar ); \n\nBecause foo() can’t be interrupted by bar(), and bar() can’t be \ninterrupted by foo( ), this program has only two possible outcomes \ndepending on which starts running first—if threading were present, \nand the individual statements in foo() and bar() could be inter¬ \nleaved, the number of possible outcomes would be greatly increased! \n\nChunk 1 is synchronous (happens now), but chunks 2 and 3 are \nasynchronous (happen later), which means their execution will be \nseparated by a gap of time. \n\nChunk 1: \n\nvar a = 1; \nvar b = 2; \n\nChunk2 (foo()): \n\na++; \n\nb = b * a; \na = b + 3; \n\n\nParallel Threading | 11 \n\n\n\n\nChunk 3 (bar()): \n\n\nb--; \n\na = 8 + b; \nb = a * 2; \n\nChunks 2 and 3 may happen in either-first order, so there are two \npossible outcomes for this program, as illustrated here: \n\nOutcome 1:","metadata":{"loc":{"lines":{"from":103985,"to":104039}}}}],["1037",{"pageContent":"Chunk 3 (bar()): \n\n\nb--; \n\na = 8 + b; \nb = a * 2; \n\nChunks 2 and 3 may happen in either-first order, so there are two \npossible outcomes for this program, as illustrated here: \n\nOutcome 1: \n\nvar a = 1; \nvar b = 2; \n\n\n// foo() \na++; \n\nb = b * a; \na = b + 3; \n\n// bar() \nb--; \n\na = 8 + b; \nb = a * 2; \n\na; // 11 \n\nb; // 22 \n\nOutcome 2: \n\nvar a = 1; \nvar b = 2; \n\n// bar() \nb--; \n\na = 8 + b; \nb = a * 2; \n\n// foo() \na++; \n\nb = b * a; \na = b + 3; \n\na; // 183 \nb; // 180 \n\nTwo outcomes from the same code means we still have nondeter¬ \nminism! But it’s at the function (event) ordering level, rather than at \nthe statement ordering level (or, in fact, the expression operation \nordering level) as it is with threads. In other words, it’s more deter¬ \nministic than threads would have been. \n\n\n12 | Chapter 1: Asynchrony: Now & Later","metadata":{"loc":{"lines":{"from":104039,"to":104099}}}}],["1038",{"pageContent":"12 | Chapter 1: Asynchrony: Now & Later \n\n\n\n\nAs applied to JavaScript’s behavior, this function-ordering nonde¬ \nterminism is the common term race condition, as foo() and bar() \nare racing against each other to see which runs first. Specifically, it’s \na race condition because you cannot reliably predict how a and b \nwill turn out. \n\n\n\nIf there was a function in JS that somehow did \nnot have run-to-completion behavior, we could \nhave many more possible outcomes, right? It \nturns out ES6 introduces just such a thing (see \nChapter 4), but don’t worry right now, we’ll \ncome back to that! \n\n\nConcurrency \n\nLet’s imagine a site that displays a list of status updates (like a social \nnetwork news feed) that progressively loads as the user scrolls down \nthe list. To make such a feature work correctly, (at least) two sepa¬ \nrate “processes” will need to be executing simultaneously (i.e., dur¬ \ning the same window of time, but not necessarily at the same \ninstant).","metadata":{"loc":{"lines":{"from":104099,"to":104127}}}}],["1039",{"pageContent":"We’re using “process” in quotes here because \nthey aren’t true operating system-level pro¬ \ncesses in the computer science sense. They’re \nvirtual processes, or tasks, that represent a logi¬ \ncally connected, sequential series of operations. \nWe’ll use “process” instead of “task” because \nterminology-wise, it matches the definitions of \nthe concepts we’re exploring. \n\n\nThe first “process” will respond to onscroll events (making Ajax \nrequests for new content) as they fire when the user has scrolled the \npage further down. The second “process” will receive Ajax responses \nback (to render content onto the page). \n\nObviously, if a user scrolls fast enough, you may see two or more \nonscroll events fired during the time it takes to get the first \nresponse back and process, and thus you’re going to have onscroll \nevents and Ajax response events firing rapidly, interleaved with each \nother. \n\n\nConcurrency | 13","metadata":{"loc":{"lines":{"from":104131,"to":104153}}}}],["1040",{"pageContent":"Concurrency | 13 \n\n\n\n\n\n\n\nConcurrency is when two or more “processes” are executing simul¬ \ntaneously over the same period, regardless of whether their individ¬ \nual constituent operations happen in parallel (at the same instant on \nseparate processors or cores). You can think of concurrency then as \n“process”-level (or task-level) parallelism, as opposed to operation- \nlevel parallelism (separate-processor threads). \n\n\n\nConcurrency also introduces an optional notion \nof these “processes” interacting with each other. \nWe’ll come back to that later. \n\n\nFor a given window of time (a few seconds worth of a user scroll¬ \ning), let’s visualize each independent “process” as a series of events/ \noperations: \n\n“Process” 1 (onscroll events): \n\nonscroll, request 1 \nonscroll, request 2 \nonscroll, request 3 \nonscroll, request 4 \nonscroll, request 5 \nonscroll, request 6 \nonscroll, request 7 \n\n“Process” 2 (Ajax response events):","metadata":{"loc":{"lines":{"from":104153,"to":104189}}}}],["1041",{"pageContent":"onscroll, request 1 \nonscroll, request 2 \nonscroll, request 3 \nonscroll, request 4 \nonscroll, request 5 \nonscroll, request 6 \nonscroll, request 7 \n\n“Process” 2 (Ajax response events): \n\nresponse 1 \nresponse 2 \nresponse 3 \nresponse 4 \nresponse 5 \nresponse 6 \nresponse 7 \n\nIt’s quite possible that an onscroll event and an Ajax response \nevent could be ready to be processed at exactly the same moment. \nFor example, let’s visualize these events in a timeline: \n\nonscroll, request 1 \n\nonscroll, request 2 response 1 \n\nonscroll, request 3 response 2 \n\nresponse 3 \nonscroll, request 4 \n\nonscroll, request 5 \n\nonscroll, request 6 response 4 \n\nonscroll, request 7 \n\n\n14 | Chapter 1: Asynchrony: Now & Later \n\n\n\n\n\nresponse 6 \nresponse 5 \nresponse 7","metadata":{"loc":{"lines":{"from":104189,"to":104235}}}}],["1042",{"pageContent":"response 3 \nonscroll, request 4 \n\nonscroll, request 5 \n\nonscroll, request 6 response 4 \n\nonscroll, request 7 \n\n\n14 | Chapter 1: Asynchrony: Now & Later \n\n\n\n\n\nresponse 6 \nresponse 5 \nresponse 7 \n\nBut, going back to our notion of the event loop from earlier in the \nchapter, JS can handle only one event at a time, so either onscroll, \nrequest 2 is going to happen first or response 1 is going to happen \nfirst, but they cannot happen at literally the same moment. Just like \nkids at a school cafeteria, no matter what crowd they form outside \nthe doors, they’ll have to merge into a single line to get their lunch! \n\nLet’s visualize the interleaving of all these events onto the event loop \nqueue: \n\n\nonscroll, request 1 \nonscroll, request 2 \nresponse 1 \nonscroll, request 3 \nresponse 2 \nresponse 3 \nonscroll, request 4 \nonscroll, request 5 \nonscroll, request 6 \nresponse 4 \nonscroll, request 7 \nresponse 6 \nresponse 5 \nresponse 7 \n\n\n<— Process 1 starts \n<— Process 2 starts","metadata":{"loc":{"lines":{"from":104235,"to":104283}}}}],["1043",{"pageContent":"<— Process 1 starts \n<— Process 2 starts \n\n\n<--- Process 1 finishes \n\n<--- Process 2 finishes \n\n\n“Process” 1 and “Process” 2 run concurrently (task-level parallel), \nbut their individual events run sequentially on the event loop queue. \n\n\nBy the way, notice how response 6 and response 5 came back out \nof expected order? \n\nThe single-threaded event loop is one expression of concurrency \n(there are certainly others, which we’ll come back to later). \n\n\nNoninteracting \n\nAs two or more “processes” are interleaving their steps/events con¬ \ncurrently within the same program, they don’t necessarily need to \ninteract with each other if the tasks are unrelated. If they don’t inter¬ \nact, nondeterminism is perfectly acceptable. \n\nFor example: \n\nvar res = {}; \n\n\nConcurrency | 15 \n\n\n\n\nfunction foo(results) { \nres.foo = results; \n\n} \n\nfunction bar(results) { \nres.bar = results; \n\n}","metadata":{"loc":{"lines":{"from":104283,"to":104328}}}}],["1044",{"pageContent":"For example: \n\nvar res = {}; \n\n\nConcurrency | 15 \n\n\n\n\nfunction foo(results) { \nres.foo = results; \n\n} \n\nfunction bar(results) { \nres.bar = results; \n\n} \n\n// ajax(..) is some arbitrary Ajax function given by a library \najax( \"http://some.url.1\" , foo ); \najax( \"http://some.url.2\" , bar ); \n\nfoo() and bar() are two concurrent “processes,” and it’s nondeter- \nminate which order they will be fired in. But we’ve constructed the \nprogram so it doesn’t matter what order they fire in, because they \nact independently and as such don’t need to interact. \n\nThis is not a race condition bug, as the code will always work cor¬ \nrectly, regardless of the ordering. \n\nInteraction \n\nMore commonly, concurrent “processes” will by necessity interact, \nindirectly through scope and/or the DOM. When such interaction \nwill occur, you need to coordinate these interactions to prevent race \nconditions, as described earlier.","metadata":{"loc":{"lines":{"from":104328,"to":104365}}}}],["1045",{"pageContent":"Here’s a simple example of two concurrent “processes” that interact \nbecause of implied ordering, which is only sometimes broken: \n\nvar res = []; \n\nfunction response(data) { \nres.push( data ); \n\n} \n\n// ajax(..) is some arbitrary Ajax function given by a library \najax( \"http://some.url.1\" , response ); \najax( \"http://some.url.2\" , response ); \n\nThe concurrent “processes” are the two response( ) calls that will be \nmade to handle the Ajax responses. They can happen in either-first \norder. \n\nLet’s assume the expected behavior is that res[0] has the results of \nthe \"http://some.url.l\" call, and res[l] has the results of the \n\"http://some.url.2\" call. Sometimes that will be the case, but \nsometimes they’ll be flipped, depending on which call finishes first. \n\n\n16 | Chapter 1: Asynchrony: Now & Later \n\n\n\nThere’s a pretty good likelihood that this nondeterminism is a race \ncondition bug.","metadata":{"loc":{"lines":{"from":104367,"to":104396}}}}],["1046",{"pageContent":"16 | Chapter 1: Asynchrony: Now & Later \n\n\n\nThere’s a pretty good likelihood that this nondeterminism is a race \ncondition bug. \n\n\n\nBe extremely wary of assumptions you might \ntend to make in these situations. For example, \nit’s not uncommon for a developer to observe \nthat \"http://sone.url.2\" is always much \nslower to respond than \"http://sone.url.1\", \nperhaps by virtue of what tasks they’re doing \n(e.g., one performing a database task and the \nother just fetching a static file), so the observed \nordering seems to always be as expected. Even if \nboth requests go to the same server, and it inten¬ \ntionally responds in a certain order, there’s no \nreal guarantee of what order the responses will \narrive back in the browser. \n\n\nSo, to address such a race condition, you can coordinate ordering \ninteraction: \n\nvar res = []; \n\nfunction response(data) { \n\nif (data.url == \"http://sone.url. 1\") { \nres[0] = data; \n\n} \n\nelse if (data.url == \"http://sone.url. 2\" ) { \nres[l] = data; \n\n} \n\n}","metadata":{"loc":{"lines":{"from":104396,"to":104437}}}}],["1047",{"pageContent":"var res = []; \n\nfunction response(data) { \n\nif (data.url == \"http://sone.url. 1\") { \nres[0] = data; \n\n} \n\nelse if (data.url == \"http://sone.url. 2\" ) { \nres[l] = data; \n\n} \n\n} \n\n// ajax(..) is sone arbitrary Ajax function given by a library \najax( \"http://sone.url.1\" , response ); \najax( \"http://sone.url.2\" , response ); \n\nRegardless of which Ajax response comes back first, we inspect the \ndata.url (assuming one is returned from the server, of course!) to \nfigure out which position the response data should occupy in the \nres array. res[0] will always hold the \"http://some.url.l\" results \nand res[l] will always hold the \"http://sone.url.2\" results. \nThrough simple coordination, we eliminated the race condition \nnondeterminism. \n\nThe same reasoning from this scenario would apply if multiple con¬ \ncurrent function calls were interacting with each other through the \nshared DOM, like one updating the contents of a <div> and the \n\n\nConcurrency | 17","metadata":{"loc":{"lines":{"from":104437,"to":104470}}}}],["1048",{"pageContent":"Concurrency | 17 \n\n\n\n\nother updating the style or attributes of the <div> (e.g., to make the \nDOM element visible once it has content). You probably wouldn’t \nwant to show the DOM element before it had content, so the coor¬ \ndination must ensure proper ordering interaction. \n\nSome concurrency scenarios are always broken (not just sometimes) \nwithout coordinated interaction. Consider: \n\nvar a, b; \n\nfunction foo(x) { \na = x * 2; \nbaz( ); \n\n} \n\nfunction bar(y) { \nb = y * 2 ; \nbaz(); \n\n} \n\nfunction baz() { \n\nconsole.log(a + b); \n\n} \n\n// ajax(..) is some arbitrary Ajax function given by a library \najax( \"http://some.url.1\" , foo ); \najax( \"http://some.url.2\" , bar ); \n\nIn this example, whether foo() or bar() fires first, it will always \ncause baz() to run too early (either a or b will still be undefined), \nbut the second invocation of baz( ) will work, as both a and b will be \navailable. \n\nThere are different ways to address such a condition. Here’s one \nsimple way: \n\nvar a, b;","metadata":{"loc":{"lines":{"from":104470,"to":104515}}}}],["1049",{"pageContent":"There are different ways to address such a condition. Here’s one \nsimple way: \n\nvar a, b; \n\nfunction foo(x) { \na = x * 2; \nif (a && b) { \nbaz( ); \n\n} \n\n} \n\nfunction bar(y) { \nb = y * 2; \nif (a && b) { \nbaz(); \n\n} \n\n\n18 | Chapter 1: Asynchrony: Now & Later \n\n\n\n\n} \n\n\nfunction baz() { \n\nconsole.log( a + b ); \n\n} \n\n// ajax(..) is some arbitrary Ajax function given by a library \najax( \"http://some.url.1\" , foo ); \najax( \"http://some.url.2\" , bar ); \n\nThe if (a && b) conditional around the baz() call is traditionally \ncalled a gate, because we’re not sure what order a and b will arrive, \nbut we wait for both of them to get there before we proceed to open \nthe gate (call baz()).","metadata":{"loc":{"lines":{"from":104515,"to":104558}}}}],["1050",{"pageContent":"Another concurrency interaction condition you may run into is \nsometimes called a race, but more correctly called a latch. It’s char¬ \nacterized by “only the first one wins” behavior. Here, nondetermin¬ \nism is acceptable, in that you are explicitly saying it’s OK for the \n“race” to the finish line to have only one winner. \n\nConsider this broken code: \n\nvar a; \n\nfunction foo(x) { \na = x * 2; \nbaz(); \n\n} \n\nfunction bar(x) { \na = x / 2; \nbaz(); \n\n} \n\nfunction baz() { \n\nconsole.log( a ); \n\n} \n\n// ajax(..) is sone arbitrary Ajax function given by a library \najax( \"http://some.url. 1\" , foo ); \najax( \"http://some.url.2\" , bar ); \n\nWhichever one (foo() or bar()) fires last will not only overwrite \nthe assigned a value from the other, but it will also duplicate the call \nto baz( ) (likely undesired). \n\nSo, we can coordinate the interaction with a simple latch, to let only \nthe first one through: \n\n\nConcurrency | 19 \n\n\n\n\nvar a; \n\n\nfunction foo(x) { \nif (!a) { \n\na = x * 2; \nbaz( ); \n\n} \n\n}","metadata":{"loc":{"lines":{"from":104560,"to":104616}}}}],["1051",{"pageContent":"So, we can coordinate the interaction with a simple latch, to let only \nthe first one through: \n\n\nConcurrency | 19 \n\n\n\n\nvar a; \n\n\nfunction foo(x) { \nif (!a) { \n\na = x * 2; \nbaz( ); \n\n} \n\n} \n\nfunction bar(x) { \nif (!a) { \n\na = x / 2; \nbaz( ); \n\n} \n\n} \n\nfunction baz() { \n\nconsole.log( a ); \n\n} \n\n// ajax(..) is sone arbitrary Ajax function given by a library \najax( \"http://some.url.1\" , foo ); \najax( \"http://some.url.2\" , bar ); \n\nThe if (! a) conditional allows only the first of foo() or bar() \nthrough, and the second (and indeed any subsequent) calls would \njust be ignored. There’s just no virtue in coming in second place!","metadata":{"loc":{"lines":{"from":104616,"to":104660}}}}],["1052",{"pageContent":"In all these scenarios, we’ve been using global \nvariables for simplistic illustration purposes, but \nthere’s nothing about our reasoning here that \nrequires it. As long as the functions in question \ncan access the variables (via scope), they’ll work \nas intended. Relying on lexically scoped vari¬ \nables (see the Scope & Closures title of this ser¬ \nies), and in fact global variables as in these \nexamples, is one obvious downside to these \nforms of concurrency coordination. As we go \nthrough the next few chapters, we’ll see other \nways of coordination that are much cleaner in \nthat respect. \n\n\n20 | Chapter 1: Asynchrony: Now & Later \n\n\n\n\n\nCooperation","metadata":{"loc":{"lines":{"from":104664,"to":104685}}}}],["1053",{"pageContent":"20 | Chapter 1: Asynchrony: Now & Later \n\n\n\n\n\nCooperation \n\nAnother expression of concurrency coordination is called coopera¬ \ntive concurrency. Here, the focus isn’t so much on interacting via \nvalue sharing in scopes (though that’s obviously still allowed!). The \ngoal is to take a long-running “process” and break it up into steps or \nbatches so that other concurrent “processes” have a chance to inter¬ \nleave their operations into the event loop queue. \n\nFor example, consider an Ajax response handler that needs to run \nthrough a long list of results to transform the values. We’ll use \nArray#map( ..) to keep the code shorter: \n\nvar res = []; \n\n// ' response(..) ' receives array of results from the Ajax call \nfunction response(data) { \n\n// add onto existing 'res' array \nres = res.concat( \n\n// make a new transformed array with all \n// 'data' values doubled \ndata.map( functxon(val){ \nreturn vat * 2; \n\n} ) \n\n); \n\n}","metadata":{"loc":{"lines":{"from":104685,"to":104721}}}}],["1054",{"pageContent":"// add onto existing 'res' array \nres = res.concat( \n\n// make a new transformed array with all \n// 'data' values doubled \ndata.map( functxon(val){ \nreturn vat * 2; \n\n} ) \n\n); \n\n} \n\n// ajax(..) is some arbitrary Ajax function given by a library \najax( \"http://some.urt.1\" , response ); \najax( \"http://some.urt.2\" , response ); \n\nIf \"http://some. url. 1\" gets its results back first, the entire list will \nbe mapped into res all at once. If it’s a few thousand or less records, \nthis is not generally a big deal. But if it’s, say, 10 million records, that \ncan take a while to run (several seconds on a powerful laptop, much \nlonger on a mobile device, etc.). \n\nWhile such a “process” is running, nothing else in the page can hap¬ \npen, including no other response(.. ) calls, no UI updates, not even \nuser events like scrolling, typing, button clicking, and the like. \nThat’s pretty painful.","metadata":{"loc":{"lines":{"from":104721,"to":104748}}}}],["1055",{"pageContent":"So, to make a more cooperatively concurrent system, one that’s \nfriendlier and doesn’t hog the event loop queue, you can process \nthese results in asynchronous batches, after each one yielding back \nto the event loop to let other waiting events happen. \n\n\nConcurrency [ 21 \n\n\n\nHere’s a very simple approach: \nvar res = []; \n\n// 'response(..)' receives array of results from the Ajax call \nfunction response(data) { \n\n// let’s just do 1066 at a tine \nvar chunk = data.splice( 0, 1000 ); \n\n// add onto existing 'res' array \nres = res.concat( \n\n// make a new transformed array with all \n// 'chunk' values doubled \n\nchunk.nap( function(val){ \nreturn val * 2; \n\n} ) \n\n); \n\n\n// anything left to process? \nif (data.length > 0) { \n\n// async schedule next batch \nsetTimeout( function(){ \nresponse( data ); \n\n}, o ); \n\n} \n\n} \n\n// ajax(..) is some arbitrary Ajax function given by a library \najax( \"http://some.url.1\" , response ); \najax( \"http://some.url.2\" , response );","metadata":{"loc":{"lines":{"from":104750,"to":104798}}}}],["1056",{"pageContent":"}, o ); \n\n} \n\n} \n\n// ajax(..) is some arbitrary Ajax function given by a library \najax( \"http://some.url.1\" , response ); \najax( \"http://some.url.2\" , response ); \n\nWe process the data set in maximum-sized chunks of 1,000 items. \nBy doing so, we ensure a short-running “process,” even if that \nmeans many more subsequent “processes,” as the interleaving onto \nthe event loop queue will give us a much more responsive (perform- \nant) site/app. \n\nOf course, we’re not interaction-coordinating the ordering of any of \nthese “processes,” so the order of results in res won’t be predictable. \nIf ordering was required, you’d need to use interaction techniques \nlike those we discussed earlier, or ones we will cover in later chap¬ \nters of this book. \n\nWe use the setTimeout(. .0) (hack) for async scheduling, which \nbasically just means “stick this function at the end of the current \nevent loop queue.” \n\n\n22 | Chapter 1: Asynchrony: Now & Later","metadata":{"loc":{"lines":{"from":104798,"to":104825}}}}],["1057",{"pageContent":"22 | Chapter 1: Asynchrony: Now & Later \n\n\n\n\n\nsetTineout(. .0) is not technically inserting an \nitem directly onto the event loop queue. The \ntimer will insert the event at its next opportu¬ \nnity. For example, two subsequent setTine \nout(. .0) calls would not be strictly guaranteed \nto be processed in call order, so it is possible to \nsee various conditions like timer drift where the \nordering of such events isn’t predictable. In \nNode.js, a similar approach is process.next \nTick( ..). Despite how convenient (and usually \nmore performant) it would be, there’s not a sin¬ \ngle direct way (at least yet) across all environ¬ \nments to ensure async event ordering. We cover \nthis topic in more detail in the next section. \n\n\nJobs \n\nAs of ES6, there’s a new concept layered on top of the event loop \nqueue, called the Job queue. The most likely exposure you’ll have to \nit is with the asynchronous behavior of Promises (see Chapter 3).","metadata":{"loc":{"lines":{"from":104825,"to":104851}}}}],["1058",{"pageContent":"Unfortunately, at the moment it’s a mechanism without an exposed \nAPI, and thus demonstrating it is a bit more convoluted. So we’re \ngoing to describe it conceptually, such that when we discuss async \nbehavior with Promises in Chapter 3, you’ll understand how those \nactions are being scheduled and processed. \n\nSo, the best way to think about this that I’ve found is that the Job \nqueue is a queue hanging off the end of every tick in the event loop \nqueue. Certain async-implied actions that may occur during a tick \nof the event loop will not cause a whole new event to be added to the \nevent loop queue, but will instead add an item (aka Job) to the end \nof the current tick’s Job queue. \n\nIt’s kinda like saying, “oh, here’s this other thing I need to do later, \nbut make sure it happens right away before anything else can hap¬ \npen.”","metadata":{"loc":{"lines":{"from":104853,"to":104868}}}}],["1059",{"pageContent":"It’s kinda like saying, “oh, here’s this other thing I need to do later, \nbut make sure it happens right away before anything else can hap¬ \npen.” \n\nThe event loop queue is like an amusement park ride: once you fin¬ \nish the ride, you have to go to the back of the line to ride again. But \nthe Job queue is like finishing the ride, cutting in line, and getting \nright back on. \n\nA Job can also cause more Jobs to be added to the end of the same \nqueue. So, it’s theoretically possible that a Job loop (a Job that keeps \n\n\nJobs | 23 \n\n\n\n\nadding another Job, etc.) could spin indefinitely, thus starving the \nprogram of the ability to move on to the next event loop tick. This \nwould conceptually be almost the same as just expressing a long- \nrunning or infinite loop (like while (true) ..) in your code. \n\nJobs are kind of like the spirit of the setTimeout(. .0) hack, but \nimplemented in such a way as to have a much more well-defined \nand guaranteed ordering: later, but as soon as possible.","metadata":{"loc":{"lines":{"from":104868,"to":104893}}}}],["1060",{"pageContent":"Jobs are kind of like the spirit of the setTimeout(. .0) hack, but \nimplemented in such a way as to have a much more well-defined \nand guaranteed ordering: later, but as soon as possible. \n\nLet’s imagine an API for scheduling Jobs (directly, without hacks), \nand call it schedule( ..). Consider: \n\nconsole.log( \"A\" ); \n\nsetTimeout( function(){ \nconsole.log( \"B\" ); \n\n}, 0 ); \n\n// theoretical \"Job API\" \n\nschedule! function! ){ \nconsole.log! \"C\" ); \n\nschedule! function!)! \nconsole.log! \"D\" ); \n\n} ); \n\n} ); \n\nYou might expect this to print out A B C D, but instead it would \nprint out A C D B, because the Jobs happen at the end of the current \nevent loop tick, and the timer fires to schedule for the next event \nloop tick (if available!). \n\nIn Chapter 3, we’ll see that the asynchronous behavior of Promises \nis based on Jobs, so it’s important to keep clear how that relates to \nevent loop behavior. \n\nStatement Ordering","metadata":{"loc":{"lines":{"from":104893,"to":104928}}}}],["1061",{"pageContent":"In Chapter 3, we’ll see that the asynchronous behavior of Promises \nis based on Jobs, so it’s important to keep clear how that relates to \nevent loop behavior. \n\nStatement Ordering \n\nThe order in which we express statements in our code is not neces¬ \nsarily the same order as the JS engine will execute them. That may \nseem like quite a strange assertion to make, so we’ll just briefly \nexplore it. \n\nBut before we do, we should be crystal clear on something: the rules/ \ngrammar of the language (see the Types & Grammar title of this ser¬ \nies) dictate a very predictable and reliable behavior for statement \nordering from the program point of view. So what we’re about to \n\n\n24 | Chapter 1: Asynchrony: Now & Later \n\n\n\ndiscuss are things you should never be able to observe in your JS \nprogram.","metadata":{"loc":{"lines":{"from":104928,"to":104950}}}}],["1062",{"pageContent":"24 | Chapter 1: Asynchrony: Now & Later \n\n\n\ndiscuss are things you should never be able to observe in your JS \nprogram. \n\n\n\nIf you are ever able to observe compiler state¬ \nment reordering like we’re about to illustrate, \nthat’d be a clear violation of the specification, \nand it would unquestionably be due to a bug in \nthe JS engine in question—one which should \npromptly be reported and fixed! But it’s vastly \nmore common that you suspect something crazy \nis happening in the JS engine, when in fact it’s \njust a bug (probably a race condition!) in your \nown code—so look there first, and again and \nagain. The JS debugger, using breakpoints and \nstepping through code line by line, will be your \nmost powerful tool for sniffing out such bugs in \nyour code. \n\n\nConsider: \nvar a, b; \n\na = 10; \nb = 30; \n\na = a + 1; \nb = b + 1; \n\nconsole.log ( a + b ); // 42","metadata":{"loc":{"lines":{"from":104950,"to":104984}}}}],["1063",{"pageContent":"Consider: \nvar a, b; \n\na = 10; \nb = 30; \n\na = a + 1; \nb = b + 1; \n\nconsole.log ( a + b ); // 42 \n\nThis code has no expressed asynchrony to it (other than the rare \nconsole async I/O discussed earlier!), so the most likely assumption \nis that it would process line by line in top-down fashion. \n\nBut it’s possible that the JS engine, after compiling this code (yes, JS \nis compiled—see the Scope & Closures title of this series!) might find \nopportunities to run your code faster by rearranging (safely) the \norder of these statements. Essentially, as long as you can’t observe \nthe reordering, anything’s fair game. \n\nFor example, the engine might find it’s faster to actually execute the \ncode like this: \n\nvar a, b; \n\na = 10; \na++; \n\n\nStatement Ordering | 25 \n\n\n\n\nb = 30; \nb++; \n\nconsole.log ( a + b );// 42 \nOr this: \n\nvar a, b; \n\na = 11; \nb = 31; \n\nconsole.log ( a + b ); // 42 \nOr even:","metadata":{"loc":{"lines":{"from":104984,"to":105031}}}}],["1064",{"pageContent":"var a, b; \n\na = 10; \na++; \n\n\nStatement Ordering | 25 \n\n\n\n\nb = 30; \nb++; \n\nconsole.log ( a + b );// 42 \nOr this: \n\nvar a, b; \n\na = 11; \nb = 31; \n\nconsole.log ( a + b ); // 42 \nOr even: \n\n// because 'a' and 'b' aren't used anynore, we can \n// inline and don't even need then! \nconsole.log( 42 ); // 42 \n\nIn all these cases, the JS engine is performing safe optimizations \nduring its compilation, as the end observable result will be the same. \n\nBut here’s a scenario where these specific optimizations would be \nunsafe and thus couldn’t be allowed (of course, not to say that it’s \nnot optimized at all): \n\nvar a, b; \n\na = 10; \nb = 30; \n\n// we need 'o' and 'b' in their preincrenented state! \nconsole.log ( a * b ); // 300 \n\na = a + 1; \nb = b + 1; \n\nconsole.log ( a + b ); // 42","metadata":{"loc":{"lines":{"from":105031,"to":105078}}}}],["1065",{"pageContent":"var a, b; \n\na = 10; \nb = 30; \n\n// we need 'o' and 'b' in their preincrenented state! \nconsole.log ( a * b ); // 300 \n\na = a + 1; \nb = b + 1; \n\nconsole.log ( a + b ); // 42 \n\nOther examples where the compiler reordering could create observ¬ \nable side effects (and thus must be disallowed) would include things \nlike any function call with side effects (even and especially getter \nfunctions), or ES6 Proxy objects (see the ES6 & Beyond title of this \nseries). \n\nConsider: \n\nfunction foo() { \n\nconsole.log( b ); \nreturn 1; \n\n\n26 | Chapter 1: Asynchrony: Now & Later \n\n\n\n\n} \n\n\nvar a, b, c; \n\n// ES5.1 getter literal syntax \nc = { \n\nget bar() { \n\nconsole.log( a ); \n\nreturn 1; \n\n} \n\n}; \n\na = 10; \nb = 30; \n\na += foo(); // 30 \n\nb += c.bar; // 11 \n\nconsole.log ( a + b ); // 42","metadata":{"loc":{"lines":{"from":105078,"to":105135}}}}],["1066",{"pageContent":"var a, b, c; \n\n// ES5.1 getter literal syntax \nc = { \n\nget bar() { \n\nconsole.log( a ); \n\nreturn 1; \n\n} \n\n}; \n\na = 10; \nb = 30; \n\na += foo(); // 30 \n\nb += c.bar; // 11 \n\nconsole.log ( a + b ); // 42 \n\nIf it weren’t for the console. log(..) statements in this snippet (just \nused as a convenient form of observable side effect for the illustra¬ \ntion), the JS engine would likely have been free, if it wanted to (who \nknows if it would!?), to reorder the code to: \n\n// ... \n\na = 10 + foo(); \nb = 30 + c.bar; \n\n// ... \n\nWhile JS semantics thankfully protect us from the observable night¬ \nmares that compiler statement reordering would seem to be in dan¬ \nger of, it’s still important to understand just how tenuous a link \nthere is between the way source code is authored (in top-down fash¬ \nion) and the way it runs after compilation.","metadata":{"loc":{"lines":{"from":105135,"to":105175}}}}],["1067",{"pageContent":"Compiler statement reordering is almost a micro-metaphor for con¬ \ncurrency and interaction. As a general concept, such awareness can \nhelp you understand async JS code flow issues better. \n\nReview \n\nA JavaScript program is (practically) always broken up into two or \nmore chunks, where the first chunk runs now and the next chunk \nruns later , in response to an event. Even though the program is exe¬ \ncuted chunk-by-chunk, all of them share the same access to the \n\n\nReview [ 27 \n\n\n\nprogram scope and state, so each modification to state is made on \ntop of the previous state. \n\nWhenever there are events to run, the event loop runs until the \nqueue is empty. Each iteration of the event loop is a tick. User inter¬ \naction, IO, and timers enqueue events on the event queue. \n\nAt any given moment, only one event can be processed from the \nqueue at a time. While an event is executing, it can directly or indi¬ \nrectly cause one or more subsequent events.","metadata":{"loc":{"lines":{"from":105177,"to":105202}}}}],["1068",{"pageContent":"At any given moment, only one event can be processed from the \nqueue at a time. While an event is executing, it can directly or indi¬ \nrectly cause one or more subsequent events. \n\nConcurrency is when two or more chains of events interleave over \ntime, such that from a high-level perspective, they appear to be run¬ \nning simultaneously (even though at any given moment only one \nevent is being processed). \n\nIt’s often necessary to do some form of interaction coordination \nbetween these concurrent “processes” (as distinct from operating \nsystem processes), for instance to ensure ordering or to prevent race \nconditions. These “processes” can also cooperate by breaking them¬ \nselves into smaller chunks and to allow other “process” interleaving. \n\n\n28 | Chapter 1: Asynchrony: Now & Later \n\n\n\nCHAPTER 2 \n\n\nCallbacks","metadata":{"loc":{"lines":{"from":105202,"to":105225}}}}],["1069",{"pageContent":"28 | Chapter 1: Asynchrony: Now & Later \n\n\n\nCHAPTER 2 \n\n\nCallbacks \n\n\nIn Chapter 1, we explored the terminology and concepts around \nasynchronous programming in JavaScript. Our focus is on under¬ \nstanding the single-threaded (one-at-a-time) event loop queue that \ndrives all events (async function invocations). We also explored var¬ \nious ways that concurrency patterns explain the relationships (if \nany!) between simultaneously running chains of events, or “pro¬ \ncesses” (tasks, function calls, etc.). \n\nAll our examples in Chapter 1 used the function as the individual, \nindivisible unit of operations, whereby inside the function, state¬ \nments run in predictable order (above the compiler level!), but at \nthe function-ordering level, events (aka async function invocations) \ncan happen in a variety of orders.","metadata":{"loc":{"lines":{"from":105225,"to":105247}}}}],["1070",{"pageContent":"In all these cases, the function is acting as a callback, because it \nserves as the target for the event loop to “call back into” the pro¬ \ngram, whenever that item in the queue is processed. \n\nAs you no doubt have observed, callbacks are by far the most com¬ \nmon way that asynchrony in JS programs is expressed and managed. \nIndeed, the callback is the most fundamental async pattern in the \nlanguage. \n\nCountless JS programs, even very sophisticated and complex ones, \nhave been written upon no other async foundation than the callback \n(with, of course, the concurrency interaction patterns we explored \nin Chapter 1). The callback function is the async workhorse for \nJavaScript, and it does its job respectably. \n\n\n29 \n\n\n\n\n\nExcept...callbacks are not without their shortcomings. Many devel¬ \nopers are excited by the promise (pun intended!) of better async pat¬ \nterns. But it’s impossible to effectively use any abstraction if you \ndon’t understand what it’s abstracting, and why.","metadata":{"loc":{"lines":{"from":105249,"to":105274}}}}],["1071",{"pageContent":"In this chapter, we will explore a couple of those in depth, as moti¬ \nvation for why more sophisticated async patterns (explored in sub¬ \nsequent chapters of this book and Appendix B) are necessary and \ndesired. \n\nContinuations \n\nLet’s go back to the async callback example we started with in Chap¬ \nter 1, but let me slightly modify it to illustrate a point: \n\n// A \n\najax( function! ..){ \n\n// C \n\n} ); \n\n// B \n\n//A and // B represent the first half of the program (aka the now), \nand // C marks the second half of the program (aka the later). The \nfirst half executes right away, and then there’s a pause of indetermi¬ \nnate length. At some future moment, if the Ajax call completes, then \nthe program will pick up where it left off, and continue with the sec¬ \nond half. \n\nIn other words, the callback function wraps or encapsulates the con¬ \ntinuation of the program. \n\nLet’s make the code even simpler: \n\n// A \n\nsetTimeout( function(){ \n\n// C \n\n}, 1000 ); \n\n// B","metadata":{"loc":{"lines":{"from":105276,"to":105316}}}}],["1072",{"pageContent":"In other words, the callback function wraps or encapsulates the con¬ \ntinuation of the program. \n\nLet’s make the code even simpler: \n\n// A \n\nsetTimeout( function(){ \n\n// C \n\n}, 1000 ); \n\n// B \n\nStop for a moment and ask yourself how you’d describe (to some¬ \none else less informed about how JS works) the way that program \nbehaves. Go ahead, try it out loud. It’s a good exercise that will help \nmy next points make more sense. \n\nMost readers just now probably thought or said something to the \neffect of: “Do A, then set up a timeout to wait 1,000 milliseconds, \nthen once that fires, do C.” How close was your rendition? \n\n\n30 | Chapter 2: Callbacks \n\n\n\n\nYou might have caught yourself and self-edited to: “Do A, set up the \ntimeout for 1,000 milliseconds, then do B, then after the timeout \nfires, do C.” That’s more accurate than the first version. Can you \nspot the difference?","metadata":{"loc":{"lines":{"from":105316,"to":105349}}}}],["1073",{"pageContent":"Even though the second version is more accurate, both versions are \ndeficient in explaining this code in a way that matches our brains to \nthe code, and the code to the JS engine. The disconnect is both sub¬ \ntle and monumental, and is at the very heart of understanding the \nshortcomings of callbacks as async expression and management. \n\nAs soon as we introduce a single continuation (or several dozen, as \nmany programs do!) in the form of a callback function, we have \nallowed a divergence to form between how our brains work and the \nway the code will operate. Any time these two diverge (and this is by \nfar not the only place that happens, as I’m sure you know!), we run \ninto the inevitable fact that our code becomes harder to understand, \nreason about, debug, and maintain. \n\nSequential Brain","metadata":{"loc":{"lines":{"from":105351,"to":105365}}}}],["1074",{"pageContent":"Sequential Brain \n\nI’m pretty sure most of you have heard someone say, or made the \nclaim yourself: “I’m a multitasker.” The effects of trying to act as a \nmultitasker range from humorous (e.g., the silly patting-head- \nrubbing-stomach kids’ game) to mundane (chewing gum while \nwalking) to downright dangerous (texting while driving). \n\nBut are we multitaskers? Can we really do two conscious, inten¬ \ntional actions at once and think/reason about both of them at \nexactly the same moment? Does our highest level of brain function¬ \nality have parallel multithreading going on? \n\nThe answer may surprise you: probably not. \n\nThat’s just not really how our brains appear to be set up. We’re \nmuch more single taskers than many of us (especially A-type per¬ \nsonalities!) would like to admit. We can really only think about one \nthing at any given instant.","metadata":{"loc":{"lines":{"from":105365,"to":105383}}}}],["1075",{"pageContent":"I’m not talking about all our involuntary, subconscious, automatic \nbrain functions, such as heart beating, breathing, and eyelid blink¬ \ning. Those are all vital tasks to our sustained life, but we don’t inten¬ \ntionally allocate any brain power to them. Thankfully, while we \nobsess about checking social network feeds for the 15th time in \n\n\nSequential Brain | 31 \n\n\n\nthree minutes, our brain carries on in the background (threads!) \nwith all those important tasks. \n\nWe’re instead talking about whatever task is at the forefront of our \nminds at the moment. For me, it’s writing the text in this book right \nnow. Am I doing any other higher level brain function at exactly \nthis same moment? Nope, not really. I get distracted quickly and \neasily—a few dozen times in these last couple of paragraphs!","metadata":{"loc":{"lines":{"from":105385,"to":105403}}}}],["1076",{"pageContent":"When we fake multitasking, such as trying to type something at the \nsame time we’re talking to a friend or family member on the phone, \nwhat we’re actually most likely doing is acting as fast context switch¬ \ners. In other words, we switch back and forth between two or more \ntasks in rapid succession, simultaneously progressing on each task \nin tiny, fast little chunks. We do it so fast that to the outside world it \nappears as if we’re doing these things in parallel. \n\nDoes that sound suspiciously like async evented concurrency (like \nthe sort that happens in JS) to you?! If not, go back and read Chap¬ \nter 1 again! \n\nIn fact, one way of simplifying (i.e., abusing) the massively complex \nworld of neurology into something I can remotely hope to discuss \nhere is that our brains work kinda like the event loop queue.","metadata":{"loc":{"lines":{"from":105405,"to":105419}}}}],["1077",{"pageContent":"If you think about every single letter (or word) I type as a single \nasync event, in just this sentence alone there are several dozen \nopportunities for my brain to be interrupted by some other event, \nsuch as from my senses, or even just my random thoughts. \n\nI don’t get interrupted and pulled to another “process” at every \nopportunity that I could be (thankfully—or this book would never \nbe written!). But it happens often enough that I feel my own brain is \nnearly constantly switching to various different contexts (aka “pro¬ \ncesses”). And that’s an awful lot like how the JS engine would proba¬ \nbly feel. \n\nDoing Versus Planning \n\nOK, so our brains can be thought of as operating in single-threaded \nevent loop queue like ways, as can the JS engine. That sounds like a \ngood match. \n\n\n32 | Chapter 2: Callbacks","metadata":{"loc":{"lines":{"from":105421,"to":105440}}}}],["1078",{"pageContent":"OK, so our brains can be thought of as operating in single-threaded \nevent loop queue like ways, as can the JS engine. That sounds like a \ngood match. \n\n\n32 | Chapter 2: Callbacks \n\n\n\n\nBut we need to be more nuanced than that in our analysis. There’s a \nbig, observable difference between how we plan various tasks, and \nhow our brains actually perform those tasks. \n\nAgain, back to the writing of this text as my metaphor. My rough \nmental outline plan here is to keep writing and writing, going \nsequentially through a set of points I have ordered in my thoughts. I \ndon’t plan to have any interruptions or nonlinear activity in this \nwriting. But yet, my brain is nevertheless switching around all the \ntime. \n\nEven though at an operational level our brains are async evented, we \nseem to plan out tasks in a sequential, synchronous way. “I need to \ngo to the store, then buy some milk, then drop off my dry cleaning.”","metadata":{"loc":{"lines":{"from":105440,"to":105463}}}}],["1079",{"pageContent":"You’ll notice that this higher level thinking (planning) doesn’t seem \nvery async evented in its formulation. In fact, it’s kind of rare for us \nto deliberately think solely in terms of events. Instead, we plan \nthings out carefully, sequentially (A, then B, then C), and we assume \nto an extent a sort of temporal blocking that forces B to wait on A, \nand C to wait on B. \n\nWhen a developer writes code, they are planning out a set of actions \nto occur. If they’re any good at being a developer, they’re carefully \nplanning it out. “I need to set z to the value of x, and then x to the \nvalue of y,” and so forth. \n\nWhen we write out synchronous code, statement by statement, it \nworks a lot like our errands to-do list: \n\n// swap 'x' and 'y' (via temp variable z') \nz = x; \nx = y; \n\ny = z;","metadata":{"loc":{"lines":{"from":105465,"to":105484}}}}],["1080",{"pageContent":"When we write out synchronous code, statement by statement, it \nworks a lot like our errands to-do list: \n\n// swap 'x' and 'y' (via temp variable z') \nz = x; \nx = y; \n\ny = z; \n\nThese three assignment statements are synchronous, so x = y waits \nfor z = x to finish, and y = z in turn waits for x = y to finish. \nAnother way of saying it is that these three statements are tempo¬ \nrally bound to execute in a certain order, one right after the other. \nThankfully, we don’t need to be bothered with any async evented \ndetails here. If we did, the code gets a lot more complex, quickly! \n\nSo if synchronous brain planning maps well to synchronous code \nstatements, how well do our brains do at planning out asynchronous \ncode? \n\n\nSequential Brain | 33 \n\n\n\n\nIt turns out that how we express asynchrony (with callbacks) in our \ncode doesn’t map very well at all to that synchronous brain planning \nbehavior.","metadata":{"loc":{"lines":{"from":105484,"to":105512}}}}],["1081",{"pageContent":"Sequential Brain | 33 \n\n\n\n\nIt turns out that how we express asynchrony (with callbacks) in our \ncode doesn’t map very well at all to that synchronous brain planning \nbehavior. \n\nCan you actually imagine having a line of thinking that plans out \nyour to-do errands like this? \n\n“I need to go to the store, but on the way I’m sure I’ll get a phone \ncall, so Hi, Mom, and while she starts talking, I’ll be looking up the \nstore address on GPS, but that’ll take a second to load, so I’ll turn \ndown the radio so I can hear Mom better, then I’ll realize I forgot \nto put on a jacket and it’s cold outside, but no matter, keep driving \nand talking to Mom, and then the seatbelt ding reminds me to \nbuckle up, so yes. Mom, I am wearing my seatbelt, I always do! Ah, \nfinally the GPS got the directions, now.","metadata":{"loc":{"lines":{"from":105512,"to":105531}}}}],["1082",{"pageContent":"As ridiculous as that sounds as a formulation for how we plan our \nday out and think about what to do and in what order, nonetheless \nit’s exactly how our brains operate at a functional level. Remember, \nthat’s not multitasking, it’s just fast context switching. \n\nThe reason it’s difficult for us as developers to write async evented \ncode, especially when all we have is the callback to do it, is that \nstream of consciousness thinking/planning is unnatural for most of \nus. \n\nWe think in step-by-step terms, but the tools (callbacks) available to \nus in code are not expressed in a step-by-step fashion once we move \nfrom synchronous to asynchronous. \n\nAnd that is why it’s so hard to accurately author and reason about \nasync JS code with callbacks: because it’s not how our brain plan¬ \nning works.","metadata":{"loc":{"lines":{"from":105533,"to":105549}}}}],["1083",{"pageContent":"And that is why it’s so hard to accurately author and reason about \nasync JS code with callbacks: because it’s not how our brain plan¬ \nning works. \n\n\n\nThe only thing worse than not knowing why \nsome code breaks is not knowing why it worked \nin the first place! It’s the classic “house of cards” \nmentality: “it works, but I’m not sure why, so \nnobody touch it!” You may have heard, “Hell is \nother people” (Sartre), and the programmer \nmeme twist, “Hell is other people’s code.” I \nbelieve truly: “Hell is not understanding my own \ncode.” And callbacks are one main culprit. \n\n\n34 | Chapter 2: Callbacks \n\n\n\n\n\nNested/Chained Callbacks \n\nConsider: \n\nllsten( \"click\", function handler(evt){ \nsetTimeout( function request(){ \n\najax( \"http://some.url.1\" , function response(text){ \n\nIf (text == \"hello\") { \nhandler( ); \n\n} \n\nelse if (text == \"world\") { \nrequest( ); \n\n} \n\n} ); \n\n}, 500) ; \n\n} );","metadata":{"loc":{"lines":{"from":105549,"to":105595}}}}],["1084",{"pageContent":"ajax( \"http://some.url.1\" , function response(text){ \n\nIf (text == \"hello\") { \nhandler( ); \n\n} \n\nelse if (text == \"world\") { \nrequest( ); \n\n} \n\n} ); \n\n}, 500) ; \n\n} ); \n\nThere’s a good chance code like that is recognizable to you. We’ve \ngot a chain of three functions nested together, each one representing \na step in an asynchronous series (task, “process”). \n\nThis kind of code is often called callback hell, and sometimes also \nreferred to as the pyramid of doom (for its sideways-facing triangu¬ \nlar shape due to the nested indentation). \n\nBut callback hell actually has almost nothing to do with the nesting/ \nindentation. It’s a far deeper problem than that. We’ll see how and \nwhy as we continue through the rest of this chapter. \n\nFirst, we’re waiting for the click event, then we’re waiting for the \ntimer to fire, then we’re waiting for the Ajax response to come back, \nat which point it might do it all again.","metadata":{"loc":{"lines":{"from":105595,"to":105627}}}}],["1085",{"pageContent":"First, we’re waiting for the click event, then we’re waiting for the \ntimer to fire, then we’re waiting for the Ajax response to come back, \nat which point it might do it all again. \n\nAt first glance, this code may seem to map its asynchrony naturally \nto sequential brain planning. \n\nFirst (now), we: \n\nltsten( function handler(..){ \n\n// ■■ \n\n} ); \n\nThen later, we: \n\nsetT!meout( function request(..){ \n\n// \n\n}, 500) ; \n\n\nSequential Brain | 35 \n\n\n\n\nThen still later, we: \n\n\najax( function response( ..){ \n\n// •• \n\n} ); \n\nAnd finally (most later), we: \n\nif ( •■ ) { \n\n// •• \n\n} \n\nelse .. \n\nBut there’s several problems with reasoning about this code linearly \nin such a fashion.","metadata":{"loc":{"lines":{"from":105627,"to":105676}}}}],["1086",{"pageContent":"// •• \n\n} ); \n\nAnd finally (most later), we: \n\nif ( •■ ) { \n\n// •• \n\n} \n\nelse .. \n\nBut there’s several problems with reasoning about this code linearly \nin such a fashion. \n\nFirst, it’s an accident of the example that our steps are on subse¬ \nquent lines (1, 2, 3, and 4..In real async JS programs, there’s often \na lot more noise cluttering things up, noise that we have to deftly \nmaneuver past in our brains as we jump from one function to the \nnext. Understanding the async flow in such callback-laden code is \nnot impossible, but it’s certainly not natural or easy, even with lots \nof practice. \n\nBut also, there’s something deeper wrong, which isn’t evident just in \nthat code example. Let me make up another scenario (pseudocode- \nish) to illustrate it: \n\ndoA( function(){ \ndoB(); \n\ndoC( function(){ \ndoD( ); \n\n} ) \n\ndoE(); \n\n} ); \ndoF();","metadata":{"loc":{"lines":{"from":105676,"to":105716}}}}],["1087",{"pageContent":"doA( function(){ \ndoB(); \n\ndoC( function(){ \ndoD( ); \n\n} ) \n\ndoE(); \n\n} ); \ndoF(); \n\nWhile the experienced among you will correctly identify the true \norder of operations here, I’m betting it is more than a little confus¬ \ning at first glance, and takes some concerted mental cycles to arrive \nat. The operations will happen in this order: \n\n• doA() \n\n. doFQ \n\n• doB() \n\n\n36 | Chapter 2: Callbacks \n\n\n\n\n. doCQ \n. doEQ \n• doD() \n\nDid you get that right the very first time you glanced at the code? \n\nOK, some of you are thinking I was unfair in my function naming, \nto intentionally lead you astray. I swear I was just naming in top- \ndown appearance order. But let me try again: \n\ndoA( function(){ \n\ndoCO; \n\ndoD( function(){ \ndoF(); \n\n} ) \n\ndoEQ ; \n\n} ); \ndoBQ;","metadata":{"loc":{"lines":{"from":105716,"to":105768}}}}],["1088",{"pageContent":"doA( function(){ \n\ndoCO; \n\ndoD( function(){ \ndoF(); \n\n} ) \n\ndoEQ ; \n\n} ); \ndoBQ; \n\nNow, I’ve named them alphabetically in order of actual execution. \nBut I still bet, even with experience now in this scenario, tracing \nthrough the A->B->C->D->E->F order doesn’t come naturally. \nCertainly your eyes do an awful lot of jumping up and down the \ncode snippet, right? \n\nBut even if that all comes naturally to you, there’s still one more \nhazard that could wreak havoc. Can you spot what it is? \n\nWhat if doA(..) or doD(..) aren’t actually async, the way we obvi¬ \nously assumed them to be? Uh-oh, now the order is different. If \nthey’re both in sync (and maybe only sometimes, depending on the \nconditions of the program at the time), the order is now A -> C ->• D \n-> F -> E -> B. \n\nThat sound you just heard faintly in the background is the sighs of \nthousands of JS developers who just had a face-in-hands moment.","metadata":{"loc":{"lines":{"from":105768,"to":105798}}}}],["1089",{"pageContent":"That sound you just heard faintly in the background is the sighs of \nthousands of JS developers who just had a face-in-hands moment. \n\nIs nesting the problem? Is that what makes it so hard to trace the \nasync flow? That’s part of it, certainly. \n\nBut let me rewrite the previous nested event/timeout/Ajax example \nwithout using nesting: \n\nlisten( \"click\", handler ); \n\n\nSequential Brain | 37 \n\n\n\nfunction handlerQ { \n\nsetTlmeout( request, 500 ); \n\n} \n\nfunction request(){ \n\najax( \"http://some.url.1\" , response ); \n\n} \n\nfunction response(text){ \nif (text == \"hello\") { \nhandlerQ; \n\n} \n\nelse if (text == \"world\") { \nrequest( ); \n\n} \n\n} \n\nThis formulation of the code is not hardly as recognizable as having \nthe nesting/indentation woes of its previous form, and yet it’s every \nbit as susceptible to callback hell. Why?","metadata":{"loc":{"lines":{"from":105798,"to":105841}}}}],["1090",{"pageContent":"} \n\n} \n\nThis formulation of the code is not hardly as recognizable as having \nthe nesting/indentation woes of its previous form, and yet it’s every \nbit as susceptible to callback hell. Why? \n\nAs we go to linearly (sequentially) reason about this code, we have \nto skip from one function, to the next, to the next, and bounce all \naround the code base to “see” the sequence flow. And remember, \nthis is simplified code in sort of best-case fashion. We all know that \nreal async JS program code bases are often fantastically more jum¬ \nbled, which makes such reasoning orders of magnitude more diffi¬ \ncult. \n\nAnother thing to notice: to get steps 2, 3, and 4 linked together so \nthey happen in succession, the only affordance callbacks alone gives \nus is to hardcode step 2 into step 1, step 3 into step 2, step 4 into \nstep 3, and so on. The hardcoding isn’t necessarily a bad thing, if it \nreally is a fixed condition that step 2 should always lead to step 3.","metadata":{"loc":{"lines":{"from":105841,"to":105861}}}}],["1091",{"pageContent":"But the hardcoding definitely makes the code a bit more brittle, as it \ndoesn’t account for anything going wrong that might cause a devia¬ \ntion in the progression of steps. For example, if step 2 fails, step 3 \nnever gets reached, nor does step 2 retry, or move to an alternate \nerror handling flow, and so on. \n\nAll of these issues are things you can manually hardcode into each \nstep, but that code is often very repetitive and not reusable in other \nsteps or in other async flows in your program. \n\nEven though our brains might plan out a series of tasks in a sequen¬ \ntial type of way (this, then this, then this), the evented nature of our \n\n\n38 | Chapter 2: Callbacks","metadata":{"loc":{"lines":{"from":105863,"to":105877}}}}],["1092",{"pageContent":"Even though our brains might plan out a series of tasks in a sequen¬ \ntial type of way (this, then this, then this), the evented nature of our \n\n\n38 | Chapter 2: Callbacks \n\n\n\n\nbrain operation makes recove ry/retry/forking of flow control almost \neffortless. If you’re out running errands, and you realize you left a \nshopping list at home, it doesn’t end the day because you didn’t plan \nthat ahead of time. Your brain routes around this hiccup easily: you \ngo home, get the list, then head right back out to the store. \n\nBut the brittle nature of manually hardcoded callbacks (even with \nhardcoded error handling) is often far less graceful. Once you end \nup specifying (aka pre-planning) all the various eventualities/paths, \nthe code becomes so convoluted that it’s hard to ever maintain or \nupdate it. \n\nThat is what callback hell is all about! The nesting/indentations are \nbasically a side show, a red herring.","metadata":{"loc":{"lines":{"from":105877,"to":105899}}}}],["1093",{"pageContent":"That is what callback hell is all about! The nesting/indentations are \nbasically a side show, a red herring. \n\nAnd as if all that’s not enough, we haven’t even touched what hap¬ \npens when two or more chains of these callback continuations are \nhappening simultaneously, or when the third step branches out into \nparallel callbacks with gates or latches, or...OMG, my brain hurts, \nhow about yours!? \n\nAre you catching the notion here that our sequential, blocking brain \nplanning behaviors just don’t map well onto callback-oriented async \ncode? That’s the first major deficiency of callbacks: they express \nasynchrony in code in ways our brains have to fight just to keep in \nsync with (pun intended!). \n\nTrust Issues \n\nThe mismatch between sequential brain planning and callback- \ndriven async JS code is only part of the problem with callbacks. \nThere’s something much deeper to be concerned about.","metadata":{"loc":{"lines":{"from":105899,"to":105918}}}}],["1094",{"pageContent":"Trust Issues \n\nThe mismatch between sequential brain planning and callback- \ndriven async JS code is only part of the problem with callbacks. \nThere’s something much deeper to be concerned about. \n\nLet’s once again revisit the notion of a callback function as the con¬ \ntinuation (aka the second half) of our program: \n\n// A \n\najax( function( ..){ \n\n// C \n\n} ); \n\n// B \n\n//A and // B happen now, under the direct control of the main JS \nprogram. But // C gets deferred to happen later, and under the con¬ \ntrol of another party—in this case, the a jax(..) function. In a basic \n\n\nTrust Issues [ 39 \n\n\n\nsense, that sort of hand-off of control doesn’t regularly cause lots of \nproblems for programs.","metadata":{"loc":{"lines":{"from":105918,"to":105947}}}}],["1095",{"pageContent":"Trust Issues [ 39 \n\n\n\nsense, that sort of hand-off of control doesn’t regularly cause lots of \nproblems for programs. \n\nBut don’t be fooled by its infrequency and assume that this control \nswitch isn’t a big deal. In fact, it’s one of the worst (and yet most \nsubtle) problems with callback-driven design. It revolves around the \nidea that sometimes a jax(..) (i.e., the party you hand your callback \ncontinuation to) is not a function that you wrote, or that you \ndirectly control. Many times it’s a utility provided by some third \nparty. \n\nWe call this inversion of control, when you take part of your pro¬ \ngram and give over control of its execution to another third party. \nThere’s an unspoken contract that exists between your code and the \nthird-party utility—a set of things you expect to be maintained. \n\nTale of Five Callbacks \n\nIt might not be terribly obvious why this is such a big deal. Let me \nconstruct an exaggerated scenario to illustrate the hazards of trust at \nplay.","metadata":{"loc":{"lines":{"from":105947,"to":105971}}}}],["1096",{"pageContent":"Tale of Five Callbacks \n\nIt might not be terribly obvious why this is such a big deal. Let me \nconstruct an exaggerated scenario to illustrate the hazards of trust at \nplay. \n\nImagine you’re a developer tasked with building out an ecommerce \ncheckout system for a site that sells expensive TVs. You already have \nall the various pages of the checkout system built out just fine. On \nthe last page, when the user clicks “confirm” to buy the TV, you \nneed to call a third-party function (provided, say, by some analytics \ntracking company) so that the sale can be tracked. \n\nYou notice that they’ve provided what looks like an async tracking \nutility, probably for the sake of performance best practices, which \nmeans you need to pass in a callback function. In this continuation \nthat you pass in, you will have the final code that charges the cus¬ \ntomer’s credit card and displays the thank you page. \n\nThis code might look like:","metadata":{"loc":{"lines":{"from":105971,"to":105990}}}}],["1097",{"pageContent":"This code might look like: \n\nanatytics.trackPurchase( purchaseData, functxon(){ \nchargeCreditCard( ); \ndlsplayThankyouPage( ); \n\n} ); \n\nEasy enough, right? You write the code, test it, everything works, \nand you deploy to production. Everyone’s happy! \n\n\n40 | Chapter 2: Callbacks \n\n\n\n\nSix months go by and no issues. You’ve almost forgotten you even \nwrote that code. One morning, you’re at a coffee shop before work, \ncasually enjoying your latte, when you get a panicked call from your \nboss insisting you drop the coffee and rush into work right away. \n\nWhen you arrive, you find out that a high-profile customer has had \nhis credit card charged five times for the same TV, and he’s under¬ \nstandably upset. Customer service has already issued an apology and \nprocessed a refund. But your boss demands to know how this could \npossibly have happened. “Don’t we have tests for stuff like this!?”","metadata":{"loc":{"lines":{"from":105990,"to":106016}}}}],["1098",{"pageContent":"You don’t even remember the code you wrote. But you dig back in \nand start trying to find out what could have gone awry. \n\nAfter digging through some logs, you come to the conclusion that \nthe only explanation is that the analytics utility somehow, for some \nreason, called your callback five times instead of once. Nothing in \ntheir documentation mentions anything about this. \n\nFrustrated, you contact customer support, who of course is as aston¬ \nished as you are. They agree to escalate it to their developers, and \npromise to get back to you. The next day, you receive a lengthy \nemail explaining what they found, which you promptly forward to \nyour boss.","metadata":{"loc":{"lines":{"from":106018,"to":106030}}}}],["1099",{"pageContent":"Apparently, the developers at the analytics company had been work¬ \ning on some experimental code that, under certain conditions, \nwould retry the provided callback once per second, for five seconds, \nbefore failing with a timeout. They had never intended to push that \ninto production, but somehow they did, and they’re totally embar¬ \nrassed and apologetic. They go into plenty of detail about how \nthey’ve identified the breakdown and what they’ll do to ensure it \nnever happens again. Yadda, yadda. \n\nWhat’s next? \n\nYou talk it over with your boss, but he’s not feeling particularly \ncomfortable with the state of things. He insists, and you reluctantly \nagree, that you can’t trust them anymore (that’s what bit you), and \nthat you’ll need to figure out how to protect the checkout code from \nsuch a vulnerability again. \n\nAfter some tinkering, you implement some simple ad hoc code like \nthe following, which the team seems happy with: \n\n\nTrust Issues | 41 \n\n\n\n\nvar tracked = false;","metadata":{"loc":{"lines":{"from":106032,"to":106058}}}}],["1100",{"pageContent":"After some tinkering, you implement some simple ad hoc code like \nthe following, which the team seems happy with: \n\n\nTrust Issues | 41 \n\n\n\n\nvar tracked = false; \n\n\nanalytics.trackPurchase( purchaseData, function(){ \nif (! tracked) { \n\ntracked = true; \nchargeCreditCard( ); \ndisplayThankyouPage( ); \n\n} \n\n} ); \n\n\n\nThis should look familiar to you from Chap¬ \nter 1, because we’re essentially creating a latch to \nhandle any multiple concurrent invocations of \nour callback. \n\n\nBut then one of your QA engineers asks, “what happens if they \nnever call the callback?” Oops. Neither of you had thought about \nthat. \n\nYou begin to chase down the rabbit hole, and think of all the possi¬ \nble things that could go wrong with them calling your callback. \nHere’s roughly the list you come up with of ways the analytics utility \ncould misbehave: \n\n• Call the callback too early (before it’s been tracked) \n\n• Call the callback too late (or never)","metadata":{"loc":{"lines":{"from":106058,"to":106100}}}}],["1101",{"pageContent":"• Call the callback too early (before it’s been tracked) \n\n• Call the callback too late (or never) \n\n• Call the callback too few or too many times (like the problem \nyou encountered!) \n\n• Fail to pass along any necessary environment/parameters to \nyour callback \n\n• Swallow any errors/exceptions that may happen \n\n\nThat should feel like a troubling list, because it is. You’re probably \nslowly starting to realize that you’re going to have to invent an awful \nlot of ad hoc logic in each and every single callback that’s passed to a \nutility you’re not positive you can trust. \n\nNow you realize a bit more completely just how hellish callback hell \nis. \n\n\n42 | Chapter 2: Callbacks \n\n\n\n\n\nNot Just Others' Code \n\nSome of you may doubt that this is as big a deal as I’m making it out \nto be. Perhaps you don’t interact with truly third-party utilities \nmuch, if at all. Perhaps you use versioned APIs or self-host such \nlibraries, so that its behavior can’t be changed out from underneath \nyou.","metadata":{"loc":{"lines":{"from":106100,"to":106134}}}}],["1102",{"pageContent":"So, contemplate this: can you even really trust utilities that you do \ntheoretically control (in your own code base)? \n\nThink of it this way: most of us agree that at least to some extent we \nshould build our own internal functions with some defensive checks \non the input parameters, to reduce/prevent unexpected issues. \n\nOverly trusting of input: \n\nfunction addNumbers(x,y) { \n\n//+ is overloaded with coercion to also be \n// string concatenation, so this operation \n// isn't strictly safe depending on what's \n// passed in. \nreturn x + y; \n\n1 \n\naddNumbers( 21, 21 ); // 42 \n\naddNumbers( 21, \"21\" ); // \" 2121 \" \n\nDefensive against untrusted input: \n\nfunction addNumbers(x,y) { \n\n// ensure numerical input \n\nIf (typeof x != \"number\" || typeof y != \"number\") { \nthrow Error( \"Bad parameters\" ); \n\n} \n\n// if we get here, + will safely do numeric addition \n\nreturn x + y; \n\n} \n\naddNumbers( 21, 21 ); // 42 \n\naddNumbers( 21, \"21\" ); // Error: \"Bad parameters\" \n\nStill safe but friendlier:","metadata":{"loc":{"lines":{"from":106136,"to":106180}}}}],["1103",{"pageContent":"} \n\n// if we get here, + will safely do numeric addition \n\nreturn x + y; \n\n} \n\naddNumbers( 21, 21 ); // 42 \n\naddNumbers( 21, \"21\" ); // Error: \"Bad parameters\" \n\nStill safe but friendlier: \n\nfunction addNumbers(x,y) { \n\n// ensure numerical input \nx = Number( x ); \ny = Number( y ); \n\n// + will safely do numeric addition \n\n\nTrust Issues | 43 \n\n\n\n\nreturn x + y; \n\n} \n\naddNumbers( 21, 21 ); // 42 \n\naddNumbers( 21, \"21\" ); // 42 \n\nHowever you go about it, these sorts of checks/normalizations are \nfairly common on function inputs, even with code we theoretically \nentirely trust. In a crude sort of way, it’s like the programming \nequivalent of the geopolitical principle “trust, but verify.” \n\nSo, doesn’t it stand to reason that we should do the same thing \nabout composition of async function callbacks, not just with truly \nexternal code but even with code we know is generally under our \nown control? Of course we should.","metadata":{"loc":{"lines":{"from":106180,"to":106224}}}}],["1104",{"pageContent":"But callbacks don’t really offer anything to assist us. We have to \nconstruct all that machinery ourselves, and it often ends up being a \nlot of boilerplate/overhead that we repeat for every single async call¬ \nback. \n\nThe most troublesome problem with callbacks is inversion of con¬ \ntrol leading to a complete breakdown along all those trust lines. \n\nIf you have code that uses callbacks, especially but not exclusively \nwith third-party utilities, and you’re not already applying some sort \nof mitigation logic for all these inversion of control trust issues, your \ncode has bugs in it right now even though they may not have bitten \nyou yet. Latent bugs are still bugs. \n\nHell indeed. \n\nTrying to Save Callbacks \n\nThere are several variations of callback design that have attempted \nto address some (not all!) of the trust issues we’ve just looked at. It’s \na valiant, but doomed, effort to save the callback pattern from \nimploding on itself.","metadata":{"loc":{"lines":{"from":106226,"to":106247}}}}],["1105",{"pageContent":"For example, regarding more graceful error handling, some API \ndesigns provide for split callbacks (one for the success notification, \nand one for the error notification): \n\nfunction success(data) { \nconsole.log( data ); \n\n1 \n\n\n44 | Chapter 2: Callbacks \n\n\n\n\nfunction failure(err) { \nconsole.error( err ); \n\n} \n\n\najax( \"http://some.url.1\" , success, failure ); \n\nIn APIs of this design, often the failureQ error handler is \noptional, and if not provided it will be assumed you want the errors \nswallowed. Ugh. \n\n\n\nThis split-callback design is what the ES6 \nPromise API uses. We’ll cover ES6 Promises in \nmuch more detail in Chapter 3.","metadata":{"loc":{"lines":{"from":106249,"to":106280}}}}],["1106",{"pageContent":"This split-callback design is what the ES6 \nPromise API uses. We’ll cover ES6 Promises in \nmuch more detail in Chapter 3. \n\n\nAnother common callback pattern is called “error-first style” (some¬ \ntimes called “Node style,” as it’s also the convention used across \nnearly all Node.js APIs), where the first argument of a single call¬ \nback is reserved for an error object (if any). If successful, this argu¬ \nment will be empty/falsy (and any subsequent arguments will be the \nsuccess data), but if an error result is being signaled, the first argu¬ \nment is set/truthy (and usually nothing else is passed): \n\nfunction response(err,data) { \n\n// error? \nif (err) { \n\nconsole.error( err ); \n\n} \n\n// otherwise, assune success \n\nelse { \n\nconsole.log( data ); \n\n} \n\n} \n\najax( \"http://some.url.1\" , response ); \n\nIn both of these cases, several things should be observed.","metadata":{"loc":{"lines":{"from":106280,"to":106314}}}}],["1107",{"pageContent":"} \n\n// otherwise, assune success \n\nelse { \n\nconsole.log( data ); \n\n} \n\n} \n\najax( \"http://some.url.1\" , response ); \n\nIn both of these cases, several things should be observed. \n\nFirst, it has not really resolved the majority of trust issues like it may \nappear. There’s nothing about either callback that prevents or filters \nunwanted repeated invocations. Moreover, things are worse now, \nbecause you may get both success and error signals, or neither, and \nyou still have to code around either of those conditions. \n\nAlso, don’t miss the fact that while it’s a standard pattern you can \nemploy, it’s definitely more verbose and boilerplate-ish without \n\n\nTrying to Save Callbacks | 45 \n\n\n\n\nmuch reuse, so you’re going to get weary of typing all that out for \nevery single callback in your application.","metadata":{"loc":{"lines":{"from":106314,"to":106346}}}}],["1108",{"pageContent":"Trying to Save Callbacks | 45 \n\n\n\n\nmuch reuse, so you’re going to get weary of typing all that out for \nevery single callback in your application. \n\nWhat about the trust issue of never being called? If this is a concern \n(and it probably should be!), you likely will need to set up a timeout \nthat cancels the event. You could make a utility (proof-of-concept \nonly shown) to help you with that: \n\nfunction timeoutify(fn,detay) { \n\nvar intv = setTimeout( function(){ \nintv = null; \n\nfn( new Error( \"Timeout!\" ) ); \n\n}, delay ) \n\n\nreturn function () { \n\n// tineout hasn't happened yet? \nif (intv) { \n\nclearTimeout( intv ); \nfn.appty( this, arguments ); \n\n} \n\n1 ; \n\n} \n\nHere’s how you use it: \n\n// using \"error-first style\" callback design \nfunction foo(err.data) { \nif (err) { \n\nconsole.error( err ); \n\n} \n\nelse { \n\nconsole.log( data ); \n\n} \n\n} \n\najax( \"http://some.url.1\" , tlmeoutify( foo, 500 ) );","metadata":{"loc":{"lines":{"from":106346,"to":106401}}}}],["1109",{"pageContent":"console.error( err ); \n\n} \n\nelse { \n\nconsole.log( data ); \n\n} \n\n} \n\najax( \"http://some.url.1\" , tlmeoutify( foo, 500 ) ); \n\nAnother trust issue is being called too early. In application-specific \nterms, this may actually involve being called before some critical \ntask is complete. But more generally, the problem is evident in util¬ \nities that can either invoke the callback you provide now (synchro¬ \nnously), or later (asynchronously). \n\nThis nondeterminism around the sync-or-async behavior is almost \nalways going to lead to very difficult to track down bugs. In some \ncircles, the fictional insanity-inducing monster named Zalgo is used \nto describe the sync/async nightmares. “Don’t release Zalgo!” is a \ncommon cry, and it leads to very sound advice: always invoke call- \n\n\n46 | Chapter 2: Callbacks \n\n\n\nbacks asynchronously, even if that’s right away on the next turn of \nthe event loop, so that all callbacks are predictably async.","metadata":{"loc":{"lines":{"from":106401,"to":106433}}}}],["1110",{"pageContent":"46 | Chapter 2: Callbacks \n\n\n\nbacks asynchronously, even if that’s right away on the next turn of \nthe event loop, so that all callbacks are predictably async. \n\n\n\nFor more information on Zalgo, see Oren \nGolan’s “Don’t Release Zalgo!” and Isaac Z. \nSchlueter’s “Designing APIs for Asynchrony”. \n\n\nConsider: \n\nfunction result(data) { \nconsole.log( a ); \n\n} \n\nvar a = 0; \n\najax( \"..pre-cached-url.. \", result ); \na++; \n\nWill this code print 0 (sync callback invocation) or 1 (async callback \ninvocation)? It depends on the conditions. \n\nYou can see just how quickly the unpredictability of Zalgo can \nthreaten any JS program. So the silly-sounding “never release Zalgo” \nis actually incredibly common and solid advice. Always be asyncing. \n\nWhat if you don’t know whether the API in question will always \nexecute async? You could invent a utility like this asyncify!..) \nproof-of-concept: \n\nfunction asyncify(fn) { \nvar orig_fn = fn, \n\nintv = setTimeout( function! ){ \nintv = null; \nif (fn) fn();","metadata":{"loc":{"lines":{"from":106433,"to":106475}}}}],["1111",{"pageContent":"function asyncify(fn) { \nvar orig_fn = fn, \n\nintv = setTimeout( function! ){ \nintv = null; \nif (fn) fn(); \n\n}, 0 ) \n\n\nfn = null; \nreturn function!) { \n\n// firing too quickly, before 'intv' timer has fired to \n// indicate async turn has passed? \nif (intv) { \n\nfn = orig_fn.bind.apply ( \norig_fn, \n\n// add the wrapper's 'this' to the ~bind(..)' \n\n// call parameters, as well as currying any \n\n\nTrying to Save Callbacks | 47 \n\n\n\n\n\n// passed in paraneters \n\n[this] .concat( [] .slice.call( arguments ) ) \n\n\n); \n\n} \n\n// already async \n\nelse { \n\n// invoke original function \norig_fn.apply( this, arguments ); \n\n} \n\n}; \n\n} \n\nYou use asyncify( ..) like this: \n\nfunction result(data) { \nconsole.log( a ); \n\n} \n\nvar a = 0; \n\najax( \"..pre-cached-url.. asyncify( result ) ); \na++;","metadata":{"loc":{"lines":{"from":106475,"to":106538}}}}],["1112",{"pageContent":"} \n\n}; \n\n} \n\nYou use asyncify( ..) like this: \n\nfunction result(data) { \nconsole.log( a ); \n\n} \n\nvar a = 0; \n\najax( \"..pre-cached-url.. asyncify( result ) ); \na++; \n\nWhether the Ajax request is in the cache and resolves to try to call \nthe callback right away, or must be fetched over the wire and thus \ncomplete later asynchronously, this code will always output 1 \ninstead of 0—result(..) cannot help but be invoked asynchro¬ \nnously, which means the a++ has a chance to run before result(..) \ndoes. \n\nYay, another trust issue “solved”! But it’s inefficient, and yet again \nmore bloated boilerplate to weigh your project down. \n\nThat’s just the story, over and over again, with callbacks. They can \ndo pretty much anything you want, but you have to be willing to \nwork hard to get it, and oftentimes this effort is much more than \nyou can or should spend on such code reasoning.","metadata":{"loc":{"lines":{"from":106538,"to":106569}}}}],["1113",{"pageContent":"You might find yourself wishing for built-in APIs or other language \nmechanics to address these issues. ES6 has finally arrived on the \nscene with some great answers, so keep reading! \n\nReview \n\nCallbacks are the fundamental unit of asynchrony in JS. But they’re \nnot enough for the evolving landscape of async programming as JS \nmatures. \n\n\n48 | Chapter 2: Callbacks \n\n\n\n\nFirst, our brains plan things out in sequential, blocking, single- \nthreaded semantic ways, but callbacks express asynchronous flow in \na rather nonlinear, nonsequential way, which makes reasoning \nproperly about such code much harder. Hard-to-reason-about code \nis bad code that leads to bad bugs. \n\nWe need a way to express asynchrony in a more synchronous, \nsequential, blocking manner, just like our brains do.","metadata":{"loc":{"lines":{"from":106571,"to":106594}}}}],["1114",{"pageContent":"We need a way to express asynchrony in a more synchronous, \nsequential, blocking manner, just like our brains do. \n\nSecond, and more importantly, callbacks suffer from inversion of \ncontrol in that they implicitly give control over to another party \n(often a third-party utility not in your control!) to invoke the con¬ \ntinuation of your program. This control transfer leads us to a trou¬ \nbling list of trust issues, such as whether the callback is called more \ntimes than we expect. \n\nInventing ad hoc logic to solve these trust issues is possible, but it’s \nmore difficult than it should be, and it produces code that is clunk- \nier, harder to maintain, and likely insufficiently protected from \nthese hazards until you get visibly bitten by the bugs. \n\nWe need a generalized solution to all of the trust issues, one that can \nbe reused for as many callbacks as we create without all the extra \nboilerplate overhead.","metadata":{"loc":{"lines":{"from":106594,"to":106611}}}}],["1115",{"pageContent":"We need a generalized solution to all of the trust issues, one that can \nbe reused for as many callbacks as we create without all the extra \nboilerplate overhead. \n\nWe need something better than callbacks. They’ve served us well to \nthis point, but the future of JavaScript demands more sophisticated \nand capable async patterns. The subsequent chapters in this book \ndive into those emerging evolutions. \n\n\nReview | 49 \n\n\n\nCHAPTER 3 \n\n\nPromises \n\n\nIn Chapter 2, we identified two major categories of deficiencies with \nusing callbacks to express program asynchrony and manage concur¬ \nrency: lack of sequentiality and lack of trustability. Now that we \nunderstand the problems more intimately, it’s time we turn our \nattention to patterns that can address them. \n\nThe issue we want to address first is the inversion of control, the \ntrust that is so fragilely held and so easily lost.","metadata":{"loc":{"lines":{"from":106611,"to":106638}}}}],["1116",{"pageContent":"The issue we want to address first is the inversion of control, the \ntrust that is so fragilely held and so easily lost. \n\nRecall that we wrap up the continuation of our program in a call¬ \nback function, and hand that callback over to another party (poten¬ \ntially even external code) and just cross our fingers that it will do the \nright thing with the invocation of the callback. \n\nWe do this because we want to say, “here’s what happens later, after \nthe current step finishes.” \n\nBut what if we could uninvert that inversion of control? What if, \ninstead of handing the continuation of our program to another \nparty, we could expect it to return us a capability to know when its \ntask finishes, and then our code could decide what to do next? \n\nThis paradigm is called Promises.","metadata":{"loc":{"lines":{"from":106638,"to":106654}}}}],["1117",{"pageContent":"This paradigm is called Promises. \n\nPromises are starting to take the JS world by storm, as developers \nand specification writers alike desperately seek to untangle the \ninsanity of callback hell in their code/design. In fact, most new \nasync APIs being added to the JS/DOM platform are being built on \n\n\n51 \n\n\n\n\n\nPromises. So it’s probably a good idea to dig in and learn them, \ndon’t you think! ? \n\n\n\nThe word “immediately” is used frequently in \nthis chapter, generally to refer to some Promise \nresolution action. However, in essentially all \ncases, “immediately” means in terms of the Job \nqueue behavior (see Chapter 1), not in the \nstrictly synchronous now sense. \n\n\nWhat Is a Promise? \n\nWhen developers decide to learn a new technology or pattern, usu¬ \nally their first step is “show me the code!” It’s quite natural for us to \njust jump in feet first and learn as we go.","metadata":{"loc":{"lines":{"from":106654,"to":106685}}}}],["1118",{"pageContent":"When developers decide to learn a new technology or pattern, usu¬ \nally their first step is “show me the code!” It’s quite natural for us to \njust jump in feet first and learn as we go. \n\nBut it turns out that some abstractions get lost on the APIs alone. \nPromises are one of those tools where it can be painfully obvious \nfrom how someone uses it whether they understand what it’s for \nand about versus just learning and using the API. \n\nSo before I show the Promise code, I want to fully explain what a \nPromise really is conceptually. I hope this will then guide you better \nas you explore integrating Promise theory into your own async flow. \n\nWith that in mind, let’s look at two different analogies for what a \nPromise is. \n\nFuture Value","metadata":{"loc":{"lines":{"from":106685,"to":106701}}}}],["1119",{"pageContent":"With that in mind, let’s look at two different analogies for what a \nPromise is. \n\nFuture Value \n\nImagine this scenario: I walk up to the counter at a fast-food restau¬ \nrant, and place an order for a cheeseburger. I hand the cashier $1.47. \nBy placing my order and paying for it, I’ve made a request for a \nvalue back (the cheeseburger). I’ve started a transaction. \n\nBut often, the chesseburger is not immediately available for me. The \ncashier hands me something in place of my cheeseburger: a receipt \nwith an order number on it. This order number is an IOU (“I owe \nyou”) promise that ensures that I should eventually receive my \ncheeseburger. \n\nSo I hold onto my receipt and order number. I know it represents \nmy future cheeseburger, so I don’t need to worry about it anymore— \naside from being hungry! \n\n\n52 | Chapter 3: Promises","metadata":{"loc":{"lines":{"from":106701,"to":106722}}}}],["1120",{"pageContent":"So I hold onto my receipt and order number. I know it represents \nmy future cheeseburger, so I don’t need to worry about it anymore— \naside from being hungry! \n\n\n52 | Chapter 3: Promises \n\n\n\n\n\n\nWhile I wait, I can do other things, like send a text message to a \nfriend that says, “Hey, can you come join me for lunch? I’m going to \neat a cheeseburger.” \n\nI am reasoning about my future cheeseburger already, even though I \ndon’t have it in my hands yet. My brain is able to do this because it’s \ntreating the order number as a placeholder for the cheeseburger. \nThe placeholder essentially makes the value time independent. It’s a \nfuture value. \n\nEventually, I hear, “order 113!” and I gleefully walk back up to the \ncounter with receipt in hand. I hand my receipt to the cashier, and I \ntake my cheeseburger in return. \n\nIn other words, once my future value was ready, I exchanged my \nvalue-promise for the value itself.","metadata":{"loc":{"lines":{"from":106722,"to":106749}}}}],["1121",{"pageContent":"In other words, once my future value was ready, I exchanged my \nvalue-promise for the value itself. \n\nBut there’s another possible outcome. They call my order number, \nbut when I go to retrieve my cheeseburger, the cashier regretfully \ninforms me, “I’m sorry, but we appear to be all out of cheesebur¬ \ngers.” Setting aside the customer frustration of this scenario for a \nmoment, we can see an important characteristic of future values: \nthey can either indicate a success or failure. \n\nEvery time I order a cheeseburger, I know that I’ll either get a \ncheeseburger eventually, or I’ll get the sad news of the cheeseburger \nshortage, and I’ll have to figure out something else to eat for lunch. \n\n\n\nIn code, things are not quite as simple, because \nmetaphorically the order number may never be \ncalled, in which case we’re left indefinitely in an \nunresolved state. We’ll come back to dealing \nwith that case later. \n\n\nValues Now and Later","metadata":{"loc":{"lines":{"from":106749,"to":106772}}}}],["1122",{"pageContent":"Values Now and Later \n\nThis all might sound too mentally abstract to apply to your code. So \nlet’s be more concrete. \n\nHowever, before we can introduce how Promises work in this fash¬ \nion, we’re going to derive in code that we already understand—call¬ \nbacks!—how to handle these future values. \n\nWhen you write code to reason about a value, such as performing \nmath on a number, whether you realize it or not, you’ve been assum- \n\n\nWhat Is a Promise? | 53 \n\n\n\n\ning something very fundamental about that value, which is that it’s a \nconcrete now value already: \n\nvar x, y = 2; \n\nconsole.log( x + y ); // NaN <-- because 'x' isn't set yet \n\nThe x + y operation assumes both x and y are already set. In terms \nwe’ll expound on shortly, we assume the x and y values are already \nresolved.","metadata":{"loc":{"lines":{"from":106772,"to":106799}}}}],["1123",{"pageContent":"The x + y operation assumes both x and y are already set. In terms \nwe’ll expound on shortly, we assume the x and y values are already \nresolved. \n\nIt would be nonsense to expect that the + operator by itself would \nsomehow be magically capable of detecting and waiting around \nuntil both x and y are resolved (aka ready), and only then do the \noperation. That would cause chaos in the program if different state¬ \nments finished now and others finished later, right? \n\nHow could you possibly reason about the relationships between two \nstatements if either one (or both) of them might not be finished yet? \nIf statement 2 relies on statement 1 being finished, there are just two \noutcomes: either statement 1 finished right now and everything pro¬ \nceeds fine, or statement 1 didn’t finish yet, and thus statement 2 is \ngoing to fail. \n\nIf this sort of thing sounds familiar from Chapter 1, good!","metadata":{"loc":{"lines":{"from":106799,"to":106816}}}}],["1124",{"pageContent":"If this sort of thing sounds familiar from Chapter 1, good! \n\nLet’s go back to our x + y math operation. Imagine if there was a \nway to say, “Add x and y, but if either of them isn’t ready yet, just \nwait until they are. Add them as soon as you can.” \n\nYour brain might have just jumped to callbacks. OK, so... \n\nfunction add(getX,getY,cb) { \nvar x, y; \n\ngetX( function(xVal){ \nx = xVal; \n\n// both are ready? \n\nif (y != undefined) { \n\ncb( x + y ); // send along sun \n\n} \n\n} ); \n\ngetY( function(yVal){ \ny = yVal; \n\n// both are ready? \n\nif (x != undefined) { \n\ncb( x + y ); // send along sun \n\n} \n\n} ); \n\n} \n\n\n54 | Chapter 3: Promises \n\n\n\n\n\n// 'fetchX()~ and 'fetchY()' are sync or async \n// functions \n\nadd( fetchX, fetchY, function(sum){ \n\nconsole.log( sum ); // that was easy, huh? \n\n} ); \n\nTake just a moment to let the beauty (or lack thereof) of that snippet \nsink in (whistles patiently). \n\nWhile the ugliness is undeniable, there’s something very important \nabout this async pattern.","metadata":{"loc":{"lines":{"from":106816,"to":106875}}}}],["1125",{"pageContent":"Take just a moment to let the beauty (or lack thereof) of that snippet \nsink in (whistles patiently). \n\nWhile the ugliness is undeniable, there’s something very important \nabout this async pattern. \n\nIn that snippet, we treated x and y as future values, and we express \nan operation add( ..) that (from the outside) does not care whether \nx or y or both are available right away. In other words, it normalizes \nthe now and later, such that we can rely on a predictable outcome of \nthe add(. .) operation. \n\nBy using an add(.. ) that is temporally consistent—it behaves the \nsame across now and later times—the async code is much easier to \nreason about. \n\nTo put it more plainly: to consistently handle both now and later, we \nmake both of them later: all operations become async.","metadata":{"loc":{"lines":{"from":106875,"to":106892}}}}],["1126",{"pageContent":"To put it more plainly: to consistently handle both now and later, we \nmake both of them later: all operations become async. \n\nOf course, this rough callbacks-based approach leaves much to be \ndesired. It’s just a first tiny step toward realizing the benefits of rea¬ \nsoning about future values without worrying about the time aspect \nof when it’s available or not. \n\nPromise Value \n\nWe’ll definitely go into a lot more detail about Promises later in the \nchapter—so don’t worry if some of this is confusing—but let’s just \nbriefly glimpse at how we can express the x + y example via \nPromises functions: \n\nfunction add(xPromise,yPromise) { \n\n// 'Promise.all([ .. ])' takes an array of promises, \n\n// and returns a new promise that waits on them \n// all to finish \n\nreturn Promise.atl( [xPromise, yPromise] ) \n\n// when that promise is resolved, let's take the \n// received 'X' and 'Y' values and add them together. \n\n.then( function(values){ \n\n// 'values' is an array of the messages from the","metadata":{"loc":{"lines":{"from":106892,"to":106921}}}}],["1127",{"pageContent":"// when that promise is resolved, let's take the \n// received 'X' and 'Y' values and add them together. \n\n.then( function(values){ \n\n// 'values' is an array of the messages from the \n\n\nWhat Is a Promise? | 55 \n\n\n\n\n// previously resolved promises \nreturn values[0] + valuesfl]; \n\n} ); \n\n} \n\n// 'fetchX()~ and 'fetchY()' return promises for \n// their respective values, which may be ready \n// now or later. \nadd( fetchXQ, fetchYQ ) \n\n// we get a promise back for the sum of those \n// two numbers. \n\n// now we chain-call ~then(..)' to wait for the \n// resolution of that returned promise. \n\n.then( function(sum){ \n\nconsole.log( sum ); // that was easier! \n\n} ); \n\nThere are two layers of Promises in this snippet.","metadata":{"loc":{"lines":{"from":106921,"to":106958}}}}],["1128",{"pageContent":".then( function(sum){ \n\nconsole.log( sum ); // that was easier! \n\n} ); \n\nThere are two layers of Promises in this snippet. \n\nfetchXQ and fetchYQ are called directly, and the values they \nreturn (promises!) are passed into add(..). The underlying values \nthose promises represent may be ready now or later, but each \npromise normalizes the behavior to be the same regardless. We rea¬ \nson about X and Y values in a time-independent way. They are future \nvalues. \n\nThe second layer is the promise that add(..) creates (via \nPromise.all([ .. ])) and returns, which we wait on by calling \nthen(. .). When the add(..) operation completes, our sum future \nvalue is ready and we can print it out. We hide inside of add( ..) the \nlogic for waiting on the X and Y future values. \n\n\n56 | Chapter 3: Promises","metadata":{"loc":{"lines":{"from":106958,"to":106980}}}}],["1129",{"pageContent":"56 | Chapter 3: Promises \n\n\n\n\nInside add(..)> the Promise. all( [ .. ]) call \ncreates a promise (which is waiting on promiseX \nand promiseY to resolve). The chained call \nto .then(..) creates another promise, which \nthe return values[0] + values[1] line imme¬ \ndiately resolves (with the result of the addition). \nThus, the then( ..) call we chain off the end of \nthe add(. .) call—at the end of the snippet—is \nactually operating on that second promise \nreturned, rather than the first one created by \nPromise.all([ .. ]). Also, though we are not \nchaining off the end of that second then( ..), it \ntoo has created another promise, had we chosen \nto observe/use it. This Promise chaining stuff \nwill be explained in much greater detail later in \nthis chapter.","metadata":{"loc":{"lines":{"from":106980,"to":107000}}}}],["1130",{"pageContent":"Just like with cheeseburger orders, it’s possible that the resolution of \na Promise is rejection instead of fulfillment. Unlike a fulfilled \nPromise, where the value is always programmatic, a rejection value \n—commonly called a rejection reason —can either be set directly \nby the program logic, or it can result implicitly from a runtime \nexception. \n\nWith Promises, the then(. .) call can actually take two functions, \nthe first for fulfillment (as shown earlier), and the second for \nrejection: \n\nadd( fetchXQ, fetchY() ) \n\n. then( \n\n// fullfillnent handler \n\nfunction(sum) { \n\nconsole.log( sum ); \n\n}. \n\n// rejection handler \n\nfunction(err) { \n\nconsole.error( err ); // bunner! \n\n} \n\n); \n\nIf something went wrong getting X or Y, or something somehow \nfailed during the addition, the promise that add(..) returns is rejec¬ \nted, and the second callback error handler passed to then( ..) will \nreceive the rejection value from the promise. \n\n\nWhat Is a Promise? | 57","metadata":{"loc":{"lines":{"from":107003,"to":107042}}}}],["1131",{"pageContent":"What Is a Promise? | 57 \n\n\n\n\n\nBecause Promises encapsulate the time-dependent state—waiting on \nthe fulfillment or rejection of the underlying value—from the out¬ \nside, the Promise itself is time-independent, and thus Promises can \nbe composed (combined) in predictable ways regardless of the tim¬ \ning or outcome underneath. \n\nMoreover, once a Promise is resolved, it stays that way forever—it \nbecomes an immutable value at that point—and can then be \nobserved as many times as necessary.","metadata":{"loc":{"lines":{"from":107042,"to":107056}}}}],["1132",{"pageContent":"Moreover, once a Promise is resolved, it stays that way forever—it \nbecomes an immutable value at that point—and can then be \nobserved as many times as necessary. \n\n\n\nBecause a Promise is externally immutable once \nresolved, it’s now safe to pass that value around \nto any party and know that it cannot be modi¬ \nfied accidentally or maliciously. This is espe¬ \ncially true in relation to multiple parties \nobserving the resolution of a Promise. It is not \npossible for one party to affect another party’s \nability to observe Promise resolution. Immuta¬ \nbility may sound like an academic topic, but it’s \nactually one of the most fundamental and \nimportant aspects of Promise design, and \nshouldn’t be casually passed over.","metadata":{"loc":{"lines":{"from":107056,"to":107073}}}}],["1133",{"pageContent":"That’s one of the most powerful and important concepts to under¬ \nstand about Promises. With a fair amount of work, you could ad \nhoc create the same effects with nothing but ugly callback composi¬ \ntion, but that’s not really an effective strategy, especially because you \nhave to do it over and over again. \n\nPromises are an easily repeatable mechanism for encapsulating and \ncomposing future values. \n\nCompletion Event \n\nAs we just saw, an individual Promise behaves as a future value. But \nthere’s another way to think of the resolution of a Promise: as a \nflow-control mechanism—a temporal this-then-that—for two or \nmore steps in an asynchronous task. \n\nLet’s imagine calling a function foo(..) to perform some task. We \ndon’t know about any of its details, nor do we care. It may complete \nthe task right away, or it may take a while. \n\n\n58 | Chapter 3: Promises","metadata":{"loc":{"lines":{"from":107076,"to":107097}}}}],["1134",{"pageContent":"58 | Chapter 3: Promises \n\n\n\n\n\n\nWe just simply need to know when foo( ..) finishes so that we can \nmove on to our next task. In other words, we’d like a way to be noti¬ \nfied of foo( .. )’s completion so that we can continue. \n\nIn typical JavaScript fashion, if you need to listen for a notification, \nyou’d likely think of that in terms of events. So we could reframe \nour need for notification as a need to listen for a completion event \n(or continuation event) emitted by foo(..).","metadata":{"loc":{"lines":{"from":107097,"to":107111}}}}],["1135",{"pageContent":"Whether you call it a completion or a continua¬ \ntion event depends on your perspective. Is the \nfocus more on what happens with foo(. .), or \nwhat happens after foo( ..) finishes? Both per¬ \nspectives are accurate and useful. The event \nnotification tells us that foo( ..) has completed, \nbut also that it’s OK to continue with the next \nstep. Indeed, the callback you pass to be called \nfor the event notification is itself what we’ve \npreviously called a continuation. The comple¬ \ntion event is a bit more focused on the foo(..), \nwhich has our attention at present, so we call it a \ncompletion event for the rest of this text. \n\n\nWith callbacks, the notification would be our callback invoked by \nthe task (foo (..)). But with Promises, we turn the relationship \naround, and expect that we can listen for an event from foo(..), \nand when notified, proceed accordingly. \n\nFirst, consider some pseudocode: \nfoo(x) { \n\n// start doing something that could take a while \n\n} \n\nfoo( 42 )","metadata":{"loc":{"lines":{"from":107115,"to":107142}}}}],["1136",{"pageContent":"First, consider some pseudocode: \nfoo(x) { \n\n// start doing something that could take a while \n\n} \n\nfoo( 42 ) \n\non (foo \"completion\") { \n\n// now we can do the next step! \n\n} \n\non (foo \"error\") { \n\n// oops, something went wrong in 'foo(..)' \n\n} \n\nWe call foo( ..) and then we set up two event listeners, one for \n\"completion\" and one for \"error\" —the two possible final out- \n\n\nWhat Is a Promise? | 59 \n\n\n\n\ncomes of the foo( ..) call. In essence, foo( ..) doesn’t even appear \nto be aware that the calling code has subscribed to these events, \nwhich makes for a very nice separation of concerns. \n\nUnfortunately, such code would require some magic of the JS envi¬ \nronment that doesn’t exist (and would likely be a bit impractical). \nHere’s the more natural way we could express that in JS: \n\nfunction foo(x) { \n\n// start doing something that could take a while \n\n// make a 'listener' event notification \n// capability to return \n\nreturn listener; \n\n1 \n\nvar evt = foo( 42 );","metadata":{"loc":{"lines":{"from":107142,"to":107191}}}}],["1137",{"pageContent":"function foo(x) { \n\n// start doing something that could take a while \n\n// make a 'listener' event notification \n// capability to return \n\nreturn listener; \n\n1 \n\nvar evt = foo( 42 ); \n\nevt.on( \"completion\", function(){ \n\n// now we can do the next step! \n\n} ); \n\nevt.on( \"failure\", function(err){ \n\n// oops, something went wrong in 'foo(..)' \n\n1 ); \n\nfoo( ..) expressly creates an event subscription capability to return \nback, and the calling code receives and registers the two event han¬ \ndlers against it. \n\nThe inversion from normal callback-oriented code should be obvi¬ \nous, and it’s intentional. Instead of passing the callbacks to foo(.. ), \nit returns an event capability we call evt, which receives the call¬ \nbacks.","metadata":{"loc":{"lines":{"from":107191,"to":107223}}}}],["1138",{"pageContent":"But if you recall from Chapter 2, callbacks themselves represent an \ninversion of control. So inverting the callback pattern is actually an \ninversion of inversion, or an uninversion of control —restoring con¬ \ntrol back to the calling code where we wanted it to be in the first \nplace. \n\nOne important benefit is that multiple separate parts of the code can \nbe given the event listening capability, and they can all independ¬ \nently be notified when foo( ..) completes, in order to perform sub¬ \nsequent steps: \n\n\n60 | Chapter 3: Promises \n\n\n\n\n\nvar evt = foo( 42 ); \n\n\n// let 'bar(..)' listen to 'foo(..)'’s completion \nbar( evt ); \n\n//also, let ~baz(..)' listen to 'foo(..)''s completion \nbaz( evt ); \n\nUninversion of control enables a nicer separation of concerns, \nwhere bar(..) and baz(..) don’t need to be involved in how \nfoo(..) is called. Similarly, foo(..) doesn’t need to know or care \nthat bar(..) and baz(..) exist or are waiting to be notified when \nfoo(..) completes.","metadata":{"loc":{"lines":{"from":107225,"to":107256}}}}],["1139",{"pageContent":"Essentially, this evt object is a neutral third-party negotiation \nbetween the separate concerns. \n\nPromise \"Events\" \n\nAs you may have guessed by now, the evt event listening capability \nis an analogy for a Promise. \n\nIn a Promise-based approach, the previous snippet would have \nfoo(..) creating and returning a Promise instance, and that \npromise would then be passed to bar(..) and baz(..). \n\n\n\nThe Promise resolution “events” we listen for \naren’t strictly events (though they certainly \nbehave like events for these purposes), and \nthey’re not typically called \"completion\" or \n\"error\". Instead, we use then( ..) to register a \n\"then\" event. Or perhaps more precisely, \nthen(..) registers \"fulfillment\" and/or \n\"rejection\" event(s), though we don’t see \nthose terms used explicitly in the code. \n\n\nConsider: \n\nfunction foo(x) { \n\n// start doing something that could take a while \n\n// construct and return a promise \n\nreturn new Promise! function(resolve, reject)!","metadata":{"loc":{"lines":{"from":107258,"to":107291}}}}],["1140",{"pageContent":"Consider: \n\nfunction foo(x) { \n\n// start doing something that could take a while \n\n// construct and return a promise \n\nreturn new Promise! function(resolve, reject)! \n\n//eventually, call ' resolve (..)' or ' reject(..) ', \n// which are the resolution callbacks for \n// the promise. \n\n\nWhat Is a Promise? | 61 \n\n\n\n\n} \n\n\nvar p = foo( 42 ); \n\n\nbar( p ); \nbaz( p ); \n\n\n\nThe pattern shown with new Promise( func \ntion(..){ } ) is generally called the reveal¬ \n\ning constructor. The function passed in is \nexecuted immediately (not async deferred, as \ncallbacks to then( ..) are), and it’s provided two \nparameters, which in this case we’ve named \nresolve and reject. These are the resolution \nfunctions for the promise. resolve(..) gener¬ \nally signals fulfillment, and reject( ..) signals \nrejection. \n\n\nYou can probably guess what the internals of bar( ..) and baz(..) \nmight look like: \n\nfunction bar(fooPromlse) { \n\n// listen for 'foo(..)' to complete \nfooPronlse.then( \nfunction( ){","metadata":{"loc":{"lines":{"from":107291,"to":107342}}}}],["1141",{"pageContent":"You can probably guess what the internals of bar( ..) and baz(..) \nmight look like: \n\nfunction bar(fooPromlse) { \n\n// listen for 'foo(..)' to complete \nfooPronlse.then( \nfunction( ){ \n\n// ~foo(..)' has now finished, so \n// do 'bar(.’s task \n\n}, \n\nfunction( ){ \n\n// oops, something went wrong in 'foo(..)' \n\n} \n\n); \n\n} \n\n// ditto for baz(..)' \n\nPromise resolution doesn’t necessarily need to involve sending \nalong a message, as it did when we were examining Promises as \nfuture values. It can just be a flow-control signal, as used in the pre¬ \nvious snippet. \n\n\n62 | Chapter 3: Promises \n\n\n\n\nAnother way to approach this is: \nfunction bar() { \n\n// 'foo(..)' has definitely finished, so \n// do 'bar(.' s task \n\n} \n\nfunction oopsBarQ { \n\n// oops, something went wrong in 'foo(..)\\ \n// so 'bar(..)' didn't run \n\n} \n\n// ditto for ~baz()' and ' oopsBaz() ' \nvar p = foo( 42 ); \np.then( bar, oopsBar ); \np.then( baz, oopsBaz );","metadata":{"loc":{"lines":{"from":107342,"to":107397}}}}],["1142",{"pageContent":"// oops, something went wrong in 'foo(..)\\ \n// so 'bar(..)' didn't run \n\n} \n\n// ditto for ~baz()' and ' oopsBaz() ' \nvar p = foo( 42 ); \np.then( bar, oopsBar ); \np.then( baz, oopsBaz ); \n\n\n\nIf you’ve seen Promise-based coding before, you \nmight be tempted to believe that the last two \nlines of that code could be written as \np.then( .. ).then( .. ), using chaining, \n\nrather than p.then(..); p.then(..). That \n\nwould have an entirely different behavior, so be \ncareful! The difference might not be clear right \nnow, but it’s actually a different async pattern \nthan we’ve seen thus far: splitting/forking. Don’t \nworry! We’ll come back to this point later in this \nchapter. \n\n\nInstead of passing the p promise to bar(..) and baz(..), we use the \npromise to control when bar(..) and baz(..) will get executed, if \never. The primary difference is in the error handling.","metadata":{"loc":{"lines":{"from":107397,"to":107426}}}}],["1143",{"pageContent":"Instead of passing the p promise to bar(..) and baz(..), we use the \npromise to control when bar(..) and baz(..) will get executed, if \never. The primary difference is in the error handling. \n\nIn the first snippet’s approach, bar(..) is called regardless of \nwhether foo(..) succeeds or fails, and it handles its own fallback \nlogic if it’s notified that foo(..) failed. The same is true for \nbaz(..), obviously. \n\nIn the second snippet, bar(..) gets called only if foo(..) succeeds, \nand otherwise oopsBar(..) gets called. Ditto for baz(..). \n\nNeither approach is correct per se. There will be cases where one is \npreferred over the other. \n\n\nWhat Is a Promise? | 63 \n\n\n\n\nIn either case, the promise p that comes back from foo(..) is used \nto control what happens next.","metadata":{"loc":{"lines":{"from":107426,"to":107448}}}}],["1144",{"pageContent":"What Is a Promise? | 63 \n\n\n\n\nIn either case, the promise p that comes back from foo(..) is used \nto control what happens next. \n\nMoreover, the fact that both snippets end up calling then(..) twice \nagainst the same promise p illustrates the point made earlier, which \nis that Promises (once resolved) retain their same resolution (fulfill¬ \nment or rejection) forever, and can subsequently be observed as \nmany times as necessary. \n\nWhenever p is resolved, the next step will always be the same, both \nnow and later. \n\nThenable Duck Typing \n\nIn Promises-land, an important detail is how to know for sure if \nsome value is a genuine Promise or not. Or more directly, is it a \nvalue that will behave like a Promise? \n\nGiven that Promises are constructed by the new Promise (..) syn¬ \ntax, you might think that p instanceof Promise would be an \nacceptable check. But unfortunately, there are a number of reasons \nthat’s not totally sufficient.","metadata":{"loc":{"lines":{"from":107448,"to":107474}}}}],["1145",{"pageContent":"Mainly, you can receive a Promise value from another browser win¬ \ndow (iframe, etc.), which would have its own Promise different from \nthe one in the current window/frame, and that check would fail to \nidentify the Promise instance. \n\nMoreover, a library or framework may choose to vend its own \nPromises and not use the native ES6 Promise implementation to do \nso. In fact, you may very well be using Promises with libraries in \nolder browsers that have no Promise at all. \n\nWhen we discuss Promise resolution processes later in this chapter, \nit will become more obvious why it is still very important to be able \nto recognize and assimilate a Promise-like value that is not genuine. \nBut for now, just take my word for it that it’s a critical piece of the \npuzzle.","metadata":{"loc":{"lines":{"from":107476,"to":107490}}}}],["1146",{"pageContent":"As such, it was decided that the way to recognize a Promise (or \nsomething that behaves like a Promise) would be to define some¬ \nthing called a thenable as any object or function which has a \nthen(..) method on it. It is assumed that any such value is a \nPromise-conforming thenable. \n\n\n64 | Chapter 3: Promises \n\n\n\n\n\nThe general term for type checks that make assumptions about a \nvalue’s type based on its shape (what properties are present) is called \nduck typing —“If it looks like a duck, and quacks like a duck, it must \nbe a duck” (see the Types & Grammar title of this series). So the \nduck typing check for a thenable would roughly be: \n\nif ( \n\np !== null && \n\n( \n\ntypeof p === \"object\" || \ntypeof p === \"function\" \n\n) && \n\ntypeof p.then === \"function\" \n\n) { \n\n// assume it's a thenable! \n\n} \n\nelse { \n\n// not a thenable \n\n} \n\nYuck! Setting aside the fact that this logic is a bit ugly to implement \nin various places, there’s something deeper and more troubling \ngoing on.","metadata":{"loc":{"lines":{"from":107492,"to":107538}}}}],["1147",{"pageContent":"} \n\nelse { \n\n// not a thenable \n\n} \n\nYuck! Setting aside the fact that this logic is a bit ugly to implement \nin various places, there’s something deeper and more troubling \ngoing on. \n\nIf you try to fulfill a Promise with any object/function value that \nhappens to have a then(.. ) function on it, but you weren’t intend¬ \ning it to be treated as a Promise/thenable, you’re out of luck, because \nit will automatically be recognized as thenable and treated with spe¬ \ncial rules (see later in the chapter). \n\nThis is even true if you didn’t realize the value has a then(. .) on it. \nFor example: \n\nvar o = { then: function( ){} }; \n\n//make 'v' be ' [[Prototype]] '-linked to 'o' \nvar v = Object. create( o ); \n\nv.someStuff = \"cool\"; \nv.otherStuff = \"not so cool\"; \n\nv.hasOwnProperty( \"then\" ); // false \n\nv doesn’t look like a Promise or thenable at all. It’s just a plain object \nwith some properties on it. You’re probably just intending to send \nthat value around like any other object.","metadata":{"loc":{"lines":{"from":107538,"to":107571}}}}],["1148",{"pageContent":"v doesn’t look like a Promise or thenable at all. It’s just a plain object \nwith some properties on it. You’re probably just intending to send \nthat value around like any other object. \n\nBut unknown to you, v is also [ [Prototype] ]-linked (see the this & \nObject Prototypes title of this series) to another object o, which hap- \n\n\nThenable Duck Typing | 65 \n\n\n\npens to have a then( ..) on it. So the thenable duck typing checks \nwill think and assume v is a thenable. Uh-oh. \n\nIt doesn’t even need to be something as directly intentional as that: \n\nObject, prototype, then = functton()0; \n\nArray. prototype.then = function ( ){}; \n\nvar vl = { helto: \"world\" }; \nvar v2 = [ \"Hello\", \"World\" ];","metadata":{"loc":{"lines":{"from":107571,"to":107593}}}}],["1149",{"pageContent":"Object, prototype, then = functton()0; \n\nArray. prototype.then = function ( ){}; \n\nvar vl = { helto: \"world\" }; \nvar v2 = [ \"Hello\", \"World\" ]; \n\nBoth vl and v2 will be assumed to be thenables. You can’t control or \npredict if any other code accidentally or maliciously adds then(.. ) \nto Object, prototype, Array. prototype, or any of the other native \nprototypes. And if what’s specified is a function that doesn’t call \neither of its parameters as callbacks, then any Promise resolved with \nsuch a value will just silently hang forever! Crazy. \n\nSound implausible or unlikely? Perhaps.","metadata":{"loc":{"lines":{"from":107593,"to":107607}}}}],["1150",{"pageContent":"Sound implausible or unlikely? Perhaps. \n\nBut keep in mind that there were several well-known non-Promise \nlibraries preexisting in the community prior to ES6 that happened \nto already have a method on them called then( ..). Some of those \nlibraries chose to rename their own methods to avoid collision (that \nsucks!). Others have simply been relegated to the unfortunate status \nof “incompatible with Promise-based coding” in reward for their \ninability to change to get out of the way. \n\nThe standards decision to hijack the previously nonreserved—and \ncompletely general-purpose sounding —then property name means \nthat no value (or any of its delegates), either past, present, or future, \ncan have a then( ..) function present, either on purpose or by acci¬ \ndent, or that value will be confused for a thenable in Promises sys¬ \ntems, which will probably create bugs that are really hard to track \ndown.","metadata":{"loc":{"lines":{"from":107607,"to":107623}}}}],["1151",{"pageContent":"I do not like how we ended up with duck typing \nof thenables for Promise recognition. There \nwere other options, such as “branding” or even \n“anti-branding”; what we got seems like a worst- \ncase compromise. But it’s not all doom and \ngloom. Thenable duck typing can be helpful, as \nwe’ll see later. Just beware that thenable duck \ntyping can be hazardous if it incorrectly identi¬ \nfies something as a Promise that isn’t. \n\n\n66 | Chapter 3: Promises \n\n\n\n\n\nPromise Trust \n\nWe’ve now seen two strong analogies that explain different aspects \nof what Promises can do for our async code. But if we stop there, \nwe’ve missed perhaps the single most important characteristic that \nthe Promise pattern establishes: trust.","metadata":{"loc":{"lines":{"from":107627,"to":107649}}}}],["1152",{"pageContent":"Whereas the future values and completion events analogies play out \nexplicitly in the code patterns we’ve explored, it won’t be entirely \nobvious why or how Promises are designed to solve all of the inver¬ \nsion of control trust issues we laid out in “Trust Issues” on page 39 \nin Chapter 2. But with a little digging, we can uncover some impor¬ \ntant guarantees that restore the confidence in async coding that \nChapter 2 tore down! \n\nLet’s start by reviewing the trust issues with callbacks-only coding. \nWhen you pass a callback to a utility foo( ..), it might: \n\n• Call the callback too early \n\n• Call the callback too late (or never) \n\n• Call the callback too few or too many times \n\n• Fail to pass along any necessary environment/parameters \n\n• Swallow any errors/exceptions that may happen \n\nThe characteristics of Promises are intentionally designed to pro¬ \nvide useful, repeatable answers to all these concerns. \n\nCalling Too Early","metadata":{"loc":{"lines":{"from":107651,"to":107675}}}}],["1153",{"pageContent":"• Swallow any errors/exceptions that may happen \n\nThe characteristics of Promises are intentionally designed to pro¬ \nvide useful, repeatable answers to all these concerns. \n\nCalling Too Early \n\nPrimarily, this is a concern of whether code can introduce Zalgo- \nlike effects (see Chapter 2), where sometimes a task finishes syn¬ \nchronously and sometimes asynchronously, which can lead to race \nconditions. \n\nPromises by definition cannot be susceptible to this concern, \nbecause even an immediately fulfilled Promise (like new \nPrornise(function(resolve){ resolve(42); })) cannot be \nobserved synchronously. \n\nThat is, when you call then( ..) on a Promise, even if that Promise \nwas already resolved, the callback you provide to then(..) will \nalways be called asynchronously (for more on this, refer back to \n“Jobs” on page 23 in Chapter 1). \n\n\nPromise Trust | 67 \n\n\n\nNo more need to insert your own setTimeout(.. ,0) hacks. Prom¬ \nises prevent Zalgo automatically. \n\nCalling Too Late","metadata":{"loc":{"lines":{"from":107675,"to":107705}}}}],["1154",{"pageContent":"Promise Trust | 67 \n\n\n\nNo more need to insert your own setTimeout(.. ,0) hacks. Prom¬ \nises prevent Zalgo automatically. \n\nCalling Too Late \n\nSimilar to the previous point, a Promise’s then(..) registered \nobservation callbacks are automatically scheduled when either \nresolve(..) or reject(..) are called by the Promise creation \ncapability. Those scheduled callbacks will predictably be fired at the \nnext asynchronous moment (see “Jobs” on page 23 in Chapter 1). \n\nIt’s not possible for synchronous observation, so it’s not possible for \na synchronous chain of tasks to run in such a way to in effect delay \nanother callback from happening as expected. That is, when a \nPromise is resolved, all then(.. ) registered callbacks on it will be \ncalled, in order, immediately at the next asynchronous opportunity \n(again, see “Jobs” on page 23 in Chapter 1), and nothing that hap¬ \npens inside of one of those callbacks can affect/delay the calling of \nthe other callbacks. \n\nFor example:","metadata":{"loc":{"lines":{"from":107705,"to":107729}}}}],["1155",{"pageContent":"For example: \n\np.then( function(){ \n\np.then( function(){ \n\nconsole.log( \"C\" ); \n\n} ); \n\nconsole.log( \"A\" ); \n\n} ); \n\np.then( function(){ \n\nconsole.log( \"B\" ); \n\n} ); \n\n//ABC \n\nHere, \"C\" cannot interrupt and precede \"B\", by virtue of how Prom¬ \nises are defined to operate. \n\nPromise Scheduling Quirks \n\nIt’s important to note, though, that there are lots of nuances of \nscheduling where the relative ordering between callbacks chained \noff two separate Promises is not reliably predictable. \n\nIf two promises pi and p2 are both already resolved, it should be \ntrue that pi. then(..); p2.then( ..) would end up calling the call¬ \nbacks) for pi before the ones for p2. But there are subtle cases \nwhere that might not be true, such as the following: \n\n\n68 | Chapter 3: Promises \n\n\n\n\nvar p3 = new Promlse( function(resolve,reject){ \nresolve( \"B\" ); \n\n} ); \n\nvar pi = new Prordse( function(resolve,reject){ \nresolve( p3 ); \n\n} ); \n\np2 = new Promise( functi.on(resolve,reject){ \nresolve( \"A\" ); \n\n} );","metadata":{"loc":{"lines":{"from":107729,"to":107784}}}}],["1156",{"pageContent":"} ); \n\nvar pi = new Prordse( function(resolve,reject){ \nresolve( p3 ); \n\n} ); \n\np2 = new Promise( functi.on(resolve,reject){ \nresolve( \"A\" ); \n\n} ); \n\npl.then( function(v){ \nconsole.log ( v ); \n\n} ); \n\np2.then( function(v){ \nconsole.log( v ); \n\n} ); \n\n// A B <-■ not BA as you night expect \n\nWe’ll cover this more later, but as you can see, pi is resolved not \nwith an immediate value, but with another promise p3, which is \nitself resolved with the value \"B\". The specified behavior is to \nunwrap p3 into pi, but asynchronously, so pi’s callback(s) are \nbehind p2’s callback(s) in the asynchronus Job queue (see “Jobs” on \npage 23). \n\nTo avoid such nuanced nightmares, you should never rely on any¬ \nthing about the ordering/scheduling of callbacks across Promises. In \nfact, a good practice is not to code in such a way where the ordering \nof multiple callbacks matters at all. Avoid that if you can. \n\nNever Calling the Callback","metadata":{"loc":{"lines":{"from":107784,"to":107820}}}}],["1157",{"pageContent":"Never Calling the Callback \n\nThis is a very common concern. It’s addressable in several ways with \nPromises. \n\nFirst, nothing (not even a JS error) can prevent a Promise from noti¬ \nfying you of its resolution (if it’s resolved). If you register both ful¬ \nfillment and rejection callbacks for a Promise, and the Promise gets \nresolved, one of the two callbacks will always be called. \n\nOf course, if your callbacks themselves have JS errors, you may not \nsee the outcome you expect, but the callback will in fact have been \n\n\nPromise Trust | 69 \n\n\n\n\n\ncalled. We’ll cover later how to be notified of an error in your call¬ \nback, because even those don’t get swallowed. \n\nBut what if the Promise itself never gets resolved either way? Even \nthat is a condition that Promises provide an answer for, using a \nhigher level abstraction called a race: \n\n// a utility for timing out a Promise \nfunction timeoutPromlse(delay) {","metadata":{"loc":{"lines":{"from":107820,"to":107848}}}}],["1158",{"pageContent":"// a utility for timing out a Promise \nfunction timeoutPromlse(delay) { \n\nreturn new Promise? function(resolve, reject){ \nsetTimeout( function? ){ \nreject? \"Timeout!\" ); \n\n}, delay ); \n\n} ); \n\n} \n\n// setup a timeout for 'foo()' \n\nPromise.race? [ \n\nfoo(), // attempt 'foo()' \n\ntimeoutPromise? 3000 ) // give it 3 seconds \n\n] ) \n\n. then? \n\nfunction? ){ \n\n// 'foo(..)' fulfilled in time! \n\n}, \n\nfunction(err){ \n\n// either 'foo()' rejected, or it just \n// didn't finish in time, so inspect \n// 'err' to know which \n\n} \n\n); \n\nThere are more details to consider with this Promise timeout pat¬ \ntern, but we’ll come back to it later. \n\nImportantly, we can ensure a signal as to the outcome of foo(), to \nprevent it from hanging our program indefinitely. \n\nCalling Too Few or Too Many Times \n\nBy definition, one is the appropriate number of times for the call¬ \nback to be called. The “too few” case would be zero calls, which is \nthe same as the “never” case we just examined.","metadata":{"loc":{"lines":{"from":107848,"to":107899}}}}],["1159",{"pageContent":"By definition, one is the appropriate number of times for the call¬ \nback to be called. The “too few” case would be zero calls, which is \nthe same as the “never” case we just examined. \n\nThe “too many” case is easy to explain. Promises are defined so that \nthey can only be resolved once. If for some reason the Promise cre¬ \nation code tries to call resolve?.. ) or reject?.. ) multiple times, \nor tries to call both, the Promise will accept only the first resolution, \nand silently ignore any subsequent attempts. \n\n\n70 | Chapter 3: Promises \n\n\n\nBecause a Promise can only be resolved once, any then( ..) regis¬ \ntered callbacks will only ever be called once (each). \n\nOf course, if you register the same callback more than once, (e.g., \np.then(f); p.then(f);), it’ll be called as many times as it was reg¬ \nistered. The guarantee that a response function is called only once \ndoes not prevent you from shooting yourself in the foot. \n\nFailing to Pass Along Any Parameters/Environment","metadata":{"loc":{"lines":{"from":107899,"to":107922}}}}],["1160",{"pageContent":"Failing to Pass Along Any Parameters/Environment \n\nPromises can have, at most, one resolution value (fulfillment or \nrejection). \n\nIf you don’t explicitly resolve with a value either way, the value is \nundefined, as is typical in JS. But whatever the value, it will always \nbe passed to all registered (and appropriate fulfillment or rejection) \ncallbacks, either now or in the future. \n\nSomething to be aware of: If you call resolve( ..) or reject(..) \nwith multiple parameters, all subsequent parameters beyond the \nfirst will be silently ignored. Although that might seem a violation of \nthe guarantee we just described, it’s not exactly, because it consti¬ \ntutes an invalid usage of the Promise mechanism. Other invalid usa¬ \nges of the API (such as calling resolve( ..) multiple times) are \nsimilarly protected, so the Promise behavior here is consistent (if \nnot a tiny bit frustrating).","metadata":{"loc":{"lines":{"from":107922,"to":107939}}}}],["1161",{"pageContent":"If you want to pass along multiple values, you must wrap them in \nanother single value that you pass, such as an array or an object. \n\nAs for environment, functions in JS always retain their closure of \nthe scope in which they’re defined (see the Scope & Closures title of \nthis series), so they of course would continue to have access to what¬ \never surrounding state you provide. Of course, the same is true of \ncallbacks-only design, so this isn’t a specific augmentation of benefit \nfrom Promises—but it’s a guarantee we can rely on nonetheless. \n\nSwallowing Any Errors/Exceptions \n\nIn the base sense, this is a restatement of the previous point. If you \nreject a Promise with a reason (aka an error message), that value is \npassed to the rejection callback(s). \n\nBut there’s something much bigger at play here. If at any point in \nthe creation of a Promise, or in the observation of its resolution, a JS \n\n\nPromise Trust | 71","metadata":{"loc":{"lines":{"from":107941,"to":107961}}}}],["1162",{"pageContent":"But there’s something much bigger at play here. If at any point in \nthe creation of a Promise, or in the observation of its resolution, a JS \n\n\nPromise Trust | 71 \n\n\n\nexception error occurs, such as a TypeError or ReferenceError, \nthat exception will be caught, and it will force the Promise in ques¬ \ntion to become rejected. \n\nFor example: \n\nvar p = new Promise( function( resotve,reject){ \n\nfoo.bar(); // 'foo' is not defined, so error! \nresolve( 42 ); // never gets here :( \n\n} ); \np.then( \n\nfunction fulftlled(){ \n\n// never gets here :( \n\n}, \n\nfunction rejected(err){ \n\n// 'err' will be a 'TypeError' exception object \n//from the 'foo.bar()' line. \n\n} \n\n); \n\nThe JS exception that occurs from foo.barQ becomes a Promise \nrejection that you can catch and respond to.","metadata":{"loc":{"lines":{"from":107961,"to":107999}}}}],["1163",{"pageContent":"// 'err' will be a 'TypeError' exception object \n//from the 'foo.bar()' line. \n\n} \n\n); \n\nThe JS exception that occurs from foo.barQ becomes a Promise \nrejection that you can catch and respond to. \n\nThis is an important detail, because it effectively solves another \npotential Zalgo moment, which is that errors could create a syn¬ \nchronous reaction whereas nonerrors would be asynchronous. \nPromises turn even JS exceptions into asynchronous behavior, \nthereby reducing the race condition chances greatly. \n\nBut what happens if a Promise is fulfilled, but there’s a JS exception \nerror during the observation (in a then(..) registered callback)? \nEven those aren’t lost, but you may find how they’re handled a bit \nsurprising, until you dig in a little deeper: \n\nvar p = new Promise( function(resotve,reject){ \nresolve( 42 ); \n\n} ); \np.then( \n\nfunction fulftlled(msg){ \nfoo.bar(); \n\nconsole.log( msg ); // never gets here :( \n\n}, \n\nfunction rejected(err){ \n\n// never gets here either :( \n\n} \n\n);","metadata":{"loc":{"lines":{"from":107999,"to":108039}}}}],["1164",{"pageContent":"} ); \np.then( \n\nfunction fulftlled(msg){ \nfoo.bar(); \n\nconsole.log( msg ); // never gets here :( \n\n}, \n\nfunction rejected(err){ \n\n// never gets here either :( \n\n} \n\n); \n\n\n72 | Chapter 3: Promises \n\n\n\n\n\nWait, that makes it seem like the exception from foo.barQ really \ndid get swallowed. Never fear, it didn’t. But something deeper is \nwrong, which is that we’ve failed to listen for it. The p. then (.. ) call \nitself returns another promise, and it’s that promise that will be \nrejected with the TypeError exception. \n\nWhy couldn’t it just call the error handler we have defined there? \nSeems like a logical behavior on the surface. But it would violate the \nfundamental principle that Promises are immutable once resolved, p \nwas already fulfilled to the value 42, so it can’t later be changed to a \nrejection just because there’s an error in observing p’s resolution.","metadata":{"loc":{"lines":{"from":108039,"to":108074}}}}],["1165",{"pageContent":"Besides the principle violation, such behavior could wreak havoc, if \nsay there were multiple then(..) registered callbacks on the \npromise p, because some would get called and others wouldn’t, and \nit would be very opaque as to why. \n\nTrustable Promise? \n\nThere’s one last detail to examine to establish trust based on the \nPromise pattern. \n\nYou’ve no doubt noticed that Promises don’t get rid of callbacks at \nall. They just change where the callback is passed to. Instead of pass¬ \ning a callback to foo( ..), we get something (ostensibly a genuine \nPromise) back from foo(. .), and we pass the callback to that some¬ \nthing instead. \n\nBut why would this be any more trustable than just callbacks alone? \nHow can we be sure the something we get back is in fact a trustable \nPromise? Isn’t it basically all just a house of cards where we can trust \nonly because we already trusted?","metadata":{"loc":{"lines":{"from":108076,"to":108095}}}}],["1166",{"pageContent":"One of the most important, but often overlooked, details of Prom¬ \nises is that they have a solution to this issue as well. Included with \nthe native ES6 Promise implementation is Promise. resolve(..). \n\nIf you pass an immediate, non-Promise, non-thenable value to \nPromise. resolve( ..), you get a promise that’s fulfilled with that \nvalue. In this case, promises pi and p2 will behave identically: \n\nvar pi = new Promtse( function(resolve, reject)! \nresolve( 42 ); \n\nI ); \n\nvar p2 = Promise.resolve! 42 ); \n\n\nPromise Trust | 73 \n\n\n\n\nBut if you pass a genuine Promise to Promise. resolve( ..), you \njust get the same promise back: \n\nvar pi = Promise.resolve( 42 ); \nvar p2 = Promise.resolve( pi ); \n\n\npi === p2; // true \n\nEven more importantly, if you pass a non-Promise thenable value to \nPromise. resolve( ..), it will attempt to unwrap that value, and the \nunwrapping will keep going until a concrete final non-Promise-like \nvalue is extracted. \n\nRecall our previous discussion of thenables?","metadata":{"loc":{"lines":{"from":108097,"to":108132}}}}],["1167",{"pageContent":"Recall our previous discussion of thenables? \n\nConsider: \n\nvar p = { \n\nthen: function(cb) { \ncb( 42 ); \n\n} \n\n}; \n\n\n// this works OK, but only by good fortune \nP \n\n. then( \n\nfunction fulfilled(val){ \n\nconsole.log( val ); // 42 \n\n}, \n\nfunction rejected(err){ \n\n// never gets here \n\n} \n\n); \n\nThis p is a thenable, but it’s not a genuine Promise. Luckily, it’s rea¬ \nsonable, as most will be. But what if you got back instead something \nthat looked like: \n\nvar p = { \n\nthen: function(cb,errcb) { \ncb( 42 ); \n\nerrcb( \"evil laugh\" ); \n\n} \n\n}; \n\n\np \n\n. then( \n\nfunction fulfilled(val){ \n\nconsole.log( val ); // 42 \n\n}, \n\n\n74 | Chapter 3: Promises \n\n\n\n\nfunction rejected(err){ \n\n// oops, shouldn't have run \nconsole.log( err ); // evil laugh \n\n} \n\n); \n\nThis p is a thenable but it’s not so well behaved of a promise. Is it \nmalicious? Or is it just ignorant of how Promises should work? It \ndoesn’t really matter, to be honest. In either case, it’s not trustable as \nis.","metadata":{"loc":{"lines":{"from":108132,"to":108209}}}}],["1168",{"pageContent":"Nonetheless, we can pass either of these versions of p to \nPromise. resolve(..), and we’ll get the normalized, safe result we’d \nexpect: \n\nPromise.resolve( p ) \n\n. then( \n\nfunction fulfilled(val){ \n\nconsole.log( val ); // 42 \n\n}, \n\nfunction rejected(err){ \n\n// never gets here \n\n1 \n\n); \n\nPromise. resolve(..) will accept any thenable, and unwrap it to its \nnon-thenable value. But you get back from Promise. resoive(..) a \nreal, genuine Promise in its place, one that you can trust. If what \nyou passed in is already a genuine Promise, you just get it right \nback, so there’s no downside at all to filtering through \nPromise. resolve(..) to gain trust. \n\nSo let’s say we’re calling a foo(..) utility and we’re not sure we can \ntrust its return value to be a well-behaving Promise, but we know it’s \nat least a thenable. Promise. resolve(..) will give us a trustable \nPromise wrapper to chain off of: \n\n// don't just do this: \nfoo( 42 ) \n\n.then( function(v){ \nconsole.log( v ); \n\n} );","metadata":{"loc":{"lines":{"from":108211,"to":108251}}}}],["1169",{"pageContent":"// don't just do this: \nfoo( 42 ) \n\n.then( function(v){ \nconsole.log( v ); \n\n} ); \n\n// instead, do this: \n\nPromise.resolve? foo( 42 ) ) \n\n.then? function(v){ \nconsole.log? v ); \n\n} ); \n\n\nPromise Trust | 75 \n\n\n\n\n\n\nAnother beneficial side effect of wrapping \nPromise. resolve( ..) around any function’s \nreturn value (thenable or not) is that it’s an easy \nway to normalize that function call into a well¬ \nbehaving async task. If foo(42) returns an \nimmediate value sometimes, or a Promise other \ntimes, Promise, resolve( foo(42) ) makes \n\nsure it’s always a Promise result. And avoiding \nZalgo makes for much better code. \n\n\nTrust Built \n\nHopefully the previous discussion now fully “resolves” (pun \nintended) in your mind why the Promise is trustable, and more \nimportantly, why that trust is so critical in building robust, main¬ \ntainable software.","metadata":{"loc":{"lines":{"from":108251,"to":108293}}}}],["1170",{"pageContent":"Can you write async code in JS without trust? Of course you can. \nWe JS developers have been coding async with nothing but callbacks \nfor nearly two decades. \n\nBut once you start questioning just how much you can trust the \nmechanisms you build upon to actually be predictable and reliable, \nyou start to realize callbacks have a pretty shaky trust foundation. \n\nPromises are a pattern that augments callbacks with trustable \nsemantics, so that the behavior is more reason-able and more relia¬ \nble. By uninverting the inversion of control of callbacks, we place \nthe control with a trustable system (Promises) that was designed \nspecifically to bring sanity to our async. \n\n\nChain Flow \n\nWe’ve hinted at this a couple of times already, but Promises are not \njust a mechanism for a single-step this-then-that sort of operation. \nThat’s the building block, of course, but it turns out we can string \nmultiple Promises together to represent a sequence of async steps.","metadata":{"loc":{"lines":{"from":108295,"to":108315}}}}],["1171",{"pageContent":"The key to making this work is built on two behaviors intrinsic to \nPromises: \n\n\n• Every time you call then(..) on a Promise, it creates and \nreturns a new Promise, which we can chain with. \n\n\n76 | Chapter 3: Promises \n\n\n\n\n\n\n• Whatever value you return from the then(..) call’s fulfillment \ncallback (the first parameter) is automatically set as the fulfill¬ \nment of the chained Promise (from the first point). \n\nLet’s first illustrate what that means, and then we’ll derive how that \nhelps us create async sequences of flow control. Consider the follow¬ \ning: \n\nvar p = Promise.resotve( 21 ); \n\nvar p2 = p.then( function(v){ \nconsole.log ( v ); // 21 \n\n// fulfill 'p2' with value '42' \n\nreturn v * 2; \n\n} ); \n\n// chain off 'p2' \n\np2.then( function(v){ \n\nconsole.log ( v ); // 42 \n\n} );","metadata":{"loc":{"lines":{"from":108317,"to":108357}}}}],["1172",{"pageContent":"var p2 = p.then( function(v){ \nconsole.log ( v ); // 21 \n\n// fulfill 'p2' with value '42' \n\nreturn v * 2; \n\n} ); \n\n// chain off 'p2' \n\np2.then( function(v){ \n\nconsole.log ( v ); // 42 \n\n} ); \n\nBy returning v * 2 (i.e., 42), we fulfill the p2 promise that the first \nthen(..) call created and returned. When p2’s then(..) call runs, \nit’s receiving the fulfillment from the return v * 2 statement. Of \ncourse, p2.then(..) creates yet another promise, which we could \nhave stored in a p3 variable. \n\nBut it’s a little annoying to have to create an intermediate variable \np2 (or p3, etc.). Thankfully, we can easily just chain these together: \n\nvar p = Promise.resolve( 21 ); \n\nP \n\n.then( function(v){ \n\nconsole.log ( v ); // 21 \n\n// fulfill the chained promise with value '42' \n\nreturn v * 2; \n\n} ) \n\n// here's the chained promise \n\n.then( function(v){ \n\nconsole.log ( v ); // 42 \n\n} );","metadata":{"loc":{"lines":{"from":108357,"to":108403}}}}],["1173",{"pageContent":"console.log ( v ); // 21 \n\n// fulfill the chained promise with value '42' \n\nreturn v * 2; \n\n} ) \n\n// here's the chained promise \n\n.then( function(v){ \n\nconsole.log ( v ); // 42 \n\n} ); \n\nSo now the first then(..) is the first step in an async sequence, and \nthe second then(..) is the second step. This could keep going for as \nlong as you need it to extend. Just keep chaining off a previous \nthen(..) with each automatically created Promise. \n\n\nChain Flow | 77 \n\n\n\nBut there’s something missing here. What if we want step 2 to wait \nfor step 1 to do something asynchronous? We’re using an immedi¬ \nate return statement, which immediately fulfills the chained \npromise.","metadata":{"loc":{"lines":{"from":108403,"to":108432}}}}],["1174",{"pageContent":"The key to making a Promise sequence truly async capable at every \nstep is to recall how Promise. resolve(..) operates when what you \npass to it is a Promise or thenable instead of a final value. \nPromise. resolve(..) directly returns a received genuine Promise, \nor it unwraps the value of a received thenable—and keeps going \nrecursively while it keeps unwrapping thenables. \n\nThe same sort of unwrapping happens if you return a thenable or \nPromise from the fulfillment (or rejection) handler. Consider: \n\nvar p = Promise.resolve( 21 ); \n\np.then( function(v){ \n\nconsole.log ( v ); // 21 \n\n// create a promise and return it \n\nreturn new Promise( function(resolve,reject){ \n\n// fulfill with value '42' \nresolve( v * 2 ); \n\n} ); \n\n} ) \n\n.then( function(v){ \n\nconsole.log ( v ); // 42 \n\n} );","metadata":{"loc":{"lines":{"from":108434,"to":108465}}}}],["1175",{"pageContent":"return new Promise( function(resolve,reject){ \n\n// fulfill with value '42' \nresolve( v * 2 ); \n\n} ); \n\n} ) \n\n.then( function(v){ \n\nconsole.log ( v ); // 42 \n\n} ); \n\nEven though we wrapped 42 up in a promise that we returned, it still \ngot unwrapped and ended up as the resolution of the chained \npromise, such that the second then(..) still received 42. If we intro¬ \nduce asynchrony to that wrapping promise, everything still nicely \nworks the same: \n\nvar p = Promise.resolve( 21 ); \n\np.then( function(v){ \n\nconsole.log ( v ); // 21 \n\n// create a promise to return \n\nreturn new Promise( function(resolve,reject){ \n\n// introduce asynchrony! \nsetTimeout( function(){ \n\n// fulfill with value '42' \nresolve( v * 2 ); \n\n}, 100 ); \n\n} ); \n\n\n78 | Chapter 3: Promises \n\n\n\n\n\n} ) \n\n. then( function(v){ \n\n// runs after the 100ns delay in the previous step \nconsole.log( v ); // 42 \n\n} );","metadata":{"loc":{"lines":{"from":108465,"to":108520}}}}],["1176",{"pageContent":"}, 100 ); \n\n} ); \n\n\n78 | Chapter 3: Promises \n\n\n\n\n\n} ) \n\n. then( function(v){ \n\n// runs after the 100ns delay in the previous step \nconsole.log( v ); // 42 \n\n} ); \n\nThat’s incredibly powerful! Now we can construct a sequence of \nhowever many async steps we want, and each step can delay the next \nstep (or not!), as necessary. \n\nOf course, the value passing from step to step in these examples is \noptional. If you don’t return an explicit value, an implicit undefined \nis assumed, and the promises still chain together the same way. Each \nPromise resolution is thus just a signal to proceed to the next step. \n\nTo further the chain illustration, let’s generalize a delay-Promise \ncreation (without resolution messages) into a utility we can reuse for \nmultiple steps: \n\nfunction detay(tine) { \n\nreturn new Pronise( function(resolve, reject){ \nsetTimeout( resolve, tine ); \n\n} ); \n\n} \n\n\ndelay( 100 ) // step 1 \n\n.then( function STEP2(){ \nconsole.log( \"step 2 \nreturn delay( 200 ); \n\n} )","metadata":{"loc":{"lines":{"from":108520,"to":108569}}}}],["1177",{"pageContent":"return new Pronise( function(resolve, reject){ \nsetTimeout( resolve, tine ); \n\n} ); \n\n} \n\n\ndelay( 100 ) // step 1 \n\n.then( function STEP2(){ \nconsole.log( \"step 2 \nreturn delay( 200 ); \n\n} ) \n\n.then( function STEP3(){ \nconsole.log( \"step 3 \n\n} ) \n\n.then( function STEP4(){ \nconsole.log( \"step 4 \nreturn delay( 50 ); \n\n} ) \n\n.then( function STEPS ()f \nconsole.log( \"step 5 \n\n} ) \n\n\n(after 100ns)\" ); \n\n(after another 200ns)\" ); \n\n(next Job)\" ); \n\n(after another 50ns)\" ); \n\n\nCalling delay (200) creates a promise that will fulfill in 200ms, and \nthen we return that from the first then(..) fulfillment callback, \nwhich causes the second then( .. )’s promise to wait on that 200ms \npromise. \n\n\nChain Flow | 79","metadata":{"loc":{"lines":{"from":108569,"to":108617}}}}],["1178",{"pageContent":"Chain Flow | 79 \n\n\n\n\n\nAs described, technically there are two promises \nin that interchange: the 200ms-delay promise \nand the chained promise that the second \nthen( ..) chains from. But you may find it eas¬ \nier to mentally combine these two promises \ntogether, because the Promise mechanism auto¬ \nmatically merges their states for you. In that \nrespect, you could think of return delay(200) \nas creating a promise that replaces the earlier- \nreturned chained promise. \n\n\nTo be honest, though, sequences of delays with no message passing \nisn’t a terribly useful example of Promise flow control. Let’s look at a \nscenario that’s a little more practical. \n\nInstead of timers, let’s consider making Ajax requests: \n\n// assume an 'ajax( {url}, {callback} )' utility \n\n// Promise-aware ajax \nfunction request(url) { \n\nreturn new Promise( functlon(resolve, reject)! \n\n// the 'ajax(..)' callback should be our \n// promise's ' resolve (..)' function \najax( url, resolve ); \n\n} ); \n\n}","metadata":{"loc":{"lines":{"from":108617,"to":108654}}}}],["1179",{"pageContent":"return new Promise( functlon(resolve, reject)! \n\n// the 'ajax(..)' callback should be our \n// promise's ' resolve (..)' function \najax( url, resolve ); \n\n} ); \n\n} \n\nWe first define a request(..) utility that constructs a promise to \nrepresent the completion of the a jax(..) call: \n\nrequest( \"http://some.url.l/\" ) \n\n.then( functlon(responsel){ \n\nreturn request( \"http://some.url.2/?v=\" + responsel ); \n\n} ) \n\n.then( functlon(response2){ \nconsole.log( response2 ); \n\n} ); \n\n\n80 | Chapter 3: Promises \n\n\n\n\n\nDevelopers commonly encounter situations in \nwhich they want to do Promise-aware async \nflow control with utilities that are not them¬ \nselves Promise-enabled (like ajax(..) here, \nwhich expects a callback). Although the native \nES6 Promise mechanism doesn’t automatically \nsolve this pattern for us, practically all Promise \nlibraries do. They usually call this process “lift¬ \ning,” “promisifying,” or some variation thereof. \nWe’ll come back to this technique later.","metadata":{"loc":{"lines":{"from":108654,"to":108696}}}}],["1180",{"pageContent":"Using the Promise-returning request(. .), we create the first step \nin our chain implicitly by calling it with the first URL, and chain off \nthat returned promise with the first then(..). \n\nOnce responsel comes back, we use that value to construct a sec¬ \nond URL, and make a second request(..) call. That second \nrequest( ..) promise is returned so that the third step in our async \nflow control waits for that Ajax call to complete. Finally, we print \nresponse2 once it returns. \n\nThe Promise chain we construct is not only a flow control that \nexpresses a multistep async sequence, but it also acts as a message \nchannel to propagate messages from step to step. \n\nWhat if something went wrong in one of the steps of the Promise \nchain? An error/exception is on a per-Promise basis, which means \nit’s possible to catch such an error at any point in the chain, and that \ncatching acts to sort of “reset” the chain back to normal operation at \nthat point: \n\n// step 1:","metadata":{"loc":{"lines":{"from":108699,"to":108719}}}}],["1181",{"pageContent":"// step 1: \n\nrequest( \"http://some.url.1/\" ) \n\n// step 2: \n\n.then( function/responsel)/ \n\nfoo.bar(); // undefined, error! \n\n// never gets here \n\nreturn request/ \"http://some.url.2/?v=\" + responsel ); \n\n1 ) \n\n// step 3: \n\n. then( \n\nfunction fulfilled/response2){ \n\n// never gets here \n\n}, \n\n\nChain Flow | 81 \n\n\n\n\n\n// rejection handler to catch the error \nfunction rejected(err){ \nconsole.log( err ); \n\n// 'TypeError' from 'foo.bar()' error \n\nreturn 42; \n\n} \n\n) \n\n// step 4: \n\n.then( function (msg){ \n\nconsole.log( msg ); // 42 \n\n} ); \n\nWhen the error occurs in step 2, the rejection handler in step 3 \ncatches it. The return value (42 in this snippet), if any, from that \nrejection handler fulfills the promise for the next step (4), such that \nthe chain is now back in a fulfillment state.","metadata":{"loc":{"lines":{"from":108719,"to":108775}}}}],["1182",{"pageContent":"As we discussed earlier, when returning a \npromise from a fulfillment handler, it’s unwrap¬ \nped and can delay the next step. That’s also true \nfor returning promises from rejection handlers, \nsuch that if the return 42 in step 3 instead \nreturned a promise, that promise could delay \nstep 4. A thrown exception inside either the ful¬ \nfillment or rejection handler of a then( ..) call \ncauses the next (chained) promise to be imme¬ \ndiately rejected with that exception. \n\n\nIf you call then(..) on a promise, and you only pass a fulfillment \nhandler to it, an assumed rejection handler is substituted: \n\nvar p = new Promise( function(resolve, reject){ \nreject( \"Oops\" ); \n\n} ); \n\nvar p2 = p.then( \n\nfunction fulftlled(){ \n\n// never gets here \n\n} \n\n// assumed rejection handler, if omitted or \n// any other non-function value passed \n// function(err) { \n\n// throw err; \n\n// } \n\n); \n\n\n82 | Chapter 3: Promises","metadata":{"loc":{"lines":{"from":108779,"to":108818}}}}],["1183",{"pageContent":"// never gets here \n\n} \n\n// assumed rejection handler, if omitted or \n// any other non-function value passed \n// function(err) { \n\n// throw err; \n\n// } \n\n); \n\n\n82 | Chapter 3: Promises \n\n\n\n\nAs you can see, the assumed rejection handler simply rethrows the \nerror, which ends up forcing p2 (the chained promise) to reject with \nthe same error reason. In essence, this allows the error to continue \npropagating along a Promise chain until an explicitly defined rejec¬ \ntion handler is encountered. \n\n\n\nWe’ll cover more details of error handling with \nPromises a little later, because there are other \nnuanced details to be concerned about. \n\n\nIf a proper valid function is not passed as the fulfillment handler \nparameter to then(..), there’s also a default handler substituted: \n\nvar p = Promise.resotve( 42 ); \np.then( \n\n// assumed fulfillment handler, if omitted or \n// any other non-function value passed \n// function(v) { \n\n// return v; \n\n// } \n\nnull, \n\nfunction rejected(err){","metadata":{"loc":{"lines":{"from":108818,"to":108867}}}}],["1184",{"pageContent":"// assumed fulfillment handler, if omitted or \n// any other non-function value passed \n// function(v) { \n\n// return v; \n\n// } \n\nnull, \n\nfunction rejected(err){ \n\n// never gets here \n\n} \n\n); \n\nAs you can see, the default fulfillment handler simply passes what¬ \never value it receives along to the next step (Promise). \n\n\n\nThe then(null,function(err){ .. }) pattern \n—only handling rejections (if any) but letting \nfulfillments pass through—has a shortcut in the \nAPI: catch(function(err){ .. }). We’ll cover \ncatch (.. ) more fully in the next section. \n\n\nLet’s review briefly the intrinsic behaviors of Promises that enable \nchaining flow control: \n\n• Athen(..) call against one Promise automatically produces a \nnew Promise to return from the call. \n\n\nChain Flow | 83 \n\n\n\n\n\n\n• Inside the fulfillment/rejection handlers, if you return a value or \nan exception is thrown, the new returned (chainable) Promise is \nresolved accordingly.","metadata":{"loc":{"lines":{"from":108867,"to":108913}}}}],["1185",{"pageContent":"Chain Flow | 83 \n\n\n\n\n\n\n• Inside the fulfillment/rejection handlers, if you return a value or \nan exception is thrown, the new returned (chainable) Promise is \nresolved accordingly. \n\n• If the fulfillment or rejection handler returns a Promise, it is \nunwrapped, so that whatever its resolution is will become the \nresolution of the chained Promise returned from the current \nthen(..). \n\nWhile chaining flow control is helpful, it’s probably most accurate \nto think of it as a side benefit of how Promises compose (combine) \ntogether, rather than the main intent. As we’ve discussed in detail \nseveral times already, Promises normalize asynchrony and encapsu¬ \nlate time-dependent value state, and that is what lets us chain them \ntogether in this useful way.","metadata":{"loc":{"lines":{"from":108913,"to":108934}}}}],["1186",{"pageContent":"Certainly, the sequential expressiveness of the chain (this-then-this- \nthen-this...) is a big improvement over the tangled mess of callbacks \nas we identified in Chapter 2. But there’s still a fair amount of boil¬ \nerplate (then(..) and function(){ .. }) to wade through. In \nChapter 4, we’ll see a significantly nicer pattern for sequential flow \ncontrol expressivity, with generators. \n\nTerminology: Resolve, Fulfill, and Reject \n\nThere’s some slight confusion around the terms resolve, fulfill, and \nreject that we need to clear up, before you get too much deeper into \nlearning about Promises. Let’s first consider the Promise(..) con¬ \nstructor: \n\nvar p = new Promise( function(X,Y){ \n\n// X() f or fulfillment \n// Y() for rejection \n\n} );","metadata":{"loc":{"lines":{"from":108936,"to":108955}}}}],["1187",{"pageContent":"var p = new Promise( function(X,Y){ \n\n// X() f or fulfillment \n// Y() for rejection \n\n} ); \n\nAs you can see, two callbacks (here labeled X and Y) are provided. \nThe first is usually used to mark the Promise as fulfilled, and the \nsecond always marks the Promise as rejected. But what’s the usually \nabout, and what does that imply about accurately naming those \nparameters? \n\nUltimately, it’s just your user code and the identifier names aren’t \ninterpreted by the engine to mean anything, so it doesn’t technically \nmatter; foo(.. ) and bar( .. ) are equally functional. But the words \nyou use can affect not only how you are thinking about the code, but \n\n\n84 | Chapter 3: Promises \n\n\n\nhow other developers on your team will think about it. Thinking \nwrongly about carefully orchestrated async code is almost surely \ngoing to be worse than the spaghetti-callback alternatives. \n\nSo it actually does kind of matter what you call them.","metadata":{"loc":{"lines":{"from":108955,"to":108982}}}}],["1188",{"pageContent":"So it actually does kind of matter what you call them. \n\nThe second parameter is easy to decide. Almost all literature uses \nreject(.. ) as its name, and because that’s exactly (and only!) what \nit does, that’s a very good choice for the name. I’d strongly recom¬ \nmend you always use reject(..). \n\nBut there’s a little more ambiguity around the first parameter, which \nin Promise literature is often labeled resolve(..). That word is \nobviously related to “resolution,” which is what’s used across the lit¬ \nerature (including this book) to describe setting a final value/state to \na Promise. We’ve already used “resolve the Promise” several times \nto mean either fulfilling or rejecting the Promise. \n\nBut if this parameter seems to be used to specifically fulfill the \nPromise, why shouldn’t we call it fulfill/ ..) instead of \nresolve/..) to be more accurate? To answer that question, let’s \nalso take a look at two of the Promise API methods:","metadata":{"loc":{"lines":{"from":108982,"to":108999}}}}],["1189",{"pageContent":"var fulfiltedPr = Promise.resolve/ 42 ); \nvar rejectedPr = Promise.reject/ \"Oops\" ); \n\nPromise . resolve/ ..) creates a Promise that’s resolved to the value \ngiven to it. In this example, 42 is a normal, non-Promise, non- \nthenable value, so the fulfilled promise fulfilledPr is created for \nthe value 42. Promise, reject/\"Oops\") creates the rejected promise \nrejectedPr for the reason \"Oops\". \n\nLet’s now illustrate why the word “resolve” (such as in \nPromise, resolve/ ..)) is unambiguous and indeed more accurate, \nif used explicitly in a context that could result in either fulfillment or \nrejection: \n\nvar rejectedTh = { \n\nthen: function/ resolved,rejected) { \nrejected( \"Oops\" ); \n\n} \n\n}; \n\n\nvar rejectedPr = Promise.resolve/ rejectedTh ); \n\n\nChain Flow | 85","metadata":{"loc":{"lines":{"from":109001,"to":109028}}}}],["1190",{"pageContent":"var rejectedTh = { \n\nthen: function/ resolved,rejected) { \nrejected( \"Oops\" ); \n\n} \n\n}; \n\n\nvar rejectedPr = Promise.resolve/ rejectedTh ); \n\n\nChain Flow | 85 \n\n\n\n\nAs we discussed earlier in this chapter, Promise. resolve( ..) will \nreturn a received genuine Promise directly, or unwrap a received \nthenable. If that thenable unwrapping reveals a rejected state, the \nPromise returned from Promise. resolve(.. ) is in fact in that same \nrejected state. \n\nSo Promise. resolve( ..) is a good, accurate name for the API \nmethod, because it can actually result in either fulfillment or rejec¬ \ntion. \n\nThe first callback parameter of the Promise(..) constructor will \nunwrap either a thenable (identically to Promise. resolve(.. )) or a \ngenuine Promise: \n\nvar rejectedPr = new Promise! function( resolve,reject)! \n\n// resolve this promise with a rejected promise \nresolve( Promise.reject( \"Oops\" ) ); \n\n} ); \n\nrejectedPr . then( \n\nfunction fulftlled(){ \n\n// never gets here \n\n},","metadata":{"loc":{"lines":{"from":109028,"to":109073}}}}],["1191",{"pageContent":"// resolve this promise with a rejected promise \nresolve( Promise.reject( \"Oops\" ) ); \n\n} ); \n\nrejectedPr . then( \n\nfunction fulftlled(){ \n\n// never gets here \n\n}, \n\nfunction rejected(err){ \n\nconsole.log( err ); // \"Oops\" \n\n} \n\n); \n\nIt should be clear now that resolve (..) is the appropriate name for \nthe first callback parameter of the Promise (..) constructor. \n\n\n\nThe previously mentioned reject( ..) does not \ndo the unwrapping that resolve( ..) does. If \nyou pass a Promise/thenable value to \nreject( ■ • ), that untouched value will be set as \nthe rejection reason. A subsequent rejection \nhandler would receive the actual Promise/thena¬ \nble you passed to reject( ..), not its underlying \nimmediate value. \n\n\nBut now let’s turn our attention to the callbacks provided to \nthen(..). What should they be called (both in literature and in \ncode)? I would suggest fulfilled! • •) and rejected!. ■): \n\nfunction fulfilled(msg) { \nconsole.log! msg ); \n\n} \n\n\n86 | Chapter 3: Promises","metadata":{"loc":{"lines":{"from":109073,"to":109119}}}}],["1192",{"pageContent":"function fulfilled(msg) { \nconsole.log! msg ); \n\n} \n\n\n86 | Chapter 3: Promises \n\n\n\n\n\nfunction rejected(err) { \nconsole.error( err ); \n\n} \n\np.then( \n\nfulfilled, \n\nrejected \n\n); \n\nIn the case of the first parameter to then( ..it’s unambiguously \nalways the fulfillment case, so there’s no need for the duality of \n“resolve” terminology. As a side note, the ES6 specification uses \nonFulfilled(.. ) and onRejected(.. ) to label these two callbacks, \nso they are accurate terms. \n\nError Handling \n\nWe’ve already seen several examples of how Promise rejection— \neither intentional through calling reject( ..) or accidental through \nJS exceptions—allows saner error handling in asynchronous pro¬ \ngramming. Let’s circle back though and be explicit about some of \nthe details that we glossed over. \n\nThe most natural form of error handling for most developers is \nthe synchronous try., catch construct. Unfortunately, it’s \nsynchronous-only, so it fails to help in async code patterns: \n\nfunction foo() {","metadata":{"loc":{"lines":{"from":109119,"to":109162}}}}],["1193",{"pageContent":"function foo() { \n\nsetTimeout( function(){ \nbaz.bar(); \n\n}, 100 ); \n\n} \n\ntry { \n\nfoo( ); \n\n// later throws global error from 'baz.bar()' \n\n} \n\ncatch (err) { \n\n// never gets here \n\n} \n\ntry. .catch would certainly be nice to have, but it doesn’t work \nacross async operations. That is, unless there’s some additional envi¬ \nronmental support, which we’ll come back to with generators in \nChapter 4. \n\n\nError Handling | 87 \n\n\n\n\nIn callbacks, some standards have emerged for patterned error han¬ \ndling, most notably the error-first callback style: \n\nfunction foo(cb) { \n\nsetTlmeout( function(){ \ntry { \n\nvar x = baz.bar(); \n\ncb( null, x ); // success! \n\n} \n\ncatch (err) { \ncb( err ); \n\n} \n\n}, 100 ); \n\n} \n\n\nfoo( function(err,val){ \nif (err) { \n\nconsole.error( err ); // bunner :( \n\n} \n\nelse { \n\nconsole.log( val ); \n\n} \n\n} );","metadata":{"loc":{"lines":{"from":109162,"to":109233}}}}],["1194",{"pageContent":"} \n\ncatch (err) { \ncb( err ); \n\n} \n\n}, 100 ); \n\n} \n\n\nfoo( function(err,val){ \nif (err) { \n\nconsole.error( err ); // bunner :( \n\n} \n\nelse { \n\nconsole.log( val ); \n\n} \n\n} ); \n\n\n\nThe try. .catch here works only from the per¬ \nspective that the baz.barQ call will either suc¬ \nceed or fail immediately, synchronously. If \nbaz.barQ was itself its own async completing \nfunction, any async errors inside it would not be \ncatchable. \n\n\nThe callback we pass to foo(..) expects to receive a signal of an \nerror by the reserved first parameter, err. If present, error is \nassumed. If not, success is assumed. \n\nThis sort of error handling is technically async capable, but it \ndoesn’t compose well at all. Multiple levels of error-first callbacks \nwoven together with these ubiquitous if statement checks will \ninevitably lead you to the perils of callback hell (see Chapter 2).","metadata":{"loc":{"lines":{"from":109233,"to":109277}}}}],["1195",{"pageContent":"So we come back to error handling in Promises, with the rejection \nhandler passed to then(..). Promises don’t use the popular error- \nfirst callback design style, but instead use split-callback style; there’s \none callback for fulfillment and one for rejection: \n\n\n88 | Chapter 3: Promises \n\n\n\n\n\n\nvar p = Promise.reject( \"Oops\" ); \n\n\np.then( \n\nfunction fulfilled(){ \n\n// never gets here \n\n}, \n\nfunction rejected(err){ \n\nconsole.log( err ); // \"Oops\" \n\n} \n\n); \n\nWhile this pattern of error handling makes fine sense on the surface, \nthe nuances of Promise error handling are often a fair bit more diffi¬ \ncult to fully grasp. \n\nConsider: \n\nvar p = Promise.resolve( 42 ); \np.then( \n\nfunction fulfilled(msg){ \n\n// numbers don't have string functions, \n\n// so will throw an error \nconsole.log( msg . toLowerCase( ) ); \n\n}. \n\nfunction rejected(err){ \n\n// never gets here \n\n} \n\n);","metadata":{"loc":{"lines":{"from":109279,"to":109335}}}}],["1196",{"pageContent":"function fulfilled(msg){ \n\n// numbers don't have string functions, \n\n// so will throw an error \nconsole.log( msg . toLowerCase( ) ); \n\n}. \n\nfunction rejected(err){ \n\n// never gets here \n\n} \n\n); \n\nIf the msg.toLowerCaseQ legitimately throws an error (it does!), \nwhy doesn’t our error handler get notified? As we explained earlier, \nit’s because that error handler is for the p promise, which has \nalready been fulfilled with value 42. The p promise is immutable, so \nthe only promise that can be notified of the error is the one returned \nfrom p. t h e n (..), which in this case we don’t capture. \n\nThat should paint a clear picture of why error handling with Prom¬ \nises is error-prone (pun intended). It’s far too easy to have errors \nswallowed, as this is very rarely what you’d intend. \n\n\nError Handling | 89","metadata":{"loc":{"lines":{"from":109335,"to":109364}}}}],["1197",{"pageContent":"Error Handling | 89 \n\n\n\n\nIf you use the Promise API in an invalid way \nand an error occurs that prevents proper \nPromise construction, the result will be an \nimmediately thrown exception, not a rejected \nPromise. Some examples of incorrect usage that \nfail Promise construction: new Pronise(null), \nPromise.all(), Promise.race(42), and so on. \nYou can’t get a rejected Promise if you don’t use \nthe Promise API validly enough to actually con¬ \nstruct a Promise in the first place! \n\n\nPit of Despair \n\nJeff Atwood noted years ago that programming languages are often \nset up in such a way that, by default, developers fall into the “pit of \ndespair”— where accidents are punished—and that you have to try \nharder to get it right. He implored us to instead create a “pit of suc¬ \ncess,” where by default you fall into expected (successful) action, \nand thus would have to try hard to fail.","metadata":{"loc":{"lines":{"from":109364,"to":109388}}}}],["1198",{"pageContent":"Promise error handling is unquestionably “pit of despair” design. By \ndefault, it assumes that you want any error to be swallowed by the \nPromise state, and if you forget to observe that state, the error \nsilently languishes/dies in obscurity—usually despair. \n\nTo avoid losing an error to the silence of a forgotten/discarded \nPromise, some developers have claimed that a best practice for \nPromise chains is to always end your chain with a final catch(..), \nlike: \n\n\nvar p = Promise.resolve( 42 ); \np.then( \n\nfunction fulfilled(msg){ \n\n// numbers don't have string functions, \n\n// so will throw an error \nconsole.log( msg.toiowerCaseQ ); \n\n} \n\n) \n\n.catch( handleErrors );","metadata":{"loc":{"lines":{"from":109390,"to":109415}}}}],["1199",{"pageContent":"function fulfilled(msg){ \n\n// numbers don't have string functions, \n\n// so will throw an error \nconsole.log( msg.toiowerCaseQ ); \n\n} \n\n) \n\n.catch( handleErrors ); \n\nBecause we didn’t pass a rejection handler to the then(..), the \ndefault handler was substituted, which simply propagates the error \nto the next promise in the chain. As such, both errors that come into \np, and errors that come after p in its resolution (like the msg.toLo \nwerCaseQ one) will filter down to the final handleErrors(..). \n\n\n90 | Chapter 3: Promises \n\n\n\n\nProblem solved, right? Not so fast! \n\nWhat happens if handleErrors( ..) itself also has an error in it? \nWho catches that? There’s still yet another unattended promise: the \none catch (..) returns, which we don’t capture and don’t register a \nrejection handler for.","metadata":{"loc":{"lines":{"from":109415,"to":109445}}}}],["1200",{"pageContent":"You can’t just stick another catch(..) on the end of that chain, \nbecause it too could fail. The last step in any Promise chain, what¬ \never it is, always has the possibility, even decreasingly so, of dan¬ \ngling with an uncaught error stuck inside an unobserved Promise. \n\nSound like an impossible conundrum yet? \n\nUncaught Handling \n\nIt’s not exactly an easy problem to solve completely. There are other \n(many would say better) ways to approach it. \n\nSome Promise libraries have added methods for registering some¬ \nthing like a “global unhandled rejection” handler, which would be \ncalled instead of a globally thrown error. But their solution for how \nto identify an error as uncaught is to have an arbitrary-length timer, \nsay three seconds, running from time of rejection. If a Promise is \nrejected but no error handler is registered before the timer fires, \nthen it’s assumed that you won’t ever be registering a handler, so it’s \nuncaught.","metadata":{"loc":{"lines":{"from":109447,"to":109466}}}}],["1201",{"pageContent":"In practice, this has worked well for many libraries, as most usage \npatterns don’t typically call for significant delay between Promise \nrejection and observation of that rejection. But this pattern is trou¬ \nblesome because three seconds is so arbitrary (even if empirical), \nand also because there are indeed some cases where you want a \nPromise to hold on to its rejectedness for some indefinite period of \ntime, and you don’t really want to have your uncaught handler \ncalled for all those false positives (not-yet-handled uncaught errors). \n\nAnother more common suggestion is that Promises should have a \ndone(. .) added to them, which essentially marks the Promise chain \nas done. done(. .) doesn’t create and return a Promise, so the call¬ \nbacks passed to done( ..) are obviously not wired up to report prob¬ \nlems to a chained Promise that doesn’t exist.","metadata":{"loc":{"lines":{"from":109468,"to":109481}}}}],["1202",{"pageContent":"So what happens instead? It’s treated as you might usually expect in \nuncaught error conditions: any exception inside a done(.. ) rejec- \n\n\nError Handling | 91 \n\n\n\n\ntion handler would be thrown as a global uncaught error (in the \ndeveloper console, basically): \n\nvar p = Promise.resotve( 42 ); \np.then( \n\nfunction fulfilled(msg){ \n\n// numbers don't have string functions, \n\n// so will throw an error \nconsole.log( msg . toLowerCase( ) ); \n\n} \n\n) \n\n.done( null, handleErrors ); \n\n// if ~handleErrors(..)' caused its own exception, it would \n// be thrown globally here \n\nThis might sound more attractive than the never-ending chain or \nthe arbitrary timeouts. But the biggest problem is that it’s not part of \nthe ES6 standard, so no matter how good it sounds, at best it’s a lot \nlonger way off from being a reliable and ubiquitous solution. \n\nAre we just stuck, then? Not entirely.","metadata":{"loc":{"lines":{"from":109483,"to":109519}}}}],["1203",{"pageContent":"Are we just stuck, then? Not entirely. \n\nBrowsers have a unique capability that our code does not have: they \ncan track and know for sure when any object gets thrown away and \ngarbage collected. So, browsers can track Promise objects, and \nwhenever they get garbage collected, if they have a rejection in them, \nthe browser knows for sure this was a legitimate uncaught error, and \ncan thus confidently know it should report it to the developer con¬ \nsole. \n\n\n\nAt the time of this writing, both Chrome and \nFirefox have early attempts at this sort of \nuncaught rejection capability, though support is \nincomplete at best. \n\n\nHowever, if a Promise doesn’t get garbage collected—it’s exceed¬ \ningly easy for that to accidentally happen through lots of different \ncoding patterns—the browser’s garbage collection sniffing won’t \nhelp you know and diagnose that you have a silently rejected \nPromise laying around. \n\nIs there any other alternative? Yes. \n\n\n92 | Chapter 3: Promises","metadata":{"loc":{"lines":{"from":109519,"to":109546}}}}],["1204",{"pageContent":"Is there any other alternative? Yes. \n\n\n92 | Chapter 3: Promises \n\n\n\n\n\n\nPit of Success \n\nThe following is just theoretical, how Promises could be someday \nchanged to behave. I believe it would be far superior to what we cur¬ \nrently have. And I think this change would be possible even post- \nES6 because I don’t think it would break web compatibility with ES6 \nPromises. Moreover, it can be polyfilled/prollyfilled in, if you’re \ncareful. Let’s take a look: \n\n• Promises could default to reporting (to the developer console) \nany rejection, on the next Job or event loop tick, if at that exact \nmoment no error handler has been registered for the Promise. \n\n• For the cases where you want a rejected Promise to hold onto its \nrejected state for an indefinite amount of time before observing, \nyou could call deferQ, which suppresses automatic error \nreporting on that Promise.","metadata":{"loc":{"lines":{"from":109546,"to":109572}}}}],["1205",{"pageContent":"If a Promise is rejected, it defaults to noisily reporting that fact to \nthe developer console (instead of defaulting to silence). You can opt \nout of that reporting either implicitly (by registering an error han¬ \ndler before rejection), or explicitly (with deferQ). In either case, \nyou control the false positives. \n\nConsider: \n\nvar p = Promise.reject( \"Oops\" ).defer(); \n\n// 'foo(..)~ is Pronise-aware \nfoo( 42 ) \n\n. then( \n\nfunction fulfilled(){ \nreturn p; \n\n}. \n\nfunction rejected(err){ \n\n// handle 'foo(..)' error \n\n} \n\n); \n\n\nWhen we create p, we know we’re going to wait a while to use/ \nobserve its rejection, so we call deferQ —thus no global reporting. \ndeferQ simply returns the same promise, for chaining purposes. \n\nThe promise returned from foo( ..) gets an error handler attached \nright away, so it’s implicitly opted out and no global reporting for it \noccurs either. \n\n\nError Handling | 93","metadata":{"loc":{"lines":{"from":109574,"to":109612}}}}],["1206",{"pageContent":"The promise returned from foo( ..) gets an error handler attached \nright away, so it’s implicitly opted out and no global reporting for it \noccurs either. \n\n\nError Handling | 93 \n\n\n\nBut the promise returned from the then( ..) call has no defer () or \nerror handler attached, so if it rejects (from inside either resolution \nhandler), then it will be reported to the developer console as an \nuncaught error. \n\nThis design is a pit of success. By default, all errors are either handled \nor reported—what almost all developers in almost all cases would \nexpect. You either have to register a handler or you have to inten¬ \ntionally opt out, and indicate you intend to defer error handling \nuntil later; you’re opting for the extra responsibility in just that spe¬ \ncific case. \n\nThe only real danger in this approach is if you defer () a Promise \nbut then fail to actually ever observe/handle its rejection.","metadata":{"loc":{"lines":{"from":109612,"to":109634}}}}],["1207",{"pageContent":"The only real danger in this approach is if you defer () a Promise \nbut then fail to actually ever observe/handle its rejection. \n\nBut you had to intentionally call deferQ to opt into that pit of \ndespair—the default was the pit of success—so there’s not much else \nwe could do to save you from your own mistakes. \n\nI think there’s still hope for Promise error handling (post-ES6). I \nhope the powers that be will rethink the situation and consider this \nalternative. In the meantime, you can implement this yourself (a \nchallenging exercise for the reader!), or use a smarter Promise \nlibrary that does so for you! \n\n\n\nThis exact model for error handling/reporting is \nimplemented in my asynquence Promise \nabstraction library, which is discussed in \nAppendix A of this book. \n\n\nPromise Patterns","metadata":{"loc":{"lines":{"from":109634,"to":109655}}}}],["1208",{"pageContent":"This exact model for error handling/reporting is \nimplemented in my asynquence Promise \nabstraction library, which is discussed in \nAppendix A of this book. \n\n\nPromise Patterns \n\nWe’ve already implicitly seen the sequence pattern with Promise \nchains (this-then-this-then-that flow control) but there are lots of \nvariations on asynchronous patterns that we can build as abstrac¬ \ntions on top of Promises. These patterns serve to simplify the \nexpression of async flow control—which helps make our code more \nreason-able and more maintainable—even in the most complex \nparts of our programs. \n\nTwo such patterns are codified directly into the native ES6 Promise \nimplementation, so we get them for free, to use as building blocks \nfor other patterns. \n\n\n94 | Chapter 3: Promises \n\n\n\n\n\n\nPromise.all([.. ])","metadata":{"loc":{"lines":{"from":109655,"to":109683}}}}],["1209",{"pageContent":"94 | Chapter 3: Promises \n\n\n\n\n\n\nPromise.all([.. ]) \n\nIn an async sequence (Promise chain), only one async task is being \ncoordinated at any given moment—step 2 strictly follows step 1, and \nstep 3 strictly follows step 2. But what about doing two or more \nsteps concurrently (aka “in parallel”)? \n\nIn classic programming terminology, a gate is a mechanism that \nwaits on two or more parallel/concurrent tasks to complete before \ncontinuing. It doesn’t matter what order they finish in, just that all \nof them have to complete for the gate to open and let the flow con¬ \ntrol through. \n\nIn the Promise API, we call this pattern all ([ .. ]). \n\nSay you wanted to make two Ajax requests at the same time, and \nwait for both to finish, regardless of their order, before making a \nthird Ajax request. Consider: \n\n// ' request(..) ' is a Promise-aware Ajax utility, \n\n// like we defined earlier in the chapter \n\nvar pi = request( \"http://some.url. 1/\" ); \nvar p2 = request( \"http://some.url.2/\" );","metadata":{"loc":{"lines":{"from":109683,"to":109714}}}}],["1210",{"pageContent":"// ' request(..) ' is a Promise-aware Ajax utility, \n\n// like we defined earlier in the chapter \n\nvar pi = request( \"http://some.url. 1/\" ); \nvar p2 = request( \"http://some.url.2/\" ); \n\nPromise.all( [pl,p2] ) \n\n.then( function(msgs){ \n\n// both 'pi' and 'p2' fulfill and pass in \n// their messages here \n\nreturn request! \n\n\"http://some.url.3/?v=\" + msgs . join(\" , \") \n\n); \n\nI ) \n\n.then( function (msg){ \nconsole.log( msg ); \n\nI ); \n\nPromise. all([ .. ]) expects a single argument, an array, consist¬ \ning generally of Promise instances. The promise returned from the \nPromise. all([ .. ]) call will receive a fulfillment message (msgs \nin this snippet) that is an array of all the fulfillment messages from \nthe passed in promises, in the same order as specified (regardless of \nfulfillment order). \n\n\nPromise Patterns | 95 \n\n\n\n\n\nTechnically, the array of values passed into \nPromise.all([ .. ]) can include Promises,","metadata":{"loc":{"lines":{"from":109714,"to":109756}}}}],["1211",{"pageContent":"Promise Patterns | 95 \n\n\n\n\n\nTechnically, the array of values passed into \nPromise.all([ .. ]) can include Promises, \n\nthenables, or even immediate values. Each value \nin the list is essentially passed through \nPromise. resoive( ..) to make sure it’s a genu¬ \nine Promise to be waited on, so an immediate \nvalue will just be normalized into a Promise for \nthat value. If the array is empty, the main \nPromise is immediately fulfilled. \n\n\nThe main promise returned from Promise.all([ .. ]) will only \nbe fulfilled if and when all its constituent promises are fulfilled. If \nany one of those promises is instead rejected, the main \nPromise.all([ .. ]) promise is immediately rejected, discarding \nall results from any other promises. \n\nRemember to always attach a rejection/error handler to every \npromise, even and especially the one that comes back from \nPromise.all([ .. ]). \n\nPromise.race([.. ])","metadata":{"loc":{"lines":{"from":109756,"to":109784}}}}],["1212",{"pageContent":"Remember to always attach a rejection/error handler to every \npromise, even and especially the one that comes back from \nPromise.all([ .. ]). \n\nPromise.race([.. ]) \n\nWhile Promise.all([ .. ]) coordinates multiple Promises con¬ \ncurrently and assumes all are needed for fulfillment, sometimes you \nwant to respond only to the “first Promise to cross the finish line,” \nletting the other Promises fall away. \n\nThis pattern is classically called a latch, but in Promises it’s called a \nrace. \n\n\n\nWhile the metaphor of “only the first across the \nfinish line wins” fits the behavior well, unfortu¬ \nnately “race” is kind of a loaded term, because \nrace conditions are generally taken as bugs in \nprograms (see Chapter 1). Don’t confuse \nPromise. race( [.. ]) with a race condition.","metadata":{"loc":{"lines":{"from":109784,"to":109805}}}}],["1213",{"pageContent":"Promise.race([ .. ]) also expects a single array argument, con¬ \ntaining one or more Promises, thenables, or immediate values. It \ndoesn’t make much practical sense to have a race with immediate \nvalues, because the first one listed will obviously win—like a foot \nrace where one runner starts at the finish line! \n\n\n96 | Chapter 3: Promises \n\n\n\n\n\n\nSimilarto Promise, all([ .. ]), Promise. race( [ .. ]) will fulfill \nif and when any Promise resolution is a fulfillment, and it will reject \nif and when any Promise resolution is a rejection.","metadata":{"loc":{"lines":{"from":109808,"to":109824}}}}],["1214",{"pageContent":"Similarto Promise, all([ .. ]), Promise. race( [ .. ]) will fulfill \nif and when any Promise resolution is a fulfillment, and it will reject \nif and when any Promise resolution is a rejection. \n\n\n\nA race requires at least one “runner,” so if you \npass an empty array, instead of immediately \nresolving, the main race([..]) Promise will \nnever resolve. This is a footgun! ES6 should have \nspecified that it either fulfills, rejects, or just \nthrows some sort of synchronous error. \nUnfortunately, because of precedence in \nPromise libraries predating ES6 Promise, they \nhad to leave this gotcha in there, so be careful \nnever to send in an empty array. \n\n\nLet’s revisit our previous concurrent Ajax example, but in the con¬ \ntext of a race between pi and p2: \n\n// 'request(..is a Promise-aware Ajax utility, \n\n// like we defined earlier in the chapter \n\nvar pi = request( \"http://some.url. 1/\" ); \nvar p2 = request( \"http://some.url.2/\" ); \n\nPromise.race( [pl,p2] ) \n\n.then( function(msg){","metadata":{"loc":{"lines":{"from":109824,"to":109854}}}}],["1215",{"pageContent":"// like we defined earlier in the chapter \n\nvar pi = request( \"http://some.url. 1/\" ); \nvar p2 = request( \"http://some.url.2/\" ); \n\nPromise.race( [pl,p2] ) \n\n.then( function(msg){ \n\n// either 'pi' or 'p2' will win the race \nreturn request( \n\n\"http://some.url.3/?v=\" + msg \n\n); \n\n} ) \n\n.then( function(msg){ \nconsole.log( msg ); \n\n} ); \n\nBecause only one promise wins, the fulfillment value is a single mes¬ \nsage, not an array as it was for Promise. all( [ .. ]). \n\nTimeout Race \n\nWe saw this example earlier, illustrating how \nPromise. race( [ .. ]) can be used to express the Promise timeout \npattern: \n\n// ~foo()' is a Promise-aware function \n\n// 'timeoutPromise(.., defined ealier, returns \n\n\nPromise Patterns | 97 \n\n\n\n\n// a Promise that rejects after a specified delay \n\n\n// setup a timeout for 'foo()' \n\nPromise.race( [ \n\nfoo(), // attempt 'foo()' \n\ntimeoutPromlseC 3000 ) // give it 3 seconds \n\n] ) \n\n. then( \n\nfunction(){ \n\n// 'foo(..)' fulfilled in time! \n\n}. \n\nfunction(err){","metadata":{"loc":{"lines":{"from":109854,"to":109917}}}}],["1216",{"pageContent":"Promise.race( [ \n\nfoo(), // attempt 'foo()' \n\ntimeoutPromlseC 3000 ) // give it 3 seconds \n\n] ) \n\n. then( \n\nfunction(){ \n\n// 'foo(..)' fulfilled in time! \n\n}. \n\nfunction(err){ \n\n// either 'foo()' rejected, or it just \n// didn't finish in time, so inspect \n// 'err' to know which \n\n} \n\n); \n\nThis timeout pattern works well in most cases. But there are some \nnuances to consider, and frankly they apply to both \nPromise.race([ .. ]) and Promise.all([ .. ]) equally. \n\n\"Finally\" \n\nThe key question to ask is, “What happens to the promises that get \ndiscarded/ignored?” We’re not asking that question from the per¬ \nformance perspective—they would typically end up garbage collec¬ \ntion eligible—but from the behavioral perspective (side effects, etc.). \nPromises cannot be canceled—and shouldn’t be as that would \ndestroy the external immutability trust discussed in “Promise \nUncancelable” on page 116 —so they can only be silently ignored.","metadata":{"loc":{"lines":{"from":109917,"to":109955}}}}],["1217",{"pageContent":"But what if foo() in the previous example is reserving some sort of \nresource for usage, but the timeout fires first and causes that \npromise to be ignored? Is there anything in this pattern that proac¬ \ntively frees the reserved resource after the timeout, or otherwise can¬ \ncels any side effects it may have had? What if all you wanted was to \nlog the fact that foo( ) timed out? \n\nSome developers have proposed that Promises need a finally(..) \ncallback registration, which is always called when a Promise \nresolves, and allows you to specify any cleanup that may be neces¬ \nsary. This doesn’t exist in the specification at the moment, but it \nmay come in ES7+. We’ll have to wait and see. \n\nIt might look like: \n\n\n98 | Chapter 3: Promises \n\n\n\n\n\nvar p = Promise.resolve( 42 ); \n\n\np.then( something ) \n\n. finally ( cleanup ) \n.then( another ) \n\n. finally ( cleanup );","metadata":{"loc":{"lines":{"from":109957,"to":109987}}}}],["1218",{"pageContent":"It might look like: \n\n\n98 | Chapter 3: Promises \n\n\n\n\n\nvar p = Promise.resolve( 42 ); \n\n\np.then( something ) \n\n. finally ( cleanup ) \n.then( another ) \n\n. finally ( cleanup ); \n\n\n\nIn various Promise libraries, finally(..) still \ncreates and returns a new Promise (to keep the \nchain going). If the cleanup( ..) function were \nto return a Promise, it would be linked into the \nchain, which means you could still have the \nunhandled rejection issues we discussed earlier. \n\n\nIn the meantime, we could make a static helper utility that lets us \nobserve (without interfering with) the resolution of a Promise: \n\n// polyfill-safe guard check \nIf (! Promise.observe) { \n\nPromise.observe = function(pr,cb) { \n\n// side-observe 'pr~'s resolution \npr . then( \n\nfunction fulfilled (msg){ \n\n// schedule callback async (as Job) \n\nPromise.resolve( msg ).then( cb ); \n\n}. \n\nfunction rejected(err){ \n\n// schedule callback async (as Job) \n\nPromise.resolve( err ).then( cb ); \n\n} \n\n); \n\n\n// return original promise","metadata":{"loc":{"lines":{"from":109987,"to":110046}}}}],["1219",{"pageContent":"Promise.resolve( msg ).then( cb ); \n\n}. \n\nfunction rejected(err){ \n\n// schedule callback async (as Job) \n\nPromise.resolve( err ).then( cb ); \n\n} \n\n); \n\n\n// return original promise \n\nreturn pr; \n\n}; \n\n} \n\nHere’s how we’d use it in the timeout example from before: \n\nPromise.race( [ \n\nPromise.observe! \n\nfoo(), // attempt ~foo()' \n\nfunction cleanup(msg){ \n\n// clean up after 'foo()~, even if it \n// didn't finish before the timeout \n\n} \n\n). \n\ntimeoutPromise( 3000 ) // give it 3 seconds \n\n\nPromise Patterns | 99 \n\n\n\n\n\nThis Promise. observe(..) helper is just an illustration of how you \ncould observe the completions of Promises without interfering with \nthem. Other Promise libraries have their own solutions. Regardless \nof how you do it, you’ll likely have places where you want to make \nsure your Promises aren’t just silently ignored by accident. \n\nVariations on all([.. ]) and race([.. ])","metadata":{"loc":{"lines":{"from":110046,"to":110101}}}}],["1220",{"pageContent":"Variations on all([.. ]) and race([.. ]) \n\nWhile native ES6 Promises come with built-in \nPromise.all([ .. ]) and Promise.race([ .. ]), there are sev¬ \neral other commonly used patterns with variations on those seman¬ \ntics: \n\nnone([ .. ]) \n\nThis pattern is like all([ .. ]), but fulfillments and rejections \nare transposed. All Promises need to be rejected—rejections \nbecome the fulfillment values and vice versa. \n\nany([ .. ]) \n\nThis pattern is like all( [ .. ]), but it ignores any rejections, \nso only one needs to fulfill instead of all of them. \n\nfirst([ .. ]) \n\nThis pattern is like a race with any( [ .. ]), which means that \nit ignores any rejections and fulfills as soon as the first Promise \nfulfills. \n\nlast([ .. ]) \n\nThis pattern is like first([ .. ]), but only the latest fulfill¬ \nment wins. \n\nSome Promise abstraction libraries provide these, but you could also \ndefine them yourself using the mechanics of Promises, \nrace([ .. ])andall([ .. ]).","metadata":{"loc":{"lines":{"from":110101,"to":110132}}}}],["1221",{"pageContent":"Some Promise abstraction libraries provide these, but you could also \ndefine them yourself using the mechanics of Promises, \nrace([ .. ])andall([ .. ]). \n\nFor example, here’s how we could define f i r s t ([ .. ]): \n\n// poly fill-safe guard check \nif (! Promise. first) { \n\nPromise.first = function(prs) { \n\nreturn new Promise( function( resolve,reject){ \n\n// loop through all pronises \nprs.forEach( function(pr){ \n\n// normalize the value \nPromise.resolve( pr ) \n\n// whichever one fulfills first wins, and \n\n\n100 | Chapter 3: Promises \n\n\n\n// gets to resolve the main promise \n. then( resolve ); \n\n} ); \n\n} ); \n\n}; \n\n} \n\n\n\nThis implementation of first(..) does not \nreject if all its promises reject; it simply hangs, \nmuch like a Promise. race([]) does. If desired, \nyou could add additional logic to track each \npromise rejection and if all reject, call reject() \non the main promise. We’ll leave that as an \nexercise for the reader. \n\n\nConcurrent Iterations","metadata":{"loc":{"lines":{"from":110132,"to":110180}}}}],["1222",{"pageContent":"Concurrent Iterations \n\nSometimes you want to iterate over a list of Promises and perform \nsome task against all of them, much like you can do with synchro¬ \nnous arrays (e.g., forEach(..), map(..), some(..), and \n\nevery(.. )). If the task to perform against each Promise is funda¬ \nmentally synchronous, these work fine, just as we used forEach(..) \nin the previous snippet. \n\nBut if the tasks are fundamentally asynchronous, or can/should \notherwise be performed concurrently, you can use async versions of \nthese utilities as provided by many libraries. \n\nFor example, let’s consider an asynchronous map( ..) utility that \ntakes an array of values (could be Promises or anything else), plus a \nfunction (task) to perform against each. map( ..) itself returns a \npromise whose fulfillment value is an array that holds (in the same \nmapping order) the async fulfillment value from each task: \n\nif (! Promise.map) { \n\nPromise.map = function(vals,cb) {","metadata":{"loc":{"lines":{"from":110180,"to":110202}}}}],["1223",{"pageContent":"if (! Promise.map) { \n\nPromise.map = function(vals,cb) { \n\n// new promise that waits for all mapped promises \n\nreturn Promise.all( \n\n// note: regular array 'map(..)', turns \n// the array of values into an array of \n// promises \n\nvals.map( function(val){ \n\n// replace 'val' with a new promise that \n// resolves after 'val' is async mapped \nreturn new Promise! function(resolve){ \ncb( val, resolve ); \n\n\nPromise Patterns | 101 \n\n\n\n\n\n} \n\n\n}; \n\n\n} ); \n\n} ) \n\n); \n\n\n\nIn this implementation of map(..)> you can’t \nsignal async rejection, but if a synchronous \nexception/error occurs inside of the mapping \ncallback (cb(..))> the main Promise. map(..) \nreturned promise would reject. \n\n\nLet’s illustrate using map(..) with a list of Promises (instead of sim¬ \nple values): \n\nvar pi = Promise.resolve! 21 ); \nvar p2 = Promise.resolve! 42 ); \nvar p3 = Promise.reject( \"Oops\" ); \n\n// double values in list even if they're in \n// Promises \n\nPromise.map( [pl,p2,p3], function(pr,done){","metadata":{"loc":{"lines":{"from":110202,"to":110259}}}}],["1224",{"pageContent":"// double values in list even if they're in \n// Promises \n\nPromise.map( [pl,p2,p3], function(pr,done){ \n\n// make sure the item itself is a Promise \nPromise.resolve! P r ) \n\n. then( \n\n// extract value as 'v' \n\nfunction(v){ \n\n// map fulfillment 'v' to new value \ndone( v * 2 ); \n\n}, \n\n// or, map to promise rejection message \ndone \n\n); \n\n} ) \n\n.then( function(vals){ \n\nconsole.log! vals ); // [42,84,\"Oops\"] \n\n} ); \n\nPromise API Recap \n\nLet’s review the ES6 Promise API that we’ve already seen unfold in \nbits and pieces throughout this chapter. \n\n\n102 | Chapter 3: Promises \n\n\n\n\n\n\nThe following API is native only as of ES6, but \nthere are specification-compliant polyfills (not \njust extended Promise libraries) which can \ndefine Promise and all its associated behavior so \nthat you can use native Promises even in pre- \nES6 browsers. One such polyfill is “Native \nPromise Only”, which I wrote! \n\n\nnew Promise(..) Constructor","metadata":{"loc":{"lines":{"from":110259,"to":110313}}}}],["1225",{"pageContent":"new Promise(..) Constructor \n\nThe revealing constructor Promise/..) must be used with new, and \nmust be provided a function callback, which is synchronously/ \nimmediately called. This function is passed two function callbacks \nthat act as resolution capabilities for the promise. We commonly \nlabel these resolve(..) and re ject(..): \n\nvar p = new Promise/ function(resolve,reject){ \n\n// 're solve(..) ' to resolve/fulfill the promise \n// 'reject(..)' to reject the promise \n\n} ); \n\nreject/..) simply rejects the promise, but resolve(..) can either \nfulfill the promise or reject it, depending on what it’s passed. If \nresolve/..) is passed an immediate, non-Promise, non-thenable \nvalue, then the promise is fulfilled with that value. \n\nBut if resolve /..) is passed a genuine Promise or thenable value, \nthat value is unwrapped recursively, and whatever its final resolu¬ \ntion/state is will be adopted by the promise. \n\nPromise.resolve(..) and Promise.reject(..)","metadata":{"loc":{"lines":{"from":110313,"to":110337}}}}],["1226",{"pageContent":"Promise.resolve(..) and Promise.reject(..) \n\nA shortcut for creating an already-rejected Promise is \nPromise. reject/..), so these two promises are equivalent: \n\nvar pi = new Promise/ function(resolve,reject){ \nreject/ \"Oops\" ); \n\n1 ); \n\nvar p2 = Promise.reject/ \"Oops\" ); \n\nPromise, resolve/..) is usually used to create an already-fulfilled \nPromise in a similar way to Promise, reject/..). However, \nPromise, resolve/..) also unwraps thenable values (as discusssed \nseveral times already). In that case, the Promise returned adopts the \n\n\nPromise API Recap | 103 \n\n\n\n\n\nfinal resolution of the thenable you passed in, which could either be \nfulfillment or rejection: \n\nvar fulfiltedTh = { \n\nthen: function(cb) { cb( 42 ); } \n\n}; \n\nvar rejectedTh = { \n\nthen: function(cb,errCb) { \nerrCb( \"Oops\" ); \n\n} \n\n}; \n\n\nvar pi = Promise.resotve( fulfiltedTh ); \nvar p2 = Promise.resotve( rejectedTh ); \n\n// 'pi' will be a fulfilled promise \n// 'p2' will be a rejected promise","metadata":{"loc":{"lines":{"from":110337,"to":110384}}}}],["1227",{"pageContent":"} \n\n}; \n\n\nvar pi = Promise.resotve( fulfiltedTh ); \nvar p2 = Promise.resotve( rejectedTh ); \n\n// 'pi' will be a fulfilled promise \n// 'p2' will be a rejected promise \n\nAnd remember, Promise, resolvef ..) doesn’t do anything if what \nyou pass is already a genuine Promise; it just returns the value \ndirectly. So there’s no overhead to calling Promise. resolvef.. ) on \nvalues that you don’t know the nature of, if one happens to already \nbe a genuine Promise. \n\nthen(..) and catch(..) \n\nEach Promise instance ( not the Promise API namespace) has \nthen(. .) and catchf. .) methods, which allow registering of fulfill¬ \nment and rejection handlers for the Promise. Once the Promise is \nresolved, one or the other of these handlers will be called, but not \nboth, and it will always be called asynchronously (see “Jobs” on page \n23 in Chapter 1).","metadata":{"loc":{"lines":{"from":110384,"to":110408}}}}],["1228",{"pageContent":"then( ..) takes one or two parameters, the first for the fulfillment \ncallback, and the second for the rejection callback. If either is omit¬ \nted or is otherwise passed as a non-function value, a default callback \nis substituted respectively. The default fulfillment callback simply \npasses the message along, while the default rejection callback simply \nrethrows (propagates) the error reason it receives. \n\ncatch (..) takes only the rejection callback as a parameter, and \nautomatically substitutes the default fulfillment callback, as just dis¬ \ncussed. In other words, it’s equivalent to thenfnull,..): \n\n\n104 | Chapter 3: Promises \n\n\n\n\np.then( fulfilled ); \n\n\np.then( fulfilled, rejected ); \n\np.catch( rejected ); // or 'p.then( null, rejected )'","metadata":{"loc":{"lines":{"from":110410,"to":110432}}}}],["1229",{"pageContent":"104 | Chapter 3: Promises \n\n\n\n\np.then( fulfilled ); \n\n\np.then( fulfilled, rejected ); \n\np.catch( rejected ); // or 'p.then( null, rejected )' \n\nthen(..) and catch(..) also create and return a new promise, \nwhich can be used to express Promise chain flow control. If the ful¬ \nfillment or rejection callbacks have an exception thrown, the \nreturned promise is rejected. If either callback returns an immedi¬ \nate, non-Promise, non-thenable value, that value is set as the fulfill¬ \nment for the returned promise. If the fulfillment handler specifically \nreturns a promise or thenable value, that value is unwrapped and \nbecomes the resolution of the returned promise. \n\nPromise.all([.. ]) and Promise.race([.. ]) \n\nThe static helpers Promise. all([ .. ]) and \n\nPromise.race([ .. ]) on the ES6 Promise API both create a \nPromise as their return value. The resolution of that promise is con¬ \ntrolled entirely by the array of promises that you pass in.","metadata":{"loc":{"lines":{"from":110432,"to":110459}}}}],["1230",{"pageContent":"Promise.race([ .. ]) on the ES6 Promise API both create a \nPromise as their return value. The resolution of that promise is con¬ \ntrolled entirely by the array of promises that you pass in. \n\nFor Promise.all( [ .. ]), all the promises you pass in must fulfill \nfor the returned promise to fulfill. If any promise is rejected, the \nmain returned promise is immediately rejected, too (discarding the \nresults of any of the other promises). For fulfillment, you receive an \narray of all the passed in promises’ fulfillment values. For rejection, \nyou receive just the first promise rejection reason value. This pattern \nis classically called a gate: all must arrive before the gate opens. \n\nFor Promise. race([ .. ]), only the first promise to resolve (fulfill¬ \nment or rejection) wins, and whatever that resolution is becomes the \nresolution of the returned promise. This pattern is classically called \na latch: the first one to open the latch gets through. Consider:","metadata":{"loc":{"lines":{"from":110459,"to":110474}}}}],["1231",{"pageContent":"var pi = Promise.resolve( 42 ); \n\nvar p2 = Promise.resolve( \"Hello World\" ); \n\nvar p3 = Promise.reject( \"Oops\" ); \n\nPromise. race( [pl,p2,p3] ) \n\n.then( function(msg){ \n\nconsole.log ( msg ); // 42 \n\n} ); \n\nPromise.all( [pl,p2,p3] ) \n\n.catch( function(err){ \n\nconsole.error( err ); // \"Oops\" \n\n\nPromise API Recap | 105 \n\n\n\nPromise.all( [pl,p2] ) \n\n.then( function(msgs){ \n\nconsole.log( msgs ); // [42, \"Hello World\"] \n\n} ); \n\n\n\nBe careful! If an empty array is passed to \nPromise.all ([ .. ]), it will fulfill immedi¬ \n\nately, but Promise. race( [ .. ]) will hang for¬ \never and never resolve. \n\n\nThe ES6 Promise API is pretty simple and straightforward. It’s at \nleast good enough to serve the most basic of async cases, and is a \ngood place to start when rearranging your code from callback hell to \nsomething better.","metadata":{"loc":{"lines":{"from":110476,"to":110521}}}}],["1232",{"pageContent":"But there’s a whole lot of async sophistication that apps often \ndemand which Promises themselves will be limited in addressing. In \nthe next section, we’ll dive into those limitations as motivations for \nthe benefit of Promise libraries. \n\nPromise Limitations \n\nMany of the details we’ll discuss in this section have already been \nalluded to in this chapter, but we’ll just make sure to review these \nlimitations specifically. \n\nSequence Error Handling \n\nWe covered Promise-flavored error handling in detail earlier in this \nchapter. The limitations of how Promises are designed—how they \nchain, specifically—creates a very easy pitfall where an error in a \nPromise chain can be silently ignored accidentally.","metadata":{"loc":{"lines":{"from":110523,"to":110539}}}}],["1233",{"pageContent":"But there’s something else to consider with Promise errors. Because \na Promise chain is nothing more than its constituent Promises \nwired together, there’s no entity to refer to the entire chain as a sin¬ \ngle thing, which means there’s no external way to observe any errors \nthat may occur. \n\nIf you construct a Promise chain that has no error handling in it, \nany error anywhere in the chain will propagate indefinitely down \nthe chain, until observed (by registering a rejection handler at some \n\n\n106 | Chapter 3: Promises \n\n\n\n\nstep). So, in that specific case, having a reference to the last promise \nin the chain is enough (p in the following snippet), because you can \nregister a rejection handler there, and it will be notified of any \npropagated errors: \n\n//foot...), STEP2(..) and STEP3(..) are \n// all promise-aware utilities \n\nvar p = foo( 42 ) \n\n. then( STEP2 ) \n\n. then( STEP3 );","metadata":{"loc":{"lines":{"from":110541,"to":110569}}}}],["1234",{"pageContent":"//foot...), STEP2(..) and STEP3(..) are \n// all promise-aware utilities \n\nvar p = foo( 42 ) \n\n. then( STEP2 ) \n\n. then( STEP3 ); \n\nAlthough it may seem sneakily confusing, p here doesn’t point to \nthe first promise in the chain (the one from the foo(42) call), but \ninstead from the last promise, the one that comes from the \nthen(STEP3) call. \n\nAlso, no step in the Promise chain is observably doing its own error \nhandling. That means that you could then register a rejection error \nhandler on p, and it would be notified if any errors occur anywhere \nin the chain: \n\np.catch( handleErrors );","metadata":{"loc":{"lines":{"from":110569,"to":110588}}}}],["1235",{"pageContent":"p.catch( handleErrors ); \n\nBut if any step of the chain in fact does its own error handling (per¬ \nhaps hidden/abstracted away from what you can see), your handle \nErrors( ..) won’t be notified. This may be what you want—it was, \nafter all, a “handled rejection”—but it also may not be what you \nwant. The complete lack of ability to be notified (of “already han¬ \ndled” rejection errors) is a limitation that restricts capabilities in \nsome use cases. \n\nIt’s basically the same limitation that exists with a try. .catch that \ncan catch an exception and simply swallow it. So this isn’t a limita¬ \ntion unique to Promises, but it is something we might wish to have a \nworkaround for. \n\nUnfortunately, many times there is no reference kept for the inter¬ \nmediate steps in a Promise-chain sequence, so without such refer¬ \nences, you cannot attach error handlers to reliably observe the \nerrors. \n\n\nPromise Limitations | 107 \n\n\n\n\n\nSingle Value","metadata":{"loc":{"lines":{"from":110588,"to":110615}}}}],["1236",{"pageContent":"Promise Limitations | 107 \n\n\n\n\n\nSingle Value \n\nPromises by definition only have a single fulfillment value or a sin¬ \ngle rejection reason. In simple examples, this isn’t that big of a deal, \nbut in more sophisticated scenarios, you may find this limiting. \n\nThe typical advice is to construct a values wrapper (such as an \nobject or array) to contain these multiple messages. This solution \nworks, but it can be quite awkward and tedious to wrap and unwrap \nyour messages with every single step of your Promise chain. \n\nSplitting Values \n\nSometimes you can take this as a signal that you could/should \ndecompose the problem into two or more Promises. \n\nImagine you have a utility foo( ..) that produces two values (x and \ny) asynchronously: \n\nfunction getY(x) { \n\nreturn new Promise( function(resolve, reject)! \nsetTimeout( function! ){ \n\nresolve! (3 * x) - 1 ); \n\n}, 100 ); \n\n} ); \n\n} \n\nfunction foo!bar,baz) { \nvar x = bar * baz; \n\nreturn getY( x ) \n\n.then( function(y){","metadata":{"loc":{"lines":{"from":110615,"to":110658}}}}],["1237",{"pageContent":"resolve! (3 * x) - 1 ); \n\n}, 100 ); \n\n} ); \n\n} \n\nfunction foo!bar,baz) { \nvar x = bar * baz; \n\nreturn getY( x ) \n\n.then( function(y){ \n\n// wrap both values into container \n\nreturn [x,y]; \n\n} ); \n\n} \n\nfoo( 10, 20 ) \n\n.then! function(msgs){ \nvar x = msgs [0]; \nvar y = msgs [1]; \n\nconsole.log! x, y ); // 200 599 \n\n} ); \n\nFirst, let’s rearrange what foo(.. ) returns so that we don’t have to \nwrap x and y into a single array value to transport through one \npromise. Instead, we can wrap each value into its own promise: \n\n\n108 | Chapter 3: Promises \n\n\n\nfunction foo(bar,baz) { \nvar x = bar * baz; \n\n// return both promises \n\nreturn [ \n\nPromise.resolve( x ), \ngetY( x ) \n\n]; \n\n} \n\nPromise.all( \n\nfoo( 10, 20 ) \n\n) \n\n.then( function(msgs){ \nvar x = msgs[0]; \nvar y = msgs[l]; \n\nconsole.log( x, y ); \n\n} ); \n\nIs an array of promises really better than an array of values passed \nthrough a single promise? Syntactically, it’s not much of an \nimprovement.","metadata":{"loc":{"lines":{"from":110658,"to":110730}}}}],["1238",{"pageContent":"console.log( x, y ); \n\n} ); \n\nIs an array of promises really better than an array of values passed \nthrough a single promise? Syntactically, it’s not much of an \nimprovement. \n\nBut this approach more closely embraces the Promise design theory. \nIt’s now easier in the future to refactor to split the calculation of x \nand y into separate functions. It’s cleaner and more flexible to let the \ncalling code decide how to orchestrate the two promises—using \nPromise.all([ .. ]) here, but certainly not the only option — \nrather than to abstract such details away inside of foo(..). \n\nUnwrap/Spread Arguments \n\nThe var x = .. and var y = .. assignments are still awkward \noverhead. We can employ some functional trickery (hat tip to Regi¬ \nnald Braithwaite, @raganwald on Twitter) in a helper utility: \n\nfunction spread(fn) { \n\nreturn Function. apply.bind( fn, null ); \n\n} \n\nPromise.all( \n\nfoo( 10, 20 ) \n\n) \n\n. then( \n\nspread( function(x,y){ \n\nconsole.log( x, y ); // 200 599 \n\n} ) \n\n)","metadata":{"loc":{"lines":{"from":110730,"to":110771}}}}],["1239",{"pageContent":"function spread(fn) { \n\nreturn Function. apply.bind( fn, null ); \n\n} \n\nPromise.all( \n\nfoo( 10, 20 ) \n\n) \n\n. then( \n\nspread( function(x,y){ \n\nconsole.log( x, y ); // 200 599 \n\n} ) \n\n) \n\n\nPromise Limitations | 109 \n\n\n\n\n\nThat’s a bit nicer! Of course, you could inline the functional magic \nto avoid the extra helper: \n\nPromise. alt( \n\nfoo( 10, 20 ) \n\n) \n\n.then( Function. apply.blnd( \nfunctlon(x,y){ \n\nconsole.log( x, y ); // 200 599 \n\n}, \n\nnull \n\n) ); \n\nThese tricks may be neat, but ES6 has an even better answer for us: \ndestructuring. The array destructuring assignment form looks like \nthis: \n\n\nPromise.all( \n\nfoo( 10, 20 ) \n\n) \n\n.then( functlon(msgs){ \nvar [x,y] = msgs; \n\nconsole.log( x, y ); // 200 599 \n\n} ); \n\nBut best of all, ES6 offers the array parameter destructuring form: \n\nPromise.all( \n\nfoo( 10, 20 ) \n\n) \n\n.then( functlon( [x,y]){ \n\nconsole.log( x, y ); // 200 599 \n\n} ); \n\nWe’ve now embraced the one-value-per-Promise mantra, but kept \nour supporting boilerplate to a minimum!","metadata":{"loc":{"lines":{"from":110771,"to":110853}}}}],["1240",{"pageContent":"foo( 10, 20 ) \n\n) \n\n.then( functlon( [x,y]){ \n\nconsole.log( x, y ); // 200 599 \n\n} ); \n\nWe’ve now embraced the one-value-per-Promise mantra, but kept \nour supporting boilerplate to a minimum! \n\n\n\nFor more information on ES6 destructuring \nforms, see the ES6 & Beyond title of this series. \n\n\nSingle Resolution \n\nOne of the most intrinsic behaviors of Promises is that a Promise \ncan only be resolved once (fulfillment or rejection). For many async \nuse cases, you’re only retrieving a value once, so this works fine. \n\n\n110 | Chapter 3: Promises \n\n\n\n\nBut there’s also a lot of async cases that fit into a different model— \none that’s more akin to events and/or streams of data. It’s not clear \non the surface how well Promises can fit into such use cases, if at all. \nWithout a significant abstraction on top of Promises, they will com¬ \npletely fall short for handling multiple value resolution.","metadata":{"loc":{"lines":{"from":110853,"to":110888}}}}],["1241",{"pageContent":"Imagine a scenario where you might want to fire off a sequence of \nasync steps in response to a stimulus (like an event) that can in fact \nhappen multiple times, like a button click. \n\nThis probably won’t work the way you want: \n\n// 'click(..)' binds the '\"click\"' event to a DOM element \n// 'request(..) ' is the previously defined Promise-aware Ajax \n\nvar p = new Promise/ function/ resolve,reject){ \nclick/ \"#mybtn\", resolve ); \n\n} ); \n\np.then/ function(evt){ \n\nvar btnID = evt.currentTarget.id; \n\nreturn request/ \"http://some.url.l/?id=\" + btnID ); \n\n} ) \n\n.then/ function(text){ \nconsole.log/ text ); \n\n} ); \n\nThe behavior here works only if your application calls for the button \nto be clicked just once. If the button is clicked a second time, the p \npromise has already been resolved, so the second resolve /..) call \nwould be ignored. \n\nInstead, you’d probably need to invert the paradigm, creating a \nwhole new Promise chain for each event firing: \n\nclick/ \"#mybtn\", function/evt)/","metadata":{"loc":{"lines":{"from":110890,"to":110925}}}}],["1242",{"pageContent":"Instead, you’d probably need to invert the paradigm, creating a \nwhole new Promise chain for each event firing: \n\nclick/ \"#mybtn\", function/evt)/ \n\nvar btnID = evt.currentTarget.id; \n\nrequest/ \"http://some.url.1/?id=\" + btnID ) \n\n.then/ function/text)/ \nconsole.log/ text ); \n\n} ); \n\n} ); \n\nThis approach will work in that a whole new Promise sequence will \nbe fired off for each \"click\" event on the button. \n\nBut beyond just the ugliness of having to define the entire Promise \nchain inside the event handler, this design in some respects violates \n\n\nPromise Limitations | 111 \n\n\n\nthe idea of separation of concerns/capabilities (SoC). You might \nvery well want to define your event handler in a different place in \nyour code from where you define the response to the event (the \nPromise chain). That’s pretty awkward to do in this pattern, without \nhelper mechanisms.","metadata":{"loc":{"lines":{"from":110925,"to":110956}}}}],["1243",{"pageContent":"Another way of articulating this limitation is \nthat it’d be nice if we could construct some sort \nof “observable” that we can subscribe a Promise \nchain to. There are libraries that have created \nthese abstractions (such as RxJS), but the \nabstractions can seem so heavy that you can’t \neven see the nature of Promises anymore. Such \nheavy abstraction brings important questions to \nmind, such as whether (sans Promises) these \nmechanisms are as trustable as Promises them¬ \nselves have been designed to be. We’ll revisit the \n“observable” pattern in Appendix B. \n\n\nInertia \n\nOne concrete barrier to starting to use Promises in your own code is \nall the code that currently exists that is not already Promise-aware. \nIf you have lots of callback-based code, it’s far easier to just keep \ncoding in that same style. \n\n“A code base in motion (with callbacks) will remain in motion (with \ncallbacks) unless acted upon by a smart, Promises-aware developer.”","metadata":{"loc":{"lines":{"from":110960,"to":110982}}}}],["1244",{"pageContent":"“A code base in motion (with callbacks) will remain in motion (with \ncallbacks) unless acted upon by a smart, Promises-aware developer.” \n\nPromises offer a different paradigm, and as such, the approach to \nthe code can be anywhere from just a little different to, in some \ncases, radically different. You have to be intentional about it, \nbecause Promises will not just naturally shake out from the same ol’ \nways of doing code that have served you well thus far. \n\nConsider a callback-based scenario like the following: \n\nfunction foo(x,y,cb) { \najax( \n\n\"http://some.url.l/?x=\" + x + \"&y=\" + y, \ncb \n\n); \n\n} \n\nfoo( 11, 31, function(err, text) { \nif (err) { \n\n\n112 | Chapter 3: Promises \n\n\n\n\n\nconsole.error( err ); \n\n\n} \n\nelse { \n\nconsole.log( text ); \n\n} \n\n} );","metadata":{"loc":{"lines":{"from":110982,"to":111024}}}}],["1245",{"pageContent":"); \n\n} \n\nfoo( 11, 31, function(err, text) { \nif (err) { \n\n\n112 | Chapter 3: Promises \n\n\n\n\n\nconsole.error( err ); \n\n\n} \n\nelse { \n\nconsole.log( text ); \n\n} \n\n} ); \n\nIs it immediately obvious what the first steps are to convert this \ncallback-based code to Promise-aware code? Depends on your expe¬ \nrience. The more practice you have with it, the more natural it will \nfeel. But certainly, Promises don’t just advertise on the label exactly \nhow to do it—there’s no one-size-fits-all answer—so the responsi¬ \nbility is up to you. \n\nAs we’ve covered before, we definitely need an Ajax utility that is \nPromise-aware instead of callback-based, which we could call \nrequest(. .). You can make your own, as we have already. But the \noverhead of having to manually define Promise-aware wrappers for \nevery callback-based utility makes it less likely you’ll choose to \nrefactor to Promise-aware coding at all.","metadata":{"loc":{"lines":{"from":111024,"to":111063}}}}],["1246",{"pageContent":"Promises offer no direct answer to that limitation. Most Promise \nlibraries do offer a helper, however. But even without a library, \nimagine a helper like this: \n\n// polyfill-safe guard check \nif (! Promise. wrap) { \n\nPromise.wrap = function(fn) { \nreturn functionQ { \n\nvar args = [] .slice.call( arguments ); \n\nreturn new Promise( function( resolve, reject)! \nfn.apply( \nnull, \n\nargs.concat( function(err,v){ \nif (err) { \n\nreject( err ); \n\n} \n\nelse { \n\nresolve( v ); \n\n} \n\n} ) \n\n); \n\n} ); \n\n}; \n\n}; \n\n} \n\n\nPromise Limitations | 113 \n\n\n\nOK, that’s more than just a tiny trivial utility. However, although it \nmay look a bit intimidating, it’s not as bad as you’d think. It takes a \nfunction that expects an error-first style callback as its last parame¬ \nter, and returns a new one that automatically creates a Promise to \nreturn, and substitutes the callback for you, wired up to the Promise \nfulfillment/rejection.","metadata":{"loc":{"lines":{"from":111065,"to":111116}}}}],["1247",{"pageContent":"Rather than waste too much time talking about how this \nPromise. wrap( ..) helper works, let’s just look at how we use it: \n\nvar request = Promise.wrap( ajax ); \n\nrequest! \"http://some.url.1/\" ) \n\n. then( .. ) \n\n\nWow, that was pretty easy! \n\nPromise.wrap( ..) does not produce a Promise. It produces a func¬ \ntion that will produce Promises. In a sense, a Promise-producing \nfunction could be seen as a Promise factory. I propose “promisory” \nas the name for such a thing (“Promise” + “factory”). \n\nThe act of wrapping a callback-expecting function to be a Promise- \naware function is sometimes referred to as “lifting” or “promisify- \ning.” But there doesn’t seem to be a standard term for what to call \nthe resultant function other than a “lifted function”, so I like “prom¬ \nisory” better, as I think it’s more descriptive.","metadata":{"loc":{"lines":{"from":111118,"to":111139}}}}],["1248",{"pageContent":"Promisory isn’t a made-up term. It’s a real word, \nand its definition means to contain or convey a \npromise. That’s exactly what these functions are \ndoing, so it turns out to be a pretty perfect ter¬ \nminology match! \n\n\nSo, Promise.wrap(ajax) produces an ajax(..) promisory we call \nrequest(..), and that promisory produces Promises for Ajax \nresponses. \n\nIf all functions were already promisories, we wouldn’t need to make \nthem ourselves, so the extra step is a tad bit of a shame. But at least \nthe wrapping pattern is (usually) repeatable so we can put it into a \nPromise.wrap( ..) helper as shown to aid our promise coding. \n\nSo back to our earlier example, we need a promisory for both \najax( ..) and foo(..): \n\n\n114 | Chapter 3: Promises \n\n\n\n\n// make a provisory for ~ajax(..)' \nvar request = Promise.wrap( ajax );","metadata":{"loc":{"lines":{"from":111143,"to":111169}}}}],["1249",{"pageContent":"So back to our earlier example, we need a promisory for both \najax( ..) and foo(..): \n\n\n114 | Chapter 3: Promises \n\n\n\n\n// make a provisory for ~ajax(..)' \nvar request = Promise.wrap( ajax ); \n\n// refactor 'foo(..)', but keep it externally \n// callback-based for compatibility with other \n// parts of the code for now--only use \n// 'request(..) ''s promise internally. \nfunction foo(x,y,cb) { \nrequest( \n\n\"http://some.url.l/?x=\" + x + \"&y=\" + y \n\n) \n\n.then( \n\nfunction fulfilled(text){ \ncb( null, text ); \n\n}. \n\ncb \n\n); \n\n} \n\n// now, for this code's purposes, make a \n\n// provisory for 'foo(..)~ \n\nvar betterFoo = Promise.wrap( foo ); \n\n// and use the provisory \nbetterFoo( 11, 31 ) \n\n. then( \n\nfunction fulfilled(text){ \nconsole.log( text ); \n\n}. \n\nfunction rejected(err){ \nconsole.error( err ); \n\n} \n\n);","metadata":{"loc":{"lines":{"from":111169,"to":111226}}}}],["1250",{"pageContent":"// and use the provisory \nbetterFoo( 11, 31 ) \n\n. then( \n\nfunction fulfilled(text){ \nconsole.log( text ); \n\n}. \n\nfunction rejected(err){ \nconsole.error( err ); \n\n} \n\n); \n\nOf course, while we’re refactoring foo(..) to use our new \nrequest(..) promisory, we could just make foo(..) a promisory \nitself, instead of remaining callback-based and needing to make and \nuse the subsequent betterFoo(..) promisory. This decision just \ndepends on whether foo(..) needs to stay callback-based compati¬ \nble with other parts of the code base. \n\nConsider: \n\n\"foo(..)‘ is now also a promisory because it \ndelegates to the 'request( ..)' promisory \nfunction foo(x,y) { \nreturn request( \n\n\"http://some.url.l/?x=\" + x + \"&y=\" + y \n\n); \n\n1 \n\n\nPromise Limitations | 115 \n\n\n\n\n\nfoo( 11, 31 ) \n. then( .. )","metadata":{"loc":{"lines":{"from":111226,"to":111271}}}}],["1251",{"pageContent":"\"http://some.url.l/?x=\" + x + \"&y=\" + y \n\n); \n\n1 \n\n\nPromise Limitations | 115 \n\n\n\n\n\nfoo( 11, 31 ) \n. then( .. ) \n\n\nWhile ES6 Promises don’t natively ship with helpers for such prom- \nisory wrapping, most libraries provide them, or you can make your \nown. Either way, this particular limitation of Promises is addressa¬ \nble without too much pain (certainly compared to the pain of call¬ \nback hell!). \n\nPromise Uncancelable \n\nOnce you create a Promise and register a fulfillment and/or rejec¬ \ntion handler for it, there’s nothing external you can do to stop that \nprogression if something else happens to make that task moot.","metadata":{"loc":{"lines":{"from":111271,"to":111298}}}}],["1252",{"pageContent":"Many Promise abstraction libraries provide \nfacilities to cancel Promises, but this is a terrible \nidea! Many developers wish Promises had \nnatively been designed with external cancelation \ncapability, but the problem is that it would let \none consumer/observer of a Promise affect some \nother consumer’s ability to observe that same \nPromise. This violates the future-value’s trusta- \nbility (external immutability), but morever is the \nembodiment of the “action at a distance” anti¬ \npattern. Regardless of how useful it seems, it will \nactually lead you straight back into the same \nnightmares as callbacks. \n\n\nConsider our Promise timeout scenario from earlier: \n\nvar p = foo( 42 ); \n\nPromise.race( [ \n\nP. \n\ntlmeoutPromlse( 3000 ) \n\n] ) \n\n. then( \n\ndoSomething, \n\nhandleError \n\n\np.then( functionQf \n\n// still happens even in the timeout case :( \n\n} ); \n\n\n116 | Chapter 3: Promises \n\n\n\n\n\nThe “timeout” was external to the promise p, so p itself keeps going, \nwhich we probably don’t want.","metadata":{"loc":{"lines":{"from":111302,"to":111350}}}}],["1253",{"pageContent":"// still happens even in the timeout case :( \n\n} ); \n\n\n116 | Chapter 3: Promises \n\n\n\n\n\nThe “timeout” was external to the promise p, so p itself keeps going, \nwhich we probably don’t want. \n\nOne option is to invasively define your resolution callbacks: \n\nvar OK = true; \n\nvar p = foo( 42 ); \n\nPromise.race( [ \n\nP, \n\ntlmeoutPromlse( 3000 ) \n\n.catch( function(err){ \n\nOK = false; \nthrow err; \n\n} ) \n\n] ) \n\n. then( \n\ndoSomething, \n\nhandleError \n\n); \n\n\np.then( function(){ \nif (OK) { \n\n// only happens if no timeout! :) \n\n} \n\n} ); \n\nThis is ugly. It works, but it’s far from ideal. Generally, you should \ntry to avoid such scenarios. \n\nBut if you can’t, the ugliness of this solution should be a clue that \ncancelation is a functionality that belongs at a higher level of \nabstraction on top of Promises. I’d recommend you look to Promise \nabstraction libraries for assistance rather than hacking it yourself.","metadata":{"loc":{"lines":{"from":111350,"to":111409}}}}],["1254",{"pageContent":"My asynquence Promise abstraction library pro¬ \nvides just such an abstraction and an abort() \ncapability for the sequence, all of which will be \ndiscussed in Appendix A. \n\n\nA single Promise is not really a flow-control mechanism (at least not \nin a very meaningful sense), which is exactly what cancelation refers \nto; that’s why Promise cancelation would feel awkward. \n\nBy contrast, a chain of Promises taken collectively together—what I \nlike to call a “sequence ”—is a flow control expression, and thus it’s \nappropriate for cancelation to be defined at that level of abstraction. \n\n\nPromise Limitations | 117 \n\n\n\n\nNo individual Promise should be cancelable, but it’s sensible for a \nsequence to be cancelable, because you don’t pass around a sequence \nas a single immutable value like you do with a Promise. \n\nPromise Performance \n\nThis particular limitation is both simple and complex.","metadata":{"loc":{"lines":{"from":111413,"to":111439}}}}],["1255",{"pageContent":"Promise Performance \n\nThis particular limitation is both simple and complex. \n\nComparing how many pieces are moving with a basic callback- \nbased async task chain versus a Promise chain, it’s clear Promises \nhave a fair bit more going on, which means they are naturally at \nleast a tiny bit slower. Think back to just the simple list of trust \nguarantees that Promises offer, as compared to the ad hoc solution \ncode you’d have to layer on top of callbacks to achieve the same pro¬ \ntections. \n\nMore work to do, more guards to protect, means that Promises are \nslower as compared to naked, untrustable callbacks. That much is \nobvious, and probably simple to wrap your brain around. \n\nBut how much slower? Well...that’s actually proving to be an \nincredibly difficult question to answer absolutely, across the board.","metadata":{"loc":{"lines":{"from":111439,"to":111456}}}}],["1256",{"pageContent":"But how much slower? Well...that’s actually proving to be an \nincredibly difficult question to answer absolutely, across the board. \n\nFrankly, it’s kind of an apples-to-oranges comparison, so it’s proba¬ \nbly the wrong question to ask. You should actually compare \nwhether an ad hoc callback system with all the same protections \nmanually layered in is faster than a Promise implementation. \n\nIf Promises have a legitimate performance limitation, it’s more that \nthey don’t really offer a line-item choice as to which trustability pro¬ \ntections you want/need or not—you get them all, always. \n\nNevertheless, if we grant that a Promise is generally a little bit slower \nthan its non-Promise, non-trustable callback equivalent—assuming \nthere are places where you feel you can justify the lack of trustability \n—does that mean that Promises should be avoided across the board, \nas if your entire application is driven by nothing but must-be- \nutterly-the-fastest code possible?","metadata":{"loc":{"lines":{"from":111456,"to":111473}}}}],["1257",{"pageContent":"Sanity check: if your code is legitimately like that, is JavaScript even \nthe right language for such tasks? JavaScript can be optimized to run \napplications very performantly (see Chapters 5 and 6). But is obsess¬ \ning over tiny performance tradeoffs with Promises, in light of all the \nbenefits they offer, really appropriate? \n\n\n118 | Chapter 3: Promises \n\n\n\n\nAnother subtle issue is that Promises make everything async, which \nmeans that some immediately (synchronously) complete steps still \ndefer advancement of the next step to a Job (see Chapter 1). That \nmeans that it’s possible that a sequence of Promise tasks could com¬ \nplete ever-so-slightly slower than the same sequence wired up with \ncallbacks. \n\nOf course, the question here is this: are these potential slips in tiny \nfractions of performance worth all the other articulated benefits of \nPromises we’ve laid out across this chapter?","metadata":{"loc":{"lines":{"from":111475,"to":111496}}}}],["1258",{"pageContent":"Of course, the question here is this: are these potential slips in tiny \nfractions of performance worth all the other articulated benefits of \nPromises we’ve laid out across this chapter? \n\nMy take is that in virtually all cases where you might think Promise \nperformance is slow enough to be concerned, it’s actually an anti¬ \npattern to optimize away the benefits of Promise trustability and \ncomposability by avoiding them altogether. \n\nInstead, you should default to using them across the code base, and \nthen profile and analyze your application’s hot (critical) paths. Are \nPromises really a bottleneck, or are they just a theoretical slow¬ \ndown? Only then, armed with actual valid benchmarks (see Chap¬ \nter 6) is it responsible and prudent to factor out the Promises in just \nthose identified critical areas.","metadata":{"loc":{"lines":{"from":111496,"to":111510}}}}],["1259",{"pageContent":"Promises are a little slower, but in exchange you’re getting a lot of \ntrustability, non-Zalgo predictability, and composability built in. \nMaybe the limitation is not actually their performance, but your \nlack of perception of their benefits? \n\nReview \n\nPromises are awesome. Use them. They solve the inversion of control \nissues that plague us with callbacks-only code. \n\nThey don’t get rid of callbacks, they just redirect the orchestration of \nthose callbacks to a trustable intermediary mechanism that sits \nbetween us and another utility. \n\nPromise chains also begin to address (though certainly not per¬ \nfectly) a better way of expressing async flow in sequential fashion, \nwhich helps our brains plan and maintain async JS code better. \nWe’ll see an even better solution to that problem in Chapter 4! \n\n\nReview | 119 \n\n\n\n\nCHAPTER 4 \n\n\nGenerators \n\n\nIn Chapter 2, we identified two key drawbacks to expressing async \nflow control with callbacks:","metadata":{"loc":{"lines":{"from":111512,"to":111544}}}}],["1260",{"pageContent":"Review | 119 \n\n\n\n\nCHAPTER 4 \n\n\nGenerators \n\n\nIn Chapter 2, we identified two key drawbacks to expressing async \nflow control with callbacks: \n\n• Callback-based async doesn’t fit how our brain plans out steps \nof a task. \n\n• Callbacks aren’t trustable or composable because of inversion of \ncontrol. \n\nIn Chapter 3, we detailed how Promises uninvert the inversion of \ncontrol of callbacks, restoring trustability/composability. \n\nNow we turn our attention to expressing async flow control in a \nsequential, synchronous-looking fashion. The “magic” that makes it \npossible is ES6 generators. \n\nBreaking Run-to-Completion \n\nIn Chapter 1, we explained an expectation that JS developers almost \nuniversally rely on in their code: once a function starts executing, it \nruns until it completes, and no other code can interrupt and run in \nbetween.","metadata":{"loc":{"lines":{"from":111544,"to":111576}}}}],["1261",{"pageContent":"As bizarre as it may seem, ES6 introduces a new type of function \nthat does not behave with the run-to-completion behavior. This new \ntype of function is called a generator. \n\n\n121 \n\n\n\n\n\nTo understand the implications, let’s consider this example: \nvar x = 1; \n\nfunction foo() { \nx++; \n\nbar(); // <-- what about this line? \n\nconsole.log( \"x:\", x ); \n\n} \n\nfunction bar() { \nx++; \n\n} \n\nfoo(); // x: 3 \n\nIn this example, we know for sure that bar() runs in between x++ \nand console.log(x). But what ifbarQ wasn’t there? Obviously the \nresult would be 2 instead of 3. \n\nNow let’s twist your brain. What if bar() wasn’t present, but it \ncould still somehow run between the x++ and console.log(x) state¬ \nments? How would that be possible?","metadata":{"loc":{"lines":{"from":111578,"to":111614}}}}],["1262",{"pageContent":"Now let’s twist your brain. What if bar() wasn’t present, but it \ncould still somehow run between the x++ and console.log(x) state¬ \nments? How would that be possible? \n\nIn preemptive multithreaded languages, it would essentially be pos¬ \nsible for bar() to interrupt and run at exactly the right moment \nbetween those two statements. But JS is not preemptive, nor is it \n(currently) multithreaded. And yet, a cooperative form of this inter¬ \nruption (concurrency) is possible, if foo() itself could somehow \nindicate a pause at that part in the code. \n\n\n\nI use the word “cooperative” not only because of \nthe connection to classical concurrency termi¬ \nnology (see Chapter 1), but because as you’ll see \nin the next snippet, the ES6 syntax for indicating \na pause point in code is yield— suggesting a \npolitely cooperative yielding of control. \n\n\nHere’s the ES6 code to accomplish such cooperative concurrency: \nvar x = 1; \n\nfunction *foo() { \nx++; \n\nyield; // pause! \nconsole.log( \"x:\", x ); \n\n1","metadata":{"loc":{"lines":{"from":111614,"to":111644}}}}],["1263",{"pageContent":"Here’s the ES6 code to accomplish such cooperative concurrency: \nvar x = 1; \n\nfunction *foo() { \nx++; \n\nyield; // pause! \nconsole.log( \"x:\", x ); \n\n1 \n\n\n122 | Chapter 4: Generators \n\n\n\n\n\nfunction bar() { \nx++; \n\n} \n\n\n\nYou will likely see most other JS documenta¬ \ntion/code that will format a generator declara¬ \ntion as function* foo() { .. } instead of as \nI’ve done here with function *foo() { .. }— \nthe only difference being the stylistic positioning \nof the *. The two forms are functionally/syntac¬ \ntically identical, as is a third function*foo() \n{ .. } (no space) form. There are arguments \nfor both styles, but I basically prefer function \n*foo .. because it then matches when I reference \na generator in writing with *foo(). If I said only \nfoo(), you wouldn’t know as clearly if I was \ntalking about a generator or a regular function. \nIt’s purely a stylistic preference.","metadata":{"loc":{"lines":{"from":111644,"to":111682}}}}],["1264",{"pageContent":"Now, how can we run the code in that previous snippet such that \nbar() executes at the point of the yield inside of *foo()? \n\n// construct an iterator 'it' to control the generator \nvar it = foo(); \n\n// start 'foo()' here! \nit.next(); \n\nx; // 2 \n\nbar( ); \n\nx; // 3 \n\nit.next(); // x: 3 \n\nOK, there’s quite a bit of new and potentially confusing stuff in \n\nthose two code snippets, so we’ve got plenty to wade through. But \nbefore we explain the different mechanics/syntax with ES6 genera¬ \ntors, let’s walk through the behavior flow: \n\n1. The it = foo() operation does not execute the *foo() genera¬ \ntor yet, but it merely constructs an iterator that will control its \nexecution. More on iterators in a bit. \n\n2. The first it.nextQ starts the *foo() generator, and runs the \nx++ on the first line of * f oo (). \n\n\nBreaking Run-to-Completion | 123","metadata":{"loc":{"lines":{"from":111685,"to":111716}}}}],["1265",{"pageContent":"2. The first it.nextQ starts the *foo() generator, and runs the \nx++ on the first line of * f oo (). \n\n\nBreaking Run-to-Completion | 123 \n\n\n\n\n\n3. *foo() pauses at the yield statement, at which point that first \nit.nextQ call finishes. At the moment, *foo() is still running \nand active, but it’s in a paused state. \n\n4. We inspect the value of x, and it’s now 2. \n\n5. We call bar(), which increments x again with x++. \n\n6. We inspect the value of x again, and it’s now 3. \n\n7. The final it.next() call resumes the *foo() generator from \nwhere it was paused, and runs the console.log (..) statement, \nwhich uses the current value of x of 3. \n\nClearly, foo() started, but did not run-to-completion—it paused at \nthe yield. We resumed foo( ) later, and let it finish, but that wasn’t \neven required.","metadata":{"loc":{"lines":{"from":111716,"to":111742}}}}],["1266",{"pageContent":"Clearly, foo() started, but did not run-to-completion—it paused at \nthe yield. We resumed foo( ) later, and let it finish, but that wasn’t \neven required. \n\nSo, a generator is a special kind of function that can start and stop \none or more times, and doesn’t necessarily ever have to finish. \nWhile it won’t be terribly obvious yet why that’s so powerful, as we \ngo throughout the rest of this chapter, that will be one of the funda¬ \nmental building blocks we use to construct generators-as-async- \nflow-control as a pattern for our code. \n\nInput and Output \n\nA generator function is a special function with the new processing \nmodel we just alluded to. But it’s still a function, which means it still \nhas some basic tenets that haven’t changed—namely, that it still \naccepts arguments (aka input), and that it can still return a value \n(aka output): \n\nfunction *foo(x,y) { \nreturn x * y; \n\n1 \n\nvar it = foo( 6, 7 ); \nvar res = it.nextQ; \nres.value; // 42","metadata":{"loc":{"lines":{"from":111742,"to":111768}}}}],["1267",{"pageContent":"function *foo(x,y) { \nreturn x * y; \n\n1 \n\nvar it = foo( 6, 7 ); \nvar res = it.nextQ; \nres.value; // 42 \n\nWe pass in the arguments 6 and 7 to *foo(. .) as the parameters x \nand y, respectively. And *foo( ..) returns the value 42 back to the \ncalling code. \n\n\n124 | Chapter 4: Generators \n\n\n\n\nWe now see a difference with how the generator is invoked com¬ \npared to a normal function. foo(6,7) obviously looks familiar. But \nsubtly, the *foo(..) generator hasn’t actually run yet as it would \nhave with a function. \n\nInstead, we’re just creating an iterator object, which we assign to the \nvariable it, to control the *foo(..) generator. Then we call \nit. next(), which instructs the *foo(..) generator to advance from \nits current location, stopping either at the next yield or end of the \ngenerator.","metadata":{"loc":{"lines":{"from":111768,"to":111796}}}}],["1268",{"pageContent":"The result of that next(..) call is an object with a value property \non it holding whatever value (if anything) was returned from \n*foo(..). In other words, yield caused a value to be sent out from \nthe generator during the middle of its execution, kind of like an \nintermediate return. \n\nAgain, it won’t be obvious yet why we need this whole indirect itera¬ \ntor object to control the generator. We’ll get there, I promise. \n\nIteration Messaging \n\nIn addition to generators accepting arguments and having return \nvalues, there’s even more powerful and compelling input/output \nmessaging capability built into them, via yield and next(..). \n\nConsider: \n\nfunction *foo(x) { \n\nvar y = x * (yield); \nreturn y; \n\n} \n\nvar it = foo( 6 ); \n\n// start 'foo(..)' \nit . next( ); \n\nvar res = it.next( 7 ); \nres. value; // 42 \n\nFirst, we pass in 6 as the parameter x. Then we call it. next(), and it \nstarts up *foo(..).","metadata":{"loc":{"lines":{"from":111798,"to":111831}}}}],["1269",{"pageContent":"var it = foo( 6 ); \n\n// start 'foo(..)' \nit . next( ); \n\nvar res = it.next( 7 ); \nres. value; // 42 \n\nFirst, we pass in 6 as the parameter x. Then we call it. next(), and it \nstarts up *foo(..). \n\nInside *foo(..), the var y = x .. statement starts to be processed, \nbut then it runs across a yield expression. At that point, it pauses \n\n\nBreaking Run-to-Completion | 125 \n\n\n\n*foo(..) (in the middle of the assignment statement!), and essen¬ \ntially requests the calling code to provide a result value for the yield \nexpression. Next, we call it. next( 7 ), which is passing the 7 value \nback in to be that result of the paused yield expression. \n\nSo, at this point, the assignment statement is essentially var y = 6 \n* 7. Now, return y returns that 42 value back as the result of the \nit.next( 7 ) call.","metadata":{"loc":{"lines":{"from":111831,"to":111857}}}}],["1270",{"pageContent":"So, at this point, the assignment statement is essentially var y = 6 \n* 7. Now, return y returns that 42 value back as the result of the \nit.next( 7 ) call. \n\nNotice something very important but also easily confusing, even to \nseasoned JS developers: depending on your perspective, there’s a \nmismatch between the yield and the next(..) call. In general, \nyou’re going to have one more next(..) call than you have yield \nstatements—the preceding snippet has one yield and two next(..) \ncalls. \n\nWhy the mismatch? \n\nBecause the first next(..) always starts a generator, and runs to the \nfirst yield. But it’s the second next(..) call that fulfills the first \npaused yield expression, and the third next(..) would fulfill the \nsecond yield, and so on. \n\nTale of Two Questions \n\nActually, which code you’re thinking about primarily will affect \nwhether there’s a perceived mismatch or not. \n\nConsider only the generator code: \n\nvar y = x * (yield); \nreturn y;","metadata":{"loc":{"lines":{"from":111857,"to":111883}}}}],["1271",{"pageContent":"Actually, which code you’re thinking about primarily will affect \nwhether there’s a perceived mismatch or not. \n\nConsider only the generator code: \n\nvar y = x * (yield); \nreturn y; \n\nThis first yield is basically asking a question: “What value should I \ninsert here?” \n\nWho’s going to answer that question? Well, the first next() has \nalready run to get the generator up to this point, so obviously it \ncan’t answer the question. So, the second next(..) call must answer \nthe question posed by the first yield. \n\nSee the mismatch—second-to-first? \n\nBut let’s flip our perspective. Let’s look at it not from the generator’s \npoint of view, but from the iterator’s point of view. \n\n\n126 | Chapter 4: Generators","metadata":{"loc":{"lines":{"from":111883,"to":111905}}}}],["1272",{"pageContent":"But let’s flip our perspective. Let’s look at it not from the generator’s \npoint of view, but from the iterator’s point of view. \n\n\n126 | Chapter 4: Generators \n\n\n\n\nTo properly illustrate this perspective, we also need to explain that \nmessages can go in both directions— yield .. as an expression can \nsend out messages in response to next(.. ) calls, and next( ..) can \nsend values to a paused yield expression. Consider this slightly \nadjusted code: \n\nfunction *foo(x) { \n\nvar y = x * (yield \"Hello\"); // <-- yield a value! \n\nreturn y; \n\n} \n\nvar it = foo( 6 ); \n\n\nvar res = it.nextQ; //first 'next()', don't pass anything \nres. value; // \"Hello\" \n\n\nres = it.next( 7 ); // pass '7' to waiting 'yield' \n\nres.value; // 42 \n\nyield .. and next(..) pair together as a two-way message passing \nsystem during the execution of the generator. \n\nSo, looking only at the iterator code: \n\nvar res = it.nextQ; // first 'next()', don't pass anything \nres.value; // \"Hello\"","metadata":{"loc":{"lines":{"from":111905,"to":111945}}}}],["1273",{"pageContent":"So, looking only at the iterator code: \n\nvar res = it.nextQ; // first 'next()', don't pass anything \nres.value; // \"Hello\" \n\n\nres = it.next( 7 ); // pass '7' to waiting 'yield' \n\nres.value; // 42 \n\n\n\nWe don’t pass a value to the first next() call, \nand that’s on purpose. Only a paused yield \ncould accept such a value passed by a next(..), \nand at the beginning of the generator when we \ncall the first next( ), there is no paused yield to \naccept such a value. The specification and all \ncompliant browsers just silently discard any¬ \nthing passed to the first next(). It’s still a bad \nidea to pass a value, as you’re just creating \nsilently failing code that’s confusing. So, always \nstart a generator with an argument-free next(). \n\n\nThe first next() call (with nothing passed to it) is basically asking a \nquestion: “What next value does the *foo(..) generator have to give \nme?” And who answers this question? The first yield \"hello\" \nexpression. \n\n\nBreaking Run-to-Completion | 127","metadata":{"loc":{"lines":{"from":111945,"to":111976}}}}],["1274",{"pageContent":"Breaking Run-to-Completion | 127 \n\n\n\n\nSee? No mismatch there. \n\nDepending on who you think about asking the question, there is \neither a mismatch between the yield and next( ..) calls, or not. \n\nBut wait! There’s still an extra nextQ compared to the number of \nyield statements. So, that final it.next(7) call is again asking the \nquestion about what next value the generator will produce. But \nthere’s no more yield statements left to answer, is there? So who \nanswers? \n\nThe return statement answers the question! \n\nAnd if there is no return in your generator— return is certainly not \nany more required in generators than in regular functions—there’s \nalways an assumed/implicit return; (aka return undefined;), \nwhich serves the purpose of default answering the question posed by \nthe final it.next(7) call.","metadata":{"loc":{"lines":{"from":111976,"to":111998}}}}],["1275",{"pageContent":"These questions and answers—the two-way message passing with \nyield and next( ..)—are quite powerful, but it’s not obvious at all \nhow these mechanisms are connected to async flow control. We’re \ngetting there! \n\nMultiple Iterators \n\nIt may appear from the syntactic usage that when you use an iterator \nto control a generator, you’re controlling the declared generator \nfunction itself. But there’s a subtlety that easy to miss: each time you \nconstruct an iterator, you are implicitly constructing an instance of \nthe generator which that iterator will control. \n\nYou can have multiple instances of the same generator running at \nthe same time, and they can even interact: \n\nfunction *foo() { \nvar x = yield 2; \n\nZ++; \n\nvar y = yield (x * z); \nconsole.log( x, y, z ); \n\n1 \n\nvar z = 1; \n\nvar itl = foo(); \nvar it2 = foo(); \n\n\n128 | Chapter 4: Generators \n\n\n\n\nvar vail = itl. next().value; \nvar val2 = lt2.next() .value; \n\nvail = ltl.next( val2 * 10 ). value; \nval2 = lt2.next( vail * 5 ). value;","metadata":{"loc":{"lines":{"from":112000,"to":112041}}}}],["1276",{"pageContent":"128 | Chapter 4: Generators \n\n\n\n\nvar vail = itl. next().value; \nvar val2 = lt2.next() .value; \n\nvail = ltl.next( val2 * 10 ). value; \nval2 = lt2.next( vail * 5 ). value; \n\nltl.next( val2 / 2 ); \n\nit2.next( vail / 4 ); \n\n\n// 2 <-- yield 2 \n// 2 <-- yield 2 \n\n// 40 <-- x:20, z:2 \n\n// 600 <-- x:200, z:3 \n\n// y:300 \n// 20 300 3 \n// y:io \n// 200 10 3 \n\n\n\nThe most common usage of multiple instances \nof the same generator running concurrently is \nnot such interactions, but when the generator is \nproducing its own values without input, perhaps \nfrom some independently connected resource. \nWe’ll talk more about value production in the \nnext section. \n\n\nLet’s briefly walk through the processing: \n\n1. Both instances of *foo() are started at the same time, and both \nnext() calls reveal a value of 2 from the yield 2 statements, \nrespectively.","metadata":{"loc":{"lines":{"from":112041,"to":112084}}}}],["1277",{"pageContent":"Let’s briefly walk through the processing: \n\n1. Both instances of *foo() are started at the same time, and both \nnext() calls reveal a value of 2 from the yield 2 statements, \nrespectively. \n\n2. val2 * 10 is 2 * 10, which is sent into the first generator \ninstance itl, so that x gets value 20. z is incremented from 1 to \n2, and then 20 * 2 is yielded out, setting vail to 40. \n\n3. vail * 5 is 40 * 5, which is sent into the second generator \ninstance it2, so that x gets value 200. z is incremented again, \nfrom 2 to 3, and then 200 * 3 is yielded out, setting val2 to \n600. \n\n4. val2 / 2 is 600 / 2, which is sent into the first generator \ninstance itl, so that y gets value 300, then printing out 20 300 \n3 for its x y z values, respectively. \n\n5. vail / 4 is 40 / 4, which is sent into the second generator \ninstance it2, so that y gets value 10, then printing out 200 10 3 \nfor its x y z values, respectively. \n\nThat’s a fun example to run through in your mind. Did you keep it \nstraight?","metadata":{"loc":{"lines":{"from":112084,"to":112108}}}}],["1278",{"pageContent":"That’s a fun example to run through in your mind. Did you keep it \nstraight? \n\n\nBreaking Run-to-Completion | 129 \n\n\n\n\n\nInterleaving \n\nRecall this scenario from the “Run-to-completion” section of Chap¬ \nter 1: \n\nvar a = 1; \nvar b = 2; \n\nfunction foo() { \na++; \n\nb = b * a; \na = b + 3; \n\n} \n\nfunction bar() { \nb--; \n\na = 8 + b; \nb = a * 2; \n\n} \n\nWith normal JS functions, of course either foo() can run com¬ \npletely first, or bar() can run completely first, but foo() cannot \ninterleave its individual statements with bar(). So, there are only \ntwo possible outcomes to the preceding program. \n\nHowever, with generators, clearly interleaving (even in the middle \nof statements!) is possible: \n\nvar a = 1; \nvar b = 2; \n\nfunction *foo() { \na++; \nyield; \nb = b * a; \na = (yield b) + 3; \n\n} \n\nfunction *bar() { \n\nb--; \n\nyield; \n\na = (yield 8) + b; \nb = a * (yield 2); \n\n}","metadata":{"loc":{"lines":{"from":112108,"to":112170}}}}],["1279",{"pageContent":"var a = 1; \nvar b = 2; \n\nfunction *foo() { \na++; \nyield; \nb = b * a; \na = (yield b) + 3; \n\n} \n\nfunction *bar() { \n\nb--; \n\nyield; \n\na = (yield 8) + b; \nb = a * (yield 2); \n\n} \n\nDepending on what respective order the iterators controlling *foo( ) \nand *bar() are called, the preceding program could produce several \ndifferent results. In other words, we can actually illustrate (in a sort \nof fake-ish way) the theoretical threaded race conditions circum- \n\n\n130 | Chapter 4: Generators \n\n\n\n\nstances discussed in Chapter 1, by interleaving the two generator \ninterations over the same shared variables. \n\nFirst, let’s make a helper called step( ..) that controls an iterator: \n\nfunction step(gen) { \nvar it = gen(); \nvar last; \n\nreturn function () { \n\n// whatever is 'yield'ed out, just \n// send it right back in the next tine! \nlast = it.next( last ). value; \n\n}; \n\n}","metadata":{"loc":{"lines":{"from":112170,"to":112220}}}}],["1280",{"pageContent":"function step(gen) { \nvar it = gen(); \nvar last; \n\nreturn function () { \n\n// whatever is 'yield'ed out, just \n// send it right back in the next tine! \nlast = it.next( last ). value; \n\n}; \n\n} \n\nstep(.. ) initializes a generator to create its it iterator, then returns \na function which, when called, advances the iterator by one step. \nAdditionally, the previously yielded out value is sent right back in \nat the next step. So, yield 8 will just become 8 and yield b will just \nbe b (whatever it was at the time of yield). \n\nNow, just for fun, let’s experiment to see the effects of interleaving \nthese different chunks of *foo() and *bar(). We’ll start with the \nboring base case, making sure *foo() totally finishes before *bar() \n(just like we did in Chapter 1): \n\n// nake sure to reset 'a' and 'b' \na = 1; \nb = 2; \n\nvar si = step( foo ); \nvar s2 = step( bar ); \n\n// run '*foo()~ completely first \n\nsi(); \n\nsi(); \n\nsi(); \n\n// now run '*bar()' \n\ns2(); \n\ns2(); \n\ns2(); \n\ns2();","metadata":{"loc":{"lines":{"from":112220,"to":112268}}}}],["1281",{"pageContent":"var si = step( foo ); \nvar s2 = step( bar ); \n\n// run '*foo()~ completely first \n\nsi(); \n\nsi(); \n\nsi(); \n\n// now run '*bar()' \n\ns2(); \n\ns2(); \n\ns2(); \n\ns2(); \n\nconsole.log( a, b ); // 11 22 \n\n\nBreaking Run-to-Completion | 1B1 \n\n\n\n\n\n\nThe end result is 11 and 22, just as it was in the Chapter 1 version. \nNow let’s mix up the interleaving ordering and see how it changes \nthe final values of a and b: \n\n\n// make sure to reset 'a' and 'b' \na = 1; \nb = 2; \n\nvar si = step( foo ); \nvar s2 = step( bar ); \n\ns2(); ///>--; \n\ns2(); // yield 8 \n\nsl(); // a++; \n\ns2(); // a = 8 + b; \n\n// yield 2 \n\nsl(); // b = b * a; \n\n// yield b \n\nsl(); // a = b + 3; \n\ns2(); // b = a * 2; \n\nBefore I tell you the results, can you figure out what a and b are after \nthe preceding program? No cheating! \n\nconsole.log( a, b ); // 12 18","metadata":{"loc":{"lines":{"from":112268,"to":112332}}}}],["1282",{"pageContent":"sl(); // a = b + 3; \n\ns2(); // b = a * 2; \n\nBefore I tell you the results, can you figure out what a and b are after \nthe preceding program? No cheating! \n\nconsole.log( a, b ); // 12 18 \n\n\n\nAs an exercise for the reader, try to see how \nmany other combinations of results you can get \nback rearranging the order of the sl() and s2() \ncalls. Don’t forget you’ll always need three sl() \ncalls and four s2() calls. Recall the discussion \nearlier about matching next() with yield for \nthe reasons why. \n\n\nYou almost certainly won’t want to intentionally create this level of \ninterleaving confusion, as it creates incredibly difficult to under¬ \nstand code. But the exercise is interesting and instructive to under¬ \nstand more about how multiple generators can run concurrently in \nthe same shared scope, because there will be places where this capa¬ \nbility is quite useful. \n\nWe’ll discuss generator concurrency in more detail in “Generator \nConcurrency” on page 165. \n\n\n132 | Chapter 4: Generators","metadata":{"loc":{"lines":{"from":112332,"to":112363}}}}],["1283",{"pageContent":"We’ll discuss generator concurrency in more detail in “Generator \nConcurrency” on page 165. \n\n\n132 | Chapter 4: Generators \n\n\n\n\n\n\nGenerator-ing Values \n\nIn the previous section, we mentioned an interesting use for genera¬ \ntors, as a way to produce values. This is not the main focus in this \nchapter, but we’d be remiss if we didn’t cover the basics, especially \nbecause this use case is essentially the origin of the name: genera¬ \ntors. \n\nWe’re going to take a slight diversion into the topic of iterators for a \nbit, but we’ll circle back to how they relate to generators and using a \ngenerator to generate values. \n\nProducers and Iterators \n\nImagine you’re producing a series of values where each value has a \ndefinable relationship to the previous value. To do this, you’re going \nto need a stateful producer that remembers the last value it gave out. \n\nYou can implement something like that straightforwardly using a \nfunction closure (see the Scope & Closures title of this series):","metadata":{"loc":{"lines":{"from":112363,"to":112393}}}}],["1284",{"pageContent":"You can implement something like that straightforwardly using a \nfunction closure (see the Scope & Closures title of this series): \n\nvar gimmeSomething = (function(){ \nvar nextVat; \n\nreturn function(){ \n\nif (nextVal === undefined) { \nnextVal = 1; \n\n} \n\nelse { \n\nnextVal = (3 * nextVal) + 6; \n\n} \n\nreturn nextVal; \n\n1 ; \n\n\n1)0; \n\n\n\ngimmeSomethingC ); \n\n// \n\n1 \n\ngimmeSomething (); \n\n// \n\n9 \n\ngimmeSomethingC ); \n\n// \n\n33 \n\ngimmeSomethingC ); \n\n// \n\n105 \n\n\nGenerator-ing Values | 133 \n\n\n\n\nThe nextVal computation logic here could have \nbeen simplified, but conceptually, we don’t want \nto calculate the next value (aka nextVal) until \nthe next gimmeSomething () call happens, \nbecause in general that could be a resource-leaky \ndesign for producers of more persistent or \nresource-limited values than simple numbers. \n\n\nGenerating an arbitrary number series isn’t a terribly realistic exam¬ \nple. But what if you were generating records from a data source? \nYou could imagine much the same code.","metadata":{"loc":{"lines":{"from":112393,"to":112462}}}}],["1285",{"pageContent":"Generating an arbitrary number series isn’t a terribly realistic exam¬ \nple. But what if you were generating records from a data source? \nYou could imagine much the same code. \n\nIn fact, this task is a very common design pattern, usually solved by \niterators. An iterator is a well-defined interface for stepping through \na series of values from a producer. The JS interface for iterators, as it \nis in most languages, is to call next() each time you want the next \nvalue from the producer. \n\nWe could implement the standard iterator interface for our number \nseries producer: \n\nvar something = (function(){ \nvar nextVal; \n\nreturn { \n\n// needed for 'for..of' loops \n\n[Symbol.iterator]: function(){ return this; }, \n\n// standard iterator interface nethod \n\nnext: function(){ \n\nif (nextVal === undefined) { \nnextVal = 1; \n\n} \n\nelse { \n\nnextVal = (3 * nextVal) + 6; \n\n} \n\nreturn { done:false, value:nextVal }; \n\n} \n\n}; \n\n})(); \n\nsomething. next() .value; // 1 \n\nsomething. next() .value; // 9","metadata":{"loc":{"lines":{"from":112462,"to":112509}}}}],["1286",{"pageContent":"} \n\nelse { \n\nnextVal = (3 * nextVal) + 6; \n\n} \n\nreturn { done:false, value:nextVal }; \n\n} \n\n}; \n\n})(); \n\nsomething. next() .value; // 1 \n\nsomething. next() .value; // 9 \n\nsomething . next( ) .value; // 33 \n\nsomething . next( ) .value; // 105 \n\n\n134 | Chapter 4: Generators \n\n\n\n\n\n\nWe’ll explain why we need the [Symbol.itera \ntor] : .. part of this code snippet in “Iterables” \non page 137. Syntactically though, two ES6 fea¬ \ntures are at play. First, the [ .. ] syntax is \n\ncalled a computed property name (see the this & \nObject Prototypes title of this series). It’s a way in \nan object literal definition to specify an expres¬ \nsion and use the result of that expression as the \nname for the property. Next, Symbol.Iterator \nis one of ES6’s predefined special Symbol values \n(see the ES6 & Beyond title of this series). \n\n\nThe nextQ call returns an object with two properties: done is a \nboolean value signaling the iterators complete status; value holds \nthe iteration value.","metadata":{"loc":{"lines":{"from":112509,"to":112557}}}}],["1287",{"pageContent":"The nextQ call returns an object with two properties: done is a \nboolean value signaling the iterators complete status; value holds \nthe iteration value. \n\nES6 also adds the for. .of loop, which means that a standard itera¬ \ntor can automatically be consumed with native loop syntax: \n\nfor (var v of something) { \nconsole.log ( v ); \n\n\n// don't let the loop run forever! \nif (v > 500) { \n\nbreak; \n\n} \n\n} \n\n// 1 9 33 105 321 969 \n\n\n\nBecause our something iterator always returns \ndone:false, this for..of loop would run for¬ \never, which is why we put the break conditional \nin. It’s totally OK for iterators to be never- \nending, but there are also cases where the itera¬ \ntor will run over a finite set of values and \neventually return adone:true. \n\n\nThe for. .of loop automatically calls next() for each iteration—it \ndoesn’t pass any values in to the nextQ— and it will automatically \nterminate on receiving a done:true. It’s quite handy for looping \nover a set of data.","metadata":{"loc":{"lines":{"from":112557,"to":112593}}}}],["1288",{"pageContent":"Of course, you could manually loop over iterators, calling nextQ \nand checking for the done: true condition to know when to stop: \n\n\nGenerator-ing Values | 135 \n\n\n\n\n\nfor ( \n\nvar ret; \n\n(ret = something.next()) && ! ret.done; \n\n) { \n\nconsole.log( ret.value ); \n\n// don't let the loop run forever! \nif (ret. value > 500) { \nbreak; \n\n} \n\n} \n\n// 1 9 33 105 321 969 \n\n\n\nThis manual for approach is certainly uglier \nthan the ES6 for. .of loop syntax, but its advan¬ \ntage is that it affords you the opportunity to pass \nin values to the next(..) calls if necessary. \n\n\nIn addition to making your own iterators, many built-in data struc¬ \ntures in JS (as of ES6), like arrays, also have default iterators: \n\nvar a = [1,3,5,7,9]; \n\nfor (var v of a) { \nconsole.log( v ); \n\n1 \n\n// 1 3 5 7 9 \n\nThe f or.. of loop asks a for its iterator, and automatically uses it to \niterate over a’s values.","metadata":{"loc":{"lines":{"from":112595,"to":112646}}}}],["1289",{"pageContent":"var a = [1,3,5,7,9]; \n\nfor (var v of a) { \nconsole.log( v ); \n\n1 \n\n// 1 3 5 7 9 \n\nThe f or.. of loop asks a for its iterator, and automatically uses it to \niterate over a’s values. \n\n\n\nIt may seem a strange omission by ES6, but reg¬ \nular objects intentionally do not come with a \ndefault iterator the way arrays do. The reasons \ngo deeper than we will cover here. If all you \nwant is to iterate over the properties of an object \n(with no particular guarantee of ordering), \nObject.keys( ..) returns an array, which can \nthen be used like for (var k of \nObject.keys(obj)) { ... Such a for..of loop \nover an object’s keys would be similar to a \nfor..in loop, except that Object.keys(..) \ndoes not include properties from the [[Proto \ntype]] chain while for. .in does (see the this & \nObject Prototypes title of this series). \n\n\n136 | Chapter 4: Generators \n\n\n\n\n\n\nIterables","metadata":{"loc":{"lines":{"from":112646,"to":112683}}}}],["1290",{"pageContent":"136 | Chapter 4: Generators \n\n\n\n\n\n\nIterables \n\n\nThe something object in our running example is called an iterator, \nas it has the nextQ method on its interface. But a closely related \nterm is iterable, which is an object that contains an iterator that can \niterate over its values. \n\nAs of ES6, the way to retrieve an iterator from an iterable is that the \niterable must have a function on it, with the name being the special \nES6 symbol value Symbol.iterator. When this function is called, it \nreturns an iterator. Though not required, generally each call should \nreturn a fresh new iterator. \n\na in the previous snippet is an iterable. The for. .of loop automati¬ \ncally calls its Symbol. iterator function to construct an iterator. But \nwe could of course call the function manually, and use the iterator it \nreturns: \n\nvar a = [1,3,5,7,9]; \n\nvar it = a[Symbol.lterator](); \n\nit . next( ) .value; // 1 \n\nit.next().value; // 3 \n\nit.next().value; // 5","metadata":{"loc":{"lines":{"from":112683,"to":112717}}}}],["1291",{"pageContent":"var a = [1,3,5,7,9]; \n\nvar it = a[Symbol.lterator](); \n\nit . next( ) .value; // 1 \n\nit.next().value; // 3 \n\nit.next().value; // 5 \n\nIn the previous code listing that defined something, you may have \nnoticed this line: \n\n[Symbol.iterator] : function(){ return this; } \n\nThat little bit of confusing code is making the something value—the \ninterface of the something iterator —also an iterable; it’s now both \nan iterable and an iterator. Then, we pass something to the for. .of \nloop: \n\nfor (var v of something) { \n\n} \n\nThe for.. of loop expects something to be an iterable, so it looks for \nand calls its Symbol.iterator function. We defined that function to \nsimply return this, so it just gives itself back, and the for. .of \nloop is none the wiser. \n\n\nGenerator-ing Values | 137 \n\n\n\n\nGenerator Iterator","metadata":{"loc":{"lines":{"from":112717,"to":112752}}}}],["1292",{"pageContent":"Generator-ing Values | 137 \n\n\n\n\nGenerator Iterator \n\nLet’s turn our attention back to generators, in the context of itera¬ \ntors. A generator can be treated as a producer of values that we \nextract one at a time through an iterator interface’s next() calls. \n\nSo, a generator itself is not technically an iterable, though it’s very \nsimilar—when you execute the generator, you get an iterator back: \n\nfunction *foo(){ .. } \nvar it = foo(); \n\nWe can implement the something infinite number series producer \nfrom earlier with a generator, like this: \n\nfunction *something() { \nvar nextVal; \n\nwhile (true) { \n\nif (nextVal === undefined) { \nnextVal = 1; \n\n} \n\nelse { \n\nnextVal = (3 * nextVal) + 6; \n\n} \n\nyield nextVal; \n\n} \n\n}","metadata":{"loc":{"lines":{"from":112752,"to":112792}}}}],["1293",{"pageContent":"function *something() { \nvar nextVal; \n\nwhile (true) { \n\nif (nextVal === undefined) { \nnextVal = 1; \n\n} \n\nelse { \n\nnextVal = (3 * nextVal) + 6; \n\n} \n\nyield nextVal; \n\n} \n\n} \n\n\n\nA while, .true loop would normally be a very \nbad thing to include in a real JS program, at least \nif it doesn’t have a break or return in it, as it \nwould likely run forever, synchronously, and \nblock/lock-up the browser UI. However, in a \ngenerator, such a loop is generally totally OK if \nit has a yield in it, as the generator will pause at \neach iteration, yielding back to the main pro¬ \ngram and/or to the event loop queue. To put it \nglibly, “generators put the while, .true back in \nJS programming!” \n\n\nThat’s a fair bit cleaner and simpler, right? Because the generator \npauses at each yield, the state (scope) of the function *something() \nis kept around, meaning there’s no need for the closure boilerplate \nto preserve variable state across calls. \n\n\n138 | Chapter 4: Generators","metadata":{"loc":{"lines":{"from":112792,"to":112835}}}}],["1294",{"pageContent":"138 | Chapter 4: Generators \n\n\n\n\nNot only is it simpler code—we don’t have to make our own iterator \ninterface—it actually is more reason-able code, because it more \nclearly expresses the intent. For example, the while. .true loop tells \nus the generator is intended to run forever—to keep generating val¬ \nues as long as we keep asking for them. \n\nAnd now we can use our shiny new *something( ) generator with a \nfor.. of loop, and you’ll see it works basically identically: \n\nfor (var v of something!)) { \nconsole.log ( v ); \n\n// don't let the loop run forever! \nif (v > 500) { \n\nbreak; \n\n} \n\n} \n\n// 1 9 33 105 321 969 \n\nBut don’t skip over for (var v of something!)) ..! We didn’t \njust reference something as a value like in earlier examples, but \ninstead called the *something( ) generator to get its iterator for the \nfor. .of loop to use. \n\nIf you’re paying close attention, two questions may arise from this \ninteraction between the generator and the loop:","metadata":{"loc":{"lines":{"from":112835,"to":112869}}}}],["1295",{"pageContent":"If you’re paying close attention, two questions may arise from this \ninteraction between the generator and the loop: \n\n• Why couldn’t we say for (var v of something) ..? Because \nsomething here is a generator, which is not an iterable. We have \nto call something!) to construct a producer for the for..of \nloop to iterate over. \n\n• The something!) call produces an iterator, but the for..of \nloop wants an iterable, right? Yep. The generator’s iterator also \nhas a Symbol.iterator function on it, which basically does a \nreturn this, just like the something iterable we defined earlier. \nIn other words, a generator’s iterator is also an iterable\\ \n\nStopping the Generator \n\nIn the previous example, it would appear the iterator instance for \nthe *something() generator was basically left in a suspended state \nforever after the break in the loop was called. \n\nBut there’s a hidden behavior that takes care of that for you. \n“Abnormal completion” (i.e., “early termination”) of the for., of","metadata":{"loc":{"lines":{"from":112869,"to":112890}}}}],["1296",{"pageContent":"But there’s a hidden behavior that takes care of that for you. \n“Abnormal completion” (i.e., “early termination”) of the for., of \n\n\nGenerator-ing Values | 139 \n\n\n\nloop—generally caused by a break, return, or an uncaught excep \ntion—sends a signal to the generator’s iterator for it to terminate. \n\n\n\nTechnically, the for..of loop also sends this \nsignal to the iterator at the normal completion \nof the loop. For a generator, that’s essentially a \nmoot operation, as the generator’s iterator had \nto complete first so the for. .of loop completed. \nHowever, custom iterators might desire to \nreceive this additional signal from for. .of loop \nconsumers. \n\n\nWhile a for. .of loop will automatically send this signal, you may \nwish to send the signal manually to an iterator; you do this by call¬ \ning return(..).","metadata":{"loc":{"lines":{"from":112890,"to":112915}}}}],["1297",{"pageContent":"While a for. .of loop will automatically send this signal, you may \nwish to send the signal manually to an iterator; you do this by call¬ \ning return(..). \n\nIf you specify a try. .finally clause inside the generator, it will \nalways be run even when the generator is externally completed. This \nis useful if you need to clean up resources (database connections, \netc.): \n\nfunction *something() { \ntry { \n\nvar nextVat; \nwhile (true) { \n\nif (nextVal === undefined) { \nnextVal = 1; \n\n} \n\nelse { \n\nnextVal = (3 * nextVal) + 6; \n\n} \n\nyield nextVal; \n\n} \n\n} \n\n// cleanup clause \n\nfinally { \n\nconsole.log( \"cleaning up!\" ); \n\n} \n\n} \n\nThe earlier example with break in the for. .of loop will trigger the \nfinally clause. But you could instead manually terminate the gen¬ \nerator’s iterator instance from the outside with return(..): \n\n\n140 | Chapter 4: Generators \n\n\n\n\n\nvar it = somethlngO; \nfor (var v of It) { \nconsole.log( v ); \n\n// don't let the loop run forever! \nif (v > 500) { \nconsole.log(","metadata":{"loc":{"lines":{"from":112915,"to":112974}}}}],["1298",{"pageContent":"140 | Chapter 4: Generators \n\n\n\n\n\nvar it = somethlngO; \nfor (var v of It) { \nconsole.log( v ); \n\n// don't let the loop run forever! \nif (v > 500) { \nconsole.log( \n\n// complete the generator's iterator \nit.return( \"Hello World\" ). value \n\n); \n\n// no 'break' needed here \n\n} \n\n} \n\n// 1 9 33 105 321 969 \n// cleaning up! \n\n// Hello World \n\nWhen we call it. return( ..), it immediately terminates the genera¬ \ntor, which of course runs the finally clause. Also, it sets the \nreturned value to whatever you passed in to return( ..), which is \nhow \"Hello World\" comes right back out. We also don’t need to \ninclude a break now because the generator’s iterator is set to \ndone: true, so the for.. of loop will terminate on its next iteration. \n\nGenerators owe their namesake mostly to this consuming produced \nvalues use. But again, that’s just one of the uses for generators, and \nfrankly not even the main one we’re concerned with in the context \nof this book.","metadata":{"loc":{"lines":{"from":112974,"to":113014}}}}],["1299",{"pageContent":"But now that we more fully understand some of the mechanics of \nhow they work, we can next turn our attention to how generators \napply to async concurrency. \n\nIterating Generators Asynchronously \n\nWhat do generators have to do with async coding patterns, fixing \nproblems with callbacks, and the like? Let’s get to answering that \nimportant question. \n\nWe should revisit one of our scenarios from Chapter 3. Let’s recall \nthe callback approach: \n\nfunction foo(x,y,cb) { \najax( \n\n\"http://some.url.l/?x=\" + x + \"&y=\" + y, \ncb \n\n); \n\n} \n\n\nIterating Generators Asynchronously | 141 \n\n\n\nfoo( 11, 31, function(err,text) { \nif (err) { \n\nconsole.error( err ); \n\n} \n\nelse { \n\nconsole.log( text ); \n\n} \n\n} ); \n\nIf we wanted to express this same task flow control with a generator, \nwe could do: \n\nfunction foo(x,y) { \najax( \n\n\"http://some.url.l/?x=\" + x + \"&y=\" + y, \nfunction (err,data){ \nif (err) { \n\n// throw an error into '*main()' \n\nit.throw( err ); \n\n} \n\nelse {","metadata":{"loc":{"lines":{"from":113016,"to":113075}}}}],["1300",{"pageContent":"function foo(x,y) { \najax( \n\n\"http://some.url.l/?x=\" + x + \"&y=\" + y, \nfunction (err,data){ \nif (err) { \n\n// throw an error into '*main()' \n\nit.throw( err ); \n\n} \n\nelse { \n\n// resume '*main()' with received 'data' \nit.next( data ); \n\n} \n\n} \n\n); \n\n} \n\nfunction *main() { \ntry { \n\nvar text = yield foo( 11, 31 ); \nconsole.log( text ); \n\n} \n\ncatch (err) { \n\nconsole.error( err ); \n\n} \n\n} \n\nvar it = mainQ; \n\n// start it all up! \nit.next(); \n\nAt first glance, this snippet is longer, and perhaps a little more com¬ \nplex looking, than the callback snippet before it. But don’t let that \nimpression get you off track. The generator snippet is actually much \nbetter! But there’s a lot going on for us to explain. \n\nFirst, let’s look at this part of the code, which is the most important: \n\n\n142 | Chapter 4: Generators \n\n\n\nvar text = yield foo( 11, 31 ); \nconsole.log( text );","metadata":{"loc":{"lines":{"from":113075,"to":113135}}}}],["1301",{"pageContent":"First, let’s look at this part of the code, which is the most important: \n\n\n142 | Chapter 4: Generators \n\n\n\nvar text = yield foo( 11, 31 ); \nconsole.log( text ); \n\nThink about how that code works for a moment. We’re calling a \nnormal function foo(..) and we’re apparently able to get back the \ntext from the Ajax call, even though it’s asynchronous. \n\nHow is that possible? If you recall the beginning of Chapter 1, we \nhad almost identical code: \n\nvar data = ajax( \"..url 1..\" ); \nconsole.log( data ); \n\nAnd that code didn’t work! Can you spot the difference? It’s the \nyield used in a generator. \n\nThat’s the magic! That’s what allows us to have what appears to be \nblocking, synchronous code, but it doesn’t actually block the whole \nprogram; it only pauses/blocks the code in the generator itself.","metadata":{"loc":{"lines":{"from":113135,"to":113160}}}}],["1302",{"pageContent":"In yield foo(ll,31), first the foo(ll,31) call is made, which \nreturns nothing (aka undefined), so we’re making a call to request \ndata, but we’re actually then doing yield undefined. That’s OK, \nbecause the code is not currently relying on a yielded value to do \nanything interesting. We’ll revisit this point later in the chapter. \n\nWe’re not using yield in a message passing sense here, only in a \nflow control sense to pause/block. Actually, it will have message \npassing, but only in one direction, after the generator is resumed. \n\nSo, the generator pauses at the yield, essentially asking the ques¬ \ntion, “what value should I return to assign to the variable text?” \nWho’s going to answer that question? \n\nLook at foo( ..). If the Ajax request is successful, we call: \n\ntt.next( data );","metadata":{"loc":{"lines":{"from":113162,"to":113178}}}}],["1303",{"pageContent":"Look at foo( ..). If the Ajax request is successful, we call: \n\ntt.next( data ); \n\nThat’s resuming the generator with the response data, which means \nthat our paused yield expression receives that value directly, and \nthen as it restarts the generator code, that value gets assigned to the \nlocal variable text. \n\nPretty cool, huh? \n\nTake a step back and consider the implications. We have totally \nsynchronous-looking code inside the generator (other than the \n\n\nIterating Generators Asynchronously | 143 \n\n\n\n\nyield keyword itself), but hidden behind the scenes, inside of \nfoo( ..), the operations can complete asynchronously. \n\nThat’s huge! That’s a nearly perfect solution to our previously stated \nproblem with callbacks not being able to express asynchrony in a \nsequential, synchronous fashion that our brains can relate to.","metadata":{"loc":{"lines":{"from":113178,"to":113203}}}}],["1304",{"pageContent":"In essence, we are abstracting the asynchrony away as an implemen¬ \ntation detail, so that we can reason synchronously/sequentially \nabout our flow control: “Make an Ajax request, and when it finishes \nprint out the response.” And of course, we just expressed two steps \nin the flow control, but this same capability extends without \nbounds, to let us express however many steps we need to. \n\n\n\nThis is such an important realization, just go \nback and read the last three paragraphs again to \nlet it sink in! \n\n\nSynchronous Error Handling \n\nBut the preceding generator code has even more goodness to yield \nto us. Let’s turn our attention to the try. .catch inside the genera¬ \ntor: \n\n\ntry { \n\nvar text = yield foo( 11, 31 ); \nconsole.log( text ); \n\n} \n\ncatch (err) { \n\nconsole.error( err ); \n\n} \n\nHow does this work? The foo(..) call is asynchronously complet¬ \ning, and doesn’t try.. catch fail to catch asynchronous errors, as we \nlooked at in Chapter 3?","metadata":{"loc":{"lines":{"from":113205,"to":113241}}}}],["1305",{"pageContent":"console.error( err ); \n\n} \n\nHow does this work? The foo(..) call is asynchronously complet¬ \ning, and doesn’t try.. catch fail to catch asynchronous errors, as we \nlooked at in Chapter 3? \n\nWe already saw how the yield lets the assignment statement pause \nto wait for foo(..) to finish, so that the completed response can be \nassigned to text. The awesome part is that this yield pausing also \nallows the generator to catch an error. We throw that error into the \ngenerator with this part of the earlier code listing: \n\nif (err) { \n\n// throw an error into '*nain()' \n\n\n144 | Chapter 4: Generators \n\n\n\n\n\ntt.throw( err ); \n\n} \n\nThe yield-pause nature of generators means that not only do we get \nsynchronous-looking return values from async function calls, but \nwe can also synchronously catch errors from those async function \ncalls! \n\nSo we’ve seen we can throw errors into a generator, but what about \nthrowing errors out of a. generator? Exactly as you’d expect: \n\nfunction *main() {","metadata":{"loc":{"lines":{"from":113241,"to":113278}}}}],["1306",{"pageContent":"So we’ve seen we can throw errors into a generator, but what about \nthrowing errors out of a. generator? Exactly as you’d expect: \n\nfunction *main() { \n\nvar x = yield \"Hello World\"; \n\nyield x.toLowerCaseQ; // cause an exception! \n\n} \n\nvar it = main(); \n\nit. next() .value; // Hello World \n\ntry { \n\nit.next( 42 ); \n\n} \n\ncatch (err) { \n\nconsole.error( err ); // TypeError \n\n} \n\nOf course, we could have manually thrown an error with throw .. \ninstead of causing an exception. \n\nWe can even catch the same error that we throw(.. ) into the gen¬ \nerator, essentially giving the generator a chance to handle it but if it \ndoesn’t, the iterator code must handle it: \n\nfunction *nain() { \n\nvar x = yield \"Hello World\"; \n\n// never gets here \nconsole.log( x ); \n\n} \n\nvar it = nain(); \nit . next( ); \n\ntry { \n\n// will '*nain()' handle this error? we'll see! \nit.throw( \"Oops\" ); \n\n} \n\ncatch (err) { \n\n\nIterating Generators Asynchronously | 145 \n\n\n\n// nope, didn't handle it! \n\nconsole.error( err ); // Oops","metadata":{"loc":{"lines":{"from":113278,"to":113340}}}}],["1307",{"pageContent":"// will '*nain()' handle this error? we'll see! \nit.throw( \"Oops\" ); \n\n} \n\ncatch (err) { \n\n\nIterating Generators Asynchronously | 145 \n\n\n\n// nope, didn't handle it! \n\nconsole.error( err ); // Oops \n\n} \n\nSynchronous-looking error handling (via try..catch) with async \ncode is a huge win for readability and reason-ability. \n\nGenerators + Promises \n\nIn our previous discussion, we showed how generators can be iter¬ \nated asynchronously, which is a huge step forward in sequential \nreason-ability over the spaghetti mess of callbacks. But we lost \nsomething very important: the trustability and composability of \nPromises (see Chapter 3)! \n\nDon’t worry—we can get that back. The best of all worlds in ES6 is \nto combine generators (synchronous-looking async code) with \nPromises (trustable and composable). \n\nBut how? \n\nRecall from Chapter 3 the Promise-based approach to our running \nAjax example: \n\nfunction foo(x,y) { \nreturn request! \n\n\"http://some.url.l/?x=\" + x + \"&y=\" + y \n\n); \n\n}","metadata":{"loc":{"lines":{"from":113340,"to":113385}}}}],["1308",{"pageContent":"But how? \n\nRecall from Chapter 3 the Promise-based approach to our running \nAjax example: \n\nfunction foo(x,y) { \nreturn request! \n\n\"http://some.url.l/?x=\" + x + \"&y=\" + y \n\n); \n\n} \n\nfoo( 11, 31 ) \n\n. then( \n\nfunction! text ){ \n\nconsole.log! text ); \n\n}, \n\nfunction!err){ \n\nconsole.error! err ); \n\n} \n\n); \n\nIn our earlier generator code for the running Ajax example, foo(.. ) \nreturned nothing (undefined), and our iterator control code didn’t \ncare about that yielded value. \n\nBut here the Promise-aware foo(. .) returns a promise after making \nthe Ajax call. That suggests that we could construct a promise with \nfoo(. .) and then yield it from the generator, and then the iterator \ncontrol code would receive that promise. \n\n\n146 | Chapter 4: Generators \n\n\n\nBut what should the iterator do with the promise?","metadata":{"loc":{"lines":{"from":113385,"to":113431}}}}],["1309",{"pageContent":"146 | Chapter 4: Generators \n\n\n\nBut what should the iterator do with the promise? \n\nIt should listen for the promise to resolve (fulfillment or rejection), \nand then either resume the generator with the fulfillment message \nor throw an error into the generator with the rejection reason. \n\nLet me repeat that, because it’s so important. The natural way to get \nthe most out of Promises and generators is to yield a Promise, and \nwire that Promise to control the generator’s iterator. \n\nLet’s give it a try! First, we’ll put the Promise-aware foo(..) \ntogether with the generator *main(): \n\nfunction foo(x,y) { \nreturn request( \n\n\"http://some.url.l/?x=\" + x + \"&y=\" + y \n\n); \n\n} \n\nfunction *main() { \ntry { \n\nvar text = yield foo( 11, 31 ); \nconsole.log( text ); \n\n} \n\ncatch (err) { \n\nconsole.error( err ); \n\n} \n\n}","metadata":{"loc":{"lines":{"from":113431,"to":113471}}}}],["1310",{"pageContent":"\"http://some.url.l/?x=\" + x + \"&y=\" + y \n\n); \n\n} \n\nfunction *main() { \ntry { \n\nvar text = yield foo( 11, 31 ); \nconsole.log( text ); \n\n} \n\ncatch (err) { \n\nconsole.error( err ); \n\n} \n\n} \n\nThe most powerful revelation in this refactor is that the code inside \n*main() did not have to change at all! Inside the generator, what¬ \never values are yielded out is just an opaque implementation detail, \nso we’re not even aware it’s happening, nor do we need to worry \nabout it. \n\nBut how are we going to run *main() now? We still have some of \nthe implementation plumbing work to do, to receive and wire up \nthe yielded promise so that it resumes the generator upon resolu¬ \ntion. We’ll start by trying that manually: \n\nvar it = main(); \n\nvar p = it . next( ) .value; \n\n// wait for the 'p' promise to resolve \np.then( \n\nfunction! text ){ \n\ntt.next( text ); \n\n}. \n\n\nGenerators + Promises | 147 \n\n\n\nfunction(err){ \n\nlt.throw( err ); \n\n} \n\n); \n\nActually, that wasn’t so painful at all, was it?","metadata":{"loc":{"lines":{"from":113471,"to":113530}}}}],["1311",{"pageContent":"function! text ){ \n\ntt.next( text ); \n\n}. \n\n\nGenerators + Promises | 147 \n\n\n\nfunction(err){ \n\nlt.throw( err ); \n\n} \n\n); \n\nActually, that wasn’t so painful at all, was it? \n\nThis snippet should look very similar to what we did earlier with the \nmanually wired generator controlled by the error-first callback. \nInstead of an if (err) { it.throw. ., the promise already splits \nfulfillment (success) and rejection (failure) for us, but otherwise the \niterator control is identical. \n\nNow, we’ve glossed over some important details.","metadata":{"loc":{"lines":{"from":113530,"to":113557}}}}],["1312",{"pageContent":"Now, we’ve glossed over some important details. \n\nMost importantly, we took advantage of the fact that we knew that \n*nain( ) only had one Promise-aware step in it. What if we wanted \nto be able to Promise-drive a generator no matter how many steps it \nhas? We certainly don’t want to manually write out the Promise \nchain differently for each generator! What would be much nicer is if \nthere was a way to repeat (aka loop over) the iteration control, and \neach time a Promise comes out, wait on its resolution before con¬ \ntinuing. \n\nAlso, what if the generator throws out an error (intentionally or \naccidentally) during the it.next(..) call? Should we quit, or \nshould we catch it and send it right back in? Similarly, what if we \nit.throw(. .) a Promise rejection into the generator, but it’s not \nhandled, and comes right back out? \n\nPromise-Aware Generator Runner","metadata":{"loc":{"lines":{"from":113557,"to":113574}}}}],["1313",{"pageContent":"Promise-Aware Generator Runner \n\nThe more you start to explore this path, the more you realize, “wow, \nit’d be great if there was just some utility to do it for me.” And \nyou’re absolutely correct. This is such an important pattern, and you \ndon’t want to get it wrong (or exhaust yourself repeating it over and \nover), so your best bet is to use a utility that is specifically designed \nto run Promise-yielding generators in the manner we’ve illustrated. \n\nSeveral Promise abstraction libraries provide just such a utility, \nincluding my asynquence library and its runner (..), which are dis¬ \ncussed in Appendix A of this book. \n\nBut for the sake of learning and illustration, let’s just define our own \nstandalone utility that we’ll call run(..): \n\n\n148 | Chapter 4: Generators \n\n\n\n\n// thanks to Benjamin Cruenbaum (Qbenjamingr on GitHub) for \n// big improvements here! \n\nfunction run(gen) { \n\nvar args = [] .slice.call( arguments, 1), it;","metadata":{"loc":{"lines":{"from":113574,"to":113601}}}}],["1314",{"pageContent":"148 | Chapter 4: Generators \n\n\n\n\n// thanks to Benjamin Cruenbaum (Qbenjamingr on GitHub) for \n// big improvements here! \n\nfunction run(gen) { \n\nvar args = [] .slice.call( arguments, 1), it; \n\n// initialize the generator in the current context \nit = gen.apply( this, args ); \n\n// return a promise for the generator completing \nreturn Promise.resolveQ \n\n.then( function handleNext(value){ \n\n// run to the next yielded value \nvar next = it.next( value ); \n\nreturn (function handleResult(next){ \n\n// generator has completed running? \nif (next.done) { \n\nreturn next.value; \n\n} \n\n// otherwise keep going \n\nelse { \n\nreturn Promise.resolve( next.value ) \n\n. then( \n\n// resume the async loop on \n// success, sending the resolved \n// value back into the generator \nhandleNext, \n\n\n} \n\n\n// if 'value' is a rejected \n// promise, propagate error back \n// into the generator for its own \n// error handling \n\nfunction handleErr(err) { \nreturn Promise.resolve( \nit.throw( err ) \n\n) \n\n.then( handleResult ); \n\n}","metadata":{"loc":{"lines":{"from":113601,"to":113663}}}}],["1315",{"pageContent":"function handleErr(err) { \nreturn Promise.resolve( \nit.throw( err ) \n\n) \n\n.then( handleResult ); \n\n} \n\n); \n\n} \n\n})(next); \n\n} ); \n\n\nAs you can see, it’s a quite a bit more complex than you’d probably \nwant to author yourself, and you especially wouldn’t want to repeat \nthis code for each generator you use. So, a utility/library helper is \ndefinitely the way to go. Nevertheless, I encourage you to spend a \nfew minutes studying that code listing to get a better sense of how to \nmanage the generator + Promise negotiation. \n\n\nGenerators + Promises | 149 \n\n\n\nHow would you use run(..) with *main() in our running Ajax \nexample? \n\nfunction *main() { \n\n// \n\n} \n\nrun( main ); \n\nThat’s it! The way we wired run(..), it will automatically advance \nthe generator you pass to it, asynchronously until completion.","metadata":{"loc":{"lines":{"from":113663,"to":113706}}}}],["1316",{"pageContent":"function *main() { \n\n// \n\n} \n\nrun( main ); \n\nThat’s it! The way we wired run(..), it will automatically advance \nthe generator you pass to it, asynchronously until completion. \n\n\n\nThe run(..) we defined returns a promise \nwhich is wired to resolve once the generator is \ncomplete, or receive an uncaught exception if \nthe generator doesn’t handle it. We don’t show \nthat capability here, but we’ll come back to it \nlater in the chapter. \n\n\nES7:async and await? \n\nThe preceding pattern—generators yielding Promises that then \ncontrol the generator’s iterator to advance it to completion—is such \na powerful and useful approach, it would be nicer if we could do it \nwithout the clutter of the library utility helper (aka run(..)).","metadata":{"loc":{"lines":{"from":113706,"to":113732}}}}],["1317",{"pageContent":"There’s probably good news on that front. At the time of this writ¬ \ning, there’s early but strong support for a proposal for more syntac¬ \ntic addition in this realm for the post-ES6, ES7-ish timeframe. \nObviously, it’s too early to guarantee the details, but there’s a pretty \ndecent chance it will shake out similar to the following: \n\nfunction foo(x,y) { \nreturn request? \n\n\"http://some.url.l/?x=\" + x + \"&y=\" + y \n\n); \n\n} \n\nasync function main?) { \ntry { \n\nvar text = await foo( 11, 31 ); \nconsole.log? text ); \n\n} \n\ncatch (err) { \n\nconsole.error? err ); \n\n} \n\n} \n\n\n150 | Chapter 4: Generators \n\n\n\n\n\nnain( ); \n\n\nAs you can see, there’s no run(..) call (meaning no need for a \nlibrary utility!) to invoke and drive main()—it’s just called as a nor¬ \nmal function. Also, main() isn’t declared as a generator function \nanymore; it’s a new kind of function: async function. And finally, \ninstead of yielding a Promise, we await for it to resolve.","metadata":{"loc":{"lines":{"from":113734,"to":113779}}}}],["1318",{"pageContent":"The async function automatically knows what to do if you await a \nPromise—it will pause the function (just like with generators) until \nthe Promise resolves. We didn’t illustrate it in this snippet, but call¬ \ning an async function like main() automatically returns a promise \nthat’s resolved whenever the function finishes completely. \n\n\n\nThe async / await syntax should look very \nfamiliar to readers with experience in C#, \nbecause it’s basically identical. \n\n\nThe proposal essentially codifies support for the pattern we’ve \nalready derived, into a syntactic mechanism: combining Promises \nwith sync-looking flow control code. That’s the best of both worlds \ncombined, to effectively address practically all of the major concerns \nwe outlined with callbacks. \n\nThe mere fact that such a ES7-ish proposal already exists and has \nearly support and enthusiasm is a major vote of confidence in the \nfuture importance of this async pattern. \n\nPromise Concurrency in Generators","metadata":{"loc":{"lines":{"from":113781,"to":113804}}}}],["1319",{"pageContent":"Promise Concurrency in Generators \n\nSo far, all we’ve demonstrated is a single-step async flow with \nPromises + generators. But real-world code will often have many \nasync steps. \n\nIf you’re not careful, the sync-looking style of generators may lull \nyou into complacency with how you structure your async concur¬ \nrency, leading to suboptimal performance patterns. So we want to \nspend a little time exploring the options. \n\nImagine a scenario where you need to fetch data from two different \nsources, then combine those responses to make a third request, and \nfinally print out the last response. We explored a similar scenario \n\n\nGenerators + Promises | 151 \n\n\n\n\nwith Promises in Chapter 3, but let’s reconsider it in the context of \ngenerators. \n\nYour first instinct might be something like: \nfunction *foo() { \n\nvar rl = yield request( \"http://some.url.1\" ); \nvar r2 = yield request( \"http://some.url.2\" ); \n\nvar r3 = yield request( \n\n\"http://some.url.3/?v=\" + rl + + r2 \n\n);","metadata":{"loc":{"lines":{"from":113804,"to":113838}}}}],["1320",{"pageContent":"var rl = yield request( \"http://some.url.1\" ); \nvar r2 = yield request( \"http://some.url.2\" ); \n\nvar r3 = yield request( \n\n\"http://some.url.3/?v=\" + rl + + r2 \n\n); \n\n\nconsole.log( r3 ); \n\n} \n\n// use previously defined ~run(..)' utility \nrun( foo ); \n\nThis code will work, but in the specifics of our scenario, it’s not \noptimal. Can you spot why? \n\nBecause the rl and r2 requests can—and for performance reasons, \nshould —run concurrently, but in this code they will run sequen¬ \ntially; the \"http://some.url. 2\" URL isn’t Ajax fetched until after \nthe \"http://some.url.l\" request is finished. These two requests \nare independent, so the better performance approach would likely \nbe to have them run at the same time. \n\nBut how exactly would you do that with a generator and yield? We \nknow that yield is only a single pause point in the code, so you \ncan’t really do two pauses at the same time.","metadata":{"loc":{"lines":{"from":113838,"to":113867}}}}],["1321",{"pageContent":"But how exactly would you do that with a generator and yield? We \nknow that yield is only a single pause point in the code, so you \ncan’t really do two pauses at the same time. \n\nThe most natural and effective answer is to base the async flow on \nPromises, specifically on their capability to manage state in a time- \nindependent fashion (see “Future Value” on page 52 in Chapter 3). \n\nThe simplest approach: \n\nfunction *foo() { \n\n// make both requests \"in parallel\" \nvar pi = request( \"http://some.url.1\" ); \nvar p2 = request( \"http://some.url.2\" ); \n\n// wait until both promises resolve \n\nvar rl = yield pi; \nvar r2 = yield p2; \n\nvar r3 = yield request( \n\n\"http://some.url.3/?v=\" + rl + + r2 \n\n\n152 | Chapter 4: Generators \n\n\n\n\nconsole.log( r3 ); \n\n} \n\n// use previously defined 'run(..)' utility \nrun( foo );","metadata":{"loc":{"lines":{"from":113867,"to":113903}}}}],["1322",{"pageContent":"var r3 = yield request( \n\n\"http://some.url.3/?v=\" + rl + + r2 \n\n\n152 | Chapter 4: Generators \n\n\n\n\nconsole.log( r3 ); \n\n} \n\n// use previously defined 'run(..)' utility \nrun( foo ); \n\nWhy is this different from the previous snippet? Look at where the \nyield is and is not. pi and p2 are promises for Ajax requests made \nconcurrently (aka “in parallel”). It doesn’t matter which one finishes \nfirst, because promises will hold onto their resolved state for as long \nas necessary. \n\nThen we use two subsequent yield statements to wait for and \nretrieve the resolutions from the promises (into rl and r2, respec¬ \ntively). If pi resolves first, the yield pi resumes first then waits on \nthe yield p2 to resume. If p2 resolves first, it will just patiently hold \nonto that resolution value until asked, but the yield pi will hold on \nfirst, until pi resolves.","metadata":{"loc":{"lines":{"from":113903,"to":113931}}}}],["1323",{"pageContent":"Either way, both pi and p2 will run concurrently, and both have to \nfinish, in either order, before the r3 = yield request.. Ajax \nrequest will be made. \n\nIf that flow control processing model sounds familiar, it’s basically \nthe same as what we identified in Chapter 3 as the gate pattern, \nenabled by the Promise.all([ .. ]) utility. So, we could also \nexpress the flow control like this: \n\nfunction *foo() { \n\n// make both requests \"in parallel,\" and \n// wait until both promises resolve \nvar results = yield Promise.all( [ \nrequest( \"http://some.url.1\" ), \nrequest( \"http://some.url.2\" ) \n\n1 ); \n\nvar rl = results[0]; \nvar r2 = results[l]; \n\nvar r3 = yield request( \n\n\"http://some.url.3/?v=\" + rl + + r2 \n\n); \n\n\nconsole.log( r3 ); \n\n} \n\n\nGenerators + Promises | 153 \n\n\n\n\n// use previously defined 'run(..)' utility \nrun( foo ); \n\n\n\nAs we discussed in Chapter 3, we can even use \nES6 destructuring assignment to simplify the \nvar rl = .. var r2 = .. assignments, with \nvar [rl,r2] = results.","metadata":{"loc":{"lines":{"from":113933,"to":113980}}}}],["1324",{"pageContent":"As we discussed in Chapter 3, we can even use \nES6 destructuring assignment to simplify the \nvar rl = .. var r2 = .. assignments, with \nvar [rl,r2] = results. \n\n\nIn other words, all of the concurrency capabilities of Promises are \navailable to us in the generator + Promise approach. So in any place \nwhere you need more than sequential this-then-that async flow con¬ \ntrol steps, Promises are likely your best bet. \n\nPromises, Hidden \n\nAs a word of stylistic caution, be careful about how much Promise \nlogic you include inside your generators. The whole point of using \ngenerators for asynchrony in the way we’ve described is to create \nsimple, sequential, sync-looking code, and to hide as much of the \ndetails of asynchrony away from that code as possible. \n\nFor example, this might be a cleaner approach: \n\n// note: nornal function, not generator \nfunction bar(urll,url2) { \nreturn Promise.all( [ \nrequest( urll ), \nrequest( url2 ) \n\n] ); \n\n} \n\nfunction *foo() {","metadata":{"loc":{"lines":{"from":113980,"to":114011}}}}],["1325",{"pageContent":"// note: nornal function, not generator \nfunction bar(urll,url2) { \nreturn Promise.all( [ \nrequest( urll ), \nrequest( url2 ) \n\n] ); \n\n} \n\nfunction *foo() { \n\n// hide the Pronise-based concurrency details \n// inside 'bar(..)~ \n\nvar results = yield bar( \n\n\"http://some.url.1\" , \n\n\"http://some.url.2\" \n\n); \n\n\nvar rl = results[0]; \nvar r2 = results[l]; \n\nvar r3 = yield request( \n\n\"http://some.url.3/?v=\" + rl + + r2 \n\n); \n\n\nconsole.log( r3 ); \n\n} \n\n\n154 | Chapter 4: Generators \n\n\n\n\n\n// use previously defined 'run(..)' utility \nrun( foo ); \n\nInside *foo( ), it’s cleaner and clearer that all we’re doing is just ask¬ \ning bar( ..) to get us some results, and we’ll yield-wait on that to \nhappen. We don’t have to care that under the covers a \nPromise.all([ .. ]) Promise composition will be used to make \nthat happen. \n\nWe treat asynchrony, and indeed Promises, as an implementation \ndetail.","metadata":{"loc":{"lines":{"from":114011,"to":114066}}}}],["1326",{"pageContent":"We treat asynchrony, and indeed Promises, as an implementation \ndetail. \n\nHiding your Promise logic inside a function that you merely call \nfrom your generator is especially useful if you’re going to do a \nsophisticated series flow-control. For example: \n\nfunction bar() { \n\nPromise. all( [ \nbaz( .. ) \n\n•then( .. ), \n\nPromise. race( [ .. ] ) \n\n] ) \n\n.then( .. ) \n\n} \n\nThat kind of logic is sometimes required, and if you dump it directly \ninside your generator(s), you’ve defeated most of the reason why \nyou would want to use generators in the first place. We should \nintentionally abstract such details away from our generator code so \nthat they don’t clutter up the higher level task expression. \n\nBeyond creating code that is both functional and performant, you \nshould also strive to make code that is as reason-able and maintain¬ \nable as possible.","metadata":{"loc":{"lines":{"from":114066,"to":114096}}}}],["1327",{"pageContent":"Beyond creating code that is both functional and performant, you \nshould also strive to make code that is as reason-able and maintain¬ \nable as possible. \n\n\n\nAbstraction is not always a healthy thing for \nprogramming—many times it can increase com¬ \nplexity in exchange for terseness. But in this \ncase, I believe it’s much healthier for your gener¬ \nator + Promise async code than the alternatives. \nAs with all such advice, though, pay attention to \nyour specific situations and make proper deci¬ \nsions for you and your team. \n\n\nGenerators + Promises | 155 \n\n\n\n\n\nGenerator Delegation \n\nIn the previous section, we showed calling regular functions from \ninside a generator, and how that remains a useful technique for \nabstracting away implementation details (like async Promise flow). \nBut the main drawback of using a normal function for this task is \nthat it has to behave by the normal function rules, which means it \ncannot pause itself with yield like a generator can.","metadata":{"loc":{"lines":{"from":114096,"to":114125}}}}],["1328",{"pageContent":"It may then occur to you that you might try to call one generator \nfrom another generator, using our run( ..) helper, such as: \n\nfunction *foo() { \n\nvar r2 = yield request( \"http://some.url.2\" ); \n\nvar r3 = yield request( \"http://some.url.3/?v=\" + r2 ); \n\nreturn r3; \n\n} \n\nfunction *bar() { \n\nvar rl = yield request( \"http://some.url.1\" ); \n\n// \"delegating\" to '*foo()' via 'run(..)' \nvar r3 = yield run( foo ); \n\nconsole.log( r3 ); \n\n} \n\nrun( bar ); \n\nWe run *foo() inside of *bar( ) by using our run(. .) utility again. \nWe take advantage here of the fact that the run(.. ) we defined ear¬ \nlier returns a promise which is resolved when its generator is run to \ncompletion (or errors out), so if we yield out to a run( ..) instance \nthe promise from another run(..) call, it automatically pauses \n*bar() until *foo() finishes. \n\nBut there’s an even better way to integrate calling *foo() into \n*bar(), and it’s called yield-delegation. The special syntax for","metadata":{"loc":{"lines":{"from":114127,"to":114161}}}}],["1329",{"pageContent":"But there’s an even better way to integrate calling *foo() into \n*bar(), and it’s called yield-delegation. The special syntax for \n\nyield-delegation is: yield *_(notice the extra *). Before we see \n\nit work in our previous example, let’s look at a simpler scenario: \n\nfunction *foo() { \n\nconsole.log( \"'*foo()' starting\" ); \nyield 3; \nyield 4 ; \n\nconsole.log( \"'*foo()' finished\" ); \n\n} \n\n\n156 | Chapter 4: Generators \n\n\n\n\nfunction *bar() { \nyield 1; \nyield 2 ; \n\nyield *foo(); // 'yield'-delegation! \n\nyield 5; \n\n} \n\nvar it = bar(); \n\n\nit . next( ) .value; \nit,next( ) .value; \nit,next( ) .value; \n\nit . next( ) .value; \nit,next( ) .value; \n\n\n// 1 \n// 2 \n\n// '*foo()' starting \n\n\n// 3 \n// 4 \n\n// ~*foo()' finished \n// 5","metadata":{"loc":{"lines":{"from":114161,"to":114215}}}}],["1330",{"pageContent":"it . next( ) .value; \nit,next( ) .value; \nit,next( ) .value; \n\nit . next( ) .value; \nit,next( ) .value; \n\n\n// 1 \n// 2 \n\n// '*foo()' starting \n\n\n// 3 \n// 4 \n\n// ~*foo()' finished \n// 5 \n\n\n\nSimilar to a note earlier in this chapter where I \nexplained why I prefer function *foo() .. \ninstead of function* foo() .., I also prefer— \ndiffering from most other documentation on the \ntopic—to say yield *foo() instead of yield* \nfoo( ). The placement of the * is purely stylistic \nand up to your best judgment. But I find the \nconsistency of styling attractive. \n\n\nHow does the yield *foo( ) delegation work? \n\nFirst, calling foo() creates an iterator exactly as we’ve already seen. \nThen, yield * delegates/transfers the iterator instance control (of \nthe present *bar( ) generator) over to this other *foo( ) iterator.","metadata":{"loc":{"lines":{"from":114215,"to":114251}}}}],["1331",{"pageContent":"So, the first two lt.next() calls are controlling *bar(), but when \nwe make the third It.nextQ call, now *foo() starts up, and now \nwe’re controlling *foo() instead of *bar(). That’s why it’s called \ndelegation— *bar( ) delegated its iteration control to *foo(). \n\nAs soon as the It iterator control exhausts the entire *foo() itera¬ \ntor, it automatically returns to controlling *bar(). \n\nSo now back to the previous example with the three sequential Ajax \nrequests: \n\nfunction *foo() { \n\nvar r2 = yield request? \"http://some.url.2\" ); \n\nvar r3 = yield request? \"http://some.url.3/?v=\" + r2 ); \n\n\nGenerator Delegation | 157 \n\n\n\n\nreturn r3; \n\n} \n\nfunction *bar() { \n\nvar rl = yield request( \"http://some.url.1\" ); \n\n// \"delegating\" to '*foo()' via 'yield*' \n\nvar r3 = yield *foo(); \n\nconsole.log( r3 ); \n\n} \n\nrun( bar ); \n\nThe only difference between this snippet and the version used ear¬ \nlier is the use of yield *foo() instead of the previous yield \nrun(foo).","metadata":{"loc":{"lines":{"from":114253,"to":114296}}}}],["1332",{"pageContent":"console.log( r3 ); \n\n} \n\nrun( bar ); \n\nThe only difference between this snippet and the version used ear¬ \nlier is the use of yield *foo() instead of the previous yield \nrun(foo). \n\n\n\nyield * yields iteration control, not generator \ncontrol; when you invoke the *foo() generator, \nyou’re now yield-delegating to its iterator. But \nyou can actually yield-delegate to any iterable; \nyield *[1,2,3] would consume the default \niterator for the [1,2,3] array value. \n\n\nWhy Delegation? \n\nThe purpose of yield-delegation is mostly code organization, and \nin that way is symmetrical with normal function calling. \n\nImagine two modules that respectively provide methods foo() and \nbar(), where bar() calls foo(). The reason the two are separate is \ngenerally because the proper organization of code for the program \ncalls for them to be in separate functions. For example, there may be \ncases where foo() is called standalone, and other places where \nbar() calls foo().","metadata":{"loc":{"lines":{"from":114296,"to":114326}}}}],["1333",{"pageContent":"For all these exact same reasons, keeping generators separate aids in \nprogram readability, maintenance, and debuggability. In that \nrespect, yield * is a syntactic shortcut for manually iterating over \nthe steps of *foo() while inside of *bar(). \n\nSuch a manual approach would be especially complex if the steps in \n*foo() were asynchronous, which is why you’d probably need to \nuse that run( ..) utility to do it. And as we’ve shown, yield *foo() \n\n\n158 | Chapter 4: Generators \n\n\n\n\neliminates the need for a subinstance of the run(..) utility (like \nrun(foo)). \n\nDelegating Messages \n\nYou may wonder how this yield-delegation works not just with \niterator control but with the two-way message passing. Carefully fol¬ \nlow the flow of messages in and out, through the yield-delegation: \n\nfunction *foo() { \n\nconsole.log( \"inside '*foo()':\", yield \"B\" ); \nconsole.log( \"inside ‘*foo()':\", yield \"C\" ); \nreturn \"D\"; \n\n} \n\nfunction *bar() { \n\nconsole.log( \"inside '*bar()':\", yield \"A\" );","metadata":{"loc":{"lines":{"from":114328,"to":114362}}}}],["1334",{"pageContent":"function *foo() { \n\nconsole.log( \"inside '*foo()':\", yield \"B\" ); \nconsole.log( \"inside ‘*foo()':\", yield \"C\" ); \nreturn \"D\"; \n\n} \n\nfunction *bar() { \n\nconsole.log( \"inside '*bar()':\", yield \"A\" ); \n\n// 'yield'-delegation! \n\nconsole.log( \"inside '*bar()':\", yield *foo() ); \nconsole.log( \"inside '*bar()':\", yield \"E\" ); \nreturn \"F\"; \n\n} \n\nvar it = bar(); \n\nconsole.log( \"outside:\", it . next().value ); \n\n// outside: A \n\nconsole.log( \"outside:\", it.next( 1 ). value ); \n\n// inside '*bar()': 1 \n// outside: B \n\nconsole.log( \"outside:\", it.next( 2 ). value ); \n\n// inside '*foo()': 2 \n// outside: C \n\nconsole.log( \"outside:\", it.next( 3 ). value ); \n\n// inside '*foo()': 3 \n// inside '*bar()': D \n// outside: E \n\nconsole.log( \"outside:\", it.next( 4 ). value ); \n\n// inside '*bar()': 4 \n// outside: F \n\n\nGenerator Delegation | 159 \n\n\n\nPay particular attention to the processing steps after the it. next (3) \ncall:","metadata":{"loc":{"lines":{"from":114362,"to":114415}}}}],["1335",{"pageContent":"// inside '*bar()': 4 \n// outside: F \n\n\nGenerator Delegation | 159 \n\n\n\nPay particular attention to the processing steps after the it. next (3) \ncall: \n\n1. The 3 value is passed (through the yield-delegation in *bar()) \ninto the waiting yield \"C\" expression inside of *foo(). \n\n2. *foo() then calls return \"D\", but this value doesn’t get \nreturned all the way back to the outside it. next (3) call. \n\n3. Instead, the \"D\" value is sent as the result of the waiting yield \n*foo() expression inside of *bar() —this yield-delegation \nexpression has essentially been paused while all of *foo() was \nexhausted. So \" D\" ends up inside of * ba r () for it to print out. \n\n4. yield \"E\" is called inside of *bar(), and the \"E\" value is yiel¬ \nded to the outside as the result of the it. next (3) call. \n\nFrom the perspective of the external iterator (it), it doesn’t appear \nany differently between controlling the initial generator or a delega¬ \nted one.","metadata":{"loc":{"lines":{"from":114415,"to":114442}}}}],["1336",{"pageContent":"From the perspective of the external iterator (it), it doesn’t appear \nany differently between controlling the initial generator or a delega¬ \nted one. \n\nIn fact, yield-delegation doesn’t even have to be directed to another \ngenerator; it can just be directed to a non-generator, general itera- \nble. For example: \n\nfunction *bar() { \n\nconsole.log( \"inside '*bar()':\", yield \"A\" ); \n\n// 'yield'-delegation to a non-generator! \n\nconsole.log( \"inside \"*bar()':\", yield *[ \"B\", \"C\", \"D\" ] ); \n\nconsole.log( \"inside '*bar()':\", yield \"E\" ); \n\nreturn \"F\"; \n\n} \n\nvar it = bar(); \n\nconsole.log( \"outside:\", it . next().value ); \n\n// outside: A \n\nconsole.log( \"outside:\", it.next( 1 ). value ); \n\n// inside '*bar()': 1 \n// outside: B \n\nconsole.log( \"outside:\", it.next( 2 ). value ); \n\n// outside: C \n\nconsole.log( \"outside:\", it.next( 3 ). value ); \n\n\n160 | Chapter 4: Generators \n\n\n\n\n// outside: D \n\n\nconsole.log( \"outside:\", lt.next( 4 ). value ); \n\n// inside '*bar()': undefined \n// outside: E","metadata":{"loc":{"lines":{"from":114442,"to":114493}}}}],["1337",{"pageContent":"console.log( \"outside:\", it.next( 3 ). value ); \n\n\n160 | Chapter 4: Generators \n\n\n\n\n// outside: D \n\n\nconsole.log( \"outside:\", lt.next( 4 ). value ); \n\n// inside '*bar()': undefined \n// outside: E \n\nconsole.log( \"outside:\", it.next( 5 ). value ); \n\n// inside '*bar()~: 5 \n// outside: F \n\nNotice the differences in where the messages were received/reported \nbetween this example and the one previous. \n\nMost strikingly, the default array iterator doesn’t care about any \nmessages sent in via next(..) calls, so the values 2, 3, and 4 are \nessentially ignored. Also, because that iterator has no explicit return \nvalue (unlike the previously used *foo()), the yield * expression \ngets an undefined when it finishes. \n\nExceptions Delegated, Too! \n\nIn the same way that yield-delegation transparently passes mes¬ \nsages through in both directions, errors/exceptions also pass in both \ndirections: \n\nfunction *foo() { \ntry { \n\nyield \"B\"; \n\n} \n\ncatch (err) {","metadata":{"loc":{"lines":{"from":114493,"to":114536}}}}],["1338",{"pageContent":"function *foo() { \ntry { \n\nyield \"B\"; \n\n} \n\ncatch (err) { \n\nconsole.log( \"error caught inside '*foo()':\", err ); \n\n1 \n\nyield \"C\"; \nthrow \"D\"; \n\n} \n\nfunction *bar() { \nyield \"A\"; \n\ntry { \n\nyield *foo(); \n\n1 \n\ncatch (err) { \n\nconsole.log( \"error caught inside \"*bar()':\", err ); \n\n1 \n\nyield \"E\"; \n\n\nGenerator Delegation | 161 \n\n\n\n\nyield *baz(); \n\n\n// note: can't get here! \nyield \"G\"; \n\n} \n\nfunction *baz() { \nthrow \"F\"; \n\n} \n\nvar it = bar(); \n\nconsole.log( \"outside:\", it . next().value ); \n\n// outside: A \n\nconsole.log( \"outside:\", it.next( 1 ). value ); \n\n// outside: B \n\nconsole.log( \"outside:\", it.throw( 2 ). value ); \n\n// error caught inside ~*foo()': 2 \n// outside: C \n\nconsole.log( \"outside:\", it.next( 3 ). value ); \n\n// error caught inside '*bar()': D \n// outside: E \n\ntry { \n\nconsole.log( \"outside:\", it.next( 4 ). value ); \n\n} \n\ncatch (err) { \n\nconsole.log( \"error caught outside:\", err ); \n\n} \n\n// error caught outside: F \nSome things to note from this snippet:","metadata":{"loc":{"lines":{"from":114536,"to":114623}}}}],["1339",{"pageContent":"try { \n\nconsole.log( \"outside:\", it.next( 4 ). value ); \n\n} \n\ncatch (err) { \n\nconsole.log( \"error caught outside:\", err ); \n\n} \n\n// error caught outside: F \nSome things to note from this snippet: \n\n1. When we call it.throw(2), it sends the error message 2 into \n*bar(), which delegates that to *foo(), which then catches it \nand handles it gracefully. Then, the yield \"C\" sends \"C\" back \nout as the return value from the it. throw(2) call. \n\n2. The \"D\" value that’s next thrown from inside *foo( ) propagates \nout to *bar(), which catches it and handles it gracefully. Then \nthe yield \"E\" sends \"E\" back out as the return value from the \nit.next(3) call. \n\n3. Next, the exception thrown from *baz() isn’t caught in *bar() \n—though we did catch it outside—so both *baz() and *bar() \nare set to a completed state. After this snippet, you would not be \n\n\n162 | Chapter 4: Generators \n\n\n\nable to get the \"G\" value out with any subsequent next(..) \ncall(s)—they will just return undefined for value.","metadata":{"loc":{"lines":{"from":114623,"to":114658}}}}],["1340",{"pageContent":"162 | Chapter 4: Generators \n\n\n\nable to get the \"G\" value out with any subsequent next(..) \ncall(s)—they will just return undefined for value. \n\n\nDelegating Asynchrony \n\nLet’s finally get back to our earlier yield-delegation example with \nthe multiple sequential Ajax requests: \n\nfunction *foo() { \n\nvar r2 = yield request( \"http://some.url.2\" ); \n\nvar r3 = yield request( \"http://some.url.3/?v=\" + r2 ); \n\nreturn r3; \n\n} \n\nfunction *bar() { \n\nvar rl = yield request( \"http://some.url. 1\" ); \nvar r3 = yield *foo(); \nconsole.log( r3 ); \n\n} \n\nrun( bar ); \n\nInstead of calling yield run(foo) inside of *bar(), we just call \nyield *foo(). \n\nIn the previous version of this example, the Promise mechanism \n(controlled by run(.. )) was used to transport the value from \nreturn r3 in *foo() to the local variable r3 inside *bar(). Now, \nthat value is just returned back directly via the yield * mechanics. \n\nOtherwise, the behavior is pretty much identical. \n\nDelegating Recursion","metadata":{"loc":{"lines":{"from":114658,"to":114701}}}}],["1341",{"pageContent":"Otherwise, the behavior is pretty much identical. \n\nDelegating Recursion \n\nOf course, yield-delegation can keep following as many delegation \nsteps as you wire up. You could even use yield-delegation for \nasync-capable generator recursion —a generator yield-delegating to \nitself: \n\nfunction *foo(val) { \nif (val > 1) { \n\n// generator recursion \nval = yield *foo( val - 1 ); \n\n} \n\n\nGenerator Delegation | 163 \n\n\n\n\nreturn yield request( \"http://some.url/?v=\" + val ); \n\n\nfunction *bar() { \n\nvar rl = yield *foo( 3 ); \nconsole.log( rl ); \n\n\nrun( bar ); \n\n\n\nOur run( ..) utility could have been called with \nrun( foo, 3 ), because it supports additional \nparameters being passed along to the initializa¬ \ntion of the generator. However, we used a \nparameter-free *bar( ) here to highlight the flex¬ \nibility of yield *. \n\n\nWhat processing steps follow from that code? Hang on, this is going \nto be quite intricate to describe in detail: \n\n1. run(bar) starts up the *bar() generator.","metadata":{"loc":{"lines":{"from":114701,"to":114748}}}}],["1342",{"pageContent":"What processing steps follow from that code? Hang on, this is going \nto be quite intricate to describe in detail: \n\n1. run(bar) starts up the *bar() generator. \n\n2. foo(3) creates an iterator for *foo( ..) and passes 3 as its val \nparameter. \n\n3. Because 3 > 1, foo(2) creates another iterator and passes in 2 \nas its val parameter. \n\n4. Because 2 > 1, foo(l) creates yet another iterator and passes in \n1 as its val parameter. \n\n5. 1 > 1 is false, so we next call request(..) with the 1 value, \nand get a promise back for that first Ajax call. \n\n6. That promise is yielded out, which comes back to the *foo(2) \ngenerator instance. \n\n7. The yield * passes that promise back out to the *foo(3) gen¬ \nerator instance. Another yield * passes the promise out to the \n*bar() generator instance. And yet again another yield * \npasses the promise out to the run( ..) utility, which will wait on \nthat promise (for the first Ajax request) to proceed.","metadata":{"loc":{"lines":{"from":114748,"to":114772}}}}],["1343",{"pageContent":"8. When the promise resolves, its fulfillment message is sent to \nresume *bar(), which passes through the yield * into the \n*foo(3) instance, which then passes through the yield * to the \n\n\n164 | Chapter 4: Generators \n\n\n\n\n*foo(2) generator instance, which then passes through the \nyield * to the normal yield that’s waiting in the *foo(3) gen¬ \nerator instance. \n\n9. That first call’s Ajax response is now immediately returned \nfrom the *foo(3) generator instance, which sends that value \nback as the result of the yield * expression in the *foo(2) \ninstance, and assigned to its local val variable. \n\n10. Inside *foo(2), a second Ajax request is made with \nrequest(..), whose promise is yielded back to the *foo(l) \ninstance, and then yield * propagates all the way out to \nrun( ..) (step 7 again). When the promise resolves, the second \nAjax response propagates all the way back into the *foo(2) gen¬ \nerator instance, and is assigned to its local val variable.","metadata":{"loc":{"lines":{"from":114774,"to":114798}}}}],["1344",{"pageContent":"11. Finally, the third Ajax request is made with request(. .), its \npromise goes out to run(..)> and then its resolution value \ncomes all the way back, which is then returned so that it comes \nback to the waiting yield * expression in *bar(). \n\nPhew! A lot of crazy mental juggling, huh? You might want to read \nthrough that a few more times, and then go grab a snack to clear \nyour head! \n\nGenerator Concurrency \n\nAs we discussed in both Chapter 1 and earlier in this chapter, two \nsimultaneously running “processes” can cooperatively interleave \ntheir operations, and many times this can yield (pun intended) very \npowerful asynchrony expressions. \n\nFrankly, our earlier examples of concurrency interleaving of multi¬ \nple generators showed how to make it really confusing. But we hin¬ \nted that there’s places where this capability is quite useful.","metadata":{"loc":{"lines":{"from":114800,"to":114818}}}}],["1345",{"pageContent":"Recall a scenario we looked at in Chapter 1, where two different \nsimultaneous Ajax response handlers needed to coordinate with \neach other to make sure that the data communication was not a race \ncondition. We slotted the responses into the res array like this: \n\nfunction response(data) { \n\nif (data.url == \"http://sone.url. 1\") { \nres[0] = data; \n\n} \n\n\nGenerator Concurrency | 165 \n\n\n\nelse if (data.url == \"http://some.url.2\" ) { \nres[l] = data; \n\n} \n\n} \n\nBut how can we use multiple generators concurrently for this sce¬ \nnario? \n\n// 'request(..) ' is a Promise-aware Ajax utility \n\nvar res = []; \n\n\nfunction *reqData(url) { \nres . push( \n\nyield request( url ) \n\n); \n\n} \n\n\n\nWe’re going to use two instances of the \n*reqData(..) generator here, but there’s no dif¬ \nference to running a single instance of two dif¬ \nferent generators; both approaches are reasoned \nabout identically. We’ll see two different genera¬ \ntors coordinating in just a bit.","metadata":{"loc":{"lines":{"from":114820,"to":114868}}}}],["1346",{"pageContent":"Instead of having to manually sort out res[0] and res[l] assign¬ \nments, we’ll use coordinated ordering so that res.push(. .) prop¬ \nerly slots the values in the expected and predictable order. The \nexpressed logic thus should feel a bit cleaner. \n\nBut how will we actually orchestrate this interaction? First, let’s just \ndo it manually, with Promises: \n\nvar Itl = reqData( \"http://some.url.l\" ); \nvar lt2 = reqData( \"http://some.url.2\" ); \n\nvar pi = itl.next(); \nvar p2 = it2.next(); \n\nPi \n\n.then( functlon(data){ \nltl.next( data ); \nreturn p2; \n\n} ) \n\n.then( functlon(data){ \ntt2.next( data ); \n\n} ); \n\n\n166 | Chapter 4: Generators","metadata":{"loc":{"lines":{"from":114871,"to":114899}}}}],["1347",{"pageContent":"var pi = itl.next(); \nvar p2 = it2.next(); \n\nPi \n\n.then( functlon(data){ \nltl.next( data ); \nreturn p2; \n\n} ) \n\n.then( functlon(data){ \ntt2.next( data ); \n\n} ); \n\n\n166 | Chapter 4: Generators \n\n\n\n\n\n*reqData( .. )’s two instances are both started to make their Ajax \nrequests, then paused with yield. Then we choose to resume the \nfirst instance when pi resolves, and then p2’s resolution will restart \nthe second instance. In this way, we use Promise orchestration to \nensure that res[0] will have the first response and res[l] will have \nthe second response. \n\nBut frankly, this is awfully manual, and it doesn’t really let the gen¬ \nerators orchestrate themselves, which is where the true power can \nlie. Let’s try it a different way: \n\n// ' request(..)' is a Premise-aware Ajax utility \n\nvar res = []; \n\nfunction *reqData(url) { \n\nvar data = yield request( url ); \n\n// transfer control \n\nyield; \n\nres.push( data ); \n\n}","metadata":{"loc":{"lines":{"from":114899,"to":114947}}}}],["1348",{"pageContent":"// ' request(..)' is a Premise-aware Ajax utility \n\nvar res = []; \n\nfunction *reqData(url) { \n\nvar data = yield request( url ); \n\n// transfer control \n\nyield; \n\nres.push( data ); \n\n} \n\nvar itl = reqData( \"http://some.url.l\" ); \nvar it2 = reqData( \"http://sorne.url.2\" ); \n\nvar pi = it.next(); \nvar p2 = it.next(); \n\npl.then( function(data){ \nitl.next( data ); \n\n} ); \n\np2.then( function(data){ \nit2.next( data ); \n\n} ); \n\nPromise. all( [pl,p2] ) \n\n.then( function(){ \nitl.next(); \nit2.next(); \n\n} ); \n\nOK, this is a bit better (though still manual!), because now the two \ninstances of *reqData(.. ) run truly concurrently, and (at least for \nthe first part) independently. \n\n\nGenerator Concurrency | 167","metadata":{"loc":{"lines":{"from":114947,"to":114992}}}}],["1349",{"pageContent":"Generator Concurrency | 167 \n\n\n\n\nIn the previous snippet, the second instance was not given its data \nuntil after the first instance was totally finished. But here, both \ninstances receive their data as soon as their respective responses \ncome back, and then each instance does another yield for control \ntransfer purposes. We then choose what order to resume them in \nthe Promise.all([ .. ]) handler. \n\nWhat may not be as obvious is that this approach hints at an easier \nform for a reusable utility, because of the symmetry. We can do even \nbetter. Let’s imagine using a utility called runAll(.. \n\n// 'request(..)' is a Pronise-aware Ajax utility \n\nvar res = []; \n\nrunAll( \n\nfunction*( ){ \n\nvar pi = request( \"http://some.url.1\" ); \n\n// transfer control \n\nyield; \n\nres.push( yield pi ); \n\n}. \n\nfunction*(){ \n\nvar p2 = request( \"http://some.url.2\" ); \n\n// transfer control \n\nyield; \n\n\n); \n\n\n} \n\n\nres.push( yield p2 );","metadata":{"loc":{"lines":{"from":114992,"to":115041}}}}],["1350",{"pageContent":"// transfer control \n\nyield; \n\nres.push( yield pi ); \n\n}. \n\nfunction*(){ \n\nvar p2 = request( \"http://some.url.2\" ); \n\n// transfer control \n\nyield; \n\n\n); \n\n\n} \n\n\nres.push( yield p2 ); \n\n\n\nWe’re not including a code listing for run \nAll(..) as it is not only long enough to bog \ndown the text, but is an extension of the logic \nwe’ve already implemented in run(..) earlier. \nSo, as a good supplementary exercise for the \nreader, try your hand at evolving the code from \nrun( ..) to work like the imagined runAll(..). \nAlso, my asynquence library provides a previ¬ \nously mentioned runner(..) utility with this \nkind of capability already built in, and will be \ndiscussed in Appendix A of this book. \n\n\nHere’s how the processing inside runAllf..) would operate: \n\n\n168 | Chapter 4: Generators \n\n\n\n\n1. The first generator gets a promise for the first Ajax response \nfrom \"http://some.url.1\", then yields control back to the \nrunAll( ..) utility.","metadata":{"loc":{"lines":{"from":115041,"to":115091}}}}],["1351",{"pageContent":"168 | Chapter 4: Generators \n\n\n\n\n1. The first generator gets a promise for the first Ajax response \nfrom \"http://some.url.1\", then yields control back to the \nrunAll( ..) utility. \n\n2. The second generator runs and does the same for \"http:// \nsome, url.2\", yielding control back to the runAll(.. ) utility. \n\n3. The first generator resumes, and then yields out its promise pi. \nThe runAll( ..) utility does the same in this case as our previ¬ \nous run(. .), in that it waits on that promise to resolve, then \nresumes the same generator (no control transfer!). When pi \nresolves, runAll(. .) resumes the first generator again with that \nresolution value, and then res[0] is given its value. When the \nfirst generator then finishes, that’s an implicit transfer of \ncontrol. \n\n4. The second generator resumes, yields out its promise p2, and \nwaits for it to resolve. Once it does, runAll(. .) resumes the \nsecond generator with that value, and res [ 1 ] is set.","metadata":{"loc":{"lines":{"from":115091,"to":115114}}}}],["1352",{"pageContent":"4. The second generator resumes, yields out its promise p2, and \nwaits for it to resolve. Once it does, runAll(. .) resumes the \nsecond generator with that value, and res [ 1 ] is set. \n\nIn this running example, we use an outer variable called res to store \nthe results of the two different Ajax responses—our concurrency \ncoordination makes that possible. \n\nBut it might be quite helpful to further extend runAll(. .) to pro¬ \nvide an inner variable space for the multiple generator instances to \nshare, such as an empty object we’ll call data below. Also, it could \ntake non-Promise values that are yielded and hand them off to the \nnext generator. \n\nConsider: \n\n// 'request(.is a Promise-aware Ajax utility \nrunAll( \n\nfunction*(data){ \n\ndata.res = []; \n\n// transfer control (and message pass) \n\nvar urtl = yield \"http://some.url.2\" ; \n\nvar pi = request! urll ); // \"http://some.url.1\" \n\n// transfer control \n\nyield; \n\ndata . res . push( yield pi ); \n\n\nGenerator Concurrency | 169 \n\n\n\n\n}.","metadata":{"loc":{"lines":{"from":115114,"to":115155}}}}],["1353",{"pageContent":"var urtl = yield \"http://some.url.2\" ; \n\nvar pi = request! urll ); // \"http://some.url.1\" \n\n// transfer control \n\nyield; \n\ndata . res . push( yield pi ); \n\n\nGenerator Concurrency | 169 \n\n\n\n\n}. \n\nfunction*(data){ \n\n// transfer control (and message pass) \nvar url2 = yield \"http://some.url.1\" ; \n\nvar p2 = request( url2 ); // \"http://sone.url.2\" \n\n// transfer control \n\nyield ; \n\ndata . res.push( yield p2 ); \n\n} \n\n); \n\nIn this formulation, the two generators are not just coordinating \ncontrol transfer, but actually communicating with each other, both \nthrough data.res and the yielded messages that trade urll and \nurl2 values. That’s incredibly powerful! \n\nSuch realization also serves as a conceptual base for a more sophisti¬ \ncated asynchrony technique called Communicating Sequential Pro¬ \ncesses (CSP), which is covered in Appendix B of this book. \n\nThunks","metadata":{"loc":{"lines":{"from":115155,"to":115199}}}}],["1354",{"pageContent":"Thunks \n\nSo far, we’ve made the assumption that yielding a Promise from a \ngenerator—and having that Promise resume the generator via a \nhelper utility like run(..)—was the best possible way to manage \nasynchrony with generators. To be clear, it is. \n\nBut we skipped over another pattern that has some mildly wide¬ \nspread adoption, so in the interest of completeness we’ll take a brief \nlook at it. \n\nIn general computer science, there’s an old pre-JS concept called a \nthunk. Without getting bogged down in the historical nature, a nar¬ \nrow expression of a thunk in JS is a function that—without any \nparameters—is wired to call another function. \n\nIn other words, you wrap a function definition around function call \n—with any parameters it needs—to defer the execution of that call, \nand that wrapping function is a thunk. When you later execute the \nthunk, you end up calling the original function. \n\nFor example: \n\nfunction foo(x,y) { \nreturn x + y; \n\n\n170 | Chapter 4: Generators \n\n\n\n\n}","metadata":{"loc":{"lines":{"from":115199,"to":115231}}}}],["1355",{"pageContent":"For example: \n\nfunction foo(x,y) { \nreturn x + y; \n\n\n170 | Chapter 4: Generators \n\n\n\n\n} \n\n\nfunction fooThunkQ { \nreturn foo( 3, 4 ); \n\n} \n\n// later \n\nconsole.log( fooThunk() ); // 7 \n\nSo, a synchronous thunk is pretty straightforward. But what about \nan async thunk? We can essentially extend the narrow thunk defini¬ \ntion to include it receiving a callback. \n\nConsider: \n\nfunction foo(x,y,cb) { \n\nsetTimeout( function(){ \ncb( x + y ); \n\n}, 1000 ); \n\n} \n\nfunction fooThunk(cb) { \nfoo( 3, 4, cb ); \n\n} \n\n// later \n\nfooThunk( function(sum){ \n\nconsole.log( sum ); // 7 \n\n} ); \n\nAs you can see, fooThunk(. .) expects only a cb(..) parameter, as it \nalready has values 3 and 4 (for x and y, respectively) prespecified \nand ready to pass to foo(..). A thunk is just waiting around \npatiently for the last piece it needs to do its job: the callback. \n\nYou don’t want to make thunks manually, though. So, let’s invent a \nutility that does this wrapping for us. \n\nConsider: \n\nfunction thunkify(fn) {","metadata":{"loc":{"lines":{"from":115231,"to":115292}}}}],["1356",{"pageContent":"You don’t want to make thunks manually, though. So, let’s invent a \nutility that does this wrapping for us. \n\nConsider: \n\nfunction thunkify(fn) { \n\nvar args = [] .slice.call( arguments, 1 ); \nreturn function (cb) { \nargs.push( cb ); \nreturn fn.apply( null, args ); \n\n}; \n\n} \n\nvar fooThunk = thunkify( foo, 3, 4 ); \n\n\nThunks | 171 \n\n\n\n// later \n\n\nfooThunk( function(sum) { \n\nconsole.log ( sum ); // 7 \n\n} ); \n\n\n\nHere we assume that the original (foo(..)) \nfunction signature expects its callback in the last \nposition, with any other parameters coming \nbefore it. This is a pretty ubiquitous standard for \nasync JS function standards. You might call it \n“callback-last style.” If for some reason you had \na need to handle “callback-first style” signatures, \nyou would just make a utility that used \nargs .unshift (..) instead of args.push(..).","metadata":{"loc":{"lines":{"from":115292,"to":115334}}}}],["1357",{"pageContent":"The preceding formulation of thunkify(..) takes both the foo(..) \nfunction reference, and any parameters it needs, and returns back \nthe thunk itself (fooThunkf..)). However, that’s not the typical \napproach you’ll find to thunks in JS. \n\nInstead of thunkify(..) making the thunk itself, typically—if not \nperplexingly—the thunkify(..) utility would produce a function \nthat produces thunks. \n\nUhhhh...yeah. \n\nConsider: \n\nfunction thunkify(fn) { \nreturn function () { \n\nvar args = [] .slice.call( arguments ); \nreturn function(cb) { \nargs.pushf cb ); \nreturn fn.applyf null, args ); \n\n}; \n\n}; \n\n} \n\nThe main difference here is the extra return functionQ { .. } \nlayer. Here’s how its usage differs: \n\nvar whatlsThis = thunkifyf foo ); \nvar fooThunk = whatlsThisf 3, 4 ); \n\n// later \n\n\n172 | Chapter 4: Generators \n\n\n\n\n\n\n\nfooThunk( functlon(sum) { \n\nconsole.log( sum ); // 7 \n\n} );","metadata":{"loc":{"lines":{"from":115337,"to":115385}}}}],["1358",{"pageContent":"var whatlsThis = thunkifyf foo ); \nvar fooThunk = whatlsThisf 3, 4 ); \n\n// later \n\n\n172 | Chapter 4: Generators \n\n\n\n\n\n\n\nfooThunk( functlon(sum) { \n\nconsole.log( sum ); // 7 \n\n} ); \n\nObviously, the big question this snippet implies is what is whatls \nThis properly called? It’s not the thunk, it’s the thing that will pro¬ \nduce thunks from foo(..) calls. It’s kind of like a “factory” for \n“thunks.” There doesn’t seem to be any kind of standard agreement \nfor naming such a thing. \n\nSo, my proposal is “thunkory” (“thunk” + “factory”). So, thun \nkify(..) produces a thunkory, and a thunkory produces thunks. \nThat reasoning is symmetric to my proposal for “promisory” in \nChapter 3: \n\nvar fooThunkory = thunkify( foo ); \n\nvar fooThunkl = fooThunkory( 3, 4 ); \nvar fooThunk2 = fooThunkory( 5, 6 ); \n\n// later \n\n\nfooThunkl( functlon(sum) { \n\nconsole.log( sum ); // 7 \n\n} ); \n\nfooThunk2( function(sum) { \n\nconsole.log( sum ); // 11 \n\n} );","metadata":{"loc":{"lines":{"from":115385,"to":115434}}}}],["1359",{"pageContent":"// later \n\n\nfooThunkl( functlon(sum) { \n\nconsole.log( sum ); // 7 \n\n} ); \n\nfooThunk2( function(sum) { \n\nconsole.log( sum ); // 11 \n\n} ); \n\n\n\nThe running foo( ..) example expects a style of \ncallback that’s not “error-first style.” Of course, \n“error-first style” is much more common. If \nfoo( ..) had some sort of legitimate error- \nproducing expectation, we could change it to \nexpect and use an error-first callback. None of \nthe subsequent thunkify(..) machinery cares \nwhat style of callback is assumed. The only dif¬ \nference in usage would be fooThunkl(func \ntion(err,sum){... \n\n\nExposing the thunkory method—instead of how the earlier thun \nkify( ..) hides this intermediary step—may seem like unnecessary \ncomplication. But in general, it’s quite useful to make thunkories at \nthe beginning of your program to wrap existing API methods, and \n\n\nThunks | 173","metadata":{"loc":{"lines":{"from":115434,"to":115469}}}}],["1360",{"pageContent":"Thunks | 173 \n\n\n\n\nthen be able to pass around and call those thunkories when you \nneed thunks. The two distinct steps preserve a cleaner separation of \ncapability. \n\nTo illustrate: \n\n// cleaner: \n\nvar fooThunkory = thunkify( foo ); \n\nvar fooThunkl = fooThunkory( 3, 4 ); \nvar fooThunk2 = fooThunkory( 5, 6 ); \n\n// instead of: \n\nvar fooThunkl = thunklfy( foo, 3, 4 ); \nvar fooThunk2 = thunktfy( foo, 5, 6 ); \n\nRegardless of whether you like to deal with the thunkories explicitly, \nthe usage of thunks fooThunkl(. .) and fooThunk2( ..) remains the \nsame. \n\ns/promise/thunk/ \n\nSo what’s all this thunk stuff have to do with generators? \n\nComparing thunks to promises generally: they’re not directly inter- \nchangable as they’re not equivalent in behavior. Promises are vastly \nmore capable and trustable than bare thunks. \n\nBut in another sense, they both can be seen as a request for a value, \nwhich may be async in its answering.","metadata":{"loc":{"lines":{"from":115469,"to":115505}}}}],["1361",{"pageContent":"But in another sense, they both can be seen as a request for a value, \nwhich may be async in its answering. \n\nRecall from Chapter 3 that we defined a utility for promisifying a \nfunction, which we called Promise. wrap( ..)—we could have called \nit promisify(. .), too! This Promise-wrapping utility doesn’t pro¬ \nduce Promises; it produces promisories that in turn produce Prom¬ \nises. This is completely symmetric to the thunkories and thunks \npresently being discussed. \n\nTo illustrate the symmetry, let’s first alter the running foo(..) \nexample from earlier to assume an “error-first style” callback: \n\nfunction foo(x,y,cb) { \n\nsetTimeout( function(){ \n\n// assume 'cb(..)' as \"error-first style\" \ncb( null, x + y ); \n\n}, 1000 ); \n\n1 \n\n\n174 | Chapter 4: Generators \n\n\n\n\nNow, we’ll compare using thunkify(..) and promisify(..) (aka \nPromise.wrap(..) from Chapter 3): \n\n// symmetrical: constructing the question asker \nvar fooThunkory = thunkify( foo ); \nvar fooPromisory = promisify( foo );","metadata":{"loc":{"lines":{"from":115505,"to":115540}}}}],["1362",{"pageContent":"// symmetrical: constructing the question asker \nvar fooThunkory = thunkify( foo ); \nvar fooPromisory = promisify( foo ); \n\n// symmetrical: asking the question \nvar fooThunk = fooThunkory( 3, 4 ); \nvar fooPromise = fooPromisory ( 3, 4 ); \n\n// get the thunk answer \n\nfooThunk( function(err,sum){ \nif (err) { \n\nconsole.error( err ); \n\n} \n\nelse { \n\nconsole.log( sum ); // 7 \n\n} \n\n} ); \n\n// get the promise answer \nfooPromise \n. then( \n\nfunction(sum){ \n\nconsole.log( sum ); // 7 \n\n}. \n\nfunction(err){ \n\nconsole. error( err ); \n\n} \n\n); \n\nBoth the thunkory and the promisory are essentially asking a ques¬ \ntion (for a value), and respectively the thunk fooThunk and promise \nfooPromise represent the future answers to that question. Presented \nin that light, the symmetry is clear.","metadata":{"loc":{"lines":{"from":115540,"to":115586}}}}],["1363",{"pageContent":"With that perspective in mind, we can see that generators which \nyieid Promises for asynchrony could instead yield thunks for \nasynchrony. All we’d need is a smarter run(..) utility (like from \nbefore) that can not only look for and wire up to a yielded Promise \nbut also to provide a callback to a yielded thunk. \n\nConsider: \n\nfunction *foo() { \n\nvar val = yield request( \"http://some.url.1\" ); \nconsole.log( val ); \n\n} \n\n\nThunks | 175 \n\n\n\n\nrun( foo ); \n\nIn this example, request(..) could either be a promisory that \nreturns a promise, or a thunkory that returns a thunk. From the per¬ \nspective of what’s going on inside the generator code logic, we don’t \ncare about that implementation detail, which is quite powerful! \n\nSo, request( ..) could be either: \n\n// provisory 'request(..) ' (see Chapter 3) \nvar request = Promise.wrap( ajax ); \n\n// vs. \n\n// thunkory 'request(..)' \nvar request = thunkify( ajax );","metadata":{"loc":{"lines":{"from":115588,"to":115624}}}}],["1364",{"pageContent":"So, request( ..) could be either: \n\n// provisory 'request(..) ' (see Chapter 3) \nvar request = Promise.wrap( ajax ); \n\n// vs. \n\n// thunkory 'request(..)' \nvar request = thunkify( ajax ); \n\nFinally, as a thunk-aware patch to our earlier run(..) utility, we \nwould need logic like this: \n\n// •• \n\n// did we receive a thunk back? \n\nelse if (typeof next.value == \"function\") { \n\nreturn new Promise( function(resolve, reject)! \n\n// call the thunk with an error-first callback \nnext.value! function(err,msg) { \nif (err) { \n\nreject( err ); \n\n} \n\nelse { \n\nresolve! msg ); \n\n} \n\n} ); \n\n} ) \n\n.then( \n\nhandleNext, \n\nfunction handleErr!err) { \nreturn Promise . resolve! \nit. throw! err ) \n\n) \n\n.then! handleResult ); \n\n} \n\n); \n\n} \n\nNow, our generators can either call promisories to yield Promises, \nor call thunkories to yield thunks, and in either case, run(..) \nwould handle that value and use it to wait for the completion to \nresume the generator. \n\n\n176 | Chapter 4: Generators","metadata":{"loc":{"lines":{"from":115624,"to":115687}}}}],["1365",{"pageContent":"176 | Chapter 4: Generators \n\n\n\n\nSymmetry-wise, these two approaches look identical. However, we \nshould point out that’s true only from the perspective of Promises \nor thunks representing the future value continuation of a generator. \n\nFrom the larger perspective, thunks do not in and of themselves \nhave hardly any of the trustability or composability guarantees that \nPromises are designed with. Using a thunk as a stand-in for a \nPromise in this particular generator asynchrony pattern is workable \nbut should be seen as less than ideal when compared to all the bene¬ \nfits that Promises offer (see Chapter 3). \n\nIf you have the option, use yield pr rather than yield th. But \nthere’s nothing wrong with having a run( ..) utility which can han¬ \ndle both value types. \n\n\n\nThe runner(..) utility in my asynquence \nlibrary, which is discussed in Appendix A, han¬ \ndles yields of Promises, thunks and asynquence \nsequences. \n\n\nPre-ES6 Generators","metadata":{"loc":{"lines":{"from":115687,"to":115715}}}}],["1366",{"pageContent":"The runner(..) utility in my asynquence \nlibrary, which is discussed in Appendix A, han¬ \ndles yields of Promises, thunks and asynquence \nsequences. \n\n\nPre-ES6 Generators \n\nYou’re hopefully convinced now that generators are a very impor¬ \ntant addition to the async programming toolbox. But it’s a new syn¬ \ntax in ES6, which means you can’t just polyfill generators like you \ncan Promises (which are just a new API). So what can we do to \nbring generators to our browser JS if we don’t have the luxury of \nignoring pre-ES6 browsers? \n\nFor all new syntax extensions in ES6, there are tools—the most \ncommon term for them is transpilers, for trans-compilers—which \ncan take your ES6 syntax and transform it into equivalent (but obvi¬ \nously uglier!) pre-ES6 code. So, generators can be transpiled into \ncode that will have the same behavior but work in ES5 and below.","metadata":{"loc":{"lines":{"from":115715,"to":115734}}}}],["1367",{"pageContent":"But how? The “magic” of yield doesn’t obviously sound like code \nthat’s easy to transpile. We actually hinted at a solution in our ear¬ \nlier discussion of closure-based iterators. \n\nManual Transformation \n\nBefore we discuss the transpilers, let’s derive how manual transpila- \ntion would work in the case of generators. This isn’t just an aca- \n\n\nPre-ES6 Generators | 177 \n\n\n\n\ndemic exercise, because doing so will actually help further reinforce \nhow they work. \n\nConsider: \n\n// 'request(..is a Promise-aware Ajax utility \n\nfunction *foo(url) { \ntry { \n\nconsole.log( \"requesting:\", url ); \nvar vat = yield request( url ); \nconsole.log( val ); \n\n1 \n\ncatch (err) { \n\nconsole.log( \"Oops:\", err ); \n\nreturn false; \n\n1 \n\n} \n\nvar it = foo( \"http://sone.url.l\" ); \n\nThe first thing to observe is that we’ll still need a normal foo() \nfunction that can be called, and it will still need to return an iterator. \nSo, let’s sketch out the non-generator transformation: \n\nfunction foo(url) { \n\n// ••","metadata":{"loc":{"lines":{"from":115736,"to":115785}}}}],["1368",{"pageContent":"function foo(url) { \n\n// •• \n\n// make and return an iterator \n\nreturn { \n\nnext: function(v) { \n\n// •• \n\n}. \n\nthrow: function(e) { \n\n// \n\n} \n\n}; \n\n} \n\nvar it = foo( \"http://sone.url.l\" ); \n\nThe next thing to observe is that a generator does its “magic” by sus¬ \npending its scope/state, but we can emulate that with function clo¬ \nsure (see the Scope & Closures title of this series). To understand \nhow to write such code, we’ll first annotate different parts of our \ngenerator with state values: \n\n// ' request(..)' is a Promise-aware Ajax utility \n\nfunction *foo(url) { \n\n\n178 | Chapter 4: Generators \n\n\n\n\n// STATE 1 \n\n\ntry { \n\nconsole.log( \"requesting:\", url ); \nvar TMP1 = request( url ); \n\n\n// STATE 2 \n\nvar val = yield TMP1; \nconsole.log( val ); \n\n} \n\ncatch (err) { \n\n// STATE 3 \n\nconsole.log( \"Oops:\", err ); \n\nreturn false; \n\n} \n\n}","metadata":{"loc":{"lines":{"from":115785,"to":115853}}}}],["1369",{"pageContent":"// STATE 2 \n\nvar val = yield TMP1; \nconsole.log( val ); \n\n} \n\ncatch (err) { \n\n// STATE 3 \n\nconsole.log( \"Oops:\", err ); \n\nreturn false; \n\n} \n\n} \n\n\n\nFor more accurate illustration, we split up the \nval = yield request .. statement into two \nparts, using the temporary TMP1 variable. \nrequest( ..) happens in state 1, and the assign¬ \nment of its completion value to val happens in \nstate 2. We’ll get rid of that intermediate TMP1 \nwhen we convert the code to its non-generator \nequivalent. \n\n\nIn other words, 1 is the beginning state, 2 is the state if the \nrequest(. .) succeeds, and 3 is the state if the request(. .) fails. \nYou can probably imagine how any extra yield steps would just be \nencoded as extra states. \n\nGoing back to our transpiled generator, let’s define a variable state \nin the closure we can use to keep track of the state: \n\nfunction foo(url) { \n\n// manage generator state \nvar state; \n\n// •• \n\n}","metadata":{"loc":{"lines":{"from":115853,"to":115899}}}}],["1370",{"pageContent":"function foo(url) { \n\n// manage generator state \nvar state; \n\n// •• \n\n} \n\nNow, let’s define an inner function called process (..) inside the \nclosure which handles each state, using a switch statement: \n\n// ' request(..)' is a Promise-aware Ajax utility \n\nfunction foo(url) { \n\n// manage generator state \n\n\nPre-ES6 Generators | 179 \n\n\n\n\n\nvar state; \n\n\n// generator-wide variable declarations \nvar val; \n\nfunction process(v) { \nswitch (state) { \ncase 1: \n\nconsole.log( \"requesting:\", url ); \nreturn request( url ); \ncase 2: \n\nval = v; \n\nconsole.log( val ); \nreturn; \ncase 3: \n\nvar err = v; \n\nconsole.log( \"Oops:\", err ); \n\nreturn false; \n\n} \n\n} \n\n// ■■ \n\n} \n\nEach state in our generator is represented by its own case in the \nswitch statement. process( ..) will be called each time we need to \nprocess a new state. We’ll come back to how that works in just a \nmoment.","metadata":{"loc":{"lines":{"from":115899,"to":115961}}}}],["1371",{"pageContent":"For any generator-wide variable declarations (val), we move those \nto a var declaration outside of process(..) so they can survive \nmultiple calls to process( ..). But the block scoped err variable is \nonly needed for the 3 state, so we leave it in place. \n\nIn state 1, instead of yield resolve(..), we did return \nresolve(. .). In terminal state 2, there was no explicit return, so we \njust do a return; which is the same as return undefined. In termi¬ \nnal state 3, there was a return false, so we preserve that. \n\nNow we need to define the code in the iterator functions so they call \nprocess( ..) appropriately: \n\nfunction foo(url) { \n\n// manage generator state \nvar state; \n\n// generator-wide variable declarations \nvar val; \n\n\n180 | Chapter 4: Generators \n\n\n\n\nfunction process(v) { \nswitch (state) { \ncase 1: \n\nconsole. log( \"requesting:\", url ); \nreturn request( url ); \ncase 2: \n\nval = v; \n\nconsole. log( val ); \nreturn; \ncase 3: \n\nvar err = v; \n\nconsole. log( \"Oops:\", err );","metadata":{"loc":{"lines":{"from":115963,"to":116006}}}}],["1372",{"pageContent":"console. log( \"requesting:\", url ); \nreturn request( url ); \ncase 2: \n\nval = v; \n\nconsole. log( val ); \nreturn; \ncase 3: \n\nvar err = v; \n\nconsole. log( \"Oops:\", err ); \n\nreturn false; \n\n} \n\n} \n\n// make and return an iterator \n\nreturn { \n\nnext: function(v) { \n\n// initial state \nif (! state) { \nstate = 1; \nreturn { \n\ndone: false, \nvalue: processQ \n\n}; \n\n} \n\n// yield resumed successfully \nelse if (state == 1) { \nstate = 2; \nreturn { \n\ndone: true, \nvalue: process( v ) \n\n}; \n\n} \n\n// generator already completed \n\nelse { \n\nreturn { \n\ndone: true, \nvalue: undefined \n\n}; \n\n} \n\n}. \n\n\"throw\": function(e) { \n\n// the only explicit error handling is in \n// state 1 \nif (state == 1) { \nstate = 3; \nreturn { \n\ndone: true, \nvalue: process( e ) \n\n\nPre-ES6 Generators | 181 \n\n\n\n\n}; \n\n} \n\n// otherwise, an error won't be handled, \n\n// so just throw it right back out \n\nelse { \n\nthrow e; \n\n} \n\n} \n\n}; \n\n} \n\nHow does this code work?","metadata":{"loc":{"lines":{"from":116006,"to":116108}}}}],["1373",{"pageContent":"Pre-ES6 Generators | 181 \n\n\n\n\n}; \n\n} \n\n// otherwise, an error won't be handled, \n\n// so just throw it right back out \n\nelse { \n\nthrow e; \n\n} \n\n} \n\n}; \n\n} \n\nHow does this code work? \n\n1. The first call to the iterator s next() call would move the gener¬ \nator from the unitialized state to state 1, and then call pro \ncess() to handle that state. The return value from \nrequest(..)> which is the promise for the Ajax response, is \nreturned back as the value property from the next() call. \n\n2. If the Ajax request succeeds, the second call to next(..) should \nsend in the Ajax response value, which moves our state to 2. \nprocess(..) is again called (this time with the passed in Ajax \nresponse value), and the value property returned from \nnext(..) will be undefined.","metadata":{"loc":{"lines":{"from":116108,"to":116145}}}}],["1374",{"pageContent":"3. However, if the Ajax request fails, throw(..) should be called \nwith the error, which would move the state from 1 to 3 (instead \nof 2). Again process(..) is called, this time with the error \nvalue. That case returns false, which is set as the value prop¬ \nerty returned from the throw(..) call. \n\nFrom the outside—that is, interacting only with the iterator —this \nfoo(..) normal function works pretty much the same as the \n*foo(..) generator would have worked. So we’ve effectively tran- \nspiled our ES6 generator to pre-ES6 compatibility! \n\nWe could then manually instantiate our generator and control its \niterator—calling var it = foo(\"..\") and it . next(..) and such— \nor better, we could pass it to our previously defined run(..) utility \nas run(foo,\"..\"). \n\nAutomatic Transpilation \n\nThe preceding exercise of manually deriving a transformation of our \nES6 generator to pre-ES6 equivalent teaches us how generators \n\n\n182 | Chapter 4: Generators","metadata":{"loc":{"lines":{"from":116147,"to":116169}}}}],["1375",{"pageContent":"Automatic Transpilation \n\nThe preceding exercise of manually deriving a transformation of our \nES6 generator to pre-ES6 equivalent teaches us how generators \n\n\n182 | Chapter 4: Generators \n\n\n\nwork conceptually. But that transformation was really intricate and \nvery non-portable to other generators in our code. It would be quite \nimpractical to do this work by hand, and would completely obviate \nall the benefit of generators. \n\nBut luckily, several tools already exist that can automatically convert \nES6 generators to things like what we derived in the previous sec¬ \ntion. Not only do they do the heavy lifting work for us, but they also \nhandle several complications that we glossed over. \n\nOne such tool is regenerator, from the smart folks at Facebook. \n\nIf we use regenerator to transpile our previous generator, here’s the \ncode produced (at the time of this writing): \n\n// 'request(..)' is a Promise-aware Ajax utility \n\nvar foo = regeneratorRuntime.mark(function foo(url) { \nvar vat;","metadata":{"loc":{"lines":{"from":116169,"to":116197}}}}],["1376",{"pageContent":"// 'request(..)' is a Promise-aware Ajax utility \n\nvar foo = regeneratorRuntime.mark(function foo(url) { \nvar vat; \n\nreturn regeneratorRuntime.wrap(function foo$(context$l$0) { \nwhile (1) switch (context$l$0.prev = context$l$0.next) { \ncase 0: \n\ncontext$l$0.prev = 0; \nconsole. log( \"requesting:\", url ); \ncontext$l$0.next = 4; \nreturn request( url ); \ncase 4: \n\nval = context$l$0.sent; \nconsole. log( val ); \ncontext$l$0.next = 12; \n\nbreak; \ncase 8: \n\ncontext$l$0.prev = 8; \ncontext$l$0.t0 = context$l$0.catch(0); \nconsole . log( \"Oops:\" , context$l$0 . t0) ; \nreturn context$l$0.abrupt( \"return\" , false); \ncase 12: \ncase \"end\": \n\nreturn context$l$0.stop(); \n\n} \n\n}, foo, this, [[0, 8]]); \n\n}); \n\nThere’s some obvious similarities here to our manual derivation, \nsuch as the switch / case statements, and we even see val pulled \nout of the closure just as we did.","metadata":{"loc":{"lines":{"from":116197,"to":116236}}}}],["1377",{"pageContent":"}); \n\nThere’s some obvious similarities here to our manual derivation, \nsuch as the switch / case statements, and we even see val pulled \nout of the closure just as we did. \n\nOf course, one trade-off is that regenerator’s transpilation requires a \nhelper library regeneratorRuntime that holds all the reusable logic \n\n\nPre-ES6 Generators | 183 \n\n\n\nfor managing a general generator /iterator. A lot of that boilerplate \nlooks different than our version, but even then, the concepts can be \nseen, like with context$l$0.next = 4 keeping track of the next \nstate for the generator. \n\nThe main takeaway is that generators are not restricted to only \nbeing useful in ES6+ environments. Once you understand the con¬ \ncepts, you can employ them throughout your code, and use tools to \ntransform the code to be compatible with older environments.","metadata":{"loc":{"lines":{"from":116236,"to":116258}}}}],["1378",{"pageContent":"This is more work than just using a Promise API polyfill for pre-ES6 \nPromises, but the effort is totally worth it, because generators are so \nmuch better at expressing async flow control in a reason-able, sensi¬ \nble, synchronous-looking, sequential fashion. \n\nOnce you get hooked on generators, you’ll never want to go back to \nthe hell of async spaghetti callbacks! \n\nReview \n\nGenerators are a new ES6 function type that does not run-to- \ncompletion like normal functions. Instead, the generator can be \npaused in mid-completion (entirely preserving its state), and it can \nlater be resumed from where it left off. \n\nThis pause/resume interchange is cooperative rather than preemp¬ \ntive, which means that the generator has the sole capability to pause \nitself, using the yield keyword, and yet the iterator that controls the \ngenerator has the sole capability (via next( ..)) to resume the gen¬ \nerator.","metadata":{"loc":{"lines":{"from":116260,"to":116279}}}}],["1379",{"pageContent":"The yield / next(..) duality is not just a control mechanism, it’s \nactually a two-way message passing mechanism. A yield .. expres¬ \nsion essentially pauses waiting for a value, and the next next(..) \ncall passes a value (or implicit undefined) back to that paused yield \nexpression. \n\nThe key benefit of generators related to async flow control is that \nthe code inside a generator expresses a sequence of steps for the task \nin a naturally sync/sequential fashion. The trick is that we essentially \nhide potential asynchrony behind the yield keyword—moving the \nasynchrony to the code where the generator’s iterator is controlled. \n\n\n184 | Chapter 4: Generators \n\n\n\n\nIn other words, generators preserve a sequential, synchronous, \nblocking code pattern for async code, which lets our brains reason \nabout the code much more naturally, addressing one of the two key \ndrawbacks of callback-based async. \n\n\nReview | 185 \n\n\n\nCHAPTER 5 \n\n\nProgram Performance","metadata":{"loc":{"lines":{"from":116281,"to":116312}}}}],["1380",{"pageContent":"Review | 185 \n\n\n\nCHAPTER 5 \n\n\nProgram Performance \n\n\nThis book so far has been all about how to leverage asynchrony pat¬ \nterns more effectively. But we haven’t directly addressed why asyn¬ \nchrony really matters to JS. The most obvious explicit reason is \nperformance. \n\nFor example, if you have two Ajax requests to make, and they’re \nindependent, but you need to wait on them both to finish before \ndoing the next task, you have two options for modeling that interac¬ \ntion: serial and concurrent. \n\nYou could make the first request and wait to start the second \nrequest until the first finishes. Or, as we’ve seen both with promises \nand generators, you could make both requests in parallel, and ask \nthe gate to wait on both of them before moving on. \n\nClearly, the latter is usually going to be more performant than the \nformer. And better performance generally leads to better user expe¬ \nrience.","metadata":{"loc":{"lines":{"from":116312,"to":116339}}}}],["1381",{"pageContent":"Clearly, the latter is usually going to be more performant than the \nformer. And better performance generally leads to better user expe¬ \nrience. \n\nIt’s even possible that asynchrony (interleaved concurrency) can \nimprove just the perception of performance, even if the overall pro¬ \ngram still takes the same amount of time to complete. User percep¬ \ntion of performance is every bit—if not more!—as important as \nactual measurable performance. \n\nWe want to now move beyond localized asynchrony patterns to talk \nabout some bigger picture performance details at the program level. \n\n\n187 \n\n\n\n\n\n\nYou may be wondering about micro¬ \nperformance issues, like if a++ or ++a is faster. \nWe’ll look at those sorts of performance details \nin Chapter 6. \n\n\nWeb Workers \n\nIf you have processing-intensive tasks but you don’t want them to \nrun on the main thread (which may slow down the browser/UI), \nyou might have wished that JavaScript could operate in a multi¬ \nthreaded manner.","metadata":{"loc":{"lines":{"from":116339,"to":116371}}}}],["1382",{"pageContent":"In Chapter 1, we talked in detail about how JavaScript is single \nthreaded. And that’s still true. But a single thread isn’t the only way \nto organize the execution of your program. \n\nImagine splitting your program into two pieces, and running one of \nthose pieces on the main UI thread, and running the other piece on \nan entirely separate thread. \n\nWhat kinds of concerns would such an architecture bring up? \n\nFor one, you’d want to know if running on a separate thread meant \nthat it ran in parallel (on systems with multiple CPUs/cores) such \nthat a long-running process on that second thread would not block \nthe main program thread. Otherwise, “virtual threading” wouldn’t \nbe of much benefit over what we already have in JS with async con¬ \ncurrency.","metadata":{"loc":{"lines":{"from":116373,"to":116388}}}}],["1383",{"pageContent":"And you’d want to know if these two pieces of the program have \naccess to the same shared scope/resources. If they do, then you have \nall the questions that multithreaded languages (Java, C++, etc.) deal \nwith, such as needing cooperative or preemptive locking (mutexes, \netc.). That’s a lot of extra work, and shouldn’t be undertaken lightly. \n\nAlternatively, you’d want to know how these two pieces could com¬ \nmunicate if they couldn’t share scope/resources. \n\nAll these are great questions to consider as we explore a feature \nadded to the web platform circa HTML5 called Web Workers. This \nis a feature of the browser (aka host environment) and actually has \nalmost nothing to do with the JS language itself. That is, JavaScript \ndoes not currently have any features that support threaded execu¬ \ntion. \n\n\n188 | Chapter 5: Program Performance","metadata":{"loc":{"lines":{"from":116390,"to":116407}}}}],["1384",{"pageContent":"188 | Chapter 5: Program Performance \n\n\n\n\n\nBut an environment like your browser can easily provide multiple \ninstances of the JavaScript engine, each on its own thread, and let \nyou run a different program in each thread. Each of those separate \nthreaded pieces of your program is called a (Web) Worker. This \ntype of parallelism is called task parallelism, as the emphasis is on \nsplitting up chunks of your program to run in parallel. \n\nFrom your main JS program (or another Worker), you instantiate a \nWorker like so: \n\nvar wl = new Worker( \"http://some.url.1/nycootworker.js\" ); \n\nThe URL should point to the location of a JS file (not an HTML \npage!) which is intended to be loaded into a Worker. The browser \nwill then spin up a separate thread and let that file run as an inde¬ \npendent program in that thread.","metadata":{"loc":{"lines":{"from":116407,"to":116428}}}}],["1385",{"pageContent":"The kind of Worker created with such a URL is \ncalled a Dedicated Worker. But instead of pro¬ \nviding a URL to an external file, you can also \ncreate an Inline Worker by providing a Blob \nURL (another HTML5 feature); essentially it’s \nan inline file stored in a single (binary) value. \nHowever, Blobs are beyond the scope of what \nwe’ll discuss here. \n\n\nWorkers do not share any scope or resources with each other or the \nmain program—that would bring all the nightmares of theaded pro¬ \ngramming to the forefront—but instead have a basic event messag¬ \ning mechanism connecting them. \n\nThe wl Worker object is an event listener and trigger, which lets you \nsubscribe to events sent by the Worker as well as send events to the \nWorker. \n\nHere’s how to listen for events (actually, the fixed \"message\" event): \n\nwl.addEventListener( \"message\", function(evt){ \n\n// evt.data \n\n} ); \n\nAnd you can send the \"message\" event to the Worker: \nwl.postMessage( \"something cool to say\" );","metadata":{"loc":{"lines":{"from":116432,"to":116460}}}}],["1386",{"pageContent":"wl.addEventListener( \"message\", function(evt){ \n\n// evt.data \n\n} ); \n\nAnd you can send the \"message\" event to the Worker: \nwl.postMessage( \"something cool to say\" ); \n\n\nWeb Workers | 189 \n\n\n\n\n\nInside the Worker, the messaging is totally symmetrical: \n\n// \"mycoolworker.js\" \n\naddEventListener( \"message\", function (evt){ \n\n// evt.data \n\n} ); \n\npostMessage( \"a really cool reply\" ); \n\nNotice that a dedicated Worker is in a one-to-one relationship with \nthe program that created it. That is, the \"message\" event doesn’t \nneed any disambiguation here, because we’re sure that it could only \nhave come from this one-to-one relationship—it came from either \nthe Worker or the main page.","metadata":{"loc":{"lines":{"from":116460,"to":116492}}}}],["1387",{"pageContent":"Usually the main page application creates the Workers, but a \nWorker can instantiate its own child Worker(s)—known as sub¬ \nworkers—as necessary. Sometimes this is useful to delegate such \ndetails to a sort of “master” Worker that spawns other Workers to \nprocess parts of a task. Unfortunately, at the time of this writing, \nChrome still does not support subworkers, while Firefox does. \n\nTo kill a Worker immediately from the program that created it, call \nterminateQ on the Worker object (like wl in the previous snip¬ \npets). Abruptly terminating a Worker thread does not give it any \nchance to finish up its work or clean up any resources. It’s akin to \nyou closing a browser tab to kill a page. \n\nIf you have two or more pages (or multiple tabs with the same \npage!) in the browser that try to create a Worker from the same file \nURL, those will actually end up as completely separate Workers. \nShortly, we’ll discuss a way to share a Worker. \n\n\n190 | Chapter 5: Program Performance","metadata":{"loc":{"lines":{"from":116494,"to":116513}}}}],["1388",{"pageContent":"190 | Chapter 5: Program Performance \n\n\n\n\n\nIt may seem like a malicious or ignorant JS pro¬ \ngram could easily perform a denial-of-service \nattack on a system by spawning hundreds of \nWorkers, seemingly each with their own thread. \nWhile it’s true that it’s somewhat of a guarantee \nthat a Worker will end up on a separate thread, \nthis guarantee is not unlimited. The system is \nfree to decide how many actual threads/CPUs/ \ncores it really wants to create. There’s no way to \npredict or guarantee how many you’ll have \naccess to, though many people assume it’s at \nleast as many as the number of CPUs/cores \navailable. I think the safest assumption is that \nthere’s at least one other thread besides the main \nUI thread, but that’s about it. \n\n\nWorker Environment","metadata":{"loc":{"lines":{"from":116513,"to":116536}}}}],["1389",{"pageContent":"Worker Environment \n\nInside the Worker, you do not have access to any of the main pro¬ \ngram’s resources. That means you cannot access any of its global \nvariables, nor can you access the page’s DOM or other resources. \nRemember: it’s a totally separate thread. \n\nYou can, however, perform network operations (Ajax, WebSockets) \nand set timers. Also, the Worker has access to its own copy of sev¬ \neral important global variables/features, including navigator, loca \ntion,JSON,and applicationCache. \n\nYou can also load extra JS scripts into your Worker, using import \nScripts(..): \n\n// inside the Worker \ntmportScripts( \"foo.js\", \"bar.js\" ); \n\nThese scripts are loaded synchronously, which means the import \nScripts(..) call will block the rest of the Worker’s execution until \nthe file(s) are finished loading and executing. \n\n\nWeb Workers | 191","metadata":{"loc":{"lines":{"from":116536,"to":116559}}}}],["1390",{"pageContent":"Web Workers | 191 \n\n\n\n\n\nThere have also been some discussions about \nexposing the <canvas> API to Workers, which \ncombined with having canvases be Transfera- \nbles (see “Data Transfer” on page 192), would \nallow Workers to perform more sophisticated \noff-thread graphics processing, which can be \nuseful for high-performance gaming (WebGL) \nand other similar applications. Although this \ndoesn’t exist yet in any browsers, it’s likely to \nhappen in the near future. \n\n\nWhat are some common uses for Web Workers? \n\n• Processing intensive math calculations \n\n• Sorting large data sets \n\n• Data operations (compression, audio analysis, image pixel \nmanipulations, etc.) \n\n• High-traffic network communications \n\n\nData Transfer \n\nYou may notice a common characteristic of most of those uses, \nwhich is that they require a large amount of information to be trans¬ \nferred across the barrier between threads using the event mecha¬ \nnism, perhaps in both directions.","metadata":{"loc":{"lines":{"from":116559,"to":116594}}}}],["1391",{"pageContent":"In the early days of Workers, serializing all data to a string value was \nthe only option. In addition to the speed penalty of the two-way \nserializations, the other major negative was that the data was being \ncopied, which meant a doubling of memory usage (and the subse¬ \nquent churn of garbage collection). \n\nThankfully, we now have a few better options. \n\nIf you pass an object, a structured clone algorithm is used to copy/ \nduplicate the object on the other side. This algorithm is fairly \nsophisticated and can even handle duplicating objects with circular \nreferences. The to-string/from-string performance penalty is not \npaid, but we still have duplication of memory using this approach. \nThere is support for this in IE 10 and above, as well as all the other \nmajor browsers. \n\n\n192 | Chapter 5: Program Performance","metadata":{"loc":{"lines":{"from":116596,"to":116613}}}}],["1392",{"pageContent":"192 | Chapter 5: Program Performance \n\n\n\n\n\nAn even better option, especially for larger data sets, is Transferable \nObjects. What happens is that the object’s ownership is transferred, \nbut the data itself is not moved. Once you transfer away an object to \na Worker, it’s empty or inaccessible in the the originating location— \nthat eliminates the hazards of threaded programming over a shared \nscope. Of course, transfer of ownership can go in both directions. \n\nThere really isn’t much you need to do to opt into a Transferable \nObject; any data structure that implements the Transferable inter¬ \nface will automatically be transferred this way (supported in Firefox \n& Chrome). \n\nFor example, typed arrays like Uint8Array (see the ES6 & Beyond \ntitle of this series) are Transferables. This is how you’d send a Trans¬ \nferable Object using postMessage(..): \n\n// 'f 00 is o 'Uint8Array' for instance \n\npostMessage( foo.buffer, [ foo.buffer ] );","metadata":{"loc":{"lines":{"from":116613,"to":116637}}}}],["1393",{"pageContent":"// 'f 00 is o 'Uint8Array' for instance \n\npostMessage( foo.buffer, [ foo.buffer ] ); \n\nThe first parameter is the raw buffer and the second parameter is a \nlist of what to transfer. \n\nBrowsers that don’t support Transferable Objects simply degrade to \nstructured cloning, which means performance reduction rather than \noutright feature breakage. \n\nShared Workers \n\nIf your site or app allows for loading multiple tabs of the same page \n(a common feature), you may very well want to reduce the resource \nusage of their system by preventing duplicate dedicated Workers; \nthe most common limited resource in this respect is a socket net¬ \nwork connection, as browsers limit the number of simultaneous \nconnections to a single host. Of course, limiting multiple connec¬ \ntions from a client also eases your server resource requirements. \n\nIn this case, creating a single centralized Worker that all the page \ninstances of your site or app can share is quite useful.","metadata":{"loc":{"lines":{"from":116637,"to":116659}}}}],["1394",{"pageContent":"In this case, creating a single centralized Worker that all the page \ninstances of your site or app can share is quite useful. \n\nThat’s called a SharedWorker, which you create like so (support for \nthis is limited to Firefox and Chrome): \n\nvar wl = new SharedWorker( \"http://some.url.1/nycoolworker.js\" ); \n\nBecause a shared Worker can be connected to or from more than \none program instance or page on your site, the Worker needs a way \n\n\nWeb Workers | 193 \n\n\n\nto know which program a message comes from. This unique identi¬ \nfication is called a port —think network socket ports. So the calling \nprogram must use the port object of the Worker for communica¬ \ntion: \n\nwl.port.addEventLlstener( \"message\", handteMessages ); \n\n// •• \n\nwl.port.postMessage( \"something cool\" ); \n\nAlso, the port connection must be initialized, as: \nwl.port.start();","metadata":{"loc":{"lines":{"from":116659,"to":116687}}}}],["1395",{"pageContent":"wl.port.addEventLlstener( \"message\", handteMessages ); \n\n// •• \n\nwl.port.postMessage( \"something cool\" ); \n\nAlso, the port connection must be initialized, as: \nwl.port.start(); \n\nInside the shared Worker, an extra event must be handled: \n\"connect\". This event provides the port object for that particular \nconnection. The most convenient way to keep multiple connections \nseparate is to use closure (see Scope & Closures title of this series) \nover the port, as shown next, with the event listening and transmit¬ \nting for that connection defined inside the handler for the \"con \nnect\" event: \n\n// inside the shared Worker \naddEventListener( \"connect\", function(evt){ \n\n// the assigned port for this connection \nvar port = evt.ports[0]; \n\nport.addEventListener( \"message\", function(evt){ \n\n// •• \n\nport.postMessage( .. ); \n\n// \n\n} ); \n\n// initialize the port connection \nport.startQ; \n\n} ); \n\nOther than that difference, shared and dedicated Workers have the \nsame capabilities and semantics.","metadata":{"loc":{"lines":{"from":116687,"to":116726}}}}],["1396",{"pageContent":"port.postMessage( .. ); \n\n// \n\n} ); \n\n// initialize the port connection \nport.startQ; \n\n} ); \n\nOther than that difference, shared and dedicated Workers have the \nsame capabilities and semantics. \n\n\n\nShared Workers survive the termination of a \nport connection if other port connections are \nstill alive, whereas dedicated Workers are termi¬ \nnated whenever the connection to their initiat¬ \ning program is terminated. \n\n\n194 | Chapter 5: Program Performance \n\n\n\n\n\nPolyfilling Web Workers \n\nWeb Workers are very attractive performance-wise for running JS \nprograms in parallel. However, you may be in a position where your \ncode needs to run in older browsers that lack support. Because \nWorkers are an API and not a syntax, they can be polyfilled, to an \nextent.","metadata":{"loc":{"lines":{"from":116726,"to":116761}}}}],["1397",{"pageContent":"If a browser doesn’t support Workers, there’s simply no way to fake \nmultithreading from the performance perspective. Iframes are com¬ \nmonly thought of to provide a parallel environment, but in all \nmodern browsers they actually run on the same thread as the main \npage, so they’re not sufficient for faking parallelism. \n\nAs we detailed in Chapter 1, JS’s asynchronicity (not parallelism) \ncomes from the event loop queue, so you can force faked Workers \nto be asynchronous using timers (setTimeout( ..), etc.). Then you \njust need to provide a polyfill for the Worker API. There are some \nlisted on the Modernizr GitHub page, but frankly none of them look \ngreat.","metadata":{"loc":{"lines":{"from":116763,"to":116774}}}}],["1398",{"pageContent":"I’ve written a sketch of a polyfill for Worker on this gist. It’s basic, \nbut it should get the job done for simple Worker support, given that \nthe two-way messaging works correctly as well as \"onerror\" han¬ \ndling. You could probably also extend it with more features, such as \nterminate( ) or faked Shared Workers, as you see fit. \n\n\n\nYou can’t fake synchronous blocking, so this \npolyfill just disallows use of import \nScripts( ..). Another option might have been \nto parse and transform the Worker’s code (once \nAjax loaded) to handle rewriting to some asyn¬ \nchronous form of an importScripts( ..) poly¬ \nfill, perhaps with a promise-aware interface. \n\n\nSIMD \n\nSingle instruction, multiple data (SIMD) is a form of data parallel¬ \nism, as contrasted to task parallelism with Web Workers, because \nthe emphasis is not really on program logic chunks being parallel¬ \nized, but rather multiple bits of data being processed in parallel.","metadata":{"loc":{"lines":{"from":116776,"to":116798}}}}],["1399",{"pageContent":"With SIMD, threads don’t provide the parallelism. Instead, modern \nCPUs provide SIMD capability with “vectors” of numbers—think: \n\n\nSIMD | 195 \n\n\n\n\ntype specialized arrays—as well as instructions that can operate in \nparallel across all the numbers; these are low-level operations lever¬ \naging instruction-level parallelism. \n\nThe effort to expose SIMD capability to JavaScript is primarily \nspearheaded by Intel, namely by Mohammad Haghighat (at the time \nof this writing), in cooperation with Firefox and Chrome teams. \nSIMD is on an early standards track with a good chance of making it \ninto a future revision of JavaScript, likely in the ES7 timeframe. \n\nSIMD JavaScript proposes to expose short vector types and APIs to \nJS code, which on those SIMD-enabled systems would map the \noperations directly through to the CPU equivalents, with fallback to \nnon-parallelized operation “shims” on non-SIMD systems.","metadata":{"loc":{"lines":{"from":116800,"to":116822}}}}],["1400",{"pageContent":"The performance benefits for data-intensive applications (signal \nanalysis, matrix operations on graphics, etc.) with such parallel \nmath processing are quite obvious! \n\nEarly proposal forms of the SIMD API at the time of this writing \nlook like this: \n\nvar vl = SIMD.float32x4( 3.14159, 21.0, 32.3, 55.55 ); \nvar v2 = SIMD.float32x4( 2.1, 3.2, 4.3, 5.4 ); \n\nvar v3 = SIMD.tnt32x4( 10, 101, 1001, 10001 ); \nvar v4 = SIMD.tnt32x4( 10, 20, 30, 40 ); \n\nSIMD.float32x4.mul( vl, v2 ); \n\n// [ 6.597339, 67.2, 138.89, 299.97 ] \n\nSIMD.tnt32x4.add( v3, v4 ); \n\n// [ 20, 121, 1031, 10041 ] \n\nShown here are two different vector data types, 32-bit floating-point \nnumbers and 32-bit integer numbers. You can see that these vectors \nare sized exactly to four 32-bit elements, as this matches the SIMD \nvector sizes (128-bit) available in most modern CPUs. It’s also pos¬ \nsible we may see an x8 (or larger!) version of these APIs in the \nfuture.","metadata":{"loc":{"lines":{"from":116824,"to":116850}}}}],["1401",{"pageContent":"Besides mul() and add(), many other operations are likely to be \nincluded, such as sub(), div(), abs(), neg(), sqrtQ, recipro \ncal(), reciprocalSqrtQ (arithmetic), shuffleQ (rearrange vector \nelements), and(), or(), xor(), not() (logical), equalQ, greater \nThanQ, lessThanQ (comparison), shiftLeftQ, shiftRightLogi \n\n\n196 | Chapter 5: Program Performance \n\n\n\n\ncal(), shiftRightArithmeticQ (shifts), fromFloat32x4(), and \nfromInt32x4() (conversions). \n\n\n\nThere’s an official “prollyfiH” (hopeful, expect¬ \nant, future-leaning polyfill) for the SIMD func¬ \ntionality available, which illustrates a lot more of \nthe planned SIMD capability than we’ve illustra¬ \nted in this section. \n\n\nasm.js","metadata":{"loc":{"lines":{"from":116852,"to":116876}}}}],["1402",{"pageContent":"asm.js \n\nasm.js is a label for a highly optimizable subset of the JavaScript lan¬ \nguage. By carefully avoiding certain mechanisms and patterns that \nare hard to optimize (garbage collection, coercion, etc.), asm.js- \nstyled code can be recognized by the JS engine and given special \nattention with aggressive low-level optimizations. \n\nDistinct from other program perfomance mechanisms discussed in \nthis chapter, asm.js isn’t necessarily something that needs to be \nadopted into the JS language specification. There is an asm.js speci¬ \nfication, but it’s mostly for tracking an agreed upon set of candidate \ninferences for optimization rather than a set of requirements of JS \nengines. \n\nThere’s not currently any new syntax being proposed. Instead, \nasm.js suggests ways to recognize existing standard JS syntax that \nconforms to the rules of asm.js and lets engines implement their \nown optimizations accordingly.","metadata":{"loc":{"lines":{"from":116876,"to":116894}}}}],["1403",{"pageContent":"There’s been some disagreement between browser vendors over \nexactly how asm.js should be activated in a program. Early versions \nof the asm.js experiment required a \"use asm\"; pragma (similar to \nstrict mode’s \"use strict\";) to help alert the JS engine to look for \nasm.js optimization opportunities and hints. Others have asserted \nthat asm.js should just be a set of heuristics that engines automati¬ \ncally recognize without the author having to do anything extra, \nmeaning that existing programs could theoretically benefit from \nasm.js-style optimizations without doing anything special. \n\nHow to Optimize with asm.js \n\nThe first thing to understand about asm.js optimizations is around \ntypes and coercion (see the Types & Grammar title of this series). If \n\n\nasm.js | 197","metadata":{"loc":{"lines":{"from":116896,"to":116912}}}}],["1404",{"pageContent":"How to Optimize with asm.js \n\nThe first thing to understand about asm.js optimizations is around \ntypes and coercion (see the Types & Grammar title of this series). If \n\n\nasm.js | 197 \n\n\n\n\nthe JS engine has to track multiple different types of values in a vari¬ \nable through various operations, so that it can handle coercions \nbetween types as necessary, that’s a lot of extra work that keeps the \nprogram optimization suboptimal. \n\n\n\nWe’re going to use asm.js-style code here for \nillustration purposes, but be aware that it’s not \ncommonly expected that you’ll author such code \nby hand, asm.js is more intended to be a compil¬ \nation target from other tools, such as \nEmscripten. It’s of course possible to write your \nown asm.js code, but that’s usually a bad idea \nbecause the code is very low level and managing \nit can be a very time-consuming and error- \nprone process. Nevertheless, there may be cases \nwhere you’d want to hand tweak your code for \nasm.js optimization purposes.","metadata":{"loc":{"lines":{"from":116912,"to":116941}}}}],["1405",{"pageContent":"There are some tricks you can use to hint to an asm.js-aware JS \nengine what the intended type is for variables/operations, so that it \ncan skip these coercion tracking steps. \n\nFor example: \n\nvar a = 42; \n\n// •• \n\n\nvar b = a; \n\nIn that program, the b = a assignment leaves the door open for type \ndivergence in variables. However, it could instead be written as: \n\nvar a = 42; \n\n// •• \n\nvar b = a | 0; \n\nHere, we’ve used the | (binary OR) with value 0, which has no effect \non the value other than to make sure it’s a 32-bit integer. That code \nrun in a normal JS engine works just fine, but when run in an \nasm.js-aware JS engine it can signal that b should always be treated \nas a 32-bit integer, so the coercion tracking can be skipped. \n\n\n198 | Chapter 5: Program Performance \n\n\n\n\n\nSimilarly, the addition operation between two variables can be \nrestricted to a more performant integer addition (instead of floating \npoint): \n\n(a + b) | 0","metadata":{"loc":{"lines":{"from":116944,"to":116983}}}}],["1406",{"pageContent":"Similarly, the addition operation between two variables can be \nrestricted to a more performant integer addition (instead of floating \npoint): \n\n(a + b) | 0 \n\nAgain, the asm.js-aware JS engine can see that hint and infer that \nthe + operation should be 32-bit integer addition because the end \nresult of the whole expression would automatically be 32-bit integer \nconformed anyway. \n\nasm.js Modules \n\nOne of the biggest detractors to performance in JS is around mem¬ \nory allocation, garbage collection, and scope access, asm.js suggests \none of the ways around these issues is to declare a more formalized \nasm.js “module”—do not confuse these with ES6 modules; see the \nES6 & Beyond title of this series.","metadata":{"loc":{"lines":{"from":116983,"to":117000}}}}],["1407",{"pageContent":"For an asm.js module, you need to explicitly pass in a tightly con¬ \nformed namespace—this is referred to in the spec as stdlib, as it \nshould represent standard libraries needed—to import necessary \nsymbols, rather than just using globals via lexical scope. In the base \ncase, the window object is an acceptable stdlib object for asm.js \nmodule purposes, but you could and perhaps should construct an \neven more restricted one. \n\nYou also must declare a heap —which is just a fancy term for a \nreserved spot in memory where variables can already be used \nwithout asking for more memory or releasing previously used mem¬ \nory—and pass that in, so that the asm.js module won’t need to do \nanything that would cause memory churn; it can just use the pre¬ \nreserved space. \n\nA heap is likely a typed ArrayBuffer, such as: \n\nvar heap = new ArrayBuffer( 0x10000 ); // 64k heap","metadata":{"loc":{"lines":{"from":117002,"to":117019}}}}],["1408",{"pageContent":"A heap is likely a typed ArrayBuffer, such as: \n\nvar heap = new ArrayBuffer( 0x10000 ); // 64k heap \n\nUsing that pre-reserved 64k of binary space, an asm.js module can \nstore and retrieve values in that buffer without any memory alloca¬ \ntion or garbage collection penalties. For example, the heap buffer \ncould be used inside the module to back an array of 64-bit float val¬ \nues like this: \n\nvar arr = new Float64Array( heap ); \n\n\nasm.js | 199 \n\n\n\n\nOK, so let’s make a quick, silly example of an asm.js-styled module \nto illustrate how these pieces fit together. Well define a foo(..) \nthat takes a start (x) and end (y) integer for a range, calculates all the \ninner adjacent multiplications of the values in the range, and then \nfinally averages those values together: \n\nfunction fooASM(stdlib,foreign,heap) { \n\n\"use asm\"; \n\nvar arr = new stdlib.Int32Array( heap ); \n\nfunction foo(x,y) { \nx = x | 0; \ny = y | 0; \n\nvar i = 0; \nvar p = 0; \nvar sum = 0; \n\nvar count = ((y|0) - ( x | 0 )) | 0;","metadata":{"loc":{"lines":{"from":117019,"to":117057}}}}],["1409",{"pageContent":"\"use asm\"; \n\nvar arr = new stdlib.Int32Array( heap ); \n\nfunction foo(x,y) { \nx = x | 0; \ny = y | 0; \n\nvar i = 0; \nvar p = 0; \nvar sum = 0; \n\nvar count = ((y|0) - ( x | 0 )) | 0; \n\n// calculate all the inner adjacent multiplications \nfor (i = x | 0; \n\n(i | 0) < (y | 0); \np = (p + 8) | 0, i = (i + 1) | 0 \n\n) { \n\n// store result \n\narr[ p » 3 ] = (i * (i + 1)) | 0; \n\n} \n\n// calculate average of all intermediate values \nfor (i = 0, p = 0; \n\n(i | 0) < (count | 0); \np = (p + 8) | 0, i = (i + 1) | 0 \n\n) { \n\nsum = (sum + arr[ p » 3 ]) | 0; \n\n} \n\nreturn +(sum / count); \n\n} \n\nreturn { \n\nfoo: foo \n\n}; \n\n} \n\nvar heap = new ArrayBuffer( 0x1000 ); \nvar foo = fooASM( window, null, heap ).foo; \n\nfoo( 10, 20 ); // 233 \n\n\n200 | Chapter 5: Program Performance","metadata":{"loc":{"lines":{"from":117057,"to":117115}}}}],["1410",{"pageContent":"} \n\nreturn { \n\nfoo: foo \n\n}; \n\n} \n\nvar heap = new ArrayBuffer( 0x1000 ); \nvar foo = fooASM( window, null, heap ).foo; \n\nfoo( 10, 20 ); // 233 \n\n\n200 | Chapter 5: Program Performance \n\n\n\n\n\nThis asm.js example is hand authored for illus¬ \ntration purposes, so it doesn’t represent the \nsame code that would be produced from a com¬ \npilation tool targeting asm.js. But it does show \nthe typical nature of asm.js code, especially the \ntype hinting and use of the heap buffer for tem¬ \nporary variable storage. \n\n\nThe first call to fooASM(..) is what sets up our asm.js module with \nits heap allocation. The result is a foo(..) function we can call as \nmany times as necessary. Those foo(..) calls should be specially \noptimized by an asm.js-aware JS engine. Importantly, the preceding \ncode is completely standard JS and would run just fine (without spe¬ \ncial optimization) in a non-asm.js engine.","metadata":{"loc":{"lines":{"from":117115,"to":117151}}}}],["1411",{"pageContent":"Obviously, the nature of restrictions that make asm.js code so opti- \nmizable reduces the possible uses for such code significantly, asm.js \nwon’t necessarily be a general optimization set for any given JS pro¬ \ngram. Instead, it’s intended to provide an optimized way of han¬ \ndling specialized tasks such as intensive math operations (e.g., those \nused in graphics processing for games). \n\nReview \n\nThe first four chapters of this book are based on the premise that \nasync coding patterns give you the ability to write more performant \ncode, which is generally a very important improvement. But async \nbehavior only gets you so far, because it’s still fundamentally bound \nto a single event loop thread. \n\nSo in this chapter we’ve covered several program-level mechanisms \nfor improving performance even further.","metadata":{"loc":{"lines":{"from":117153,"to":117169}}}}],["1412",{"pageContent":"So in this chapter we’ve covered several program-level mechanisms \nfor improving performance even further. \n\nWeb Workers let you run a JS file (aka program) in a separate \nthread using async events to message between the threads. They’re \nwonderful for offloading long-running or resource-intensive tasks \nto a different thread, leaving the main UI thread more responsive. \n\nSIMD proposes to map CPU-level parallel math operations to Java¬ \nScript APIs for high-performance data-parallel operations, like \nnumber processing on large data sets. \n\nFinally, asm.js describes a small subset of JavaScript that avoids the \nhard-to-optimize parts of JS (like garbage collection and coercion) \n\n\nReview | 201","metadata":{"loc":{"lines":{"from":117169,"to":117185}}}}],["1413",{"pageContent":"Finally, asm.js describes a small subset of JavaScript that avoids the \nhard-to-optimize parts of JS (like garbage collection and coercion) \n\n\nReview | 201 \n\n\n\n\nand lets the JS engine recognize and run such code through aggres¬ \nsive optimizations, asm.js could be hand authored, but that’s \nextremely tedious and error prone, akin to hand authoring assembly \nlanguage (hence the name). Instead, the main intent is that asm.js \nwould be a good target for cross-compilation from other highly \noptimized program languages—for example, Emscripten transpiling \nC/C++ to JavaScript. \n\nWhile not covered explicitly in this chapter, there are even more \nradical ideas under very early discussion for JavaScript, including \napproximations of direct threaded functionality (not just hidden \nbehind data structure APIs). Whether that happens explicitly, or we \njust see more parallelism creep into JS behind the scenes, the future \nof more optimized program-level performance in JS looks really \npromising.","metadata":{"loc":{"lines":{"from":117185,"to":117208}}}}],["1414",{"pageContent":"202 | Chapter 5: Program Performance \n\n\n\n\nCHAPTER 6 \n\n\nBenchmarking & Tuning \n\n\nAs the first four chapters of this book were all about performance as \na coding pattern (asynchrony and concurrency), and Chapter 5 was \nabout performance at the macro program architecture level, this \nchapter goes after the topic of performance at the micro level, focus¬ \ning on single expressions/statements. \n\nOne of the most common areas of curiosity—indeed, some develop¬ \ners can get quite obsessed about it—is in analyzing and testing vari¬ \nous options for how to write a line or chunk of code, and \ndetermining which one is faster.","metadata":{"loc":{"lines":{"from":117211,"to":117231}}}}],["1415",{"pageContent":"We’re going to look at some of these issues, but it’s important to \nunderstand from the outset that this chapter is not about feeding the \nobsession of micro-performance tuning, like whether some given JS \nengine can run ++a faster than a++. The more important goal of this \nchapter is to figure out what kinds of JS performance matter and \nwhich ones don’t, and how to tell the difference. \n\nBut even before we get there, we need to explore how to most accu¬ \nrately and reliably test JS performance, because there’s tons of mis¬ \nconceptions and myths that have flooded our collective cult \nknowledge base. We’ve got to sift through all that junk to find some \nclarity. \n\nBenchmarking \n\nOK, time to start dispelling some misconceptions. I’d wager the vast \nmajority of JS developers, if asked to benchmark the speed (execu- \n\n\n203 \n\n\n\n\ntion time) of a certain operation, would initially go about it some¬ \nthing like this: \n\nvar start = (new Date()) .getTimeQ; // or 'Date. now() '","metadata":{"loc":{"lines":{"from":117233,"to":117260}}}}],["1416",{"pageContent":"203 \n\n\n\n\ntion time) of a certain operation, would initially go about it some¬ \nthing like this: \n\nvar start = (new Date()) .getTimeQ; // or 'Date. now() ' \n\n// do some operation \n\nvar end = (new DateQ) .getTimeQ; \n\nconsole.log( \"Duration:\", (end - start) ); \n\nRaise your hand if that’s roughly what came to your mind. Yep, I \nthought so. There’s a lot wrong with this approach, but don’t feel \nbad; we’ve all been there. \n\nWhat did that measurement tell you, exactly? Understanding what it \ndoes and doesn’t say about the execution time of the operation in \nquestion is key to learning how to appropriately benchmark perfor¬ \nmance in JavaScript.","metadata":{"loc":{"lines":{"from":117260,"to":117283}}}}],["1417",{"pageContent":"If the duration reported is 0, you may be tempted to believe that it \ntook less than a millisecond. But that’s not very accurate. Some plat¬ \nforms don’t have single millisecond precision, but instead only \nupdate the timer in larger increments. For example, older versions \nof windows (and thus IE) had only 15ms precision, which means the \noperation has to take at least that long for anything other than 0 to \nbe reported! \n\nMoreover, whatever duration is reported, the only thing you really \nknow is that the operation took approximately that long on that \nexact single run. You have near-zero confidence that it will always \nrun at that speed. You have no idea if the engine or system had \nsome sort of interference at that exact moment, and that at other \ntimes the operation could run faster.","metadata":{"loc":{"lines":{"from":117285,"to":117298}}}}],["1418",{"pageContent":"What if the duration reported is 4? Are you more sure it took about \nfour milliseconds? Nope. It might have taken less time, and there \nmay have been some other delay in getting either start or end time- \nstamps. \n\nMore troublingly, you also don’t know that the circumstances of this \noperation test aren’t overly optimistic. It’s possible that the JS \nengine figured out a way to optimize your isolated test case, but in a \nmore real program such optimization would be diluted or impossi¬ \nble, such that the operation would run slower than your test. \n\n\n204 | Chapter 6: Benchmarking& Tuning","metadata":{"loc":{"lines":{"from":117300,"to":117312}}}}],["1419",{"pageContent":"204 | Chapter 6: Benchmarking& Tuning \n\n\n\n\nSo...what do we know? Unfortunately, with those realizations sta¬ \nted, we know very little. Something of such low confidence isn’t \neven remotely good enough to build your determinations on. Your \nbenchmark is basically useless. And worse, it’s dangerous in that it \nimplies false confidence, not just to you but also to others who don’t \nthink critically about the conditions that led to those results. \n\nRepetition \n\n“OK,” you now say, “just put a loop around it so the whole test takes \nlonger.” If you repeat an operation 100 times, and that whole loop \nreportedly takes a total of 137ms, then you can just divide by 100 \nand get an average duration of 1.37ms for each operation, right? \n\nWell, not exactly.","metadata":{"loc":{"lines":{"from":117312,"to":117331}}}}],["1420",{"pageContent":"Well, not exactly. \n\nA straight mathematical average by itself is definitely not sufficient \nfor making judgments about performance which you plan to extrap¬ \nolate to the breadth of your entire application. With a hundred iter¬ \nations, even a couple of outliers (high or low) can skew the average, \nand then when you apply that conclusion repeatedly, you even fur¬ \nther inflate the skew beyond credulity. \n\nInstead of just running for a fixed number of iterations, you can \ninstead choose to run the loop of tests until a certain amount of time \nhas passed. That might be more reliable, but how do you decide how \nlong to run? You might guess that it should be some multiple of \nhow long your operation should take to run once. Wrong.","metadata":{"loc":{"lines":{"from":117331,"to":117344}}}}],["1421",{"pageContent":"Actually, the length of time to repeat across should be based on the \naccuracy of the timer you’re using, specifically to minimize the \nchances of inaccuracy. The less precise your timer, the longer you \nneed to run to make sure you’ve minimized the error percentage. A \n15ms timer is pretty bad for accurate benchmarking; to minimize its \nuncertainty (aka error rate) to less than 1%, you need to run your \neach cycle of test iterations for 750ms. A 1ms timer needs a cycle to \nrun for only 50ms to get the same confidence. \n\nBut then, that’s just a single sample. To be sure you’re factoring out \nthe skew, you’ll want lots of samples to average across. You’ll also \nwant to understand something about just how slow the worst sam¬ \nple is, how fast the best sample is, how far apart those best and \nworse cases were, and so on. You’ll want to know not just a number \n\n\nBenchmarking | 205","metadata":{"loc":{"lines":{"from":117346,"to":117362}}}}],["1422",{"pageContent":"Benchmarking | 205 \n\n\n\n\nthat tells you how fast something ran, but also to have some quanti¬ \nfiable measure of how trustable that number is. \n\nAlso, you probably want to combine these different techniques (as \nwell as others), so that you get the best balance of all the possible \napproaches. \n\nThat’s all the bare minimum just to get started. If you’ve been \napproaching performance benchmarking in a less serious manner \nthan what I just glossed over, well ...you don’t know: proper bench¬ \nmarking. \n\n\nBenchmark.js \n\n\nAny relevant and reliable benchmark should be based on statistically \nsound practices. I am not going to write a chapter on statistics here, \nso I’ll hand wave around some terms: standard deviation, variance, \nmargin of error. If you don’t know what those terms really mean—I \ntook a stats class back in college and I’m still a little fuzzy on them— \nyou are not actually qualified to write your own benchmarking \nlogic.","metadata":{"loc":{"lines":{"from":117362,"to":117389}}}}],["1423",{"pageContent":"Luckily, smart folks like John-David Dalton and Mathias Bynens do \nunderstand these concepts, and wrote a statistically sound bench¬ \nmarking tool called Benchmark.js. So I can end the suspense by sim¬ \nply saying: “just use that tool.” \n\nI won’t repeat their whole documentation for how Benchmark.js \nworks; they have fantastic API docs you should read. Also there are \nsome great writeups on more of the details and methodology here \nand here. \n\nBut just for quick illustration purposes, here’s how you could use \nBenchmark.js to run a quick performance test: \n\nfunction foo() { \n\n// operation(s) to test \n\n} \n\nvar bench = new Benchmark( \n\n\n\"foo test\", \nfoo, \n\n{ \n\n\n// test none \n\n// function to test (just contents) \n\n\n// \n\n} \n\n\n// optional extra options (see docs) \n\n\n); \n\n\n206 | Chapter 6: Benchmarking& Tuning \n\n\n\n\nbench. hz; \nbench.stats. moe; \nbench . stats . variance ; \n\n// \n\n\n// number of operations per second \n// margin of error \n// variance across samples","metadata":{"loc":{"lines":{"from":117391,"to":117449}}}}],["1424",{"pageContent":"206 | Chapter 6: Benchmarking& Tuning \n\n\n\n\nbench. hz; \nbench.stats. moe; \nbench . stats . variance ; \n\n// \n\n\n// number of operations per second \n// margin of error \n// variance across samples \n\n\nThere’s lots more to learn about using Benchmark.js besides this \nglance I’m including here. But the point is that it’s handling all of \nthe complexities of setting up a fair, reliable, and valid performance \nbenchmark for a given piece of JavaScript code. If you’re going to \ntry to test and benchmark your code, this library is the first place \nyou should turn. \n\nWe’re showing here the usage to test a single operation like X, but \nit’s fairly common that you want to compare X to Y. This is easy to \ndo by simply setting up two different tests in a suite (a Benchmark.js \norganizational feature). Then, you run them head-to-head, and \ncompare the statistics to conclude whether X or Y was faster.","metadata":{"loc":{"lines":{"from":117449,"to":117477}}}}],["1425",{"pageContent":"Benchmark.js can of course be used to test JavaScript in a browser \n(see “jsPerf.com” on page 211 later in this chapter), but it can also \nrun in nonbrowser environments (Node.js, etc.). \n\nOne largely untapped potential use-case for Benchmark.js is to use it \nin your Dev or QA environments to run automated performance \nregression tests against critical path parts of your application’s Java¬ \nScript. Similar to how you might run unit test suites before deploy¬ \nment, you can also compare the performance against previous \nbenchmarks to monitor if you are improving or degrading applica¬ \ntion performance. \n\nSetup/Teardown \n\nIn the previous code snippet, we glossed over the “extra options” \n{ .. } object. But there are two options we should discuss: setup \nand teardown. \n\nThese two options let you define functions to be called before and \nafter your test case runs.","metadata":{"loc":{"lines":{"from":117479,"to":117498}}}}],["1426",{"pageContent":"These two options let you define functions to be called before and \nafter your test case runs. \n\nIt’s incredibly important to understand that your setup and tear \ndown code does not run for each test iteration. The best way to think \nabout it is that there’s an outer loop (repeating cycles), and an inner \nloop (repeating test iterations), setup and teardown are run at the \nbeginning and end of each outer loop (aka cycle) iteration, but not \ninside the inner loop. \n\n\nBenchmarking | 207 \n\n\n\nWhy does this matter? Let’s imagine you have a test case that looks \nlike this: \n\na = a + \"w\"; \nb = a.charAt( 1 ); \n\nThen, you set up your test setup as follows: \nvar a = \"x\"; \n\nYour temptation is probably to believe that a is starting out as \"x\" \nfor each test iteration. \n\nBut it’s not! It’s starting a at \"x\" for each test cycle, and then your \nrepeated + \"w\" concatenations will be making a larger and larger a \nvalue, even though you’re only ever accessing the character \"w\" at \nthe 1 position.","metadata":{"loc":{"lines":{"from":117498,"to":117528}}}}],["1427",{"pageContent":"Where this most commonly bites you is when you make side effect \nchanges to something like the DOM, like appending a child element. \nYou may think your parent element is set as empty each time, but \nit’s actually getting lots of elements added, and that can significantly \nsway the results of your tests. \n\nContext Is King \n\nDon’t forget to check the context of a particular performance \nbenchmark, especially a comparison between X and Y tasks. Just \nbecause your test reveals that X is faster than Y doesn’t mean that \nthe conclusion “X is faster than Y” is actually relevant. \n\nFor example, let’s say a performance test reveals that X runs \n10,000,000 operations per second, and Y runs at 8,000,000 opera¬ \ntions per second. You could claim that Y is 20% slower than X, and \nyou’d be mathematically correct, but your assertion doesn’t hold as \nmuch water as you’d think.","metadata":{"loc":{"lines":{"from":117530,"to":117547}}}}],["1428",{"pageContent":"Let’s think about the results more critically: 10,000,000 operations \nper second is 10,000 operations per millisecond, and 10 operations \nper microsecond. In other words, a single operation takes 0.1 micro¬ \nseconds, or 100 nanoseconds. It’s hard to fathom just how small \n100ns is, but for comparison, it’s often cited that the human eye isn’t \ngenerally capable of distinguishing anything less than 100ms, which \nis one million times slower than the 100ns speed of the X operation. \n\n\n208 | Chapter 6: Benchmarking & Tuning \n\n\n\n\nEven recent scientific studies showing that maybe the brain can pro¬ \ncess as quick as 13ms (about 8x faster than previously asserted) \nwould mean that X is still running 125,000 times faster than the \nhuman brain can perceive a distinct thing happening. X is going \nreally, really fast.","metadata":{"loc":{"lines":{"from":117549,"to":117567}}}}],["1429",{"pageContent":"But more importantly, let’s talk about the difference between X and \nY, the 2,000,000 operations per second difference. If X takes 100ns, \nand Y takes 80ns, the difference is 20ns, which in the best case is still \none 650-thousandth of the interval the human brain can perceive. \n\nWhat’s my point? None of this performance difference matters, at \nall! \n\nBut wait, what if this operation is going to happen a whole bunch of \ntimes in a row? Then the difference could add up, right? \n\nOK, so what we’re asking then is, how likely is it that operation X is \ngoing to be run over and over again, one right after the other, and \nthat this has to happen 650,000 times just to get a sliver of a hope \nthe human brain could perceive it. More likely, it’d have to happen \n5,000,000 to 10,000,000 times together in a tight loop to even \napproach relevance.","metadata":{"loc":{"lines":{"from":117569,"to":117585}}}}],["1430",{"pageContent":"While the computer scientist in you might protest that this is possi¬ \nble, the louder voice of realism in you should sanity check just how \nlikely or unlikely that really is. Even if it is relevant in rare occasions, \nit’s irrelevant in most situations. \n\nThe vast majority of your benchmark results on tiny operations— \nlike the ++x vs x++ myth—are just totally bogus for supporting the \nconclusion that X should be favored over Y on a performance basis. \n\nEngine Optimizations \n\nYou simply cannot reliably extrapolate that if X was 10 microsec¬ \nonds faster than Y in your isolated test, that means X is always faster \nthan Y and should always be used. That’s not how performance \nworks. It’s vastly more complicated. \n\nFor example, let’s imagine (purely hypothetical) that you test some \nmicroperformance behavior such as comparing: \n\nvar twelve = \"12\"; \nvar foo = \"foo\"; \n\n\nContext Is King | 209 \n\n\n\n\n// test 1 \n\nvar XI = parselnt( twelve ); \nvar X2 = parselnt( foo ); \n\n// test 2","metadata":{"loc":{"lines":{"from":117587,"to":117620}}}}],["1431",{"pageContent":"var twelve = \"12\"; \nvar foo = \"foo\"; \n\n\nContext Is King | 209 \n\n\n\n\n// test 1 \n\nvar XI = parselnt( twelve ); \nvar X2 = parselnt( foo ); \n\n// test 2 \n\nvar Y1 = Number( twelve ); \nvar Y2 = Number( foo ); \n\nIf you understand what parselnt(..) does compared to Nun \nber( ..), you might intuit that parselnt( ..) potentially has more \nwork to do, especially in the foo case. Or you might intuit that they \nshould have the same amount of work to do in the foo case, as both \nshould be able to stop at the first character, f. \n\nWhich intuition is correct? I honestly don’t know. But I’ll make the \ncase it doesn’t matter what your intuition is. What might the results \nbe when you test it? Again, I’m making up a pure hypothetical here; \nI haven’t actually tried testing this, nor do I care to. \n\nLet’s pretend the test comes back that X and Y are statistically identi¬ \ncal. Have you then confirmed your intuition about the f character \nthing? Nope.","metadata":{"loc":{"lines":{"from":117620,"to":117652}}}}],["1432",{"pageContent":"Let’s pretend the test comes back that X and Y are statistically identi¬ \ncal. Have you then confirmed your intuition about the f character \nthing? Nope. \n\nIt’s possible in our hypothetical that the engine might recognize that \nthe variables twelve and foo are being used in only one place in \neach test, and so it might decide to inline those values. Then it may \nrealize that Number( \"12\" ) can just be replaced by 12. And maybe \nit comes to the same conclusion with parselnt( ..), or maybe not. \n\nOr an engine’s dead-code removal heuristic could kick in, and it \ncould realize that variables X and Y aren’t being used, so declaring \nthem is irrelevant, so it doesn’t end up doing anything at all in either \ntest.","metadata":{"loc":{"lines":{"from":117652,"to":117665}}}}],["1433",{"pageContent":"And all that’s just made with the mindset of assumptions about a \nsingle test run. Modern engines are fantastically more complicated \nthan what we’re intuiting here. They do all sorts of tricks, like trac¬ \ning and tracking how a piece of code behaves over a short period of \ntime, or with a particularly constrained set of inputs. \n\nWhat if the engine optimizes a certain way because of the fixed \ninput, but in your real program you give more varied input and the \noptimization decisions shake out differently (or not at all!)? Or what \nif the engine kicks in optimizations because it sees the code being \nrun tens of thousands of times by the benchmarking utility, but in \nyour real program it will only run a hundred times in near proxim- \n\n\n210 | Chapter 6: Benchmarking& Tuning \n\n\n\nity, and under those conditions the engine determines the optimiza¬ \ntions are not worth it?","metadata":{"loc":{"lines":{"from":117667,"to":117686}}}}],["1434",{"pageContent":"210 | Chapter 6: Benchmarking& Tuning \n\n\n\nity, and under those conditions the engine determines the optimiza¬ \ntions are not worth it? \n\nAnd all those optimizations we just hypothesized about might hap¬ \npen in our constrained test but maybe the engine wouldn’t do them \nin a more complex program (for various reasons). Or it could be \nreversed—the engine might not optimize such trivial code but may \nbe more inclined to optimize it more aggressively when the system \nis already more taxed by a more sophisticated program. \n\nThe point I’m trying to make is that you really don’t know for sure \nexactly what’s going on under the covers. All the guesses and \nhypothesis you can muster don’t amount to anything concrete for \nmaking such decisions. \n\nDoes that mean you can’t really do any useful testing? Definitely \nnot!","metadata":{"loc":{"lines":{"from":117686,"to":117706}}}}],["1435",{"pageContent":"Does that mean you can’t really do any useful testing? Definitely \nnot! \n\nWhat this boils down to is that testing not real code gives you not \nreal results. If possible and practical, you should test actual real, \nnontrivial snippets of your code, and under as best of real condi¬ \ntions as you can actually hope to. Only then will the results you get \nhave a chance to approximate reality. \n\nMicrobenchmarks like ++x vs x++ are so incredibly likely to be \nbogus, we might as well just flatly assume them as such. \n\njsPerf.com \n\nWhile Benchmark.js is useful for testing the performance of your \ncode in whatever JS environment you’re running, it cannot be \nstressed enough that you need to compile test results from lots of \ndifferent environments (desktop browsers, mobile devices, etc.) if \nyou want to have any hope of reliable test conclusions.","metadata":{"loc":{"lines":{"from":117706,"to":117724}}}}],["1436",{"pageContent":"For example, Chrome on a high-end desktop machine is not likely \nto perform anywhere near the same as Chrome mobile on a smart¬ \nphone. And a smartphone with a full battery charge is not likely to \nperform anywhere near the same as a smartphone with 2% battery \nlife left, when the device is starting to power down the radio and \nprocessor. \n\nIf you want to make assertions like “X is faster than Y” in any rea¬ \nsonable sense across more than just a single environment, you’ll \nneed to actually test as many of those real-world environments as \n\n\njsPerf.com | 211 \n\n\n\npossible. Just because Chrome executes some X operation faster \nthan Y doesn’t mean that all browsers do. And of course you also \nprobably will want to cross-reference the results of multiple browser \ntest runs with the demographics of your users.","metadata":{"loc":{"lines":{"from":117726,"to":117745}}}}],["1437",{"pageContent":"There’s an awesome website for this purpose called jsPerf. It uses the \nBenchmark.js library we talked about earlier to run statistically \naccurate and reliable tests, and makes the test on an openly available \nURL that you can pass around to others. \n\nEach time a test is run, the results are collected and persisted with \nthe test, and the cumulative test results are graphed on the page for \nanyone to see. \n\nWhen creating a test on the site, you start out with two test cases to \nfill in, but you can add as many as you need. You also have the abil¬ \nity to set up setup code that is run at the beginning of each test cycle \nand teardown code run at the end of each cycle. \n\n\n\nA trick for doing just one test case (if you’re \nbenchmarking a single approach instead of a \nhead-to-head) is to fill in the second test input \nboxes with placeholder text on first creation, \nthen edit the test and leave the second test \nblank, which will delete it. You can always add \nmore test cases later.","metadata":{"loc":{"lines":{"from":117747,"to":117769}}}}],["1438",{"pageContent":"You can define the initial page setup (importing libraries, defining \nutility helper functions, declaring variables, etc.). There are also \noptions for defining setup and teardown behavior if needed—con¬ \nsult “Setup/Teardown” on page 207. \n\nSanity Check \n\njsPerf is a fantastic resource, but there’s an awful lot of tests pub¬ \nlished that, when you analyze them, are quite flawed or bogus, for a \nvariety of reasons as outlined so far in this chapter. \n\nConsider: \n\n// Case 1 \n\nvar x = []; \n\nfor (var 1=0 ; t<10; 1++) { \nx [ 1 ] = \"x\"; \n\n} \n\n\n212 | Chapter 6: Benchmarking& Tuning \n\n\n\n\n\n// Case 2 \n\nwar x = []; \n\nfor (var 1=0 ; i<10; i++) { \nx[x. length] = \"x\"; \n\n} \n\n// Case 3 \n\nvar x = []; \n\nfor (var 1=0 ; l<10; i++) { \nx.push( \"x\" ); \n\n} \n\nSome observations to ponder about this test scenario:","metadata":{"loc":{"lines":{"from":117772,"to":117819}}}}],["1439",{"pageContent":"for (var 1=0 ; i<10; i++) { \nx[x. length] = \"x\"; \n\n} \n\n// Case 3 \n\nvar x = []; \n\nfor (var 1=0 ; l<10; i++) { \nx.push( \"x\" ); \n\n} \n\nSome observations to ponder about this test scenario: \n\n• It’s extremely common for devs to put their own loops into test \ncases, and they forget that Benchmark.js already does all the \nrepetition you need. There’s a really strong chance that the for \nloops in these cases are totally unnecessary noise. \n\n• The declaring and initializing of x is included in each test case, \npossibly unnecessarily. Recall from earlier that if x = [ ] were in \nthe setup code, it wouldn’t actually be run before each test iter¬ \nation, but instead once at the beginning of each cycle. That \nmeans x would continue growing quite large, not just the size 10 \nimplied by the for loops.","metadata":{"loc":{"lines":{"from":117819,"to":117845}}}}],["1440",{"pageContent":"So is the intent to make sure the tests are constrained only to \nhow the JS engine behaves with very small arrays (size 10)? That \ncould be the intent, but if it is, you have to consider if that’s not \nfocusing far too much on nuanced internal implementation \ndetails. \n\nOn the other hand, does the intent of the test embrace the con¬ \ntext that the arrays will actually be growing quite large? Is the JS \nengines’ behavior with larger arrays relevant and accurate when \ncompared with the intended real-world usage? \n\n• Is the intent to find out how much x. length or x. push(. .) add \nto the performance of the operation to append to the x array? \nOK, that might be a valid thing to test. But then again, push(..) \nis a function call, so of course it’s going to be slower than [.. ] \naccess. Arguably, cases 1 and 2 are fairer than case 3. \n\nHere’s another example that illustrates a common apples-to-oranges \nflaw: \n\n\njsPerf.com | 213 \n\n\n\n\n// Case 1","metadata":{"loc":{"lines":{"from":117847,"to":117873}}}}],["1441",{"pageContent":"Here’s another example that illustrates a common apples-to-oranges \nflaw: \n\n\njsPerf.com | 213 \n\n\n\n\n// Case 1 \n\nvar x = [ \"John\" , \"Albert\" , \"Sue\" , \"Frank\" , \"Bob\" ]; \nx.sort(); \n\n// Case 2 \n\nvar x = [ \"John\" , \"Albert\" , \"Sue\" , \"Frank\" , \"Bob\" ]; \nx.sort( function mySort(a,b){ \nif (a < b) return -1; \nif (a > b) return 1; \nreturn 0; \n\n} ); \n\nHere, the obvious intent is to find out how much slower the custom \nmySort(..) comparator is than the built-in default comparator. But \nby specifying the function mySort(..) as inline function expression, \nyou’ve created an unfair/bogus test. Here, the second case is not \nonly testing a custom user JS function, but it’s also testing creating a \nnew function expression for each iteration. \n\nWould it surprise you to find out that if you run a similar test but \nupdate it to isolate only for creating an inline function expression \nversus using a pre-declared function, the inline function expression \ncreation can be from 2% to 20% slower!?","metadata":{"loc":{"lines":{"from":117873,"to":117907}}}}],["1442",{"pageContent":"Unless your intent with this test is to consider the inline function \nexpression creation cost, a better/fairer test would put mySort(.. )’s \ndeclaration in the page setup—don’t put it in the test setup as that’s \nunnecessary redeclaration for each cycle—and simply reference it by \nname in the test case: x.sort(mySort). \n\nBuilding on the previous example, another pitfall is in opaquely \navoiding or adding extra work to one test case that creates an \napples-to-oranges scenario: \n\n// Case 1 \n\nvar x = [12,-14,0,3,18,0,2.9]; \nx.sort(); \n\n// Case 2 \n\nvar x = [12,-14,0,3,18,0,2.9]; \nx.sort( function mySort(a,b){ \nreturn a - b; \n\n} ); \n\nSetting aside the previously mentioned inline function expression \npitfall, the second case’s mySort(..) works in this case because you \nhave provided it numbers, but would have of course failed with \nstrings. The first case doesn’t throw an error, but it actually behaves \n\n\n214 | Chapter 6: Benchmarking& Tuning","metadata":{"loc":{"lines":{"from":117909,"to":117938}}}}],["1443",{"pageContent":"214 | Chapter 6: Benchmarking& Tuning \n\n\n\ndifferently and has a different outcome! It should be obvious, but a \ndifferent outcome between two test cases almost certainly invalid¬ \nates the entire test! \n\nBut beyond the different outcomes, in this case, the built-in \nsort( .. )’s comparator is actually doing extra work that mySortQ \ndoes not, in that the built-in one coerces the compared values to \nstrings and does lexicographic comparison. The first snippet results \nin [-14, 0, 0, 12, 18, 2.9, 3] while the second snippet results \n(likely more accurately based on intent) in [ -14, 0, 0, 2.9, 3, \n12, 18], \n\nSo that test is unfair because it’s not actually doing the same task \nbetween the cases. Any results you get are bogus. \n\nThese same pitfalls can even be much more subtle: \n\n// Case 1 \n\nvar x = false; \nvar y = x ? 1 : 2; \n\n// Case 2 \n\nvar x; \n\nvar y = x ? 1 : 2;","metadata":{"loc":{"lines":{"from":117938,"to":117968}}}}],["1444",{"pageContent":"These same pitfalls can even be much more subtle: \n\n// Case 1 \n\nvar x = false; \nvar y = x ? 1 : 2; \n\n// Case 2 \n\nvar x; \n\nvar y = x ? 1 : 2; \n\nHere, the intent might be to test the performance impact of the \ncoercion to a Boolean that the ? : operator will do if the x expres¬ \nsion is not already a Boolean (see the Types & Grammar title of this \nbook series). So, you’re apparently OK with the fact that there is \nextra work to do the coercion in the second case. \n\nThe subtle problem? You’re setting x’s value in the first case and not \nsetting it in the other, so you’re actually doing work in the first case \nthat you’re not doing in the second. To eliminate any potential \n(albeit minor) skew, try: \n\n// Case l \n\nvar x = false; \n\nvar y = x ? 1 : 2; \n\n// Case 2 \n\nvar x = undefined; \n\nvar y = x ? 1 : 2; \n\nNow there’s an assignment in both cases, so the thing you want to \ntest—the coercion of x or not—has likely been more accurately iso¬ \nlated and tested. \n\n\njsPerf.com | 215","metadata":{"loc":{"lines":{"from":117968,"to":118009}}}}],["1445",{"pageContent":"var y = x ? 1 : 2; \n\nNow there’s an assignment in both cases, so the thing you want to \ntest—the coercion of x or not—has likely been more accurately iso¬ \nlated and tested. \n\n\njsPerf.com | 215 \n\n\n\nWriting Good Tests \n\nLet me see if I can articulate the bigger point I’m trying to make \nhere. \n\nGood test authoring requires careful analytical thinking about what \ndifferences exist between two test cases and whether the differences \nbetween them are intentional or unintentional. \n\nIntentional differences are of course normal and OK, but it’s too \neasy to create unintentional differences that skew your results. You \nhave to be really, really careful to avoid that skew. Moreover, you \nmay intend a difference but it may not be obvious to other readers \nof your test what your intent was, so they may doubt (or trust!) your \ntest incorrectly. How do you fix that?","metadata":{"loc":{"lines":{"from":118009,"to":118034}}}}],["1446",{"pageContent":"Write better, clearer tests. But also, take the time to document (using \nthe jsPerf.com “Description” field and/or code comments) exactly \nwhat the intent of your test is, even to the nuanced detail. Call out \nthe intentional differences, which will help others and your future \nself to better identify unintentional differences that could be skew¬ \ning the test results. \n\nIsolate things which aren’t relevant to your test by pre-declaring \nthem in the page or test setup settings so they’re outside the timed \nparts of the test. \n\nInstead of trying to narrow in on a tiny snippet of your real code \nand benchmarking just that piece out of context, tests and bench¬ \nmarks are better when they include a larger (while still relevant) \ncontext. Those tests also tend to run slower, which means any dif¬ \nferences you spot are more relevant in context. \n\nMicroperformance","metadata":{"loc":{"lines":{"from":118036,"to":118053}}}}],["1447",{"pageContent":"Microperformance \n\nOK, until now we’ve been dancing around various microperform¬ \nance issues and generally looking disfavorably upon obsessing about \nthem. I want to take just a moment to address them directly. \n\nThe first thing you need to get more comfortable with when think¬ \ning about performance benchmarking your code is that the code \nyou write is not always the code the engine actually runs. We briefly \nlooked at that topic back in Chapter 1 when we discussed statement \nreordering by the compiler, but here we’re going to suggest the \n\n\n216 | Chapter 6: Benchmarking & Tuning \n\n\n\ncompiler can sometimes decide to run different code than you \nwrote, not just in different orders but different in substance. \n\nLet’s consider this piece of code: \n\nvar foo = 41; \n\n(function! ){ \n\n(function( ){ \n\n(function (baz){ \n\nvar bar = foo + baz; \n\n// \n\n})(D; \n\n})(); \n\n})();","metadata":{"loc":{"lines":{"from":118053,"to":118091}}}}],["1448",{"pageContent":"Let’s consider this piece of code: \n\nvar foo = 41; \n\n(function! ){ \n\n(function( ){ \n\n(function (baz){ \n\nvar bar = foo + baz; \n\n// \n\n})(D; \n\n})(); \n\n})(); \n\nYou may think about the foo reference in the innermost function as \nneeding to do a three-level scope lookup. We covered in the Scope & \nClosures title of this series how lexical scope works, and the fact that \nthe compiler generally caches such lookups so that referencing foo \nfrom different scopes doesn’t really cost anything extra. \n\nBut there’s something deeper to consider. What if the compiler real¬ \nizes that foo isn’t referenced anywhere else but that one location, \nand it further notices that the value never is anything except the 41 \nas shown? \n\nIsn’t it quite possible and acceptable that the JS compiler could \ndecide to just remove the foo variable entirely, and inline the value, \nsuch as this: \n\n(function( ){ \n\n(function! ){ \n\n(function(baz){ \n\nvar bar = 41 + baz; \n\n// \n\n})(D; \n\n})(); \n\n})(); \n\n\nMicroperformance | 217","metadata":{"loc":{"lines":{"from":118091,"to":118143}}}}],["1449",{"pageContent":"(function( ){ \n\n(function! ){ \n\n(function(baz){ \n\nvar bar = 41 + baz; \n\n// \n\n})(D; \n\n})(); \n\n})(); \n\n\nMicroperformance | 217 \n\n\n\nOf course, the compiler could probably also do a \nsimilar analysis and rewrite with the baz vari¬ \nable here, too. \n\n\n\nWhen you begin to think about your JS code as being a hint or sug¬ \ngestion to the engine of what to do, rather than a literal require¬ \nment, you realize that a lot of the obsession over discrete syntactic \nminutia is most likely unfounded. \n\nAnother example: \n\nfunction factorlal(n) { \nif (n < 2) return 1 ; \nreturn n * factorial^ n - 1 ); \n\n} \n\nfactorial( 5 ); // 120 \n\nAh, the good of fashioned factorial algorithm! You might assume \nthat the JS engine will run that code mostly as is. And to be honest, \nit might—I’m not really sure.","metadata":{"loc":{"lines":{"from":118143,"to":118187}}}}],["1450",{"pageContent":"} \n\nfactorial( 5 ); // 120 \n\nAh, the good of fashioned factorial algorithm! You might assume \nthat the JS engine will run that code mostly as is. And to be honest, \nit might—I’m not really sure. \n\nBut as an anecdote, the same code expressed in C and compiled with \nadvanced optimizations would result in the compiler realizing that \nthe call factorial(5) can just be replaced with the constant value \n120, eliminating the function and call entirely! \n\nMoreover, some engines have a practice called unrolling recursion, \nwhere it can realize that the recursion you’ve expressed can actually \nbe done more easily (i.e., optimally) with a loop. It’s possible the \npreceding code could be rewritten by a JS engine to run as: \n\nfunction factorlal(n) { \nif (n < 2) return 1; \n\nvar res = 1; \n\nfor (var i=n; i>l; i--) { \nres *= i; \n\n} \n\nreturn res; \n\n} \n\nfactorial( 5 ); // 126 \n\n\n218 | Chapter 6: Benchmarking & Tuning","metadata":{"loc":{"lines":{"from":118187,"to":118222}}}}],["1451",{"pageContent":"function factorlal(n) { \nif (n < 2) return 1; \n\nvar res = 1; \n\nfor (var i=n; i>l; i--) { \nres *= i; \n\n} \n\nreturn res; \n\n} \n\nfactorial( 5 ); // 126 \n\n\n218 | Chapter 6: Benchmarking & Tuning \n\n\n\n\n\nNow, let’s imagine that in the earlier snippet you had been worried \nabout whether n * factorial(n-l) or n *= factorial^ --n) runs \nfaster. Maybe you even did a performance benchmark to try to fig¬ \nure out which was better. But you miss the fact that in the bigger \ncontext, the engine may not run either line of code because it may \nunroll the recursion! \n\nSpeaking of - - , - - n versus n - - is often cited as one of those places \nwhere you can optimize by choosing the - - n version, because theo¬ \nretically it requires less effort down at the assembly level of process¬ \ning.","metadata":{"loc":{"lines":{"from":118222,"to":118255}}}}],["1452",{"pageContent":"That sort of obsession is basically nonsense in modern JavaScript. \nThat’s the kind of thing you should be letting the engine take care \nof. You should write the code that makes the most sense. Compare \nthese three for loops: \n\n// Option 1 \n\nfor (var 1=0 ; t<10; i++) { \nconsole.log( 1 ); \n\n} \n\n// Option 2 \n\nfor (var 1=0 ; i<10; ++i) { \nconsole.log( I ); \n\n} \n\n// Option 3 \n\nfor (var 1=- 1 ; ++l<10; ) { \nconsole.log( I ); \n\n} \n\nEven if you have some theory where the second or third option is \nmore performant than the first option by a tiny bit, which is dubi¬ \nous at best, the third loop is more confusing because you have to \nstart with -1 for i to account for the fact that ++i pre-increment is \nused. And the difference between the first and second options is \nreally quite irrelevant.","metadata":{"loc":{"lines":{"from":118257,"to":118288}}}}],["1453",{"pageContent":"It’s entirely possible that a JS engine may see a place where i++ is \nused and realize that it can safely replace it with the ++i equivalent, \nwhich means your time spent deciding which one to pick was com¬ \npletely wasted and the outcome moot. \n\n\nMicroperformance | 219 \n\n\n\n\nHere’s another common example of silly microperformance obses¬ \nsion: \n\nvar x = [ .. ]; \n\n// Option 1 \n\nfor (var 1=0 ; i < x. length; 1++) { \n\n// •• \n\n} \n\n// Option 2 \n\nfor (var 1=0, len = x. length; i < len; 1++) { \n\n// \n\n} \n\nThe theory here goes that you should cache the length of the x array \nin the variable len, because ostensibly it doesn’t change, to avoid \npaying the price of x.length being consulted for each iteration of \nthe loop. \n\nIf you run performance benchmarks around x.length usage com¬ \npared to caching it in a len variable, you’ll find that while the theory \nsounds nice, in practice any measured differences are statistically \ncompletely irrelevant.","metadata":{"loc":{"lines":{"from":118290,"to":118330}}}}],["1454",{"pageContent":"In fact, in some engines like v8, it can be shown that you could make \nthings slightly worse by pre-caching the length instead of letting the \nengine figure it out for you. Don’t try to outsmart your JavaScript \nengine; you’ll probably lose when it comes to performance opti¬ \nmizations. \n\nNot All Engines Are Alike \n\nThe different JS engines in various browsers can all be “spec compli¬ \nant” while having radically different ways of handling code. The JS \nspecification doesn’t require anything performance related—well, \nexcept for ES6’s “tail call optimization,” covered in “Tail Call Opti¬ \nmization (TCO)” on page 225. \n\nThe engines are free to decide that one operation will receive its \nattention to optimize, perhaps trading off for lesser performance on \nanother operation. It can be very tenuous to find an approach for an \noperation that always runs faster in all browsers.","metadata":{"loc":{"lines":{"from":118332,"to":118349}}}}],["1455",{"pageContent":"There’s a movement among some in the JS dev community, espe¬ \ncially those who work with Node.js, to analyze the specific internal \nimplementation details of the v8 JavaScript engine and make deci- \n\n\n220 | Chapter 6: Benchmarking& Tuning \n\n\n\nsions about writing JS code that is tailored to take best advantage of \nhow v8 works. You can actually achieve a surprisingly high degree \nof performance optimization with such endeavors, so the payoff for \nthe effort can be quite high. \n\nSome commonly cited examples for v8 are as follows: \n\n• Don’t pass the arguments variable from one function to any \nother function, as such leakage slows down the function imple¬ \nmentation. \n\n• Isolate a try.. catch in its own function. Browsers struggle with \noptimizing any function with a try.. catch in it, so moving that \nconstruct to its own function means you contain the de- \noptimization harm while letting the surrounding code be opti- \nmizable.","metadata":{"loc":{"lines":{"from":118351,"to":118375}}}}],["1456",{"pageContent":"But rather than focus on those tips specifically, let’s sanity check the \nv8-only optimization approach in a general sense. \n\nAre you genuinely writing code that needs to run in only one JS \nengine? Even if your code is entirely intended for Node.js right now, \nis the assumption that v8 will always be the used JS engine reliable? \nIs it possible that someday, a few years from now, there will be \nanother server-side JS platform besides Node.js that you choose to \nrun your code on? What if what you optimized for before is now a \nmuch slower way of doing that operation on the new engine? \n\nOr what if your code always stays running on v8 from here on out, \nbut v8 decides at some point to change the way some set of opera¬ \ntions works such that what used to be fast is now slow, and vice \nversa?","metadata":{"loc":{"lines":{"from":118377,"to":118391}}}}],["1457",{"pageContent":"These scenarios aren’t just theoretical, either. It used to be that it \nwas faster to put multiple string values into an array and then call \njoin(\"\") on the array to concatenate the values than to just use + \nconcatenation directly with the values. The historical reason for this \nis nuanced, but it has to do with internal implementation details \nabout how string values were stored and managed in memory. \n\nAs a result, best practice advice at the time disseminated across the \nindustry suggesting developers always use the array joln(..) \napproach. And many followed. \n\n\nMicroperformance | 221 \n\n\n\n\nExcept, somewhere along the way, the JS engines changed \napproaches for internally managing strings, and specifically put in \noptimizations for + concatenation. They didn’t slow down join(..) \nper se, but they put more effort into helping + usage, as it was still \nquite a bit more widespread.","metadata":{"loc":{"lines":{"from":118393,"to":118414}}}}],["1458",{"pageContent":"The practice of standardizing or optimizing \nsome particular approach based mostly on its \nexisting widespread usage is often called (meta¬ \nphorically) “paving the cowpath.” \n\n\nOnce that new approach to handling strings and concatenation took \nhold, unfortunately all the code out in the wild that was using array \njoin( ..) to concatenate strings was then suboptimal.","metadata":{"loc":{"lines":{"from":118418,"to":118426}}}}],["1459",{"pageContent":"Once that new approach to handling strings and concatenation took \nhold, unfortunately all the code out in the wild that was using array \njoin( ..) to concatenate strings was then suboptimal. \n\nAnother example: at one time, the Opera browser differed from \nother browsers in how it handled the boxing/unboxing of primitive \nwrapper objects (see the Types & Grammar title of this series). As \nsuch, their advice to developers was to use a String object instead of \nthe primitive string value if properties like length or methods like \ncharAt( ..) needed to be accessed. This advice may have been cor¬ \nrect for Opera at the time, but it was literally completely opposite for \nother major contemporary browsers, as they had optimizations \nspecifically for the string primitives and not their object wrapper \ncounterparts.","metadata":{"loc":{"lines":{"from":118426,"to":118439}}}}],["1460",{"pageContent":"I think these various gotchas are at least possible, if not likely, for \ncode even today. So I’m very cautious about making wide-ranging \nperformance optimizations in my JS code based purely on engine \nimplementation details, especially if those details are only true of a \nsingle engine. \n\nThe reverse is also something to be wary of: you shouldn’t necessar¬ \nily change a piece of code to work around one engine’s difficulty \nwith running a piece of code in an acceptably performant way. \n\nHistorically, IE has been the brunt of many such frustrations, given \nthat there have been plenty of scenarios in older IE versions where it \nstruggled with some performance aspect that other major browsers \nof the time seemed not to have much trouble with. The string con¬ \ncatenation discussion we just had was actually a real concern back in \nthe IE6 and IE7 days, when it was possible to get better performance \nout of joln( ..) than +. \n\n\n222 | Chapter 6: Benchmarking& Tuning","metadata":{"loc":{"lines":{"from":118441,"to":118460}}}}],["1461",{"pageContent":"222 | Chapter 6: Benchmarking& Tuning \n\n\n\n\nBut it’s troublesome to suggest that just one browser’s trouble with \nperformance is justification for using a code approach that quite \npossibly could be suboptimal in all other browsers. Even if the \nbrowser in question has a large market share for your site’s audi¬ \nence, it may be more practical to write the proper code and rely on \nthe browser to update itself with better optimizations eventually. \n\n“There is nothing more permanent than a temporary hack.” Chan¬ \nces are, the code you write now to work around some performance \nbug will probably outlive the performance bug in the browser itself. \n\nIn the days when a browser only updated once every five years, that \nwas a tougher call to make. But as it stands now, browsers across the \nboard are updated at a much more rapid interval (though obviously \nthe mobile world still lags), and they’re all competing to optimize \nweb features better and better.","metadata":{"loc":{"lines":{"from":118460,"to":118480}}}}],["1462",{"pageContent":"If you run across a case where a browser does have a performance \nwart that others don’t suffer from, make sure to report the issue to \nits developers through whatever means you have available. Most \nbrowsers have open public bug trackers suitable for this purpose. \n\nI’d suggest working around a performance issue \nin a browser only if it is a really drastic show- \nstopper, not just an annoyance or frustration. \n\nAnd I’d be very careful to check that the perfor¬ \nmance hack didn’t have noticeable negative side \neffects in another browser. \n\n\n\nBig Picture \n\nInstead of worrying about all these microperformance nuances, we \nshould instead be looking at big-picture types of optimizations. \n\nHow do you know what’s big picture or not? You have to first \nunderstand if your code is running on a critical path. If it’s not on a \ncritical path, chances are your optimizations are not worth much.","metadata":{"loc":{"lines":{"from":118482,"to":118504}}}}],["1463",{"pageContent":"Ever heard the admonition, “that’s premature optimization!”? It \ncomes from a famous quote from Donald Knuth: “premature opti¬ \nmization is the root of all evil.” Many developers cite this quote to \nsuggest that most optimizations are “premature” and are thus a \nwaste of effort. The truth is, as usual, more nuanced. \n\n\nMicroperformance | 223 \n\n\n\n\n\nHere is Knuth’s quote, in context (emphasis added): \n\nProgrammers waste enormous amounts of time thinking about, or \nworrying about, the speed of noncritical parts of their programs, \nand these attempts at efficiency actually have a strong negative \nimpact when debugging and maintenance are considered. We \nshould forget about small efficiencies, say about 97% of the time: \npremature optimization is the root of all evil. Yet we should not \npass up our opportunities in that critical 3%. \n\n—Computing Surveys 6 \n(December 1974)","metadata":{"loc":{"lines":{"from":118506,"to":118530}}}}],["1464",{"pageContent":"—Computing Surveys 6 \n(December 1974) \n\nI believe it’s a fair paraphrasing to say that Knuth meant: “non¬ \ncritical path optimization is the root of all evil.” So the key is to fig¬ \nure out if your code is on a critical path—if it is, you should \noptimize it! \n\nI’d even go so far as to say this: no amount of time spent optimizing \ncritical paths is wasted, no matter how little is saved; but no amount \nof optimization on noncritical paths is justified, no matter how \nmuch is saved. \n\nIf your code is on a critical path, such as a “hot” piece of code that’s \ngoing to be run over and over again, or in UX critical places where \nusers will notice, like an animation loop or CSS style updates, then \nyou should spare no effort in trying to employ relevant, measurably \nsignificant optimizations.","metadata":{"loc":{"lines":{"from":118530,"to":118547}}}}],["1465",{"pageContent":"For example, consider a critical path animation loop that needs to \ncoerce a string value to a number. There are of course multiple ways \nto do that (see the Types & Grammar title of this series), but which \none, if any, is the fastest? \n\nvar x = \"42\"; // need number '42' \n\n// Option 1: let implicit coercion automatically happen \nvar y = x / 2; \n\n// Option 2: use 'parselnt(..)' \nvar y = parselnt( x, 0 ) / 2; \n\n// Option 3: use 'Number(..)' \nvar y = Number( x ) / 2; \n\n// Option 4: use '+' unary operator \nvar y = +x / 2; \n\n\n224 | Chapter 6: Benchmarking& Tuning \n\n\n\n\n// Option 5: use '/' unary operator \nvar y = (x | 0) / 2; \n\n\n\nI will leave it as an exercise to the reader to set \nup a test if you’re interested in examining the \nminute differences in performance among these \noptions.","metadata":{"loc":{"lines":{"from":118549,"to":118582}}}}],["1466",{"pageContent":"I will leave it as an exercise to the reader to set \nup a test if you’re interested in examining the \nminute differences in performance among these \noptions. \n\n\nWhen considering these different options, as they say, “One of these \nthings is not like the others.” parselnt( ..) does the job, but it also \ndoes a lot more—it parses the string rather than just coercing. You \ncan probably guess, correctly, that parselnt( ..) is a slower option, \nand you should probably avoid it. \n\nOf course, if x can ever be a value that needs parsing, such as \"42px\" \n(like from a CSS style lookup), then parselnt( ..) really is the only \nsuitable option!","metadata":{"loc":{"lines":{"from":118582,"to":118596}}}}],["1467",{"pageContent":"Of course, if x can ever be a value that needs parsing, such as \"42px\" \n(like from a CSS style lookup), then parselnt( ..) really is the only \nsuitable option! \n\nNumber(..) is also a function call. From a behavioral perspective, \nit’s identical to the + unary operator option, but it may in fact be a \nlittle slower, requiring more machinery to execute the function. Of \ncourse, it’s also possible that the JS engine recognizes this behavioral \nsymmetry and just handles the inlining of Number(. .)’s behavior \n(aka +x) for you! \n\nBut remember, obsessing about +x versus x | 0 is in most cases a \nwaste of effort. This is a microperformance issue, and one that you \nshouldn’t let dictate/degrade the readability of your program. \n\nWhile performance is very important in critical paths of your pro¬ \ngram, it’s not the only factor. Among several options that are \nroughly similar in performance, readability should be another \nimportant concern. \n\nTail Call Optimization (TCO)","metadata":{"loc":{"lines":{"from":118596,"to":118616}}}}],["1468",{"pageContent":"Tail Call Optimization (TCO) \n\nAs we briefly mentioned earlier, ES6 includes a specific requirement \nthat ventures into the world of performance. It’s related to a specific \nform of optimization that can occur with function calls: tail call \noptimization. \n\n\nTail Call Optimization (TCO) | 225 \n\n\n\n\n\nBriefly, a tail call is a function call that appears at the “tail” of \nanother function, such that after the call finishes, there’s nothing left \nto do (except perhaps return its result value). \n\nFor example, here’s a nonrecursive setup with tail calls: \n\nfunction foo(x) { \nreturn x; \n\n} \n\nfunction bar(y) { \n\nreturn foo( y + 1 ); // tail call \n\n} \n\nfunction baz() { \n\nreturn 1 + bar( 40 ); // not tail call \n\n} \n\nbaz(); // 42","metadata":{"loc":{"lines":{"from":118616,"to":118653}}}}],["1469",{"pageContent":"function foo(x) { \nreturn x; \n\n} \n\nfunction bar(y) { \n\nreturn foo( y + 1 ); // tail call \n\n} \n\nfunction baz() { \n\nreturn 1 + bar( 40 ); // not tail call \n\n} \n\nbaz(); // 42 \n\nfoo(y+l) is a tail call in bar(..) because after foo(..) finishes, \nbar( ..) is also finished and just needs to return the result of the \nfoo(..) call. However, bar(40) is not a tail call because after it \ncompletes, its result value must be added to 1 before baz() can \nreturn it. \n\nWithout getting into too much nitty-gritty detail, calling a new \nfunction requires an extra amount of reserved memory to manage \nthe call stack, called a stack frame. So the preceding snippet would \ngenerally require a stack frame for each of baz(), bar(..)> and \nfoo(..) all at the same time.","metadata":{"loc":{"lines":{"from":118653,"to":118682}}}}],["1470",{"pageContent":"However, if a TCO-capable engine can realize that the foo(y+l) call \nis in tail position meaning bar(. .) is basically complete, then when \ncalling foo(..), it doesn’t need to create a new stack frame, but can \ninstead reuse the existing stack frame from bar( ..). That’s not only \nfaster, but it also uses less memory. \n\nThat sort of optimization isn’t a big deal in a simple snippet, but it \nbecomes a much bigger deal when dealing with recursion, especially \nif the recursion could have resulted in hundreds or thousands of \nstack frames. With TCO, the engine can perform all those calls with \na single stack frame! \n\nRecursion is a hairy topic in JS because without TCO, engines have \nhad to implement arbitrary (and different!) limits to how deep they \nwill let the recursion stack get before they stop it, to prevent running \n\n\n226 | Chapter 6: Benchmarking& Tuning","metadata":{"loc":{"lines":{"from":118684,"to":118701}}}}],["1471",{"pageContent":"226 | Chapter 6: Benchmarking& Tuning \n\n\n\nout of memory. With TCO, recursive functions with tail position \ncalls can essentially run unbounded, because there’s never any extra \nusage of memory! \n\nConsider that recursive facto rial (..) from before, but rewritten \nto make it TCO-friendly: \n\nfunction factorial(n) { \nfunction fact(n,res) { \n\nif (n < 2) return res; \n\nreturn fact( n - 1, n * res ); \n\n} \n\nreturn fact( n, 1 ); \n\n} \n\nfactorial( 5 ); // 120 \n\nThis version of factorial(. .) is still recursive, but it’s also opti- \nmizable with TCO, because both inner fact(. .) calls are in tail \nposition.","metadata":{"loc":{"lines":{"from":118701,"to":118729}}}}],["1472",{"pageContent":"} \n\nfactorial( 5 ); // 120 \n\nThis version of factorial(. .) is still recursive, but it’s also opti- \nmizable with TCO, because both inner fact(. .) calls are in tail \nposition. \n\n\n\nIt’s important to note that TCO applies only if \nthere’s actually a tail call. If you write recursive \nfunctions without tail calls, the performance will \nstill fall back to normal stack frame allocation, \nand the engines’ limits on such recursive call \nstacks will still apply. Many recursive functions \ncan be rewritten as we just showed with facto \nrial( ..), but it takes careful attention to detail. \n\n\nOne reason that ES6 requires engines to implement TCO rather \nthan leaving it up to their discretion is because the lack of TCO \nactually tends to reduce the chances that certain algorithms will be \nimplemented in JS using recursion, for fear of the call stack limits.","metadata":{"loc":{"lines":{"from":118729,"to":118752}}}}],["1473",{"pageContent":"If the lack of TCO in the engine would just gracefully degrade to \nslower performance in all cases, it wouldn’t have been something \nthat ES6 needed to require. But because the lack of TCO can actually \nmake certain programs impractical, it’s more an important feature \nof the language than just a hidden implementation detail. \n\nES6 guarantees that from now on, JS developers will be able to rely \non this optimization across all ES6+ compliant browsers. That’s a \nwin for JS performance! \n\n\nTail Call Optimization (TCO) | 227 \n\n\n\n\nReview \n\nEffectively benchmarking performance of a piece of code, especially \nto compare it to another option for that same code to see which \napproach is faster, requires careful attention to detail.","metadata":{"loc":{"lines":{"from":118754,"to":118774}}}}],["1474",{"pageContent":"Effectively benchmarking performance of a piece of code, especially \nto compare it to another option for that same code to see which \napproach is faster, requires careful attention to detail. \n\nRather than rolling your own statistically valid benchmarking logic, \njust use the Benchmark.js library, which does that for you. But be \ncareful about how you author tests, because it’s far too easy to con¬ \nstruct a test that seems valid but that’s actually flawed—even tiny \ndifferences can skew the results to be completely unreliable. \n\nIt’s important to get as many test results from as many different \nenvironments as possible to eliminate hardware/device bias. \njsPerf.com is a fantastic website for crowdsourcing performance \nbenchmark test runs.","metadata":{"loc":{"lines":{"from":118774,"to":118787}}}}],["1475",{"pageContent":"Many common performance tests unfortunately obsess about irrele¬ \nvant microperformance details like x++ versus ++x. Writing good \ntests means understanding how to focus on big picture concerns, \nlike optimizing on a critical path, and avoiding falling into traps like \ndifferent JS engines’ implementation details. \n\nTail call optimization (TCO) is a required optimization as of ES6 \nthat will make some recursive patterns practical in JS where they \nwould have been impossible otherwise. TCO allows a function call \nin the tail position of another function to execute without needing \nany extra resources, which means the engine no longer needs to \nplace arbitrary restrictions on call stack depth for recursive algo¬ \nrithms. \n\n\n228 | Chapter 0: Benchmarking & Tuning \n\n\n\n\nAPPENDIX A \n\n\nasynquence Library","metadata":{"loc":{"lines":{"from":118789,"to":118812}}}}],["1476",{"pageContent":"228 | Chapter 0: Benchmarking & Tuning \n\n\n\n\nAPPENDIX A \n\n\nasynquence Library \n\n\nChapters 1 and 2 went into quite a bit of detail about typical asyn¬ \nchronous programming patterns and how they’re commonly solved \nwith callbacks. But we also saw why callbacks are fatally limited in \ncapability, which led us to Chapters 3 and 4, with Promises and gen¬ \nerators offering a much more solid, trustable, and reason-able base \nto build your asynchrony on. \n\nI referenced my own asynchronous library asynquence — “async” + \n“sequence” = “asynquence”—several times in this book, and I want \nto now briefly explain how it works and why its unique design is \nimportant and helpful. \n\nIn Appendix B, we’ll explore some advanced async patterns, but \nyou’ll probably want a library to make those palatable enough to be \nuseful. We’ll use asynquence to express those patterns, so you’ll want \nto spend a little time here getting to know the library first.","metadata":{"loc":{"lines":{"from":118812,"to":118838}}}}],["1477",{"pageContent":"asynquence is obviously not the only option for good async coding; \ncertainly there are many great libraries in this space. But asynquence \nprovides a unique perspective by combining the best of all these pat¬ \nterns into a single library, and moreover is built on a single basic \nabstraction: the (async) sequence. \n\nMy premise is that sophisticated JS programs often need bits and \npieces of various different asynchronous patterns woven together, \nand this is usually left entirely up to each developer to figure out. \nInstead of having to bring in two or more different async libraries \nthat focus on different aspects of asynchrony, asynquence unifies \n\n\n229 \n\n\n\n\nthem into variated sequence steps, with just one core library to learn \nand deploy. \n\nI believe the value is strong enough with asynquence to make async \nflow control programming with Promise-style semantics super easy \nto accomplish, so that’s why we’ll exclusively focus on that library \nhere.","metadata":{"loc":{"lines":{"from":118840,"to":118864}}}}],["1478",{"pageContent":"To begin, I’ll explain the design principles behind asynquence, and \nthen we’ll illustrate how its API works with code examples. \n\nSequences and Abstraction Design \n\nUnderstanding asynquence begins with understanding a fundamen¬ \ntal abstraction: any series of steps for a task, whether they separately \nare synchronous or asynchronous, can be collectively thought of as a \nsequence. In other words, a sequence is a container that represents a \ntask, and is comprised of individual (potentially async) steps to \ncomplete that task. \n\nEach step in the sequence is controlled under the covers by a \nPromise (see Chapter 3). That is, every step you add to a sequence \nimplicitly creates a Promise that is wired to the previous end of the \nsequence. Because of the semantics of Promises, every single step \nadvancement in a sequence is asynchronous, even if you synchro¬ \nnously complete the step.","metadata":{"loc":{"lines":{"from":118866,"to":118883}}}}],["1479",{"pageContent":"Moreover, a sequence will always proceed linearly from step to step, \nmeaning that step 2 always comes after step 1 finishes, and so on. \n\nOf course, a new sequence can be forked off an existing sequence, \nmeaning the fork only occurs once the main sequence reaches that \npoint in the flow. Sequences can also be combined in various ways, \nincluding having one sequence subsumed by another sequence at a \nparticular point in the flow. \n\nA sequence is kind of like a Promise chain. However, with Promise \nchains, there is no “handle” to grab that references the entire chain. \nWhichever Promise you have a reference to only represents the cur¬ \nrent step in the chain plus any other steps hanging off it. Essentially, \nyou cannot hold a reference to a Promise chain unless you hold a \nreference to the first Promise in the chain. \n\nThere are many cases where it turns out to be quite useful to have a \nhandle that references the entire sequence collectively. The most","metadata":{"loc":{"lines":{"from":118885,"to":118902}}}}],["1480",{"pageContent":"There are many cases where it turns out to be quite useful to have a \nhandle that references the entire sequence collectively. The most \n\n\n230 | Appendix A: asynquence Library \n\n\n\nimportant of those cases is with sequence abort/cancel. As we cov¬ \nered extensively in Chapter 3, Promises themselves should never be \nable to be canceled, as this violates a fundamental design imperative: \nexternal immutability. \n\nBut sequences have no such immutability design principle, mostly \nbecause sequences are not passed around as future-value containers \nthat need immutable value semantics. So sequences are the proper \nlevel of abstraction to handle abort/cancel behavior, asynquence \nsequences can be abort( )ed at any time, and the sequence will stop \nat that point and not go for any reason. \n\nThere’s plenty more reasons to prefer a sequence abstraction on top \nof Promise chains for flow control purposes.","metadata":{"loc":{"lines":{"from":118902,"to":118923}}}}],["1481",{"pageContent":"There’s plenty more reasons to prefer a sequence abstraction on top \nof Promise chains for flow control purposes. \n\nFirst, Promise chaining is a rather manual process—one that can get \npretty tedious once you start creating and chaining Promises across \na wide swath of your programs—and this tedium can act counter- \nproductively to dissuade the developer from using Promises in \nplaces where they are quite appropriate. \n\nAbstractions are meant to reduce boilerplate and tedium, so the \nsequence abstraction is a good solution to this problem. With Prom¬ \nises, your focus is on the individual step, and there’s little assump¬ \ntion that you will keep the chain going. With sequences, the \nopposite approach is taken, assuming the sequence will keep having \nmore steps added indefinitely. \n\nThis abstraction complexity reduction is especially powerful when \nyou start thinking about higher-order Promise patterns (beyond \nrace( [..]) and all([..]).","metadata":{"loc":{"lines":{"from":118923,"to":118941}}}}],["1482",{"pageContent":"This abstraction complexity reduction is especially powerful when \nyou start thinking about higher-order Promise patterns (beyond \nrace( [..]) and all([..]). \n\nFor example, in the middle of a sequence, you may want to express a \nstep that is conceptually like a try..catch in that the step will \nalways result in success, either the intended main success resolution \nor a positive nonerror signal for the caught error. Or, you might \nwant to express a step that is like a retry/until loop, where it keeps \ntrying the same step over and over until success occurs. \n\nThese sorts of abstractions are quite nontrivial to express using only \nPromise primitives, and doing so in the middle of an existing \nPromise chain is not pretty. But if you abstract your thinking to a \nsequence, and consider a step as a wrapper around a Promise, that \nstep wrapper can hide such details, freeing you to think about the \n\n\nasynquence Library | 231","metadata":{"loc":{"lines":{"from":118941,"to":118959}}}}],["1483",{"pageContent":"asynquence Library | 231 \n\n\n\nflow control in the most sensible way without being bothered by the \ndetails. \n\nSecond, and perhaps more importantly, thinking of async flow con¬ \ntrol in terms of steps in a sequence allows you to abstract out the \ndetails of what types of asynchronicity are involved with each indi¬ \nvidual step. Under the covers, a Promise will always control the step, \nbut above the covers, that step can look either like a continuation \ncallback (the simple default), or like a real Promise, or as a run-to- \ncompletion generator, or... Hopefully, you get the picture.","metadata":{"loc":{"lines":{"from":118959,"to":118972}}}}],["1484",{"pageContent":"Third, sequences can more easily be twisted to adapt to different \nmodes of thinking, such as event-, stream-, or reactive-based cod¬ \ning. asynquence provides a pattern I call reactive sequences (which \nwe’ll cover later) as a variation on the reactive observable ideas in \nRxJS (Reactive Extensions), which lets a repeatable event fire off a \nnew sequence instance each time. Promises are one-shot-only, so it’s \nquite awkward to express repetitious asynchrony with Promises \nalone. \n\nAnother alternate mode of thinking inverts the resolution/control \ncapability in a pattern I call iterable sequences. Instead of each indi¬ \nvidual step internally controlling its own completion (and thus \nadvancement of the sequence), the sequence is inverted so the \nadvancement control is through an external iterator, and each step \nin the iterable sequence just responds to the next(..) iterator con¬ \ntrol.","metadata":{"loc":{"lines":{"from":118974,"to":118989}}}}],["1485",{"pageContent":"We’ll explore all of these different variations as we go throughout \nthe rest of this appendix, so don’t worry if we ran over those bits far \ntoo quickly just now. \n\nThe takeaway is that sequences are a more powerful and sensible \nabstraction for complex asynchrony than just Promises (Promise \nchains) or just generators, and asynquence is designed to express \nthat abstraction with just the right level of sugar to make async pro¬ \ngramming more understandable and more enjoyable. \n\nasynquence API \n\nTo start off, the way you create a sequence (an asynquence instance) \nis with the ASQ(..) function. An ASQ() call with no parameters cre¬ \nates an empty initial sequence, whereas passing one or more values \n\n\n232 | Appendix A: asynquence Library \n\n\n\nor functions to ASQ(..) sets up the sequence with each argument \nrepresenting the initial steps of the sequence.","metadata":{"loc":{"lines":{"from":118991,"to":119013}}}}],["1486",{"pageContent":"232 | Appendix A: asynquence Library \n\n\n\nor functions to ASQ(..) sets up the sequence with each argument \nrepresenting the initial steps of the sequence. \n\n\n\nFor the purposes of all code examples here, I will \nuse the asynquence top-level identifier in global \nbrowser usage: ASQ. If you include and use asyn¬ \nquence through a module system (browser or \nserver), you can, of course, define whichever \nsymbol you prefer, and asynquence won’t care! \n\n\nMany of the API methods discussed here are built into the core of \nasynquence, but others are provided through including the optional \n“contrib” plug-ins package. See the documentation for asynquence \nfor whether a method is built in or defined via plug-in. \n\nSteps","metadata":{"loc":{"lines":{"from":119013,"to":119035}}}}],["1487",{"pageContent":"Steps \n\nIf a function represents a normal step in the sequence, that function \nis invoked with the first parameter being the continuation callback, \nand any subsequent parameters being any messages passed on from \nthe previous step. The step will not complete until the continuation \ncallback is called. Once it’s called, any arguments you pass to it will \nbe sent along as messages to the next step in the sequence. \n\nTo add an additional normal step to the sequence, call then(..) \n(which has essentially the exact same semantics as the ASQ(..) call): \n\nASQ( \n\n// step 1 \n\nfunction(done){ \n\nsetTimeout( function! ){ \ndone( \"Hello\" ); \n\n}, 100 ); \n\n}. \n\n// step 2 \n\nfunction(done, greeting) { \nsetTimeout( function! ){ \n\ndone( greeting + \" World\" ); \n\n}, 100 ); \n\n} \n\n) \n\n// step 3 \n\n.then! function(done,msg){ \nsetTimeout! function! ){ \n\ndone( msg . toUpperCase( ) ); \n\n}, 100 ); \n\n\nasynquence Library | 233 \n\n\n\n\n// HELLO WORLD \n\n\n// step 4 \n\n.then( function(done,msg){ \nconsole.log( msg );","metadata":{"loc":{"lines":{"from":119035,"to":119094}}}}],["1488",{"pageContent":"done( msg . toUpperCase( ) ); \n\n}, 100 ); \n\n\nasynquence Library | 233 \n\n\n\n\n// HELLO WORLD \n\n\n// step 4 \n\n.then( function(done,msg){ \nconsole.log( msg ); \n\n} ); \n\n\n\nThough the name then(. .) is identical to the \nnative Promises API, this then( ..) is different. \nYou can pass as few or as many functions or val¬ \nues to then( ..) as you’d like, and each is taken \nas a separate step. There’s no two-callback fulfil¬ \nled/rejected semantics involved. \n\n\nUnlike with Promises, where to chain one Promise to the next you \nhave to create and return that Promise from a then(..) fulfillment \nhandler, with asynquence, all you need to do is call the continuation \ncallback—I always call it done() but you can name it whatever suits \nyou—and optionally pass it completion messages as arguments. \n\nEach step defined by then(..) is assumed to be asynchronous. If \nyou have a step that’s synchronous, you can either just call done(..) \nright away, or you can use the simpler val(.. ) step helper:","metadata":{"loc":{"lines":{"from":119094,"to":119132}}}}],["1489",{"pageContent":"Each step defined by then(..) is assumed to be asynchronous. If \nyou have a step that’s synchronous, you can either just call done(..) \nright away, or you can use the simpler val(.. ) step helper: \n\n// step 1 (sync) \n\nASQ( function(done){ \n\ndone( \"Hello\" ); // manually synchronous \n\n1 ) \n\n// step 2 (sync) \n\n.val( function(greeting){ \n\nreturn greeting + \" World\"; \n\n1 ) \n\n// step 3 (async) \n\n.then( function(done,msg){ \nsetTimeout( function(){ \n\ndone( msg . totlpperCase( ) ); \n\n}, 100 ); \n\n} ) \n\n// step 4 (sync) \n\n.val( function(msg){ \nconsole.log( msg ); \n\n} ); \n\nAs you can see, val( ..)-invoked steps don’t receive a continuation \ncallback, as that part is assumed for you—and the parameter list is \nless cluttered as a result! To send a message along to the next step, \nyou simply use return. \n\n\n234 | Appendix A: asynquence Library \n\n\n\n\n\nThink of val( ..) as representing a synchronous “value-only” step, \nwhich is useful for synchronous value operations, logging, and the \nlike. \n\nErrors","metadata":{"loc":{"lines":{"from":119132,"to":119186}}}}],["1490",{"pageContent":"234 | Appendix A: asynquence Library \n\n\n\n\n\nThink of val( ..) as representing a synchronous “value-only” step, \nwhich is useful for synchronous value operations, logging, and the \nlike. \n\nErrors \n\nOne important difference with asynquence compared to Promises is \nwith error handling. \n\nWith Promises, each individual Promise (step) in a chain can have \nits own independent error, and each subsequent step has the ability \nto handle the error (or not). The main reason for this semantic \ncomes (again) from the focus on individual Promises rather than on \nthe chain (sequence) as a whole. \n\nI believe that most of the time, an error in one part of a sequence is \ngenerally not recoverable, so the subsequent steps in the sequence \nare moot and should be skipped. So, by default, an error at any step \nof a sequence throws the entire sequence into error mode, and the \nrest of the normal steps are ignored.","metadata":{"loc":{"lines":{"from":119186,"to":119211}}}}],["1491",{"pageContent":"If you do need to have a step where its error is recoverable, there are \nseveral different API methods that can accommodate, such as \ntry(..) (previously mentioned as a kind of try..catch step) or \nuntil(.. ) (a retry loop that keeps attempting the step until it suc¬ \nceeds or you manually breakQ the loop), asynquence even has \npThen( ..) and pCatch( ..) methods, which work identically to how \nnormal Promise then( ..) and catch(. .) work (see Chapter 3), so \nyou can do localized mid-sequence error handling if you so choose. \n\nThe point is, you have both options, but the more common one in \nmy experience is the default. With Promises, to get a chain of steps \nto ignore all steps once an error occurs, you have to take care not to \nregister a rejection handler at any step; otherwise, that error gets \nswallowed as handled, and the sequence may continue (perhaps \nunexpectedly). This kind of desired behavior is a bit awkward to \nproperly and reliably handle.","metadata":{"loc":{"lines":{"from":119213,"to":119228}}}}],["1492",{"pageContent":"To register a sequence error notification handler, asynquence pro¬ \nvides an or(..) sequence method, which also has an alias of \nonerror(. .). You can call this method anywhere in the sequence, \nand you can register as many handlers as you’d like. That makes it \neasy for multiple different consumers to listen in on a sequence to \n\n\nasynquence Library | 235 \n\n\n\nknow if it failed or not; it’s kind of like an error event handler in that \nrespect. \n\nJust like with Promises, all JS exceptions become sequence errors, or \nyou can programmatically signal a sequence error: \n\nvar sq = ASQ( function(done){ \nsetTimeout( function(){ \n\n// signal an error for the sequence \ndone.fall( \"Oops\" ); \n\n}, 100 ); \n\n} ) \n\n. then( function(done){ \n\n// will never get here \n\n} ) \n\n.or( function(err){ \n\nconsole.log( err ); // Oops \n\n} ) \n\n.then( function(done){ \n\n// won't get here either \n\n} ); \n\n// later \n\nsq.or( function(err){ \n\nconsole.log( err ); // Oops \n\n} );","metadata":{"loc":{"lines":{"from":119230,"to":119281}}}}],["1493",{"pageContent":"} ) \n\n.or( function(err){ \n\nconsole.log( err ); // Oops \n\n} ) \n\n.then( function(done){ \n\n// won't get here either \n\n} ); \n\n// later \n\nsq.or( function(err){ \n\nconsole.log( err ); // Oops \n\n} ); \n\nAnother really important difference with error handling in asyn- \nquence compared to native Promises is the default behavior of \nunhandled exceptions. As we discussed at length in Chapter 3, a \nrejected Promise without a registered rejection handler will just \nsilently hold (aka swallow) the error; you have to remember to \nalways end a chain with a final catch (..) . \n\nIn asynquence, the assumption is reversed. \n\nIf an error occurs on a sequence, and it at that moment has no error \nhandlers registered, the error is reported to the console. In other \nwords, unhandled rejections are by default always reported so as not \nto be swallowed and missed. \n\nAs soon as you register an error handler against a sequence, it opts \nthat sequence out of such reporting, to prevent duplicate noise.","metadata":{"loc":{"lines":{"from":119281,"to":119318}}}}],["1494",{"pageContent":"As soon as you register an error handler against a sequence, it opts \nthat sequence out of such reporting, to prevent duplicate noise. \n\nThere may, in fact, be cases where you want to create a sequence \nthat may go into the error state before you have a chance to register \nthe handler. This isn’t common, but it can happen from time to \ntime. \n\n\n236 | Appendix A: asynquence Library \n\n\n\nIn those cases, you can also opt a sequence instance out of error \nreporting by calling deferQ on the sequence. You should only opt \nout of error reporting if you are sure that you’re going to eventually \nhandle such errors: \n\nvar sql = ASQ( function(done){ \n\ndoesnt . Extst( ); // will throw exception to console \n\n} ); \n\nvar sq2 = ASQ( function(done){ \n\ndoesnt . Extst( ); // will throw only a sequence error \n\n} ) \n\n// opt-out of error reporting \n.deferQ; \n\nsetTimeout( function(){ \nsql.or( function(err){ \n\nconsote.log( err ); // ReferenceError \n\n} ); \n\nsq2.or( function(err){","metadata":{"loc":{"lines":{"from":119318,"to":119358}}}}],["1495",{"pageContent":"} ) \n\n// opt-out of error reporting \n.deferQ; \n\nsetTimeout( function(){ \nsql.or( function(err){ \n\nconsote.log( err ); // ReferenceError \n\n} ); \n\nsq2.or( function(err){ \n\nconsole.log( err ); // ReferenceError \n\n} ); \n\n}, 100 ); \n\n// ReferenceError (fron sql) \n\nThis is better error handling behavior than Promises themselves \nhave, because it’s the pit of success, not the pit of failure (see Chap¬ \nter 3). \n\n\n\nIf a sequence is piped into (aka subsumed by) \nanother sequence—see “Combining Sequences” \non page 244 for a complete description—then \nthe source sequence is opted out of error report¬ \ning, but now the target sequence’s error report¬ \ning or lack thereof must be considered. \n\n\nParallel Steps","metadata":{"loc":{"lines":{"from":119358,"to":119394}}}}],["1496",{"pageContent":"Parallel Steps \n\nNot all steps in your sequences will have just a single (async) task to \nperform; some will need to perform multiple steps in parallel (con¬ \ncurrently). A step in a sequence in which multiple substeps are pro¬ \ncessing concurrently is called a gate( ..) — there’s an all( ..) alias \nif you prefer—and is directly symmetric to native \nPromise.all([..]). \n\n\nasynquence Library | 237 \n\n\n\n\nIf all the steps in the gate(..) complete successfully, all success \nmessages will be passed to the next sequence step. If any of them \ngenerate errors, the whole sequence immediately goes into an error \nstate. \n\nConsider: \n\nASQ( function(done){ \n\nsetTimeout( done, 100 ); \n\n} ) \n\n■gate( \n\nfunction(done){ \n\nsetTimeout( function(){ \ndone( \"Hello\" ); \n\n}, 100 ); \n\n}. \n\nfunction(done){ \n\nsetTimeout( function! ){ \ndone( \"World\", \"!\" ); \n\n}, 100 ); \n\n} \n\n) \n\n.val( function(msgl,nsg2){ \n\nconsole.log! msgl ); // Hello \n\nconsole.log! msg2 ); // [ \"World\", \"!\" ] \n\n} );","metadata":{"loc":{"lines":{"from":119394,"to":119450}}}}],["1497",{"pageContent":"function(done){ \n\nsetTimeout( function! ){ \ndone( \"World\", \"!\" ); \n\n}, 100 ); \n\n} \n\n) \n\n.val( function(msgl,nsg2){ \n\nconsole.log! msgl ); // Hello \n\nconsole.log! msg2 ); // [ \"World\", \"!\" ] \n\n} ); \n\nFor illustration, let’s compare that example to native Promises: \n\nnew Promise! function(resolve, reject)! \nsetTimeout( resolve, 100 ); \n\n} ) \n\n.then! function! ){ \n\nreturn Promise.all( [ \n\nnew Promise! function! resolve,reject)! \nsetTimeout! function! )! \n\nresolve! \"Hello\" ); \n\n}, 100 ); \n\n} ), \n\nnew Promise! function! resolve,reject)! \nsetTimeout! function! ){ \n\n// note: we need a [ ] array here \nresolve! [ \"World\", \"!\" ] ); \n\n}, 100 ); \n\n} ) \n\n] ); \n\n} ) \n\n.then( function(msgs)! \n\nconsole.log! msgs[0] ); // Hello \nconsole.log! msgs[l] ); // [ \"World\", \"!\" ] \n\n} ); \n\n\n238 | Appendix A: asynquence Library","metadata":{"loc":{"lines":{"from":119450,"to":119511}}}}],["1498",{"pageContent":"}, 100 ); \n\n} ) \n\n] ); \n\n} ) \n\n.then( function(msgs)! \n\nconsole.log! msgs[0] ); // Hello \nconsole.log! msgs[l] ); // [ \"World\", \"!\" ] \n\n} ); \n\n\n238 | Appendix A: asynquence Library \n\n\n\n\nYuck. Promises require a lot more boilerplate overhead to express \nthe same asynchronous flow control. That’s a great illustration of \nwhy the asynquence API and abstraction make dealing with Promise \nsteps a lot nicer. The improvement only goes higher the more com¬ \nplex your asynchrony is. \n\nStep Variations \n\nThere are several variations in the contrib plug-ins on asynquence s \ngate(..) step type that can be quite helpful: \n\n• any(..) is like gate(..), except just one segment has to even¬ \ntually succeed to proceed on the main sequence. \n\n• first(..) is like any(..), except as soon as any segment suc¬ \nceeds, the main sequence proceeds (ignoring subsequent results \nfrom other segments).","metadata":{"loc":{"lines":{"from":119511,"to":119548}}}}],["1499",{"pageContent":"• first(..) is like any(..), except as soon as any segment suc¬ \nceeds, the main sequence proceeds (ignoring subsequent results \nfrom other segments). \n\n• race(..) (symmetric with Promise. race( [..])) is like \nfirst(..except the main sequence proceeds as soon as any \nsegment completes (either success or failure). \n\n• last(..) is like any(..), except only the latest segment to com¬ \nplete successfully sends its message(s) along to the main \nsequence. \n\n• none(..) is the inverse of gate(..): the main sequence pro¬ \nceeds only if all the segments fail (with all segment error mes¬ \nsage^) transposed as success message(s) and vice versa). \n\nLet’s first define some helpers to make illustration cleaner: \n\nfunction successl(done) { \nsetTimeout( function(){ \ndone( 1 ); \n\n}, 100 ); \n\n} \n\nfunction success2(done) { \nsetTimeout( function(){ \ndone( 2 ); \n\n}, 100 ); \n\n} \n\nfunction failure3(done) { \nsetTimeout( function(){ \ndone.fail( 3 ); \n\n}, 100 ); \n\n\nasynquence Library | 239 \n\n\n\n}","metadata":{"loc":{"lines":{"from":119548,"to":119593}}}}],["1500",{"pageContent":"function success2(done) { \nsetTimeout( function(){ \ndone( 2 ); \n\n}, 100 ); \n\n} \n\nfunction failure3(done) { \nsetTimeout( function(){ \ndone.fail( 3 ); \n\n}, 100 ); \n\n\nasynquence Library | 239 \n\n\n\n} \n\n\nfunction output(nsg) { \nconsole.log( msg ); \n\n} \n\nNow, let’s demonstrate these gate( ..) step variations: \n\nASQ( ). race( \nfailure3, \nsuccessl \n\n) \n\n.or( output ); // 3 \n\n\nASQ().any( \n\nsuccessl, \n\nfailure3, \n\nsuccess2 \n\n) \n\n.val( function(){ \n\nvar args = [] .slice.call( arguments ); \nconsole.log( \n\nargs // [ 1, undefined, 2 ] \n\n); \n\n} ); \n\n\nASQ().first( \n\nfailure3, \n\nsuccessl, \n\nsuccess2 \n\n) \n\n.val( output ); // 1 \n\n\nASQ().last( \n\nfailure3, \n\nsuccessl, \n\nsuccess2 \n\n) \n\n.val( output ); // 2 \n\nASQ().none( \nfailure3 \n\n) \n\n.val( output ) // 3 \n\n. none( \n\nfailure3 \n\nsuccessl \n\n) \n\n.or( output ); // 1 \n\n\n240 | Appendix A: asynquence Library","metadata":{"loc":{"lines":{"from":119593,"to":119696}}}}],["1501",{"pageContent":"success2 \n\n) \n\n.val( output ); // 2 \n\nASQ().none( \nfailure3 \n\n) \n\n.val( output ) // 3 \n\n. none( \n\nfailure3 \n\nsuccessl \n\n) \n\n.or( output ); // 1 \n\n\n240 | Appendix A: asynquence Library \n\n\n\n\nAnother step variation is map(. .)> which lets you asynchronously \nmap elements of an array to different values, and the step doesn’t \nproceed until all the mappings are complete. map(. .) is very similar \nto gate( ..except it gets the initial values from an array instead of \nfrom separately specified functions, and also because you define a \nsingle function callback to operate on each value: \n\nfunction double(x,done) { \nsetTimeout( function(){ \ndone( x * 2 ); \n\n}, 100 ); \n\n} \n\nASQ().map( [1,2,3], double ) \n\n.val( output ); // [2,4,6] \n\nAlso, map( ..) can receive either of its parameters (the array or the \ncallback) from messages passed from the previous step: \n\nfunction plusOne(x,done) { \nsetTimeout( function(){ \ndone( x + 1 ); \n\n}, 100 ); \n\n} \n\nASQ( [1,2,3] )","metadata":{"loc":{"lines":{"from":119696,"to":119755}}}}],["1502",{"pageContent":"function plusOne(x,done) { \nsetTimeout( function(){ \ndone( x + 1 ); \n\n}, 100 ); \n\n} \n\nASQ( [1,2,3] ) \n\n,nap( double ) //message '[1,2,3]' comes in \n\n,nap( plusOne ) //message '[2,4,6]' comes in \n\n■ val( output ); // [3,5,7] \n\nAnother variation is waterfall(. .), which is kind of like a mixture \nbetween gate(..)’s message collection behavior but then(..)’s \nsequential processing. \n\nStep 1 is first executed, then the success message from step 1 is given \nto step 2, and then both success messages go to step 3, and then all \nthree success messages go to step 4, and so on, such that the mes¬ \nsages sort of collect and cascade down the “waterfall.” \n\nConsider: \n\nfunction double(done) { \n\nvar args = [] .slice.call( arguments, 1 ); \nconsole.log( args ); \n\nsetTimeout( function(){ \n\ndone( args[args.length - 1] * 2 ); \n\n}, 100 ); \n\n} \n\n\nasynquence Library | 241 \n\n\n\n\nASQ( 3 ) \n.waterfall( \n\n\ndouble, \n\ndouble, \n\ndouble, \n\ndouble \n\n\n//[ 3 ] \n\n//[ 6 ] \n\n// [ 6 , 12 ] \n\n// [ 6, 12, 24 ]","metadata":{"loc":{"lines":{"from":119755,"to":119820}}}}],["1503",{"pageContent":"}, 100 ); \n\n} \n\n\nasynquence Library | 241 \n\n\n\n\nASQ( 3 ) \n.waterfall( \n\n\ndouble, \n\ndouble, \n\ndouble, \n\ndouble \n\n\n//[ 3 ] \n\n//[ 6 ] \n\n// [ 6 , 12 ] \n\n// [ 6, 12, 24 ] \n\n\n.val( function(){ \n\nvar args = [] .slice.call( arguments ); \nconsole.log( args ); // [ 6, 12, 24, 48 ] \n\n\n} ); \n\n\nIf at any point in the “waterfall” an error occurs, the whole sequence \nimmediately goes into an error state. \n\nError Tolerance \n\nSometimes you want to manage errors at the step level and not let \nthem necessarily send the whole sequence into the error state, asyn- \nquence offers two step variations for that purpose. \n\ntry(.. ) attempts a step, and if it succeeds, the sequence proceeds as \nnormal, but if the step fails, the failure is turned into a success mes¬ \nsage formated as { catch: .. } with the error message(s) filled in: \n\nASQQ \n\n■try( successl ) \n\n.val( output ) // 1 \n\n■try( fallure3 ) \n\n.val( output ) // { catch: 3 } \n\n.or( function(err){ \n\n// never gets here \n\n\n} );","metadata":{"loc":{"lines":{"from":119820,"to":119889}}}}],["1504",{"pageContent":"ASQQ \n\n■try( successl ) \n\n.val( output ) // 1 \n\n■try( fallure3 ) \n\n.val( output ) // { catch: 3 } \n\n.or( function(err){ \n\n// never gets here \n\n\n} ); \n\n\nYou could instead set up a retry loop using until(..), which tries \nthe step and if it fails, retries the step again on the next event loop \ntick, and so on. \n\nThis retry loop can continue indefinitely, but if you want to break \nout of the loop, you can call the break( ) flag on the completion trig¬ \nger, which sends the main sequence into an error state: \n\nvar count = 0; \n\nASQ( 3 ) \n\n.until( double ) \n\n.val( output ) // 6 \n\n.until( function(done){ \n\n\ncount++; \n\n\n242 | Appendix A: asynquence Library \n\n\n\n\nsetTimeout( function(){ \nif (count < 5) { \ndone.fail( ); \n\n} \n\nelse { \n\n// break out of the 'until(..)' retry loop \ndone.break( \"Oops\" ); \n\n} \n\n}, 100 ); \n\n} ) \n\n.or( output ); // Oops \n\nPromise-Style Steps","metadata":{"loc":{"lines":{"from":119889,"to":119953}}}}],["1505",{"pageContent":"} \n\nelse { \n\n// break out of the 'until(..)' retry loop \ndone.break( \"Oops\" ); \n\n} \n\n}, 100 ); \n\n} ) \n\n.or( output ); // Oops \n\nPromise-Style Steps \n\nIf you would prefer to have, inline in your sequence, Promise-style \nsemantics like Promises’ then(..) and catch(..) (see Chapter 3), \nyou can use the pThen and pCatch plug-ins: \n\nASQ( 21 ) \n\n.pThen( function(msg){ \nreturn msg * 2; \n\n} ) \n\n.pThen( output ) // 42 \n\n.pThen( function(){ \n\n// throw an exception \ndoesnt . Exist( ); \n\n} ) \n\n.pCatch( function(err){ \n\n// caught the exception (rejection) \nconsole.log( err ); // ReferenceError \n\n} ) \n\n.val( function(){ \n\n// main sequence is back in a \n// success state because previous \n// exception was caught by \n// 'pCatch(..) ' \n\n} ); \n\npThen(..) and pCatch (..) are designed to run in the sequence, but \nbehave as if it was a normal Promise chain. As such, you can resolve \ngenuine Promises or asynquence sequences from the fulfillment \nhandler passed to pThen(..) (see Chapter 3).","metadata":{"loc":{"lines":{"from":119953,"to":120009}}}}],["1506",{"pageContent":"Forking Sequences \n\nOne feature that can be quite useful about Promises is that you can \nattach multiple then(..) handler registrations to the same promise, \neffectively forking the flow-control at that promise: \n\n\nasynquence Library | 243 \n\n\n\nvar p = Promise.resolve( 21 ); \n\n\n// fork 1 (from 'p') \n\np.then( function(msg){ \nreturn msg * 2; \n\n} ) \n\n.then( function(msg){ \n\nconsole.log ( msg ); // 42 \n\n} ) \n\n// fork 2 (from 'p') \n\np.then( function(msg){ \n\nconsole.log ( msg ); // 21 \n\n} ); \n\nThe same forking is easy in asynquence with fork(): \n\nvar sq = ASQ( ..). then( ..). then( ..); \n\nvar sq2 = sq.forkQ; \n\n// fork 1 \nsq . then( \n\n// fork 2 \nsq2.then( \n\nCombining Sequences \n\nIf you want to do the reverse of forkQing, you can combine two \nsequences by subsuming one into another, using the seq(..) \ninstance method: \n\nvar sq = ASQ( function(done){ \nsetTlmeout( function(){ \ndone( \"Hello World\" ); \n\n}, 200 ); \n\n} ); \n\nASQ( function(done){ \n\nsetTimeout( done, 100 ); \n\n} )","metadata":{"loc":{"lines":{"from":120011,"to":120076}}}}],["1507",{"pageContent":"var sq = ASQ( function(done){ \nsetTlmeout( function(){ \ndone( \"Hello World\" ); \n\n}, 200 ); \n\n} ); \n\nASQ( function(done){ \n\nsetTimeout( done, 100 ); \n\n} ) \n\n// subsume 'sq' sequence into this sequence \n■ seq( sq ) \n\n.val( function(msg){ \n\nconsole.log( msg ); // Hello World \n\n} ) \n\nseq(..) can accept either a sequence itself, as shown here, or a \nfunction. If it accepts a function, it’s expected that the function will \n\n\n244 | Appendix A: asynquence Library \n\n\n\nreturn a sequence when called, so the preceding code could have \nbeen done with: \n\n// •• \n\n. seq( function(){ \nreturn sq; \n\n} ) \n\n// •• \n\nAlso, that step could instead have been accomplished with a \npipe(..): \n\n// •• \n\n. then( function ( done ){ \n\n// pipe 'sq' into the 'done' continuation callback \nsq.pipe( done ); \n\n} ) \n\n// \n\nWhen a sequence is subsumed, both its success message stream and \nits error stream are piped in.","metadata":{"loc":{"lines":{"from":120076,"to":120134}}}}],["1508",{"pageContent":"// pipe 'sq' into the 'done' continuation callback \nsq.pipe( done ); \n\n} ) \n\n// \n\nWhen a sequence is subsumed, both its success message stream and \nits error stream are piped in. \n\n\n\nAs mentioned in an earlier note, piping (man¬ \nually with pipe(..) or automatically with \nseq(.. )) opts the source sequence out of error¬ \nreporting, but doesn’t affect the error reporting \nstatus of the target sequence. \n\n\nValue and Error Sequences \n\nIf any step of a sequence is just a normal value, that value is mapped \nto that step’s completion message: \n\nvar sq = ASQ( 42 ); \n\nsq.val( function(msg){ \n\nconsole.log( msg ); // 42 \n\n} ); \n\nIf you want to make a sequence that’s automatically errored: \n\nvar sq = ASQ.falled( \"Oops\" ); \n\nASQQ \n• seq( sq ) \n\n.val( function(msg){ \n\n// won't get here \n\n} ) \n\n.or( function(err){ \n\n\nasynquence Library | 245 \n\n\n\n\nconsole.log( err ); // Oops \n\n} );","metadata":{"loc":{"lines":{"from":120134,"to":120189}}}}],["1509",{"pageContent":"var sq = ASQ.falled( \"Oops\" ); \n\nASQQ \n• seq( sq ) \n\n.val( function(msg){ \n\n// won't get here \n\n} ) \n\n.or( function(err){ \n\n\nasynquence Library | 245 \n\n\n\n\nconsole.log( err ); // Oops \n\n} ); \n\nYou also may want to automatically create a delayed-value or a \ndelayed-error sequence. Using the after and fatlAfter contrib \nplug-ins, this is easy: \n\nvar sql = ASQ.after( 100, \"Hello\", \"World\" ); \nvar sq2 = ASQ.failAfter( 100, \"Oops\" ); \n\nsql.val( function(msgl,msg2){ \n\nconsole.log( msgl, msg2 ); // Hello Horld \n\n} ); \n\nsq2.or( function(err){ \n\nconsole.log( err ); // Oops \n\n} ); \n\nYou can also insert a delay in the middle of a sequence using \nafter(..): \n\nASQ( 42 ) \n\n// insert a delay into the sequence \n. after( 100 ) \n\n.val( function(msg){ \n\nconsole.log ( msg ); // 42 \n\n} ); \n\nPromises and Callbacks","metadata":{"loc":{"lines":{"from":120189,"to":120245}}}}],["1510",{"pageContent":"ASQ( 42 ) \n\n// insert a delay into the sequence \n. after( 100 ) \n\n.val( function(msg){ \n\nconsole.log ( msg ); // 42 \n\n} ); \n\nPromises and Callbacks \n\nI think asynquence sequences provide a lot of value on top of native \nPromises, and for the most part you’ll find it more pleasant and \nmore powerful to work at that level of abstration. However, inte¬ \ngrating asynquence with other non -asynquence code will be a reality. \n\nYou can easily subsume a promise (e.g., a thenable—see Chapter 3) \ninto a sequence using the promise(..) instance method: \n\nvar p = Promise.resolve( 42 ); \n\nASQ() \n\n.promise! P ) // could also: function(){ return p; } \n\n.val( function(msg){ \n\nconsole.log ( msg ); // 42 \n\n1 ); \n\nAnd to go the opposite direction and fork/vend a promise from a \nsequence at a certain step, use the toPronise contrib plug-in: \n\n\n246 | Appendix A: asynquence Library \n\n\n\n\nvar sq = ASQ.after( 100, \"Hello World\" ); \n\n\nsq.toPromiseQ \n\n// this is a standard promise chain now","metadata":{"loc":{"lines":{"from":120245,"to":120292}}}}],["1511",{"pageContent":"246 | Appendix A: asynquence Library \n\n\n\n\nvar sq = ASQ.after( 100, \"Hello World\" ); \n\n\nsq.toPromiseQ \n\n// this is a standard promise chain now \n\n. then( function(msg){ \n\nreturn msg.toUpperCaseQ; \n\n} ) \n\n. then( function(msg){ \n\nconsole.log( msg ); // HELLO WORLD \n\n} ); \n\nTo adapt asynquence to systems using callbacks, there are several \nhelper facilities. To automatically generate an “error-first style” call¬ \nback from your sequence to wire into a callback-oriented utility, use \nerrfcb: \n\nvar sq = ASQ( function(done){ \n\n// note: expecting \"error-first style\" callback \nsomeAsyncFuncWithCB( 1, 2, done.errfcb ) \n\n} ) \n\n.val( function(msg){ \n\n// •• \n\n} ) \n\n.or( function(err){ \n\n// •• \n\n} ); \n\n// note: expecting \"error-first style\" callback \nanotherAsyncFuncWlthCB( 1, 2, sq.errfcbQ ); \n\nYou also may want to create a sequence-wrapped version of a utility \n—compare to “promisory” in Chapter 3 and “thunkory” in Chap¬ \nter 4 —and asynquence provides ASQ.wrap(. .) for that purpose:","metadata":{"loc":{"lines":{"from":120292,"to":120345}}}}],["1512",{"pageContent":"You also may want to create a sequence-wrapped version of a utility \n—compare to “promisory” in Chapter 3 and “thunkory” in Chap¬ \nter 4 —and asynquence provides ASQ.wrap(. .) for that purpose: \n\nvar coolUtility = ASQ.wrap( someAsyncFuncWithCB ); \n\n\ncoolUtility( 1, 2 ) \n.val( function(msg){ \n// •• \n\n} ) \n\n.or( function(err){ \n// •• \n\n} ); \n\n\n\nFor the sake of clarity (and for fun!), let’s coin \nyet another term, for a sequence-producing \nfunction that comes from ASQ.wrap( ..), like \ncoolUtility here. I propose “sequory” \n(“sequence” + “factory”). \n\n\nasynquence Library | 247 \n\n\n\n\n\nIterable Sequences \n\n\nThe normal paradigm for a sequence is that each step is responsible \nfor completing itself, which is what advances the sequence. Promises \nwork the same way. \n\nThe unfortunate part is that sometimes you need external control \nover a Promise/step, which leads to awkward capability extraction. \n\nConsider this Promises example: \n\nvar domready = new Promise( function( resolve,reject){","metadata":{"loc":{"lines":{"from":120345,"to":120390}}}}],["1513",{"pageContent":"Consider this Promises example: \n\nvar domready = new Promise( function( resolve,reject){ \n\n// don't want to put this here, because \n// it belongs logically in another part \n// of the code \n\ndocument. addEventListener( \"DOMContentLoaded\" , resotve ); \n\n\n} ); \n\n\n// \n\n\ndomready .then( functionQf \n\n\n// DOM is ready! \n\n} ); \n\n\nThe capability extraction anti-pattern with Promises looks like this: \n\nvar ready; \n\nvar domready = new Promise( function( resolve,reject){ \n\n// extract the ' resolve ()' capability \nready = resolve; \n\n\n} ); \n\n\n// \n\n\ndomready .then( functionQf \n\n\n// DOM is ready! \n\n} ); \n\n\n// •• \n\n\ndocument. addEventListener( \"DOMContentLoaded\", ready ); \n\n\n\nThis anti-pattern has an awkward code smell, in \nmy opinion, but some developers like it, for rea¬ \nsons I can’t grasp. \n\n\n248 | Appendix A: asynquence Library","metadata":{"loc":{"lines":{"from":120390,"to":120451}}}}],["1514",{"pageContent":"This anti-pattern has an awkward code smell, in \nmy opinion, but some developers like it, for rea¬ \nsons I can’t grasp. \n\n\n248 | Appendix A: asynquence Library \n\n\n\n\n\nasynquence offers an inverted sequence type I call iterable sequen¬ \nces, which externalizes the control capability (it’s quite useful in use \ncases like the domready): \n\n// note: 'donready' here is an iterator that \n\n// controls the sequence \n\nvar domready = ASQ.iterableQ; \n\n// •• \n\ndomready .vat( function(){ \n\n// DOM is ready \n\n1 ); \n\n// •• \n\ndocument. addEventListener( \"DOMContentLoaded\" , domready.next ); \n\nThere’s more to iterable sequences than what we see in this scenario. \nWe’ll come back to them in Appendix B. \n\nRunning Generators \n\nIn Chapter 4 we derived a utility called run(..), which can run gen¬ \nerators to completion, listening for yielded Promises and using \nthem to asynchronously resume the generator, asynquence has just \nsuch a utility built in, called runner (..).","metadata":{"loc":{"lines":{"from":120451,"to":120492}}}}],["1515",{"pageContent":"Let’s first set up some helpers for illustration: \n\nfunction doublePr(x) { \n\nreturn new Promise( function( resolve,reject){ \nsetTimeout( function(){ \nresolve( x * 2 ); \n\n}, 100 ); \n\n1 ); \n\n} \n\nfunction doubleSeq(x) { \n\nreturn ASQ( function(done){ \nsetTimeout( function(){ \ndone( x * 2) \n\n}, 100 ); \n\n1 ); \n\n} \n\n\nasynquence Library | 249 \n\n\n\nNow we can use runner( ..) as a step in the middle of a sequence: \n\nASQ( 10, 11 ) \n\n.runner( function*(token){ \n\nvar x = token. messages[Q] + token. messagesfl]; \n\n// yield a real promise \nx = yield doublePr( x ); \n\n// yield a sequence \nx = yield doubleSeq( x ); \n\nreturn x; \n\n} ) \n\n.val( function(msg){ \n\nconsole.log( msg ); // 84 \n\n} ); \n\nWrapped Generators \n\nYou can also create a self-packaged generator—that is, a normal \nfunction that runs your specified generator and returns a sequence \nfor its completion—by ASQ.wrap( .. )ing it: \n\nvar foo = ASQ.wrap( function*(token){ \n\nvar x = token. rnessages[6] + token. messagesfl];","metadata":{"loc":{"lines":{"from":120494,"to":120557}}}}],["1516",{"pageContent":"var foo = ASQ.wrap( function*(token){ \n\nvar x = token. rnessages[6] + token. messagesfl]; \n\n// yield a real promise \nx = yield doublePr( x ); \n\n// yield a sequence \nx = yield doubleSeq( x ); \n\nreturn x; \n\n}, { gen: true } ); \n\n// \n\nfoo( 8, 9 ) \n\n.val( function(msg){ \n\nconsole.log ( msg ); // 68 \n\n} ); \n\nThere’s a lot more awesome that runner(.. ) is capable of, but we’ll \ncome back to that in Appendix B. \n\n\n250 | Appendix A: asynquence Library \n\n\n\n\nReview \n\nasynquence is a simple abstraction—a sequence is a series of (async) \nsteps—on top of Promises, aimed at making working with various \nasynchronous patterns much easier, without compromising capabil¬ \nity. \n\nThere are other goodies in the asynquence core API and its contrib \nplug-ins beyond what we saw in this appendix, but we’ll leave \nchecking out the rest of the capabilities as an exercise for the reader.","metadata":{"loc":{"lines":{"from":120557,"to":120599}}}}],["1517",{"pageContent":"You’ve now seen the essence and spirit of asynquence. The key take¬ \naway is that a sequence is comprised of steps, and those steps can be \nany of dozens of different variations on Promises, or they can be a \ngenerator-run, or... The choice is up to you; you have the freedom \nto weave together whatever async flow control logic is appropriate \nfor your tasks. No more library switching to catch different async \npatterns. \n\nIf these asynquence snippets have made sense to you, you’re now \npretty well up to speed on the library; it doesn’t take that much to \nlearn, actually! \n\nIf you’re still a little fuzzy on how it works (or why!), you’ll want to \nspend a little more time examining the previous examples and play¬ \ning around with asynquence before going on to Appendix B, where \nwe will push asynquence into several more advanced and powerful \nasync patterns. \n\n\nasynquence Library | 251 \n\n\n\nAPPENDIX B \n\n\nAdvanced Async Patterns","metadata":{"loc":{"lines":{"from":120601,"to":120627}}}}],["1518",{"pageContent":"asynquence Library | 251 \n\n\n\nAPPENDIX B \n\n\nAdvanced Async Patterns \n\n\nAppendix A introduced the asynquence library for sequence- \noriented async flow control, primarily based on Promises and gen¬ \nerators. \n\nNow we’ll explore other advanced asynchronous patterns built on \ntop of that existing understanding and functionality, and see how \nasynquence makes those sophisticated async techniques easy to mix \nand match in our programs without needing lots of separate libra¬ \nries. \n\nIterable Sequences \n\nWe introduced asynquence s iterable sequences in the previous \nappendix, but we want to revisit them in more detail. \n\nTo refresh, recall: \n\nvar domready = ASQ.iterabteQ; \n\n// \n\ndomready.vat( function(){ \n\n// DOM is ready \n\n} ); \n\n// •• \n\ndocument. addEventListener( \"DOMContentLoaded\" , domready.next ); \n\n\n253 \n\n\n\n\n\n\nNow, let’s define a sequence of multiple steps as an iterable \nsequence: \n\nvar steps = ASQ.iterableQ; \nsteps \n\n. then( function STEPl(x){ \nreturn x * 2; \n\n} )","metadata":{"loc":{"lines":{"from":120627,"to":120685}}}}],["1519",{"pageContent":"253 \n\n\n\n\n\n\nNow, let’s define a sequence of multiple steps as an iterable \nsequence: \n\nvar steps = ASQ.iterableQ; \nsteps \n\n. then( function STEPl(x){ \nreturn x * 2; \n\n} ) \n\n. steps( function STEP2(x){ \nreturn x + 3; \n\n} ) \n\n. steps( function STEP3(x){ \nreturn x * 4; \n\n} ); \n\nsteps.next( 8 ). value; // 16 \nsteps.next( 16 ). value; // 19 \nsteps. next( 19 ). value; // 76 \nsteps. next().done; // true \n\nAs you can see, an iterable sequence is a standard-compliant iterator \n(see Chapter 4). So, it can be iterated with an ES6 for.. of loop, just \nlike a generator (or any other iterable) can: \n\nvar steps = ASQ.iterableQ; \nsteps \n\n.then( function STEP1Q{ return 2; } ) \n\n.then( function STEP2Q{ return 4; } ) \n\n.then( function STEP3Q{ return 6; } ) \n\n.then( function STEP4Q{ return 8; } ) \n\n.then( function STEP5Q{ return 10; } ); \n\nfor (var v of steps) { \nconsole.log( v ); \n\n} \n\n// 2 4 6 8 16","metadata":{"loc":{"lines":{"from":120685,"to":120740}}}}],["1520",{"pageContent":".then( function STEP3Q{ return 6; } ) \n\n.then( function STEP4Q{ return 8; } ) \n\n.then( function STEP5Q{ return 10; } ); \n\nfor (var v of steps) { \nconsole.log( v ); \n\n} \n\n// 2 4 6 8 16 \n\nBeyond the event triggering example shown in Appendix A, iterable \nsequences are interesting because in essence they can be seen as a \nstand-in for generators or Promise chains, but with even more flexi¬ \nbility. \n\nConsider a multiple Ajax request example—we’ve seen the same \nscenario in Chapters 3 and 4, both as a Promise chain and as a gen¬ \nerator, respectively—expressed as an iterable sequence: \n\n// sequence-aware ajax \n\nvar request = ASQ.wrap( ajax ); \n\n\n254 | Appendix B: Advanced Async Patterns \n\n\n\n\nASQ( \"http://sone.url.1\" ) \n\n. runner( \n\nASQ.lterableO \n\n.then( function STEPl(token){ \nvar url = token.nessages[0]; \nreturn request( url ); \n\n} ) \n\n.then( function STEP2(resp){ \nreturn ASQ().gate( \n\nrequest( \"http://some.url.2/?v=\" + resp ), \nrequest( \"http://sone.url.3/?v=\" + resp ) \n\n); \n\n} )","metadata":{"loc":{"lines":{"from":120740,"to":120792}}}}],["1521",{"pageContent":"} ) \n\n.then( function STEP2(resp){ \nreturn ASQ().gate( \n\nrequest( \"http://some.url.2/?v=\" + resp ), \nrequest( \"http://sone.url.3/?v=\" + resp ) \n\n); \n\n} ) \n\n.then( function STEP3(rl,r2){ return rl + r2; } ) \n\n) \n\n.val( function(nsg){ \nconsole.log( nsg ); \n\n} ); \n\nThe iterable sequence expresses a sequential series of (sync or async) \nsteps that looks awfully similar to a Promise chain—in other words, \nit’s much cleaner looking than just plain nested callbacks, but not \nquite as nice as the yield-based sequential syntax of generators. \n\nBut we pass the iterable sequence into ASQ#runner(. .), which runs \nit to completion as it would a generator. The fact that an iterable \nsequence behaves essentially the same as a generator is notable for a \ncouple of reasons.","metadata":{"loc":{"lines":{"from":120792,"to":120821}}}}],["1522",{"pageContent":"First, iterable sequences are kind of a pre-ES6 equivalent to a certain \nsubset of ES6 generators, which means you can either author them \ndirectly (to run anywhere), or you can author ES6 generators and \ntranspile/convert them to iterable sequences (or Promise chains for \nthat matter!). \n\nThinking of an async-run-to-completion generator as just syntactic \nsugar for a Promise chain is an important recognition of their iso¬ \nmorphic relationship. \n\nBefore we move on, we should note that the previous snippet could \nhave been expressed in asynquence as: \n\nASQ( \"http://some.url. 1\" ) \n\n.seq( /*STEP 1*/ request ) \n\n.seq( function STEP2(resp){ \nreturn ASQQ ,gate( \n\n\nAdvanced Async Patterns | 255 \n\n\n\nrequest( \"http://some.url.2/?v=\" + resp ), \nrequest( \"http://some.url.3/?v=\" + resp ) \n\n); \n\n} ) \n\n.val( function STEP3( rl,r2){ return rl + r2; } ) \n\n.val( function(msg){ \nconsole.log( msg ); \n\n} ); \n\nMoreover, step 2 could have even been expressed as: \n\n,gate( \n\nfunction STEP2a(done,resp) {","metadata":{"loc":{"lines":{"from":120823,"to":120866}}}}],["1523",{"pageContent":".val( function STEP3( rl,r2){ return rl + r2; } ) \n\n.val( function(msg){ \nconsole.log( msg ); \n\n} ); \n\nMoreover, step 2 could have even been expressed as: \n\n,gate( \n\nfunction STEP2a(done,resp) { \n\nrequest( \"http://some.url.2/?v=\" + resp ) \n\n.pipe( done ); \n\n}. \n\nfunction STEP2b(done,resp) { \n\nrequest( \"http://some.url.3/?v=\" + resp ) \n\n.pipe( done ); \n\n} \n\n) \n\nSo, why would we go to the trouble of expressing our flow control as \nan iterable sequence in a ASQ#runner(.. ) step, when it seems like a \nsimpler/flatter asynquence chain does the job well? \n\nBecause the iterable sequence form has an important trick up its \nsleeve that gives us more capability. Read on. \n\nExtending Iterable Sequences \n\nGenerators, normal asynquence sequences, and Promise chains are \nall eagerly evaluated —whatever flow control is expressed initially is \nthe fixed flow that will be followed.","metadata":{"loc":{"lines":{"from":120866,"to":120906}}}}],["1524",{"pageContent":"Generators, normal asynquence sequences, and Promise chains are \nall eagerly evaluated —whatever flow control is expressed initially is \nthe fixed flow that will be followed. \n\nHowever, iterable sequences are lazily evaluated, which means that \nduring execution of the iterable sequence, you can extend the \nsequence with more steps if desired. \n\n\n\nYou can only append to the end of an iterable \nsequence, not inject into the middle of the \nsequence. \n\n\nLet’s first look at a simpler (synchronous) example of that capability \nto get familiar with it: \n\n\n256 | Appendix B: Advanced Async Patterns \n\n\n\n\n\nfunction double(x) { \n\nx *= 2; \n\n// should we keep extending? \nif (x < 500) { \n\nisq.then( double ); \n\n} \n\nreturn x; \n\n} \n\n// setup single-step iterable sequence \nvar isq = ASQ.iterableQ . then( double ); \n\nfor (var v = 10, ret; \n\n(ret = isq.next( v )) && ! ret.done; \n\n) { \n\nv = ret.value; \nconsole.log( v ); \n\n}","metadata":{"loc":{"lines":{"from":120906,"to":120958}}}}],["1525",{"pageContent":"} \n\n// setup single-step iterable sequence \nvar isq = ASQ.iterableQ . then( double ); \n\nfor (var v = 10, ret; \n\n(ret = isq.next( v )) && ! ret.done; \n\n) { \n\nv = ret.value; \nconsole.log( v ); \n\n} \n\nThe iterable sequence starts out with only one defined step \n(isq.then(double)), but the sequence keeps extending itself under \ncertain conditions (x < 500). Both asynquence sequences and \nPromise chains technically can do something similar, but we’ll see in \na little bit why their capability is insufficient. \n\nThough this example is rather trivial and could otherwise be \nexpressed with a while loop in a generator, we’ll consider more \nsophisticated cases. \n\nFor instance, you could examine the response from an Ajax request \nand if it indicates that more data is needed, conditionally insert \nmore steps into the iterable sequence to make the additional \nrequest(s). Or you could conditionally add a value-formatting step \nto the end of your Ajax handling. \n\nConsider:","metadata":{"loc":{"lines":{"from":120958,"to":120990}}}}],["1526",{"pageContent":"Consider: \n\nvar steps = ASQ.iterableQ \n\n.then( function STEPl(token){ \n\nvar url = token.messages[0] . url; \n\n// was an additional formatting step provided? \nif (token.nessages[0].format) { \n\nsteps.then( token.messages[0].format ); \n\n1 \n\nreturn request( url ); \n\n\nAdvanced Async Patterns | 257 \n\n\n\n.then( function STEP2(resp){ \n\n// add another Ajax request to the sequence? \nif (/xl/.test( resp )) { \n\nsteps.then( function STEP5(text){ \nreturn request( \n\n\"http://sorne.url.4/?v=\" + text \n\n); \n\n} ); \n\n} \n\nreturn ASQ().gate( \n\nrequest( \"http://some.url.2/?v=\" + resp ), \nrequest( \"http://sone.url.3/?v=\" + resp ) \n\n); \n\n} ) \n\n.then( function STEP3(rl,r2){ return rl + r2; } ); \n\nYou can see two different places where we conditionally extend \nsteps with steps.then(.. ). And to run this steps iterable \nsequence, we just wire it into our main program flow with an asyn- \nquence sequence (called main here) using ASQ#runner(..): \n\nvar nain = ASQ( {","metadata":{"loc":{"lines":{"from":120990,"to":121044}}}}],["1527",{"pageContent":"var nain = ASQ( { \n\nurl: \"http://some.url.1\" , \nfornat: function STEP4(text){ \nreturn text.tollpperCase(); \n\n} \n\n} ) \n\n.runner( steps ) \n\n.val( function(nsg){ \nconsole.tog( nsg ); \n\n} ); \n\nCan the flexibility (conditional behavior) of the steps iterable \nsequence be expressed with a generator? Kind of, but we have to \nrearrange the logic in a slightly awkward way: \n\nfunction *steps(token) { \n\n// STEP 1 \n\nvar resp = yield request( token.nessages[0].url ); \n\n// STEP 2 \n\nvar rvals = yield ASQ().gate( \n\nrequest( \"http://some.url.2/?v=\" + resp ), \nrequest( \"http://some.url.3/?v=\" + resp ) \n\n); \n\n\n// STEP 3 \n\n\n258 | Appendix B: Advanced Async Patterns \n\n\n\n\nvar text = rvals[0] + rvals[l]; \n\n\n// STEP 4 \n\n// was an additional formatting step provided? \nif ( token.messages[0].format) { \n\ntext = yield token.messages[0].format! text ); \n\n} \n\n// STEP 5 \n\n// need another Ajax request added to the sequence? \nif (/foobar/.test( resp )) { \ntext = yield request( \n\n\"http://some.url.4/?v=\" + text \n\n);","metadata":{"loc":{"lines":{"from":121044,"to":121109}}}}],["1528",{"pageContent":"} \n\n// STEP 5 \n\n// need another Ajax request added to the sequence? \nif (/foobar/.test( resp )) { \ntext = yield request( \n\n\"http://some.url.4/?v=\" + text \n\n); \n\n} \n\nreturn text; \n\n} \n\n// note: '*steps()' can be run by the same 'ASQ' sequence \n// as 'steps' was previously \n\nSetting aside the already identified benefits of the sequential, \nsynchronous-looking syntax of generators (see Chapter 4), the \nsteps logic had to be reordered in the *steps() generator form, to \nfake the dynamicism of the extendable iterable sequence steps. \n\nWhat about expressing the functionality with Promises or sequen¬ \nces, though? You can do something like this: \n\nvar steps = something! • • ) \n\n. then( .. ) \n\n.then( function! •• ){ \n\n// ■■ \n\n// extending the chain, right? \nsteps = steps.then( •• ); \n\n// •• \n\n}) \n\n.then! .. );","metadata":{"loc":{"lines":{"from":121109,"to":121153}}}}],["1529",{"pageContent":"var steps = something! • • ) \n\n. then( .. ) \n\n.then( function! •• ){ \n\n// ■■ \n\n// extending the chain, right? \nsteps = steps.then( •• ); \n\n// •• \n\n}) \n\n.then! .. ); \n\nThe problem is subtle but important to grasp. So, consider trying to \nwire up our steps Promise chain into our main program flow — this \ntime expressed with Promises instead of asynquence: \n\nvar main = Promise.resolve! { \nurl: \"http://some.url.1\" , \nformat: function STEP4(text){ \nreturn text.toUpperCaseQ; \n\n} \n\n\nAdvanced Async Patterns | 259 \n\n\n\n} ) \n\n. then( function( ..){ \n\nreturn steps; // hint! \n\n} ) \n\n.val( function(msg){ \nconsole.log( msg ); \n\n} ); \n\nCan you spot the problem now? Look closely! \n\nThere’s a race condition for sequence steps ordering. When you \nreturn steps, at that moment steps might be the originally \ndefined Promise chain, or it might now point to the extended \nPromise chain via the steps = steps. then(..) call, depending on \nwhat order things happen. \n\nHere are the two possible outcomes:","metadata":{"loc":{"lines":{"from":121153,"to":121207}}}}],["1530",{"pageContent":"Here are the two possible outcomes: \n\n\n• If steps is still the original Promise chain, once it’s later “exten¬ \nded” by steps = steps. then( ..), that extended promise on \nthe end of the chain is not considered by the main flow, as it’s \nalready tapped the steps chain. This is the unfortunately limit¬ \ning eager evaluation. \n\n• If steps is already the extended Promise chain, it works as we \nexpect in that the extended promise is what main taps. \n\n\nOther than the obvious fact that a race condition is intolerable, the \nfirst case is the concern; it illustrates eager evaluation of the Promise \nchain. By contrast, we easily extended the iterable sequence without \nsuch issues, because iterable sequences are lazily evaluated. \n\nThe more dynamic you need your flow control, the more iterable \nsequences will shine. \n\n\n\nCheck out more information and examples of \niterable sequences on the asynquence site. \n\n\nEvent Reactive","metadata":{"loc":{"lines":{"from":121207,"to":121234}}}}],["1531",{"pageContent":"The more dynamic you need your flow control, the more iterable \nsequences will shine. \n\n\n\nCheck out more information and examples of \niterable sequences on the asynquence site. \n\n\nEvent Reactive \n\nIt should be obvious from (at least!) Chapter 3 that Promises are a \nvery powerful tool in your async toolbox. But one thing that’s \nclearly lacking is in their capability to handle streams of events, as a \n\n\n260 | Appendix B: Advanced Async Patterns \n\n\n\n\n\n\nPromise can only be resolved once. And frankly, this exact same \nweakness is true of plain asynquence sequences as well. \n\nConsider a scenario where you want to fire off a series of steps every \ntime a certain event is fired. A single Promise or sequence cannot \nrepresent all occurrences of that event. So, you have to create a \nwhole new Promise chain (or sequence) for each event occurrence, \nsuch as: \n\nlistener.on( \"foobar\", function(data){ \n\n// create a new event handling promise chain \nnew Promlse( function(resolve,reject){ \n\n// ••","metadata":{"loc":{"lines":{"from":121234,"to":121271}}}}],["1532",{"pageContent":"listener.on( \"foobar\", function(data){ \n\n// create a new event handling promise chain \nnew Promlse( function(resolve,reject){ \n\n// •• \n\n} ) \n\n. then( .. ) \n\n• then( .. ); \n\n\n} ); \n\nThe base functionality we need is present in this approach, but it’s \nfar from a desirable way to express our intended logic. There are \ntwo separate capabilities conflated in this paradigm: the event listen¬ \ning, and responding to the event; separation of concerns would \nimplore us to separate out these capabilities. \n\nThe carefully observant reader will see this problem as somewhat \nsymmetrical to the problems we detailed with callbacks in Chap¬ \nter 2; it’s kind of an inversion of control problem. \n\nImagine uninverting this paradigm, like so: \n\nvar observable = listener. on( \"foobar\" ); \n\n// later \nobservable \n. then( .. ) \n\n• then( .. ); \n\n// elsewhere \nobservable \n. then( .. ) \n\n• then( .. );","metadata":{"loc":{"lines":{"from":121271,"to":121311}}}}],["1533",{"pageContent":"var observable = listener. on( \"foobar\" ); \n\n// later \nobservable \n. then( .. ) \n\n• then( .. ); \n\n// elsewhere \nobservable \n. then( .. ) \n\n• then( .. ); \n\nThe observable value is not exactly a Promise, but you can observe \nit much like you can observe a Promise, so it’s closely related. In \nfact, it can be observed many times, and it will send out notifications \nevery time its event (\"foobar\") occurs. \n\n\nAdvanced Async Patterns | 261","metadata":{"loc":{"lines":{"from":121311,"to":121331}}}}],["1534",{"pageContent":"Advanced Async Patterns | 261 \n\n\n\n\nThis pattern I’ve just illustrated is a massive sim¬ \nplification of the concepts and motivations \nbehind reactive programming (RP), which has \nbeen implemented/expounded upon by several \ngreat projects and languages. A variation on RP \nis functional reactive programming (FRP), \nwhich refers to applying functional program¬ \nming techniques (immutability, referential \nintegrity, etc.) to streams of data. “Reactive” \nrefers to spreading this functionality out over \ntime in response to events. The interested reader \nshould consider studying “Reactive Observa¬ \nbles” in the fantastic “Reactive Extensions” \nlibrary (“RxJS” for JavaScript) by Microsoft; it’s \nmuch more sophisticated and powerful than I’ve \njust shown. Also, Andre Staltz has an excellent \nwrite-up that pragmatically lays out RP in con¬ \ncrete examples. \n\n\nES7 Observables","metadata":{"loc":{"lines":{"from":121331,"to":121356}}}}],["1535",{"pageContent":"ES7 Observables \n\nAt the time of this writing, there’s an early ES7 proposal for a new \ndata type called “Observable”, which in spirit is similar to what \nwe’ve laid out here, but is definitely more sophisticated. \n\nThe notion of this kind of Observable is that the way you “sub¬ \nscribe” to the events from a stream is to pass in a generator— \nactually the iterator is the interested party—whose next(..) \nmethod will be called for each event. \n\nYou could imagine it sort of like this: \n\n// ' someEventStream' is a stream of events, like from \n// mouse clicks, and the like. \n\nvar observer = new Observer( soneEventStrean, function*(){ \nwhile (var evt = yield) { \nconsole.log( evt ); \n\n} \n\n} );","metadata":{"loc":{"lines":{"from":121356,"to":121378}}}}],["1536",{"pageContent":"var observer = new Observer( soneEventStrean, function*(){ \nwhile (var evt = yield) { \nconsole.log( evt ); \n\n} \n\n} ); \n\nThe generator you pass in will yield pause the while loop waiting \nfor the next event. The iterator attached to the generator instance \nwill have its next(..) called each time someEventStream has a new \nevent published, and so that event data will resume your generator/ \niterator with the evt data. \n\n\n262 | Appendix B: Advanced Async Patterns \n\n\n\n\n\nIn the subscription to events functionality here, it’s the iterator part \nthat matters, not the generator. So conceptually you could pass in \npractically any iterable, including ASQ.iterableQ iterable sequen¬ \nces.","metadata":{"loc":{"lines":{"from":121378,"to":121402}}}}],["1537",{"pageContent":"Interestingly, there are also proposed adapters to make it easy to \nconstruct Observables from certain types of streams, such as \nfronEvent(..) for DOM events. If you look at a suggested imple¬ \nmentation of fromEvent(..) in the earlier linked ES7 proposal, it \nlooks an awful lot like the ASQ. react(..) well see in the next sec¬ \ntion. \n\nOf course, these are all early proposals, so what shakes out may very \nwell look/behave differently than shown here. But it’s exciting to see \nthe early alignments of concepts across different libraries and lan¬ \nguage proposals! \n\nReactive Sequences \n\nWith that crazy brief summary of Observables (and F/RP) as our \ninspiration and motivation, I will now illustrate an adaptation of a \nsmall subset of “Reactive Observables,” which I call “Reactive \nSequences.” \n\nFirst, let’s start with how to create an Observable, using an asyn- \nquence plug-in utility called react(.. \n\nvar observable = ASQ.react( function setup(next){ \nlistener.on( \"foobar\", next );","metadata":{"loc":{"lines":{"from":121404,"to":121427}}}}],["1538",{"pageContent":"First, let’s start with how to create an Observable, using an asyn- \nquence plug-in utility called react(.. \n\nvar observable = ASQ.react( function setup(next){ \nlistener.on( \"foobar\", next ); \n\n} ); \n\nNow, let’s see how to define a sequence that “reacts”—in F/RP, this \nis typically called “subscribing”—to that observable: \n\nobservable \n■seq( .. ) \n\n. then( .. ) \n\n• val( .. ); \n\nSo, you just define the sequence by chaining off the Observable. \nThat’s easy, huh? \n\nIn F/RP, the stream of events typically channels through a set of \nfunctional transforms, like scan(..), map(..), reduce(..), and so \non. With reactive sequences, each event channels through a new \ninstance of the sequence. Let’s look at a more concrete example: \n\n\nAdvanced Async Patterns | 263 \n\n\n\nASQ.react( function setup(next){ \n\ndocument. getElementById( \"mybtn\" ) \n\n.addEventListener( \"click\", next, false ); \n\n} ) \n\n.seq( function(evt){ \n\nvar btnID = evt.target. id; \nreturn request( \n\n\"http://some.url.l/?id=\" + btnID","metadata":{"loc":{"lines":{"from":121427,"to":121471}}}}],["1539",{"pageContent":"document. getElementById( \"mybtn\" ) \n\n.addEventListener( \"click\", next, false ); \n\n} ) \n\n.seq( function(evt){ \n\nvar btnID = evt.target. id; \nreturn request( \n\n\"http://some.url.l/?id=\" + btnID \n\n); \n\n} ) \n\n.val( function(text){ \nconsole.log ( text ); \n\n} ); \n\nThe “reactive” portion of the reactive sequence comes from assign¬ \ning one or more event handlers to invoke the event trigger (calling \nnext(..)). \n\nThe “sequence” portion of the reactive sequence is exactly like the \nsequences we’ve already explored: each step can be whatever asyn¬ \nchronous technique makes sense, from continuation callback to \nPromise to generator. \n\nOnce you set up a reactive sequence, it will continue to initiate \ninstances of the sequence as long as the events keep firing. If you \nwant to stop a reactive sequence, you can call stop(). \n\nIf a reactive sequence is stopQped, you likely want the event han¬ \ndler^) to be unregistered as well; you can register a teardown han¬ \ndler for this purpose:","metadata":{"loc":{"lines":{"from":121471,"to":121508}}}}],["1540",{"pageContent":"If a reactive sequence is stopQped, you likely want the event han¬ \ndler^) to be unregistered as well; you can register a teardown han¬ \ndler for this purpose: \n\nvar sq = ASQ.react( function setup(next,registerTeardown){ \nvar btn = document. getElementById( \"mybtn\" ); \n\nbtn . addEventListener( \"click\", next, false ); \n\n// will be called once 'sq.stop()' is called \nregisterTeardown( function(){ \n\nbtn . removeEventListener( \"click\", next, false ); \n\n} ); \n\n} ) \n\n■ seq( .. ) \n\n. then( .. ) \n\n• val( .. ); \n\n// later \nsq.stop(); \n\n\n264 | Appendix B: Advanced Async Patterns \n\n\n\n\n\nThe this binding reference inside the \nsetup(..) handler is the same sq reactive \nsequence, so you can use the this reference to \nadd to the reactive sequence definition, call \nmethods like stop( ), and so on. \n\n\nHere’s an example from the Node.js world, using reactive sequences \nto handle incoming HTTP requests: \n\nvar server = http.createServerQ; \nserver.iisten (8000); \n\n// reactive observer","metadata":{"loc":{"lines":{"from":121508,"to":121555}}}}],["1541",{"pageContent":"Here’s an example from the Node.js world, using reactive sequences \nto handle incoming HTTP requests: \n\nvar server = http.createServerQ; \nserver.iisten (8000); \n\n// reactive observer \n\nvar request = ASQ.react( function setup(next,registerTeardown){ \nserver . addListener( \"request\", next ); \nserver . addListener( \"close\", this. stop ); \n\nregisterTeardown( functionQf \n\nserver . removeListener( \"request\", next ); \nserver . removeListener( \"close\", request.stop ); \n\n} ); \n\n1 ); \n\n// respond to requests \nrequest \n\n.seq( pullFromDatabase ) \n\n.val( function(data,res){ \nres.end( data ); \n\n} ); \n\n// node teardown \n\nprocess. on( \"SIGINT\", request.stop ); \n\nThe next(..) trigger can also adapt to node streams easily, using \nonStream(..) and unStream(..): \n\nASQ.react( function setup(next){ \n\nvar fstream = fs.createReadStream( \"/some/file\" ); \n\n// pipe the stream's \"data\" event to ~next(..)' \nnext.onStream( fstream );","metadata":{"loc":{"lines":{"from":121555,"to":121598}}}}],["1542",{"pageContent":"ASQ.react( function setup(next){ \n\nvar fstream = fs.createReadStream( \"/some/file\" ); \n\n// pipe the stream's \"data\" event to ~next(..)' \nnext.onStream( fstream ); \n\n// listen for the end of the stream \nfstream. on( \"end\", function(){ \nnext.unStream( fstream ); \n\n1 ); \n\n} ) \n\n■ seq( .. ) \n\n. then( .. ) \n\n■val( .. ); \n\n\nAdvanced Async Patterns | 265 \n\n\n\n\nYou can also use sequence combinations to compose multiple reac¬ \ntive sequence streams: \n\nvar sql = ASQ.react( .. ).seq( .. ).then( .. ); \nvar sq2 = ASQ.react( .. ).seq( .. ).then( .. ); \n\nvar sq3 = ASQ.react( ..) \n\n■gate( \n\nsql, \n\nsq2 \n\n) \n\n• then( .. ); \n\nThe main takeaway is that ASQ. react(..) is a lightweight adapta¬ \ntion of F/RP concepts, enabling the wiring of an event stream to a \nsequence, hence the term “reactive sequence.” Reactive sequences \nare generally capable enough for basic reactive uses.","metadata":{"loc":{"lines":{"from":121598,"to":121646}}}}],["1543",{"pageContent":"Here’s an example of using ASQ. react( ..) in \nmanaging UI state, and another example of han¬ \ndling HTTP request/response streams with \nASQ. react(..). \n\n\nGenerator Coroutine \n\nHopefully Chapter 4 helped you get pretty familiar with ES6 genera¬ \ntors. In particular, we want to revisit the “Generator Concurrency” \ndiscussion, and push it even further. \n\nWe imagined a runAll(..) utility that could take two or more gen¬ \nerators and run them concurrently, letting them cooperatively \nyield control from one to the next, with optional message passing. \n\nIn addition to being able to run a single generator to completion, \nthe ASQ#runner(..) we discussed in Appendix A is a similar imple¬ \nmentation of the concepts of runAll( ..), which can run multiple \ngenerators concurrently to completion. \n\nSo let’s see how we can implement the concurrent Ajax scenario \nfrom Chapter 4: \n\nASQ( \n\n\"http://some.url.2\" \n\n) \n\n. runner( \n\nfunction* ( token ){ \n\n// transfer control","metadata":{"loc":{"lines":{"from":121650,"to":121684}}}}],["1544",{"pageContent":"So let’s see how we can implement the concurrent Ajax scenario \nfrom Chapter 4: \n\nASQ( \n\n\"http://some.url.2\" \n\n) \n\n. runner( \n\nfunction* ( token ){ \n\n// transfer control \n\n\n266 | Appendix B: Advanced Async Patterns \n\n\n\n\n\nyield token; \n\n\nvar urll = token .messages[0] ; // \"http://sone.url.1\" \n\n// clear out Messages to start fresh \ntoken.messages = []; \n\nvar pi = request( urll ); \n\n// transfer control \nyield token; \n\ntoken.messages. push( yield pi ); \n\n}. \n\nfunction* ( token ){ \n\nvar url2 = token .messages[0] ; // \"http://sone.url.2\" \n\n// Message pass and transfer control \ntoken. messages[0] = \"http://some.url.1\" ; \nyield token; \n\nvar p2 = request( url2 ); \n\n// transfer control \nyield token; \n\ntoken.messages. push( yield p2 ); \n\n// pass along results to next sequence step \nreturn token.messages; \n\n} \n\n) \n\n.val( function ( res ){ \n\n// 'res[0]' cones fron \"http://sone.url.1\" \n\n// 'res[l]' cones fron \"http://sone.url.2\" \n\n} );","metadata":{"loc":{"lines":{"from":121684,"to":121751}}}}],["1545",{"pageContent":"} \n\n) \n\n.val( function ( res ){ \n\n// 'res[0]' cones fron \"http://sone.url.1\" \n\n// 'res[l]' cones fron \"http://sone.url.2\" \n\n} ); \n\nThe main differences between ASQ#runner(.. ) and runAll(.. ) are \nas follows: \n\n• Each generator (coroutine) is provided an argument we call \ntoken, which is the special value to yield when you want to \nexplicitly transfer control to the next coroutine. \n\n• token.messages is an array that holds any messages passed in \nfrom the previous sequence step. It’s also a data structure that \nyou can use to share messages between coroutines. \n\n\nAdvanced Async Patterns | 267 \n\n\n\n\n\n• yielding a Promise (or sequence) value does not transfer con¬ \ntrol, but instead pauses the coroutine processing until that value \nis ready. \n\n• The last returned or yielded value from the coroutine process¬ \ning run will be forward passed to the next step in the sequence. \n\nIt’s also easy to layer helpers on top of the base ASQ#runner(..) \nfunctionality to suit different uses.","metadata":{"loc":{"lines":{"from":121751,"to":121789}}}}],["1546",{"pageContent":"It’s also easy to layer helpers on top of the base ASQ#runner(..) \nfunctionality to suit different uses. \n\nState Machines \n\nOne example that may be familiar to many programmers is state \nmachines. You can, with the help of a simple cosmetic utility, create \nan easy-to-express state machine processor. \n\nLet’s imagine such a utility. We’ll call it state( ..), and will pass it \ntwo arguments: a state value and a generator that handles that state. \nstate(..) will do the dirty work of creating and returning an \nadapter generator to pass to ASQ#runner(..). \n\nConsider: \n\nfunction state(vat,handler) { \n\n// nake a coroutine handler for this state \nreturn function*(token) { \n\n// state transition handler \nfunction transition(to) { \ntoken. messages[0] = to; \n\n} \n\n// set initial state (if none set yet) \nif (token.messages.length < 1) { \ntoken. messages[0] = val; \n\n} \n\n// keep going until final state (false) is reached \nwhile (token.messages[0] !== false) {","metadata":{"loc":{"lines":{"from":121789,"to":121823}}}}],["1547",{"pageContent":"// set initial state (if none set yet) \nif (token.messages.length < 1) { \ntoken. messages[0] = val; \n\n} \n\n// keep going until final state (false) is reached \nwhile (token.messages[0] !== false) { \n\n// current state notches this handler? \nif (token. messages[0] === val) { \n\n// delegate to state handler \nyield *handler( transition ); \n\n} \n\n// transfer control to another state handler? \nif (token. messages[0] !== false) { \nyield token; \n\n} \n\n} \n\n\n268 | Appendix B: Advanced Async Patterns \n\n\n\n\n} \n\n\n}; \n\n\nIf you look closely, you’ll see that state( ..) returns back a genera¬ \ntor that accepts a token, and then it sets up a while loop that will \nrun until the state machine reaches its final state (which we arbitrar¬ \nily pick as the false value); that’s exactly the kind of generator we \nwant to pass to ASQ#runner(..)!","metadata":{"loc":{"lines":{"from":121823,"to":121864}}}}],["1548",{"pageContent":"We also arbitrarily reserve the token .messages[0] slot as the place \nwhere the current state of our state machine will be tracked, which \nmeans we can even seed the initial state as the value passed in from \nthe previous step in the sequence. \n\nHow do we use the state(.. ) helper along with ASQ#runner(..)? \nvar prevState; \n\nASQ( \n\n/* optional: initial state value */ \n\n2 \n\n) \n\n// run our state machine \n\n// transitions: 2 -> 3 -> 1 -> 3 -> false \n\n. runner( \n\n// state '1' handler \n\nstate( 1, function *stateOne(transltion){ \nconsole.log( \"in state 1\" ); \n\nprevState = 1; \n\nyield transition( 3 ); // goto state '3' \n\n} ), \n\n// state '2' handler \n\nstate( 2, function *stateTwo(transition){ \nconsole.log( \"in state 2\" ); \n\nprevState = 2; \n\nyield transition( 3 ); // goto state '3' \n\n} ), \n\n// state '3' handler \n\nstate( 3, function *stateThree(transition){ \nconsole.log( \"in state 3\" ); \n\nif (prevState === 2) { \nprevState = 3; \n\nyield transition( 1 ); // goto state '1' \n\n} \n\n//all done!","metadata":{"loc":{"lines":{"from":121866,"to":121922}}}}],["1549",{"pageContent":"state( 3, function *stateThree(transition){ \nconsole.log( \"in state 3\" ); \n\nif (prevState === 2) { \nprevState = 3; \n\nyield transition( 1 ); // goto state '1' \n\n} \n\n//all done! \n\n\nAdvanced Async Patterns | 269 \n\n\n\nelse { \n\nyield \"That's all folks!\"; \nprevState = 3; \n\nyield transition( false ); // terminal state \n\n} \n\n} ) \n\n) \n\n// state machine complete, so move on \n\n.val( function(msg){ \n\nconsole.log( msg ); // That's all folks! \n\n} ); \n\nIt’s important to note that the *stateOne(..), *stateTwo( ..), and \n*stateThree( ..) generators themselves are reinvoked each time \nthat state is entered, and they finish when you transition (..) to \nanother value. While not shown here, of course these state generator \nhandlers can be asynchronously paused by yielding Promises/ \nsequences/thunks.","metadata":{"loc":{"lines":{"from":121922,"to":121965}}}}],["1550",{"pageContent":"The underneath hidden generators produced by the state(..) \nhelper and actually passed to ASQ#runner( ..) are the ones that con¬ \ntinue to run concurrently for the length of the state machine, and \neach of them handles cooperatively yielding control to the next, \nand so on. \n\n\n\nSee this “ping pong” example for more illustra¬ \ntion of using cooperative concurrency with gen¬ \nerators driven by ASQ#runner(..). \n\n\nCommunicating Sequential Processes (CSP) \n\nCommunicating Sequential Processes (CSP) was first described by \nC. A. R. Hoare in a 1978 academic paper, and later covered in a 1985 \nbook of the same name. CSP describes a formal method for concur¬ \nrent “processes” to interact (communicate) during processing. \n\nYou may recall that we examined concurrent “processes” back in \nChapter 1, so our exploration of CSP here will build upon that \nunderstanding.","metadata":{"loc":{"lines":{"from":121967,"to":121989}}}}],["1551",{"pageContent":"You may recall that we examined concurrent “processes” back in \nChapter 1, so our exploration of CSP here will build upon that \nunderstanding. \n\nLike most great concepts in computer science, CSP is heavily stee¬ \nped in academic formalism, expressed as a process algebra. How¬ \never, I suspect symbolic algebra theorems won’t make much \n\n\n270 | Appendix B: Advanced Async Patterns \n\n\n\n\npractical difference to the reader, so we will want to find some other \nway of wrapping our brains around CSP. \n\nI will leave much of the formal description and proof of CSP to \nHoare’s work, and the many other fantastic writings since. Instead, \nwe will try to just briefly explain the idea of CSP in as unacademic \nand hopefully intuitively understandable a way as possible. \n\nMessage Passing","metadata":{"loc":{"lines":{"from":121989,"to":122011}}}}],["1552",{"pageContent":"Message Passing \n\nThe core principle in CSP is that all communication/interaction \nbetween otherwise independent processes must be through formal \nmessage passing. Perhaps counter to your expectations, CSP mes¬ \nsage passing is described as a synchronous action, where the sender \nprocess and the receiver process have to mutually be ready for the \nmessage to be passed. \n\nHow could such synchronous messaging possibly be related to asyn¬ \nchronous programming in JavaScript? \n\nThe concreteness of relationship comes from the nature of how ES6 \ngenerators are used to produce synchronous-looking actions that \nunder the covers can indeed either be synchronous or (more likely) \nasynchronous. \n\nIn other words, two or more concurrently running generators can \nappear to synchronously message each other while preserving the \nfundamental asynchrony of the system because each generator’s \ncode is paused (blocked), waiting on resumption of an asynchro¬ \nnous action. \n\nHow does this work?","metadata":{"loc":{"lines":{"from":122011,"to":122034}}}}],["1553",{"pageContent":"How does this work? \n\nImagine a generator (“process”) called “A” that wants to send a mes¬ \nsage to generator “B.” First, “A” yields the message (thus pausing \n“A”) to be sent to “B.” When “B” is ready and takes the message, “A” \nis then resumed (unblocked). \n\nSymmetrically, imagine a generator “A” that wants a message from \n“B.” “A” yields its request (thus pausing “A”) for the message from \n“B,” and once “B” sends a message, “A” takes the message and is \nresumed. \n\nOne of the more popular expressions of this CSP message passing \ntheory comes from ClojureScript’s core.async library, and also from \nthe go language. These takes on CSP embody the described commu- \n\n\nAdvanced Async Patterns | 271 \n\n\n\nnication semantics in a conduit that is opened between processes \ncalled a channel.","metadata":{"loc":{"lines":{"from":122034,"to":122056}}}}],["1554",{"pageContent":"Advanced Async Patterns | 271 \n\n\n\nnication semantics in a conduit that is opened between processes \ncalled a channel. \n\n\n\nThe term channel is used in part because there \nare modes in which more than one value can be \nsent at once into the buffer of the channel; this is \nsimilar to what you may think of as a stream. \nWe won’t go into depth about it here, but it can \nbe a very powerful technique for managing \nstreams of data. \n\n\nIn the simplest notion of CSP, a channel that we create between “A” \nand “B” would have a method called take(..) for blocking to \nreceive a value, and a method called put(.. ) for blocking to send a \nvalue. \n\nThis might look like: \nvar ch = channelQ; \n\nfunction *foo() { \n\nvar msg = yield take( ch ); \n\nconsole.log( msg ); \n\n} \n\nfunction *bar() { \n\nyield put( ch, \"Hello World\" ); \n\nconsole.log( \"message sent\" ); \n\n} \n\nrun( foo ); \nrun( bar ); \n\n// Hello World \n// \"nessage sent\"","metadata":{"loc":{"lines":{"from":122056,"to":122102}}}}],["1555",{"pageContent":"console.log( msg ); \n\n} \n\nfunction *bar() { \n\nyield put( ch, \"Hello World\" ); \n\nconsole.log( \"message sent\" ); \n\n} \n\nrun( foo ); \nrun( bar ); \n\n// Hello World \n// \"nessage sent\" \n\nCompare this structured, synchronous(-looking) message passing \ninteraction to the informal and unstructured message sharing that \nASQ#runner( ..) provides through the token .messages array and \ncooperative yielding. In essence, yield put( ..) is a single opera¬ \ntion that both sends the value and pauses execution to transfer con¬ \ntrol, whereas in earlier examples we did those as separate steps. \n\nMoreover, CSP stresses that you don’t really explicitly transfer con¬ \ntrol, but rather design your concurrent routines to block expecting \neither a value received from the channel, or to block expecting to try \n\n\n272 | Appendix B: Advanced Async Patterns \n\n\n\n\nto send a message on the channel. The blocking around receiving or \nsending messages is how you coordinate sequencing of behavior \nbetween the coroutines.","metadata":{"loc":{"lines":{"from":122102,"to":122139}}}}],["1556",{"pageContent":"to send a message on the channel. The blocking around receiving or \nsending messages is how you coordinate sequencing of behavior \nbetween the coroutines. \n\n\n\nFair warning: this pattern is very powerful but \nit’s also a little mind twisting to get used to at \nfirst. You will want to practice this a bit to get \nused to this new way of thinking about coordi¬ \nnating your concurrency. \n\n\nThere are several great libraries that have implemented this flavor of \nCSP in JavaScript, most notably js-csp, which James Long forked \nand has written extensively about. Also, it cannot be stressed \nenough how amazing the many writings of David Nolen are on the \ntopic of adapting ClojureScript’s go-style core.async CSP into JS \ngenerators. \n\nasynquence CSP emulation","metadata":{"loc":{"lines":{"from":122139,"to":122159}}}}],["1557",{"pageContent":"asynquence CSP emulation \n\nBecause we’ve been discussing async patterns here in the context of \nmy asynquence library, you might be interested to see that we can \nfairly easily add an emulation layer on top of ASQ#runner(.. ) gen¬ \nerator handling as a nearly perfect porting of the CSP API and \nbehavior. This emulation layer ships as an optional part of the \n“asynquence-contrib” package alongside asynquence. \n\nVery similar to the state( ..) helper from earlier, ASQ.csp.go(.. ) \ntakes a generator—in go/core.async terms, it’s known as a goroutine \n—and adapts it to use with ASQ#runner( ..) by returning a new gen¬ \nerator. \n\nInstead of being passed a token, your goroutine receives an initially \ncreated channel (ch) that all goroutines in this run will share. You \ncan create more channels (which is often quite helpful!) with \nASQ.csp.chan(..).","metadata":{"loc":{"lines":{"from":122159,"to":122176}}}}],["1558",{"pageContent":"In CSP, we model all asynchrony in terms of blocking on channel \nmessages, rather than blocking waiting for a Promise/sequence/ \nthunk to complete. \n\nSo, instead of yielding the Promise returned from request(..), \nrequest(..) should return a channel that you take(..) a value \n\n\nAdvanced Async Patterns | 273 \n\n\n\n\n\nfrom. In other words, a single-value channel is roughly equivalent in \nthis context/usage to a Promise/sequence. \n\nLet’s first make a channel-aware version of request! • • ): \n\nfunction request(url) { \n\nvar ch = ASQ.csp. channel!); \n\najax( url ).then( function(content){ \n\n// 'putAsync(..) ' is a version of 'put(..)' that \n// can be used outside of a generator. It returns \n// a promise for the operation's completion. We \n// don't use that promise here, but we could if \n// we needed to be notified when the value had \n// been 'take(..)'n. \n\nASQ.csp.putAsync( ch, content ); \n\n} ); \n\nreturn ch; \n\n}","metadata":{"loc":{"lines":{"from":122178,"to":122216}}}}],["1559",{"pageContent":"ASQ.csp.putAsync( ch, content ); \n\n} ); \n\nreturn ch; \n\n} \n\nFrom Chapter 3, “promisory” is a Promise-producing utility, “thun- \nkory” from Chapter 4 is a thunk-producing utility, and finally, in \nAppendix A we invented “sequory” for a sequence-producing util¬ \nity. \n\nNaturally, we need to coin a symmetric term here for a channel- \nproducing utility. So let’s unsurprisingly call it a “chanory” (“chan¬ \nnel” + “factory”). As an exercise for the reader, try your hand at \ndefining a channelify(.. ) utility similar to Pronise.wrap(..)/ \npronisifyC. .) (Chapter 3), thunkify(..) (Chapter 4), and \nASQ.wrap(..) (Appendix A). \n\nNow consider the concurrent Ajax example using asynquence- \nflavored CSP: \n\nASQ() \n\n. runner( \n\nASQ.csp. go( function*(ch){ \n\nyield ASQ.csp.put( ch, \"http://sone.url.2\" ); \n\nvar urll = yield ASQ.csp.take( ch ); \n\n// \"http://some. url. 1\" \n\nvar rest = yield ASQ.csp.take( request! urll ) ); \nyield ASQ.csp.put( ch, rest ); \n\n1 ), \n\nASQ.csp. go( functlon*(ch){","metadata":{"loc":{"lines":{"from":122216,"to":122256}}}}],["1560",{"pageContent":"var urll = yield ASQ.csp.take( ch ); \n\n// \"http://some. url. 1\" \n\nvar rest = yield ASQ.csp.take( request! urll ) ); \nyield ASQ.csp.put( ch, rest ); \n\n1 ), \n\nASQ.csp. go( functlon*(ch){ \n\nvar url2 = yield ASQ.csp.take( ch ); \n\n// \"http://some.url.2\" \n\n\n274 | Appendix B: Advanced Async Patterns \n\n\n\n\nyield ASQ.csp.put( ch, \"http://some.url.1\" ); \n\n\nvar res2 = yield ASQ.csp.take( request( url2 ) ); \nvar rest = yield ASQ.csp.take( ch ); \n\n// pass along results to next sequence step \nch.buffer_size = 2; \n\nASQ.csp.put( ch, rest ); \n\nASQ.csp.put( ch, res2 ); \n\n} ) \n\n) \n\n.val( function(resl,res2){ \n\n// 'rest' cones fron \"http://sone.url.1\" \n\n// 'res2' cones fron \"http://sone.url.2\" \n\n} );","metadata":{"loc":{"lines":{"from":122256,"to":122300}}}}],["1561",{"pageContent":"ASQ.csp.put( ch, rest ); \n\nASQ.csp.put( ch, res2 ); \n\n} ) \n\n) \n\n.val( function(resl,res2){ \n\n// 'rest' cones fron \"http://sone.url.1\" \n\n// 'res2' cones fron \"http://sone.url.2\" \n\n} ); \n\nThe message passing that trades the URL strings between the two \ngoroutines is pretty straightforward. The first goroutine makes an \nAjax request to the first URL, and that response is put onto the ch \nchannel. The second goroutine makes an Ajax request to the second \nURL, then gets the first response resl off the ch channel. At that \npoint, both responses resl and res2 are completed and ready. \n\nIf there are any remaining values in the ch channel at the end of the \ngoroutine run, they will be passed along to the next step in the \nsequence. So, to pass out message(s) from the final goroutine, \nput(.. ) them into ch. As shown, to avoid the blocking of those final \nput(..)s, we switch ch into buffering mode by setting its \nbuffer_size to 2 (default: 0).","metadata":{"loc":{"lines":{"from":122300,"to":122328}}}}],["1562",{"pageContent":"See many more examples of using asynquence- \nflavored CSP on this gist. \n\n\nReview \n\nPromises and generators provide the foundational building blocks \nupon which we can build much more sophisticated and capable \nasynchrony. \n\nasynquence has utilities for implementing iterable sequences, reac¬ \ntive sequences (“Observables”), concurrent coroutines, and even \nCSP goroutines. \n\n\nAdvanced Async Patterns | 275 \n\n\n\n\nThose patterns, combined with the continuation-callback and \nPromise capabilities, give asynquence a powerful mix of different \nasynchronous functionalities, all integrated in one clean async flow \ncontrol abstraction: the sequence. \n\n\n276 | Appendix B: Advanced Async Patterns \n\n\n\nAbout the Author \n\n\nKyle Simpson is an Open Web Evangelist from Austin, TX, who’s \npassionate about all things JavaScript. He’s an author, workshop \ntrainer, tech speaker, and OSS contributor/leader. \n\n\n\n\nYou Don't Know JS: \nES6 and Beyond \n\n\nKyle Simpson","metadata":{"loc":{"lines":{"from":122332,"to":122376}}}}],["1563",{"pageContent":"You Don't Know JS: \nES6 and Beyond \n\n\nKyle Simpson \n\n\nBeijing • Boston • Farnham • Sebastopol • Tokyo \n\n\nO'REILLY \n\n\n\n\nTable of Contents \n\n\nForeword. vii \n\nPreface. ix \n\n1. ES? Now & Future. 1 \n\nVersioning 2 \n\nTranspiling 3 \n\nReview 6 \n\n2. Syntax. 7 \n\nBlock-Scoped Declarations 7 \n\nSpread/Rest 15 \n\nDefault Parameter Values 18 \n\nDestructuring 23 \n\nObject Literal Extensions 38 \n\nTemplate Literals 47 \n\nArrow Functions 54 \n\nfor..of Loops 61 \n\nRegular Expressions 64 \n\nNumber Literal Extensions 72 \n\nUnicode 73 \n\nSymbols 80 \n\nReview 85 \n\n3. Organization. 87 \n\nIterators 87 \n\nGenerators 98 \n\n\niii \n\n\n\n\n\n\n\n\n\nModules \n\n116 \n\nClasses \n\n135 \n\nReview \n\n146 \n\nAsync Flow Control. \n\n. 147 \n\nPromises \n\n147 \n\nGenerators + Promises \n\n155 \n\nReview \n\n158 \n\nCollections. \n\n. 159 \n\nTypedArrays \n\n159 \n\nMaps \n\n165 \n\nWeakMaps \n\n169 \n\nSets \n\n170 \n\nWeakSets \n\n173 \n\nReview \n\n173 \n\nAPI Additions. \n\n. 175 \n\nArray \n\n175 \n\nObject \n\n186 \n\nMath \n\n190 \n\nNumber \n\n191 \n\nString \n\n194 \n\nReview \n\n197 \n\nMeta Programming.","metadata":{"loc":{"lines":{"from":122376,"to":122535}}}}],["1564",{"pageContent":"165 \n\nWeakMaps \n\n169 \n\nSets \n\n170 \n\nWeakSets \n\n173 \n\nReview \n\n173 \n\nAPI Additions. \n\n. 175 \n\nArray \n\n175 \n\nObject \n\n186 \n\nMath \n\n190 \n\nNumber \n\n191 \n\nString \n\n194 \n\nReview \n\n197 \n\nMeta Programming. \n\n.199 \n\nFunction Names \n\n200 \n\nMeta Properties \n\n202 \n\nWell-Known Symbols \n\n203 \n\nProxies \n\n210 \n\nReflect API \n\n224 \n\nFeature Testing \n\n228 \n\nTail Call Optimization (TCO) \n\n230 \n\nReview \n\n238 \n\nBeyond ES6. \n\n.241 \n\nasync functions \n\n242 \n\nObject.observe(..) \n\n245 \n\nExponentiation Operator \n\n249 \n\nObjects Properties and ... \n\n249 \n\nArray#includes(..) \n\n250 \n\n\niv | Table of Contents \n\n\n\n\n\n\n\n\nSIMD 251 \n\nWeb Assembly (WASM) 252 \n\nReview 254 \n\nA. Acknowledgments. 257 \n\n\nTable of Contents | v \n\n\n\n\nForeword \n\n\nKyle Simpson is a thorough pragmatist.","metadata":{"loc":{"lines":{"from":122535,"to":122668}}}}],["1565",{"pageContent":"250 \n\n\niv | Table of Contents \n\n\n\n\n\n\n\n\nSIMD 251 \n\nWeb Assembly (WASM) 252 \n\nReview 254 \n\nA. Acknowledgments. 257 \n\n\nTable of Contents | v \n\n\n\n\nForeword \n\n\nKyle Simpson is a thorough pragmatist. \n\nI can’t think of higher praise than this. To me, these are two of the \nmost important qualities that a software developer must have. That’s \nright: must, not should. Kyle’s keen ability to tease apart layers of the \nJavaScript programming language and present them in understand¬ \nable and meaningful portions is second to none.","metadata":{"loc":{"lines":{"from":122668,"to":122703}}}}],["1566",{"pageContent":"ES6 & Beyond will be familiar to readers of the You Don’t Know JS \nseries: they can expect to be deeply immersed in everything from the \nobvious, to the very subtle—revealing semantics that were either \ntaken for granted or never even considered. Until now, the You Don’t \nKnow JS book series has covered material that has at least some \ndegree of familiarity to its readers. They have either seen or heard \nabout the subject matter; they may even have experience with it. \nThis volume covers material that only a very small portion of the \nJavaScript developer community has been exposed to: the evolution¬ \nary changes to the language introduced in the ECMAScript 2015 \nLanguage Specification.","metadata":{"loc":{"lines":{"from":122705,"to":122715}}}}],["1567",{"pageContent":"Over the last couple years, I’ve witnessed Kyle’s tireless efforts to \nfamiliarize himself with this material to a level of expertise that is \nrivaled by only a handful of his professional peers. That’s quite a \nfeat, considering that at the time of this writing, the language speci¬ \nfication document hasn’t been formally published! But what I’ve said \nis true, and I’ve read every word that Kyle’s written for this book. I’ve \nfollowed every change, and each time, the content only gets better \nand provides yet a deeper level of understanding. \n\n\nVII \n\n\n\n\n\nThis book is about shaking up your sense of understanding by \nexposing you to the new and unknown. The intention is to evolve \nyour knowledge in step with your tools by bestowing you with new \ncapabilities. It exists to give you the confidence to fully embrace the \nnext major era of JavaScript programming. \n\n—Rick Waldron (@rwaldron), \nOpen Web Engineer at Bocoup \nEcma/TC39 Representative \nfor j Query \n\n\nviii | Foreword \n\n\n\nPreface","metadata":{"loc":{"lines":{"from":122717,"to":122749}}}}],["1568",{"pageContent":"—Rick Waldron (@rwaldron), \nOpen Web Engineer at Bocoup \nEcma/TC39 Representative \nfor j Query \n\n\nviii | Foreword \n\n\n\nPreface \n\n\nI’m sure you noticed, but “JS” in the series title is not an abbrevia¬ \ntion for words used to curse about JavaScript, though cursing at the \nlanguage’s quirks is something we can probably all identify with! \n\nFrom the earliest days of the Web, JavaScript has been a founda¬ \ntional technology that drives interactive experience around the con¬ \ntent we consume. While flickering mouse trails and annoying pop¬ \nup prompts may be where JavaScript started, nearly two decades \nlater, the technology and capability of JavaScript has grown many \norders of magnitude, and few doubt its importance at the heart of \nthe world’s most widely available software platform: the Web.","metadata":{"loc":{"lines":{"from":122749,"to":122772}}}}],["1569",{"pageContent":"But as a language, it has perpetually been a target for a great deal of \ncriticism, owing partly to its heritage but even more to its design \nphilosophy. Even the name evokes, as Brendan Eich once put it, \n“dumb kid brother” status next to its more mature older brother \nJava. But the name is merely an accident of politics and marketing. \nThe two languages are vastly different in many important ways. \n“JavaScript” is as related to “Java” as “Carnival” is to “Car.” \n\nBecause JavaScript borrows concepts and syntax idioms from sev¬ \neral languages, including proud C-style procedural roots as well as \nsubtle, less obvious Scheme/Lisp-style functional roots, it is exceed¬ \ningly approachable to a broad audience of developers, even those \nwith little to no programming experience. The “Hello World” of \nJavaScript is so simple that the language is inviting and easy to get \ncomfortable with in early exposure.","metadata":{"loc":{"lines":{"from":122772,"to":122786}}}}],["1570",{"pageContent":"While JavaScript is perhaps one of the easiest languages to get up \nand running with, its eccentricities make solid mastery of the lan¬ \nguage a vastly less common occurrence than in many other lan- \n\n\nIX \n\n\n\n\nguages. Where it takes a pretty in-depth knowledge of a language \nlike C or C++ to write a full-scale program, full-scale production \nJavaScript can, and often does, barely scratch the surface of what the \nlanguage can do. \n\nSophisticated concepts that are deeply rooted into the language tend \ninstead to surface themselves in seemingly simplistic ways, such as \npassing around functions as callbacks, which encourages the Java¬ \nScript developer to just use the language as-is and not worry too \nmuch about what’s going on under the hood.","metadata":{"loc":{"lines":{"from":150597,"to":150616}}}}],["1571",{"pageContent":"It is simultaneously a simple, easy-to-use language that has broad \nappeal, and a complex and nuanced collection of language mechan¬ \nics that without careful study will elude true understanding even for \nthe most seasoned of JavaScript developers. \n\nTherein lies the paradox of JavaScript, the Achilles’ heel of the lan¬ \nguage, the challenge we are presently addressing. Because JavaScript \ncan be used without understanding, the understanding of the lan¬ \nguage is often never attained. \n\nMission \n\nIf at every point that you encounter a surprise or frustration in Java¬ \nScript, your response is to add it to the blacklist (as some are accus¬ \ntomed to doing), you soon will be relegated to a hollow shell of the \nrichness of JavaScript. \n\nWhile this subset has been famously dubbed “The Good Parts,” I \nwould implore you, dear reader, to instead consider it the “The Easy \nParts,” “The Safe Parts,” or even “The Incomplete Parts.”","metadata":{"loc":{"lines":{"from":150616,"to":150635}}}}],["1572",{"pageContent":"While this subset has been famously dubbed “The Good Parts,” I \nwould implore you, dear reader, to instead consider it the “The Easy \nParts,” “The Safe Parts,” or even “The Incomplete Parts.” \n\nThis You Don’t Know JS series offers a contrary challenge: learn and \ndeeply understand all of JavaScript, even and especially “The Tough \nParts.” \n\nHere, we address head-on the tendency of JS developers to learn \n“just enough” to get by, without ever forcing themselves to learn \nexactly how and why the language behaves the way it does. Further¬ \nmore, we eschew the common advice to retreat when the road gets \nrough. \n\n\nx | Preface \n\n\n\n\n\nI am not content, nor should you be, at stopping once something \njust works and not really knowing why. I gently challenge you to \njourney down that bumpy “road less traveled” and embrace all that \nJavaScript is and can do. With that knowledge, no technique, no \nframework, no popular buzzword acronym of the week will be \nbeyond your understanding.","metadata":{"loc":{"lines":{"from":196437,"to":196463}}}}],["1573",{"pageContent":"These books each take on specific core parts of the language that are \nmost commonly misunderstood or under-understood, and dive very \ndeep and exhaustively into them. You should come away from read¬ \ning with a firm confidence in your understanding, not just of the \ntheoretical, but the practical “what you need to know” bits. \n\nThe JavaScript you know right now is probably parts handed down \nto you by others who’ve been burned by incomplete understanding. \nThat JavaScript is but a shadow of the true language. You don’t really \nknow JavaScript yet, but if you dig into this series, you will. Read on, \nmy friends. JavaScript awaits you. \n\nReview \n\nJavaScript is awesome. It’s easy to learn partially, and much harder to \nlearn completely (or even sufficiently). When developers encounter \nconfusion, they usually blame the language instead of their lack of \nunderstanding. These books aim to fix that, inspiring a strong \nappreciation for the language you can now, and should, deeply know.","metadata":{"loc":{"lines":{"from":196465,"to":196483}}}}],["1574",{"pageContent":"Many of the examples in this book assume \nmodern (and future-reaching) JavaScript engine \nenvironments, such as ES6. Some code may not \nwork as described if run in older (pre-ES6) \nengines. \n\n\nConventions Used in This Book \n\nThe following typographical conventions are used in this book: \n\nItalic \n\nIndicates new terms, URLs, email addresses, filenames, and file \nextensions. \n\n\nPreface | xi \n\n\n\n\n\n\nConstant width \n\nUsed for program listings, as well as within paragraphs to refer \nto program elements such as variable or function names, data¬ \nbases, data types, environment variables, statements, and key¬ \nwords. \n\nConstant width bold \n\nShows commands or other text that should be typed literally by \nthe user. \n\n\nConstant width italic \n\nShows text that should be replaced with user-supplied values or \nby values determined by context. \n\n\n\nThis element signifies a tip or suggestion. \n\n\n\nThis element signifies a general note. \n\n\nThis element indicates a warning or caution.","metadata":{"loc":{"lines":{"from":196487,"to":196538}}}}],["1575",{"pageContent":"This element signifies a tip or suggestion. \n\n\n\nThis element signifies a general note. \n\n\nThis element indicates a warning or caution. \n\n\nUsing Code Examples \n\nSupplemental material (code examples, exercises, etc.) is available \nfor download at http://bit.ly/ydkjs-es6beyond-code. \n\nThis book is here to help you get your job done. In general, if exam¬ \nple code is offered with this book, you may use it in your programs \nand documentation. You do not need to contact us for permission \nunless you’re reproducing a significant portion of the code. For \nexample, writing a program that uses several chunks of code from \nthis book does not require permission. Selling or distributing a CD- \nROM of examples from O’Reilly books does require permission. \nAnswering a question by citing this book and quoting example code \n\n\nxii | Preface","metadata":{"loc":{"lines":{"from":196538,"to":196563}}}}],["1576",{"pageContent":"xii | Preface \n\n\n\n\n\n\n\n\ndoes not require permission. Incorporating a significant amount of \nexample code from this book into your product’s documentation \ndoes require permission. \n\nWe appreciate, but do not require, attribution. An attribution usu¬ \nally includes the title, author, publisher, and ISBN. For example: \n“You Don’t Know JavaScript: ES6 & Beyond by Kyle Simpson \n(O’Reilly). Copyright 2016 Getify Solutions, Inc., \n978-1-491-90424-4.” \n\nIf you feel your use of code examples falls outside fair use or the per¬ \nmission given above, feel free to contact us at permis- \nsions@oreilly.com. \n\nSafari® Books Online \n\n\n^Safari \n\n\nSafari Books Online is an on-demand digital \nlibrary that delivers expert content in both \nbook and video form from the world’s lead¬ \ning authors in technology and business.","metadata":{"loc":{"lines":{"from":196563,"to":196595}}}}],["1577",{"pageContent":"^Safari \n\n\nSafari Books Online is an on-demand digital \nlibrary that delivers expert content in both \nbook and video form from the world’s lead¬ \ning authors in technology and business. \n\n\nTechnology professionals, software developers, web designers, and \nbusiness and creative professionals use Safari Books Online as their \nprimary resource for research, problem solving, learning, and certif¬ \nication training. \n\nSafari Books Online offers a range of plans and pricing for enter¬ \nprise, government, education, and individuals.","metadata":{"loc":{"lines":{"from":196595,"to":196610}}}}],["1578",{"pageContent":"Safari Books Online offers a range of plans and pricing for enter¬ \nprise, government, education, and individuals. \n\nMembers have access to thousands of books, training videos, and \nprepublication manuscripts in one fully searchable database from \npublishers like O’Reilly Media, Prentice Hall Professional, Addison- \nWesley Professional, Microsoft Press, Sams, Que, Peachpit Press, \nFocal Press, Cisco Press, John Wiley & Sons, Syngress, Morgan \nKaufmann, IBM Redbooks, Packt, Adobe Press, FT Press, Apress, \nManning, New Riders, McGraw-Hill, Jones & Bartlett, Course Tech¬ \nnology, and hundreds more. For more information about Safari \nBooks Online, please visit us online. \n\n\nPreface | xiii \n\n\n\n\n\nHow to Contact Us \n\nPlease address comments and questions concerning this book to the \npublisher: \n\nO’Reilly Media, Inc. \n\n1005 Gravenstein Highway North \nSebastopol, CA 95472 \n\n800-998-9938 (in the United States or Canada) \n\n707-829-0515 (international or local) \n\n707-829-0104 (fax)","metadata":{"loc":{"lines":{"from":213614,"to":213648}}}}],["1579",{"pageContent":"O’Reilly Media, Inc. \n\n1005 Gravenstein Highway North \nSebastopol, CA 95472 \n\n800-998-9938 (in the United States or Canada) \n\n707-829-0515 (international or local) \n\n707-829-0104 (fax) \n\nWe have a web page for this book, where we list errata, examples, \nand any additional information. You can access this page at http:// \nbit.ly/ydkjs-es6-beyond. \n\nTo comment or ask technical questions about this book, send email \nto bookquestions@oreilly.com. \n\nFor more information about our books, courses, conferences, and \nnews, see our website at http://www.oreilly.com. \n\nFind us on Facebook: http://facebook.com/oreilly \n\nFollow us on Twitter: http://twitter.com/oreillymedia \n\nWatch us on YouTube: http://www.youtube.com/oreillymedia \n\n\nxiv | Preface \n\n\n\nCHAPTER 1 \n\n\nES? Now & Future","metadata":{"loc":{"lines":{"from":213648,"to":213683}}}}],["1580",{"pageContent":"Follow us on Twitter: http://twitter.com/oreillymedia \n\nWatch us on YouTube: http://www.youtube.com/oreillymedia \n\n\nxiv | Preface \n\n\n\nCHAPTER 1 \n\n\nES? Now & Future \n\n\nBefore you dive into this book, you should have a solid working pro¬ \nficiency over JavaScript up to the most recent standard (at the time \nof this writing), which is commonly called ES5 (technically ES 5.1). \nHere, we plan to talk squarely about the upcoming ES6, as well as \ncast our vision beyond to understand how JS will evolve moving \nforward. \n\nIf you are still looking for confidence with JavaScript, I highly rec¬ \nommend you read the other titles in this series first: \n\n• Up & Going: Are you new to programming and JS? This is the \nroadmap you need to consult as you start your learning journey. \n\n• Scope & Closures: Did you know that JS lexical scope is based on \ncompiler (not interpreter!) semantics? Can you explain how clo¬ \nsures are a direct result of lexical scope and functions as values?","metadata":{"loc":{"lines":{"from":213683,"to":213713}}}}],["1581",{"pageContent":"• this & Object Prototypes: Can you recite the four simple rules for \nhow this is bound? Have you been muddling through fake \n“classes” in JS instead of adopting the simpler “behavior delega¬ \ntion” design pattern? Ever heard of objects linked to other objects \n(OLOO)? \n\n• Types & Grammar: Do you know the built-in types in JS, and \nmore importantly, do you know how to properly and safely use \ncoercion between types? How comfortable are you with the \nnuances of JS grammar/syntax? \n\n• Async & Performance: Are you still using callbacks to manage \nyour asynchrony? Can you explain what a promise is and \n\n\n1 \n\n\n\n\nwhy/how it solves “callback hell”? Do you know how to use gen¬ \nerators to improve the legibility of async code? What exactly \nconstitutes mature optimization of JS programs and individual \noperations?","metadata":{"loc":{"lines":{"from":213715,"to":213738}}}}],["1582",{"pageContent":"If you’ve already read all those titles and you feel pretty comfortable \nwith the topics they cover, it’s time we dive into the evolution of JS \nto explore all the changes coming not only soon but farther over the \nhorizon. \n\nUnlike ES5, ES6 is not just a modest set of new APIs added to the \nlanguage. It incorporates a whole slew of new syntactic forms, some \nof which may take quite a bit of getting used to. There’s also a variety \nof new organization forms and new API helpers for various data \ntypes. \n\nES6 is a radical jump forward for the language. Even if you think \nyou know JS in ES5, ES6 is full of new stuff you don’t know yet, so \nget ready! This book explores all the major themes of ES6 that you \nneed to get up to speed on, and even gives you a glimpse of future \nfeatures coming down the track that you should be aware of.","metadata":{"loc":{"lines":{"from":213740,"to":213755}}}}],["1583",{"pageContent":"All code in this book assumes an ES6+ environ¬ \nment. At the time of this writing, ES6 support \nvaries quite a bit in browsers and JS environ¬ \nments (like Node.js), so your mileage may vary. \n\n\nVersioning \n\nThe JavaScript standard is referred to officially as “ECMAScript” \n(abbreviated “ES”), and up until just recently has been versioned \nentirely by ordinal number (i.e., “5” for “5th edition”). \n\nThe earliest versions, ESI and ES2, were not widely known or \nimplemented. ES3 was the first widespread baseline for JavaScript, \nand constitutes the JavaScript standard for browsers like IE6-8 and \nolder Android 2.x mobile browsers. For political reasons beyond \nwhat we’ll cover here, the ill-fated ES4 never came about. \n\nIn 2009, ES5 was officially finalized (later ES5.1 in 2011), and settled \nas the widespread standard for JS for the modern revolution and \nexplosion of browsers, such as Firefox, Chrome, Opera, Safari, and \nmany others. \n\n\n2 | Chapter 1: ES? Now & Future","metadata":{"loc":{"lines":{"from":213759,"to":213783}}}}],["1584",{"pageContent":"2 | Chapter 1: ES? Now & Future \n\n\n\n\n\n\nLeading up to the expected next version of JS (slipped from 2013 to \n2014 and then 2015), the obvious and common label in discourse \nhas been ES6. \n\nHowever, late into the ES6 specification timeline, suggestions have \nsurfaced that versioning may in the future switch to a year-based \nschema, such as ES2016 (aka ES7) to refer to whatever version of the \nspecification is finalized before the end of 2016. Some disagree, but \nES6 will likely maintain its dominant mindshare over the late- \nchange substitute ES2015. However, ES2016 may in fact signal the \nnew year-based schema. \n\nIt has also been observed that the pace of JS evolution is much faster \neven than single-year versioning. As soon as an idea begins to pro¬ \ngress through standards discussions, browsers start prototyping the \nfeature, and early adopters start experimenting with the code.","metadata":{"loc":{"lines":{"from":213783,"to":213805}}}}],["1585",{"pageContent":"Usually well before there’s an official stamp of approval, a feature is \nde facto standardized by virtue of this early engine/tooling prototyp¬ \ning. So it’s also valid to consider the future of JS versioning to be \nper-feature rather than per-arbitrary-collection-of-major-features \n(as it is now) or even per-year (as it may become). \n\nThe takeaway is that the version labels stop being as important, and \nJavaScript starts to be seen more as an evergreen, living standard. \nThe best way to cope with this is to stop thinking about your code \nbase as being “ES6-based,” for instance, and instead consider it fea¬ \nture by feature for support. \n\nTranspiling \n\nMade even worse by the rapid evolution of features, a problem arises \nfor JS developers who at once may both strongly desire to use new \nfeatures while at the same time being slapped with the reality that \ntheir sites/apps may need to support older browsers without such \nsupport.","metadata":{"loc":{"lines":{"from":213807,"to":213825}}}}],["1586",{"pageContent":"The way ES5 appears to have played out in the broader industry, the \ntypical mindset was that code bases waited to adopt ES5 until most \nif not all pre-ES5 environments had fallen out of their support spec¬ \ntrum. As a result, many are just recently (at the time of this writing) \nstarting to adopt things like strict mode, which landed in ES5 over \nfive years ago. \n\n\nTranspiling | 3 \n\n\n\nIt’s widely considered to be a harmful approach for the future of the \nJS ecosystem to wait around and trail the specification by so many \nyears. All those responsible for evolving the language desire for \ndevelopers to begin basing their code on the new features and pat¬ \nterns as soon as they stabilize in specification form and browsers \nhave a chance to implement them.","metadata":{"loc":{"lines":{"from":213827,"to":213844}}}}],["1587",{"pageContent":"So how do we resolve this seeming contradiction? The answer is \ntooling, specifically a technique called transpiling (transformation + \ncompiling). Roughly, the idea is to use a special tool to transform \nyour ES6 code into equivalent (or close!) matches that work in ES5 \nenvironments. \n\nFor example, consider shorthand property definitions (see “Object \nLiteral Extensions” on page 38 in Chapter 2). Here’s the ES6 form: \n\nvar foo = [1,2,3]; \nvar obj = { \n\nfoo // means 'foo: foo' \n\n}; \n\n\nobj. foo; // [1,2,3] \n\nBut (roughly) here’s how that transpiles: \nvar foo = [1,2,3]; \n\nvar obj = { \nfoo: foo \n\n}; \n\n\nobj. foo; // [1,2,3] \n\nThis is a minor but pleasant transformation that lets us shorten the \nfoo: foo in an object literal declaration to just foo, if the names are \nthe same. \n\nTranspilers perform these transformations for you, usually in a build \nworkflow step similar to how you perform linting, minification, and \nother similar operations. \n\nShims/Polyfills","metadata":{"loc":{"lines":{"from":213846,"to":213884}}}}],["1588",{"pageContent":"Transpilers perform these transformations for you, usually in a build \nworkflow step similar to how you perform linting, minification, and \nother similar operations. \n\nShims/Polyfills \n\nNot all new ES6 features need a transpiler. Polyfills (aka shims) are a \npattern for defining equivalent behavior from a newer environment \ninto an older environment, when possible. Syntax cannot be polyfil- \nled, but APIs often can be. \n\n\n4 | Chapter 1: ES? Now & Future \n\n\n\nFor example, Object.is( ..) is a new utility for checking strict \nequality of two values but without the nuanced exceptions that === \nhas for NaN and -0 values. The polyfill for Object.is(.. ) is pretty \neasy: \n\nif (lObject.is) { \n\nObject. is = function(vl, v2) { \n\n// test for '-0' \nif ( v i === 0 && v2 === 0) { \nreturn 1 / vl === 1 / v2; \n\n} \n\n// test for 'NaN' \nif (vl !== vl) { \n\nreturn v2 !== v2; \n\n} \n\n// everything else \nreturn vl === v2;","metadata":{"loc":{"lines":{"from":213884,"to":213923}}}}],["1589",{"pageContent":"// test for '-0' \nif ( v i === 0 && v2 === 0) { \nreturn 1 / vl === 1 / v2; \n\n} \n\n// test for 'NaN' \nif (vl !== vl) { \n\nreturn v2 !== v2; \n\n} \n\n// everything else \nreturn vl === v2; \n\n\nPay attention to the outer if statement guard \nwrapped around the polyfill. This is an impor¬ \ntant detail, which means the snippet only \ndefines its fallback behavior for older environ¬ \nments where the API in question isn’t already \ndefined; it would be very rare that you’d want to \noverwrite an existing API. \n\nThere’s a great collection of ES6 shims called “ES6 Shim” that you \nshould definitely adopt as a standard part of any new JS project! \n\nIt is assumed that JS will continue to evolve constantly, with brows¬ \ners rolling out support for features continually rather than in large \nchunks. So the best strategy for keeping updated as it evolves is to \njust introduce polyfill shims into your code base, and a transpiler \nstep into your build workflow, right now and get used to that new \nreality.","metadata":{"loc":{"lines":{"from":213923,"to":213956}}}}],["1590",{"pageContent":"If you decide to keep the status quo and just wait around for all \nbrowsers without a feature supported to go away before you start \nusing the feature, you’re always going to be way behind. You’ll sadly \nbe missing out on all the innovations designed to make writing Java¬ \nScript more effective, efficient, and robust. \n\n\n\nTranspiling | 5 \n\n\n\n\n\nReview \n\nES6 (some may try to call it ES2015) is just landing as of the time of \nthis writing, and it has lots of new stuff you need to learn! \n\nBut it’s even more important to shift your mindset to align with the \nnew way that JavaScript is going to evolve. It’s not just waiting \naround for years for some official document to get a vote of appro¬ \nval, as many have done in the past. \n\nNow, JavaScript features land in browsers as they become ready, and \nit’s up to you whether you’ll get on the train early or whether you’ll \nbe playing costly catch-up games years from now.","metadata":{"loc":{"lines":{"from":213958,"to":213984}}}}],["1591",{"pageContent":"Now, JavaScript features land in browsers as they become ready, and \nit’s up to you whether you’ll get on the train early or whether you’ll \nbe playing costly catch-up games years from now. \n\nWhatever labels that future JavaScript adopts, it’s going to move a lot \nquicker than it ever has before. Transpilers and shims/polyfills are \nimportant tools to keep you on the forefront of where the language \nis headed. \n\nIf there’s any narrative important to understand about the new real¬ \nity for JavaScript, it’s that all JS developers are strongly implored to \nmove from the trailing edge of the curve to the leading edge. And \nlearning ES6 is where that all starts! \n\n\n6 [ Chapter 1: ES? Now & Future \n\n\n\nCHAPTER 2 \n\n\nSyntax \n\n\nIf you’ve been writing JS for any length of time, odds are the syntax \nis pretty familiar to you. There are certainly many quirks, but overall \nit’s a fairly reasonable and straightforward syntax that draws many \nsimilarities from other languages.","metadata":{"loc":{"lines":{"from":213984,"to":214012}}}}],["1592",{"pageContent":"However, ES6 adds quite a few new syntactic forms that take some \ngetting used to. In this chapter, we’ll tour through them to find out \nwhat’s in store. \n\n\n\nAt the time of this writing, some of the features \ndiscussed in this book have been implemented \nin various browsers (Firefox, Chrome, etc.), but \nsome have only been partially implemented and \nmany others have not been implemented at all. \n\nYour experience may be mixed trying these \nexamples directly. If so, try them out with tran- \nspilers, as most of these features are covered by \nthose tools. \n\nES6Fiddle is a great, easy-to-use playground for \ntrying out ES6, as is the online REPL for the \nBabel transpiler. \n\nBlock-Scoped Declarations \n\nYou’re probably aware that the fundamental unit of variable scoping \nin JavaScript has always been the function. If you needed to create a \nblock of scope, the most prevalent way to do so other than a regular \n\n\n7","metadata":{"loc":{"lines":{"from":214014,"to":214042}}}}],["1593",{"pageContent":"7 \n\n\n\n\n\nfunction declaration was the immediately invoked function expres¬ \nsion (IIFE). For example: \n\nvar a = 2; \n\n(function IIFE (){ \nvar a = 3; \n\nconsole. log( a ); // 3 \n\n})(); \n\nconsole. log ( a ); // 2 \n\nlet Declarations \n\nHowever, we can now create declarations that are bound to any \nblock, called (unsurprisingly) block scoping. This means all we need \nis a pair of { .. } to create a scope. Instead of using var, which \nalways declares variables attached to the enclosing function (or \nglobal, if top level) scope, use let: \n\nvar a = 2; \n\n{ \n\nlet a = 3; \n\nconsole. log( a ); // 3 \n\n} \n\nconsole. log ( a ); // 2 \n\nIt’s not very common or idiomatic thus far in JS to use a standalone \n{ .. } block, but it’s always been valid. And developers from other \nlanguages that have block scoping will readily recognize that pattern.","metadata":{"loc":{"lines":{"from":214042,"to":214084}}}}],["1594",{"pageContent":"I believe this is the best way to create block-scoped variables, with a \ndedicated { .. } block. Moreover, you should always put the let \ndeclaration(s) at the very top of that block. If you have more than \none to declare, I’d recommend using just one let. \n\nStylistically, I even prefer to put the let on the same line as the \nopening {, to make it clearer that this block is only for the purpose \nof declaring the scope for those variables. \n\n{ let a = 2, b, c; \n\n// ■■ \n\n} \n\nNow, that’s going to look strange and it’s not likely going to match \nthe recommendations given in most other ES6 literature. But I have \nreasons for my madness. \n\n\n8 [ Chapter 2:Syntax \n\n\n\nThere’s another experimental (not standardized) form of the let \ndeclaration called the let-block, which looks like: \n\nlet (a = 2, b, c) { \n\n// •• \n\n}","metadata":{"loc":{"lines":{"from":214086,"to":214117}}}}],["1595",{"pageContent":"8 [ Chapter 2:Syntax \n\n\n\nThere’s another experimental (not standardized) form of the let \ndeclaration called the let-block, which looks like: \n\nlet (a = 2, b, c) { \n\n// •• \n\n} \n\nThat form is what I call explicit block scoping, whereas the let .. \ndeclaration form that mirrors var is more implicit, as it kind of \nhijacks whatever { .. } pair it’s found in. Generally developers find \nexplicit mechanisms a bit more preferable than implicit mechanisms, \nand I claim this is one of those cases. \n\nIf you compare the previous two snippet forms, they’re very similar, \nand in my opinion both qualify stylistically as explicit block scoping. \nUnfortunately, the let (..) { .. } form, the most explicit of the \noptions, was not adopted in ES6. That may be revisited post-ES6, \nbut for now the former option is our best bet, I think. \n\nTo reinforce the implicit nature of let .. declarations, consider \nthese usages: \n\nlet a = 2; \n\nif (a > 1) { \n\nlet b = a * 3; \n\nconsole. log( b ); // 6","metadata":{"loc":{"lines":{"from":214117,"to":214151}}}}],["1596",{"pageContent":"To reinforce the implicit nature of let .. declarations, consider \nthese usages: \n\nlet a = 2; \n\nif (a > 1) { \n\nlet b = a * 3; \n\nconsole. log( b ); // 6 \n\nfor (let i = a; i <= b; i++) { \nlet j = i + 10; \nconsole. log( j ); \n\n} \n\n// 12 13 14 15 16 \n\nlet c = a + b; \n\nconsole. log( c ); // 8 \n\n} \n\nQuick quiz without looking back at that snippet: which variable(s) \nexist only inside the If statement, and which variable(s) exist only \ninside the for loop? \n\nThe answers: the if statement contains b and c block-scoped vari¬ \nables, and the for loop contains i and j block-scoped variables. \n\nDid you have to think about it for a moment? Does it surprise you \nthat I isn’t added to the enclosing If statement scope? That mental \n\n\nBlock-Scoped Declarations | 9 \n\n\n\n\npause and questioning—I call it a “mental tax”—comes from the fact \nthat this let mechanism is not only new to us, but it’s also implicit.","metadata":{"loc":{"lines":{"from":214151,"to":214193}}}}],["1597",{"pageContent":"Block-Scoped Declarations | 9 \n\n\n\n\npause and questioning—I call it a “mental tax”—comes from the fact \nthat this let mechanism is not only new to us, but it’s also implicit. \n\nThere’s also a hazard in the let c = .. declaration appearing so far \ndown in the scope. Unlike traditional var-declared variables, which \nare attached to the entire enclosing function scope regardless of \nwhere they appear, let declarations attach to the block scope but are \nnot initialized until they appear in the block. \n\nAccessing a let-declared variable earlier than its let .. declara¬ \ntion/initialization causes an error, whereas with var declarations the \nordering doesn’t matter (except stylistically). \n\nConsider: \n\n1 \n\nconsole. log( a ); // undefined \n\nconsole. log( b ); // ReferenceError! \n\n\n} \n\n\nvar a; \nlet b;","metadata":{"loc":{"lines":{"from":214193,"to":214224}}}}],["1598",{"pageContent":"Consider: \n\n1 \n\nconsole. log( a ); // undefined \n\nconsole. log( b ); // ReferenceError! \n\n\n} \n\n\nvar a; \nlet b; \n\n\n\nThis ReferenceError from accessing too-early \nlet-declared references is technically called a \nTemporal Dead Zone (TDZ) error—you’re \naccessing a variable that’s been declared but not \nyet initialized. This will not be the only time we \nsee TDZ errors—they crop up in several places \nin ES6. Also, note that “initialized” doesn’t \nrequire explicitly assigning a value in your code, \nas let b; is totally valid. A variable that’s not \ngiven an assignment at declaration time is \nassumed to have been assigned the undefined \nvalue, so let b; is the same as let b = unde \nfined ;. Explicit assignment or not, you cannot \naccess b until the let b statement is run. \n\n\nOne last gotcha: typeof behaves differently with TDZ variables than \nit does with undeclared (or declared!) variables. For example: \n\n{ \n\n// 'a' is not declared \nif (typeof a === \"undefined\") { \nconsole. log( \"cool\" );","metadata":{"loc":{"lines":{"from":214224,"to":214264}}}}],["1599",{"pageContent":"{ \n\n// 'a' is not declared \nif (typeof a === \"undefined\") { \nconsole. log( \"cool\" ); \n\n} \n\n\n10 | Chapter 2:Syntax \n\n\n\n\n\n// '£>' is declared, but in its TDZ \n\nif (typeof b === \"undefined\") { // ReferenceError! \n\n// ■■ \n\n} \n\n// \n\nlet b; \n\n} \n\nThe a is not declared, so typeof is the only safe way to check for its \nexistence or not. But typeof b throws the TDZ error because far¬ \nther down in the code there happens to be a let b declaration. \nOops. \n\nNow it should be clearer why I insist that let declarations should all \nbe at the top of their scope. That totally avoids the accidental errors \nof accessing too early. It also makes it more explicit when you look at \nthe start of a block, any block, what variables it contains. \n\nYour blocks (if statements, while loops, etc.) don’t have to share \ntheir original behavior with scoping behavior.","metadata":{"loc":{"lines":{"from":214264,"to":214304}}}}],["1600",{"pageContent":"Your blocks (if statements, while loops, etc.) don’t have to share \ntheir original behavior with scoping behavior. \n\nThis explicitness on your part, which is up to you to maintain with \ndiscipline, will save you lots of refactor headaches and footguns \ndown the line. \n\n\n\nFor more information on let and block scoping, \nsee Chapter 3 of the Scope & Closures title of this \nseries. \n\n\nlet + for \n\nThe only exception I’d make to the preference for the explicit form \nof let declaration blocking is a let that appears in the header of a \nfor loop. The reason may seem nuanced, but I believe it to be one of \nthe more important ES6 features. \n\nConsider: \n\nvar funcs = []; \n\nfor (let i=0; i < 5; i++) { \nfuncs.push( function(){ \nconsole. log( 1 ); \n\n\nBlock-Scoped Declarations | 11 \n\n\n\n\n\n\n} ); \n\n} \n\nfuncs[3](); // 3","metadata":{"loc":{"lines":{"from":214304,"to":214345}}}}],["1601",{"pageContent":"Consider: \n\nvar funcs = []; \n\nfor (let i=0; i < 5; i++) { \nfuncs.push( function(){ \nconsole. log( 1 ); \n\n\nBlock-Scoped Declarations | 11 \n\n\n\n\n\n\n} ); \n\n} \n\nfuncs[3](); // 3 \n\nThe let i in the for header declares an I not just for the for loop \nitself, but it redeclares a new I for each iteration of the loop. That \nmeans that closures created inside the loop iteration close over those \nper-iteration variables the way youd expect. \n\nIf you tried that same snippet but with var i in the for loop header, \nyoud get 5 instead of 3, because thered only be one I in the outer \nscope that was closed over, instead of a new i for each iterations \nfunction to close over. \n\nYou could also have accomplished the same thing slightly more ver¬ \nbosely: \n\nvar funcs = []; \n\nfor (var i = 0; i < 5; 1++) { \nlet j = i; \n\nfuncs.push( function(){ \nconsole. log( j ); \n\n} ); \n\n} \n\nfuncs[3](); // 3","metadata":{"loc":{"lines":{"from":214345,"to":214392}}}}],["1602",{"pageContent":"var funcs = []; \n\nfor (var i = 0; i < 5; 1++) { \nlet j = i; \n\nfuncs.push( function(){ \nconsole. log( j ); \n\n} ); \n\n} \n\nfuncs[3](); // 3 \n\nHere, we forcibly create a new j for each iteration, and then the clo¬ \nsure works the same way. I prefer the former approach; that extra \nspecial capability is why I endorse the for (let .. ) .. form. It \ncould be argued that it’s somewhat more implicit, but it’s explicit \nenough, and useful enough, for my tastes. \n\nlet also works the same way with for. .in and for. .of loops (see \n“for..of Loops” on page 61). \n\nconst Declarations \n\nThere’s one other form of block-scoped declaration to consider: the \nconst, which creates constants. \n\nWhat exactly is a constant? It’s a variable that’s read-only after its ini¬ \ntial value is set. Consider: \n\n\n12 | Chapter 2:Syntax \n\n\n\n\n{ \n\nconst a = 2; \n\nconsole. log( a ); // 2 \n\na = 3; // TypeError! \n\n} \n\nYou are not allowed to change the value the variable holds once it’s","metadata":{"loc":{"lines":{"from":214392,"to":214439}}}}],["1603",{"pageContent":"12 | Chapter 2:Syntax \n\n\n\n\n{ \n\nconst a = 2; \n\nconsole. log( a ); // 2 \n\na = 3; // TypeError! \n\n} \n\nYou are not allowed to change the value the variable holds once it’s \n\nbeen set, at declaration time. A const declaration must have an \n\nexplicit initialization. If you wanted a constant with the undefined \nvalue, you’d have to declare const a = undefined to get it. \n\nConstants are not a restriction on the value itself, but on the varia¬ \nble’s assignment of that value. In other words, the value is not frozen \nor immutable because of const, just the assignment of it. If the value \nis complex, such as an object or array, the contents of the value can \nstill be modified: \n\nI \n\nconst a = [1,2,3]; \na.push( 4 ); \n\nconsole. log( a ); // [1,2,3,4] \n\na = 42; // TypeError! \n\n} \n\nThe a variable doesn’t actually hold a constant array; rather, it holds \na constant reference to the array. The array itself is freely mutable.","metadata":{"loc":{"lines":{"from":214439,"to":214479}}}}],["1604",{"pageContent":"a = 42; // TypeError! \n\n} \n\nThe a variable doesn’t actually hold a constant array; rather, it holds \na constant reference to the array. The array itself is freely mutable. \n\n\n\nAssigning an object or array as a constant means \nthat value will not be able to be garbage collec¬ \nted until that constant’s lexical scope goes away, \nas the reference to the value can never be unset. \nThat may be desirable, but be careful if it’s not \nyour intent! \n\n\nEssentially, const declarations enforce what we’ve stylistically sig¬ \nnaled with our code for years, where we declared a variable name of \nall uppercase letters and assigned it some literal value that we took \ncare never to change. There’s no enforcement on a var assignment, \nbut there is now with a const assignment, which can help you catch \nunintended changes. \n\nconst can be used with variable declarations of for, for. .In, and \nfor., of loops (see “for..of Loops” on page 61). However, an error \n\n\nBlock-Scoped Dedarations | 13","metadata":{"loc":{"lines":{"from":214479,"to":214507}}}}],["1605",{"pageContent":"const can be used with variable declarations of for, for. .In, and \nfor., of loops (see “for..of Loops” on page 61). However, an error \n\n\nBlock-Scoped Dedarations | 13 \n\n\n\n\n\nwill be thrown if there’s any attempt to reassign, such as the typical \ni++ clause of a for loop. \n\nconst Or Not \n\nThere’s some rumored assumptions that a const could be more opti- \nmizable by the JS engine in certain scenarios than a let or var \nwould be. Theoretically, the engine more easily knows the variable’s \nvalue/type will never change, so it can eliminate some possible \ntracking. \n\nWhether const really helps here or this is just our own fantasies and \nintuitions, the much more important decision to make is if you \nintend constant behavior or not. Remember: one of the most impor¬ \ntant roles for source code is to communicate clearly, not only to you, \nbut your future self and other code collaborators, what your intent \nis.","metadata":{"loc":{"lines":{"from":214507,"to":214533}}}}],["1606",{"pageContent":"Some developers prefer to start out every variable declaration as a \nconst and then relax a declaration back to a let if it becomes neces¬ \nsary for its value to change in the code. This is an interesting per¬ \nspective, but it’s not clear that it genuinely improves the readability \nor reason-ability of code. \n\nIt’s not really a protection, as many believe, because any later devel¬ \noper who wants to change a value of a const can just blindly change \nconst to let on the declaration. At best, it protects accidental \nchange. But again, other than our intuitions and sensibilities, there \ndoesn’t appear to be an objective and clear measure of what consti¬ \ntutes “accidents” or prevention thereof. Similar mindsets exist \naround type enforcement.","metadata":{"loc":{"lines":{"from":214535,"to":214547}}}}],["1607",{"pageContent":"My advice: to avoid potentially confusing code, only use const for \nvariables that you’re intentionally and obviously signaling will not \nchange. In other words, don’t rely on const for code behavior, but \ninstead use it as a tool for signaling intent, when intent can be sig¬ \nnaled clearly. \n\nBlock-Scoped Functions \n\nStarting with ES6, function declarations that occur inside of blocks \nare now specified to be scoped to that block. Prior to ES6, the speci¬ \nfication did not call for this, but many implementations did it any¬ \nway. So now the specification meets reality. \n\n\n14 | Chapter 2:Syntax \n\n\n\nConsider: \n\n{ \n\nfoo(); // works! \n\nfunction foo() { \n\n// •• \n\n} \n\n} \n\nfoo(); // ReferenceError \n\nThe foo() function is declared inside the { .. } block, and as of \nES6 is block-scoped there. So it’s not available outside that block. \nBut also note that it is “hoisted” within the block, as opposed to let \ndeclarations, which suffer the TDZ error trap mentioned earlier.","metadata":{"loc":{"lines":{"from":214549,"to":214586}}}}],["1608",{"pageContent":"Block-scoping of function declarations could be a problem if you’ve \never written code like this before, and relied on the old legacy non- \nblock-scoped behavior: \n\nif (something) { \n\nfunction foo() { \n\nconsole. log( \"1\" ); \n\n} \n\n} \n\nelse { \n\nfunction foo() { \n\nconsole. log( \"2\" ); \n\n} \n\n} \n\nfoo(); // ?? \n\nIn pre-ES6 environments, foo() would print \"2\" regardless of the \nvalue of something, because both function declarations were hoisted \nout of the blocks, and the second one always wins. \n\nIn ES6, that last line throws a ReferenceError. \n\nSpread/Rest \n\nES6 introduces a new ... operator that’s typically referred to as the \nspread or rest operator, depending on where/how it’s used. Let’s take \na look: \n\nfunction foo(x,y,z) { \n\nconsole. log( x, y, z ); \n\n} \n\n\nSpread/Rest | 15 \n\n\n\n\nfoo( . . .[1,2,3] ); \n\n\n// 1 2 3 \n\n\nWhen ... is used in front of an array (actually, any iterable, which \nwe cover in Chapter 3), it acts to “spread” it out into its individual \nvalues.","metadata":{"loc":{"lines":{"from":214588,"to":214646}}}}],["1609",{"pageContent":"foo( . . .[1,2,3] ); \n\n\n// 1 2 3 \n\n\nWhen ... is used in front of an array (actually, any iterable, which \nwe cover in Chapter 3), it acts to “spread” it out into its individual \nvalues. \n\nYou’ll typically see that usage as is shown in that previous snippet, \nwhen spreading out an array as a set of arguments to a function call. \nIn this usage, ... acts to give us a simpler syntactic replacement for \nthe apply(..) method, which we would typically have used pre-ES6 \nas: \n\nfoo.apply( null, [1,2,3] ); // 1 2 3 \n\nBut ... can be used to spread out/expand a value in other contexts \nas well, such as inside another array declaration: \n\nvar a = [2,3,4]; \n\nvar b= [ 1, ...a, 5 ]; \n\nconsole. log( b ); // [1,2,3,4,5] \n\nIn this usage, ... is basically replacing concat(..), as it behaves \nlike [1] .concat( a, [5] ) here. \n\nThe other common usage of ... can be seen as essentially the oppo¬ \nsite; instead of spreading a value out, the ... gathers a set of values \ntogether into an array. Consider:","metadata":{"loc":{"lines":{"from":214646,"to":214678}}}}],["1610",{"pageContent":"The other common usage of ... can be seen as essentially the oppo¬ \nsite; instead of spreading a value out, the ... gathers a set of values \ntogether into an array. Consider: \n\nfunction foo(x, y, ...z) { \nconsole. log( x, y, z ); \n\n} \n\nfoo( 1, 2, 3, 4, 5 ); // 1 2 [3,4,5] \n\nThe ... z in this snippet is essentially saying: “gather the rest of the \narguments (if any) into an array called z.” Because x was assigned 1, \nand y was assigned 2, the rest of the arguments 3, 4, and 5 were \ngathered into z. \n\nOf course, if you don’t have any named parameters, the ... gathers \nall arguments: \n\nfunction foo(...args) { \nconsole. log( args ); \n\n} \n\nfoo( 1, 2, 3, 4, 5); // [1,2,3,4,5] \n\n\n16 | Chapter 2:Syntax \n\n\n\n\n\nThe .. .args in the foo(..) function declara¬ \ntion is usually called “rest parameters,” because \nyou’re collecting the rest of the parameters. I \nprefer “gather,” because it’s more descriptive of \nwhat it does rather than what it contains.","metadata":{"loc":{"lines":{"from":214678,"to":214715}}}}],["1611",{"pageContent":"The best part about this usage is that it provides a very solid alterna¬ \ntive to using the long-since-deprecated arguments array — actually, \nit’s not really an array, but an array-like object. Because args (or \nwhatever you call it—a lot of people prefer r or rest) is a real array, \nwe can get rid of lots of silly pre-ES6 tricks we jumped through to \nmake arguments into something we can treat as an array. \n\nConsider: \n\n// doing things the new ES6 way \nfunction foo(...args) { \n\n// 'args' is already a real array \n\n// discard first element in 'args' \nargs.shift(); \n\n// pass along all of 'args' as arguments \n// to 'console.log(..)' \nconsole. log( ...args ); \n\n} \n\n// doing things the old-school pre-ES6 way \n\nfunction bar() { \n\n// turn 'arguments' into a real array \n\nvar args = Array. prototype.slice.call( arguments ); \n\n// add some elements on the end \nargs.push( 4, 5 ); \n\n// filter out odd numbers \nargs = args.fllter( functlon(v){ \nreturn v % 2 == 0; \n\n} );","metadata":{"loc":{"lines":{"from":214718,"to":214756}}}}],["1612",{"pageContent":"var args = Array. prototype.slice.call( arguments ); \n\n// add some elements on the end \nargs.push( 4, 5 ); \n\n// filter out odd numbers \nargs = args.fllter( functlon(v){ \nreturn v % 2 == 0; \n\n} ); \n\n// pass along all of 'args' as arguments \n// to 'foo(..)' \nfoo.apply( null, args ); \n\n} \n\nbar( 0, 1, 2, 3 ); // 2 4 \n\nThe . . .args in the foo(. .) function declaration gathers arguments, \nand the ...args in the console. log( ..) call spreads them out. \n\n\nSpread/Rest | 17 \n\n\n\n\n\n\nThat’s a good illustration of the symmetric but opposite uses of \nthe ... operator. \n\nBesides the ... usage in a function declaration, there’s another case \nwhere ... is used for gathering values, and we’ll look at it in “Too \nMany, Too Few, Just Enough” on page 30 later in this chapter. \n\nDefault Parameter Values \n\nPerhaps one of the most common idioms in JavaScript relates to set¬ \nting a default value for a function parameter. The way we’ve done \nthis for years should look quite familiar:","metadata":{"loc":{"lines":{"from":214756,"to":214797}}}}],["1613",{"pageContent":"Perhaps one of the most common idioms in JavaScript relates to set¬ \nting a default value for a function parameter. The way we’ve done \nthis for years should look quite familiar: \n\nfunction foo(x,y) { \nx = x || 11; \ny = y 11 3i; \n\nconsole. log( x + y ); \n\n} \n\n\nfoo( ); // 42 \nfoo( 5, 6 ); // 11 \nfoo( 5 ); // 36 \nfoo( null, 6 ); // 17 \n\n\nOf course, if you’ve used this pattern before, you know that it’s both \nhelpful and a little bit dangerous if, for example, you need to be able \nto pass in what would otherwise be considered a falsy value for one \nof the parameters. Consider: \n\nfoo( 0, 42 ); // 53 <-- Oops, not 42 \n\nWhy? Because the 0 is falsy, and so the x | | 11 results in 11, not the \ndirectly passed in 0. \n\nTo fix this gotcha, some people will instead write the check more \nverbosely like this: \n\nfunction foo(x,y) { \n\nx = (x !== undefined) ? x : 11; \ny = (y !== undefined) ? y : 31; \n\nconsole. log( x + y ); \n\n} \n\nfoo( 0, 42 ); // 42 \n\nfoo( undefined, 6 ); // 17","metadata":{"loc":{"lines":{"from":214797,"to":214840}}}}],["1614",{"pageContent":"function foo(x,y) { \n\nx = (x !== undefined) ? x : 11; \ny = (y !== undefined) ? y : 31; \n\nconsole. log( x + y ); \n\n} \n\nfoo( 0, 42 ); // 42 \n\nfoo( undefined, 6 ); // 17 \n\n\n18 | Chapter 2:Syntax \n\n\n\n\nOf course, that means any value except undefined can be directly \npassed in. However, undefined will be assumed to signal, “I didn’t \npass this in.” That works great unless you actually need to be able to \npass undefined in. \n\nIn that case, you could test to see if the argument is actually omitted, \nby it actually not being present in the arguments array, perhaps like \nthis: \n\n\nfunction foo(x,y) { \n\nx = (0 in arguments) ? x : 11; \ny = (1 in arguments) ? y : 31; \n\nconsole. log( x + y ); \n\n} \n\nfoo( 5 ); // 36 \n\nfoo( 5, undefined ); // NaN \n\nBut how would you omit the first x argument without the ability to \npass in any kind of value (not even undefined) that signals “I’m \nomitting this argument”?","metadata":{"loc":{"lines":{"from":214840,"to":214884}}}}],["1615",{"pageContent":"foo( 5, undefined ); // NaN \n\nBut how would you omit the first x argument without the ability to \npass in any kind of value (not even undefined) that signals “I’m \nomitting this argument”? \n\nfoo( ,5) is tempting, but it’s invalid syntax, foo. apply (null, [, 5]) \nseems like it should do the trick, but apply(.. )’s quirks here mean \nthe arguments are treated as [undefined,5], which of course \ndoesn’t omit. \n\nIf you investigate further, you’ll find you can only omit arguments \non the end (i.e., righthand side) by simply passing fewer arguments \nthan “expected,” but you cannot omit arguments in the middle or at \nthe beginning of the arguments list. It’s just not possible. \n\nThere’s a principle applied to JavaScript’s design here that is impor¬ \ntant to remember: undefined means missing. That is, there’s no dif¬ \nference between undefined and missing, at least as far as function \narguments go.","metadata":{"loc":{"lines":{"from":214884,"to":214903}}}}],["1616",{"pageContent":"There are, confusingly, other places in JS where \nthis particular design principle doesn’t apply, \nsuch as for arrays with empty slots. See the Types \n& Grammar title of this series for more informa¬ \ntion. \n\n\nDefault Parameter Values | 19 \n\n\n\n\n\nWith all this in mind, we can now examine a nice helpful syntax \nadded as of ES6 to streamline the assignment of default values to \nmissing arguments: \n\n\nfunction foo(x = 11, y = 31) { \nconsole. log( x + y ); \n\n} \n\n\nfoo(); \n\n// 42 \n\nfoo( 5, 6 ); \n\n// 11 \n\nfoo( 0, 42 ); \n\n// 42 \n\nfoo( 5 ); \n\n// 36 \n\nfoo( 5, undefined ); \n\n// 36 <-- 'undefined' is missing \n\nfoo( 5, null ); \n\n// 5 <-- null coerces to 'O' \n\nfoo( undefined, 6 ); \n\n// 17 <-- 'undefined' is missing \n\nfoo( null, 6 ); \n\n// 6 <-- null coerces to 'O' \n\n\nNotice the results and how they imply both subtle differences and \nsimilarities to the earlier approaches.","metadata":{"loc":{"lines":{"from":214907,"to":214965}}}}],["1617",{"pageContent":"// 17 <-- 'undefined' is missing \n\nfoo( null, 6 ); \n\n// 6 <-- null coerces to 'O' \n\n\nNotice the results and how they imply both subtle differences and \nsimilarities to the earlier approaches. \n\nx = 11 in a function declaration is more like x !== undefined ? \nx : 11 than the much more common idiom x [ | 11, so you’ll need \nto be careful in converting your pre-ES6 code to this ES6 default \nparameter value syntax. \n\n\n\nA rest/gather parameter (see “Spread/Rest” on \npage 15) cannot have a default value. So, while \nfunction foo(...vals=[l,2,3]) { might \n\nseem like an intriguing capability, it’s not valid \nsyntax. You’ll need to continue to apply that sort \nof logic manually if necessary. \n\n\nDefault Value Expressions \n\nFunction default values can be more than just simple values like 31; \nthey can be any valid expression, even a function call: \n\nfunction bar(val) { \n\nconsole. log( \"bar called!\" ); \nreturn y + val; \n\n} \n\nfunction foo(x =y+3,z=bar(x)){ \nconsole. log( x, z ); \n\n}","metadata":{"loc":{"lines":{"from":214965,"to":215006}}}}],["1618",{"pageContent":"function bar(val) { \n\nconsole. log( \"bar called!\" ); \nreturn y + val; \n\n} \n\nfunction foo(x =y+3,z=bar(x)){ \nconsole. log( x, z ); \n\n} \n\n\n20 | Chapter 2:Syntax \n\n\n\n\n\n\n\nvar y = 5; \nfoo( ); \n\n\n// \"bar called \n// 8 13 \n// \"bar called \n// 10 15 \n\n\nfoo( 10 ); \n\n\ny - 6; \n\nfoo( undefined, 10 ); \n\n\n// 9 10 \n\n\nAs you can see, the default value expressions are lazily evaluated, \nmeaning they’re only run if and when they’re needed—that is, when \na parameter’s argument is omitted or is undefined. \n\nIt’s a subtle detail, but the formal parameters in a function declara¬ \ntion are in their own scope (think of it as a scope bubble-wrapped \naround just the ( .. ) of the function declaration), not in the func¬ \ntion body’s scope. That means a reference to an identifier in a \ndefault value expression first matches the formal parameters’ scope \nbefore looking to an outer scope. See the Scope & Closures title of \nthis series for more information. \n\nConsider: \n\nvar w = 1 , z = 2;","metadata":{"loc":{"lines":{"from":215006,"to":215062}}}}],["1619",{"pageContent":"Consider: \n\nvar w = 1 , z = 2; \n\nfunction foo( x = w + 1, y = x + 1, z = z + l ) { \nconsole. log( x, y, z ); \n\n} \n\nfoo(); // ReferenceError \n\nThe w in the w + 1 default value expression looks for w in the formal \nparameters’ scope, but does not find it, so the outer scope’s w is used. \nNext, the x in the x + 1 default value expression finds x in the for¬ \nmal parameters’ scope, and luckily x has already been initialized, so \nthe assignment to y works fine. \n\nHowever, the z in z + 1 finds z as a not-yet-initialized-at-that- \nmoment parameter variable, so it never tries to find the z from the \nouter scope. \n\nAs we mentioned in “let Declarations” on page 8 earlier in this chap¬ \nter, ES6 has a TDZ, which prevents a variable from being accessed in \nits uninitialized state. As such, the z + 1 default value expression \nthrows a TDZ ReferenceError error. \n\nThough it’s not necessarily a good idea for code clarity, a default \nvalue expression can even be an inline function expression call—","metadata":{"loc":{"lines":{"from":215062,"to":215089}}}}],["1620",{"pageContent":"Though it’s not necessarily a good idea for code clarity, a default \nvalue expression can even be an inline function expression call— \n\n\nDefault Parameter Values | 21 \n\n\n\ncommonly referred to as an immediately invoked function expres¬ \nsion (IIFE): \n\nfunction foo( x = \n\n(function(v){ return v + 11; })( 31 ) \n\n) { \n\nconsole. log( x ); \n\n} \n\nfoo( ); // 42 \n\nThere will very rarely be any cases where an IIFE (or any other exe¬ \ncuted inline function expression) will be appropriate for default \nvalue expressions. If you find yourself tempted to do this, take a step \nback and reevaluate! \n\n\n\nIf the IIFE had tried to access the x identifier \nand had not declared its own x, this would also \nhave been a TDZ error, just as discussed before.","metadata":{"loc":{"lines":{"from":215089,"to":215121}}}}],["1621",{"pageContent":"If the IIFE had tried to access the x identifier \nand had not declared its own x, this would also \nhave been a TDZ error, just as discussed before. \n\n\nThe default value expression in the previous snippet is an IIFE in \nthat in the sense that it’s a function that’s executed right inline, via \n(31). If we had left that part off, the default value assigned to x \nwould have just been a function reference itself, perhaps like a \ndefault callback. There will probably be cases where that pattern will \nbe quite useful, such as: \n\nfunction ajax(url, cb = function()0) { \n\n// \n\n} \n\najax( \"http://sone.url.1\" ); \n\nIn this case, we essentially want to default cb to be a no-op empty \nfunction call if not otherwise specified. The function expression is \njust a function reference, not a function call itself (no invoking () \non the end of it), which accomplishes that goal.","metadata":{"loc":{"lines":{"from":215121,"to":215144}}}}],["1622",{"pageContent":"Since the early days of JS, there’s been a little-known but useful quirk \navailable to us: Function, prototype is itself an empty no-op func¬ \ntion. So, the declaration could have been cb = Function. prototype \nand saved the inline function expression creation. \n\n\n22 | Chapter 2:Syntax \n\n\n\n\n\nDestructuring \n\nES6 introduces a new syntactic feature called destructuring, which \nmay be a little less confusing if you instead think of it as a structured \nassignment. To understand this meaning, consider: \n\nfunction foo() { \nreturn [1,2,3]; \n\n} \n\nvar trip = foo(), \n\na = tmp[0], fa = tmp[l], c = tmp[2]; \n\nconsole. log ( a, b, c ); // 1 2 3 \n\nAs you can see, we created a manual assignment of the values in the \narray that foo() returns to individual variables a, b, and c, and to do \nso we (unfortunately) needed the trip variable. \n\nSimilarly, we can do the following with objects: \n\nfunction bar() { \nreturn { \n\nx: 4, \ny: 5, \nz: 6 \n\n}; \n\n} \n\nvar tnp = bar(),","metadata":{"loc":{"lines":{"from":215146,"to":215192}}}}],["1623",{"pageContent":"Similarly, we can do the following with objects: \n\nfunction bar() { \nreturn { \n\nx: 4, \ny: 5, \nz: 6 \n\n}; \n\n} \n\nvar tnp = bar(), \n\nx = tmp.x, y = tmp.y, z = tnp.z; \nconsole. log ( x, y, z ); // 4 5 6 \n\nThe tmp.x property value is assigned to the x variable, and likewise \nfor tmp. y to y and trip. z to z. \n\nManually assigning indexed values from an array or properties from \nan object can be thought of as structured assignment. ES6 adds a \ndedicated syntax for destructuring, specifically array destructuring \nand object destructuring. This syntax eliminates the need for the tmp \nvariable in the previous snippets, making them much cleaner. Con¬ \nsider: \n\nvar [ a, b, c ] = foo(); \n\nvar { x: x, y: y, z: z } = bar(); \n\nconsole. log( a, b, c ); // 1 2 3 \n\nconsole. log ( x,y,z); // 4 5 6 \n\n\nDestructuring | 23 \n\n\n\nYou’re likely more accustomed to seeing syntax like [a,b,c] on the \nrighthand side of an = assignment, as the value being assigned.","metadata":{"loc":{"lines":{"from":215192,"to":215234}}}}],["1624",{"pageContent":"console. log ( x,y,z); // 4 5 6 \n\n\nDestructuring | 23 \n\n\n\nYou’re likely more accustomed to seeing syntax like [a,b,c] on the \nrighthand side of an = assignment, as the value being assigned. \n\nDestructuring symmetrically flips that pattern, so that [a,b,c] on \nthe lefthand side of the = assignment is treated as a kind of “pattern” \nfor decomposing the righthand side array value into separate vari¬ \nable assignments. \n\nSimilarly, { x: x, y: y, z: z } specifies a “pattern” to decompose \nthe object value from bar() into separate variable assignments. \n\nObject Property Assignment Pattern \n\nLet’s dig into that { x: x, .. } syntax from the previous snippet. If \nthe property name being matched is the same as the variable you \nwant to declare, you can actually shorten the syntax: \n\nvar { x, y, z } = bar(); \n\nconsole. log( x, y, z ); // 4 5 6 \n\nPretty cool, right?","metadata":{"loc":{"lines":{"from":215234,"to":215262}}}}],["1625",{"pageContent":"var { x, y, z } = bar(); \n\nconsole. log( x, y, z ); // 4 5 6 \n\nPretty cool, right? \n\nBut is { x, .. } leaving off the x: part or leaving off the : x part? \nWe’re actually leaving off the x: part when we use the shorter syntax. \nThat may not seem like an important detail, but you’ll understand \nits importance in just a moment. \n\nIf you can write the shorter form, why would you ever write out the \nlonger form? Because that longer form actually allows you to assign \na property to a different variable name, which can sometimes be \nquite useful: \n\nvar { x: bam, y: baz, z: bap } = bar(); \n\nconsole. log( bam, baz, bap ); // 4 5 6 \n\nconsole. log ( x, y, z ); // ReferenceError \n\nThere’s a subtle but super-important quirk to understand about this \nvariation of the object destructuring form. To illustrate why it can be \na gotcha you need to be careful of, let’s consider the “pattern” of how \nnormal object literals are specified: \n\nvar X = 10, Y = 20; \nvar o={a:X, b: Y };","metadata":{"loc":{"lines":{"from":215262,"to":215290}}}}],["1626",{"pageContent":"var X = 10, Y = 20; \nvar o={a:X, b: Y }; \n\nconsole. log( o.a, o.b ); // 10 20 \n\n\n24 | Chapter 2:Syntax \n\n\n\n\nIn { a: X, b: Y }, we know that a is the object property, and X is \nthe source value that gets assigned to it. In other words, the syntactic \npattern is target: source, or more obviously, property-alias: \nvalue. We intuitively understand this because it’s the same as = \nassignment, where the pattern is target = source. \n\nHowever, when you use object destructuring assignment—that is, \nputting the { .. } object literal-looking syntax on the lefthand side \nof the = operator — you invert that target: sou rce pattern. \n\nRecall: \n\nvar { x: bam, y: baz, z: bap } = bar(); \n\nThe syntactic pattern here is source: target (or value: \nvariable-alias), x: bam means the x property is the source value \nand bam is the target variable to assign to. In other words, object lit¬ \nerals are target <-- source, and object destructuring assignments \nare source - - > target. See how that’s flipped?","metadata":{"loc":{"lines":{"from":215290,"to":215319}}}}],["1627",{"pageContent":"There’s another way to think about this syntax though, which may \nhelp ease the confusion. Consider: \n\nvar aa = 10, bb = 20; \n\n\nvar o = { x: aa, y: bb }; \n\nvar { x: AA, y: BB } = o; \n\nconsole. tog( AA, BB ); // 10 20 \n\nIn the { x: aa, y : bb } line, the x and y represent the object prop¬ \nerties. In the { x: AA, y: BB } line, the x and y also represent the \n\nobject properties. \n\nRecall how earlier I asserted that { x, .. } was leaving off the x: \npart? In those two lines, if you erase the x: and y: parts in that snip¬ \npet, you’re left only with aa, bb and AA, BB, which in effect—only \nconceptually, not actually—are assignments from aa to AA and from \nbb to BB. \n\nSo, that symmetry may help to explain why the syntactic pattern was \nintentionally flipped for this ES6 feature. \n\n\nDestructuring | 25","metadata":{"loc":{"lines":{"from":215321,"to":215348}}}}],["1628",{"pageContent":"So, that symmetry may help to explain why the syntactic pattern was \nintentionally flipped for this ES6 feature. \n\n\nDestructuring | 25 \n\n\n\n\n\nI would have preferred the syntax to be { AA: \nx , BB : y } for the destructuring assignment, \nas that would have preserved consistency of the \nmore familiar target: source pattern for both \nusages. Alas, I’m having to train my brain for the \ninversion, as some readers may also have to do. \n\n\nNot Just Declarations \n\nSo far, we’ve used destructuring assignment with var declarations \n(of course, they could also use let and const), but destructuring is a \ngeneral assignment operation, not just a declaration. \n\nConsider: \n\nvar a, b, c, x, y, z; \n\n[a,b,c] = foo( ); \n\n( { x, y, z } = bar() ); \n\nconsole. log ( a, b, c ); // 1 2 3 \n\nconsole. log ( x, y, z ); // 4 S 6 \n\nThe variables can already be declared, and then the destructuring \nonly does assignments, exactly as we’ve already seen.","metadata":{"loc":{"lines":{"from":215348,"to":215385}}}}],["1629",{"pageContent":"console. log ( a, b, c ); // 1 2 3 \n\nconsole. log ( x, y, z ); // 4 S 6 \n\nThe variables can already be declared, and then the destructuring \nonly does assignments, exactly as we’ve already seen. \n\n\n\nFor the object destructuring form specifically, \nwhen leaving off a var/let/const declarator, we \nhad to surround the whole assignment expres¬ \nsion in ( ), because otherwise the { .. } on the \nlefthand side as the first element in the state¬ \nment is taken to be a block statement instead of \nan object. \n\n\nIn fact, the assignment expressions (a, y, etc.) don’t actually need to \nbe just variable identifiers. Anything that’s a valid assignment \nexpression is allowed. For example: \n\nvar o = {}; \n\n[o.a, o.b, o.c] = foo(); \n\n( { x: o.x, y: o.y, z: o.z } = bar() ); \n\nconsole. log ( o.a,o.b,o.c); // 1 2 3 \n\nconsole. log( o.x, o.y, o.z ); // 4 5 6 \n\n\n26 | Chapter 2:Syntax \n\n\n\n\n\n\n\n\nYou can even use computed property expressions in the destructur¬ \ning. Consider: \n\nvar which = \"x\", \no = {};","metadata":{"loc":{"lines":{"from":215385,"to":215431}}}}],["1630",{"pageContent":"console. log( o.x, o.y, o.z ); // 4 5 6 \n\n\n26 | Chapter 2:Syntax \n\n\n\n\n\n\n\n\nYou can even use computed property expressions in the destructur¬ \ning. Consider: \n\nvar which = \"x\", \no = {}; \n\n( { [which]: o[which] } = bar() ); \nconsole. log ( o.x ); // 4 \n\nThe [which]: part is the computed property, which results in x—the \nproperly to destructure from the object in question as the source of \nthe assignment. The o[which] part is just a normal object key refer¬ \nence, which equates to o. x as the target of the assignment. \n\nYou can use the general assignments to create object mappings/ \ntransformations, such as: \n\nvar ol = { a: 1, b: 2 , c: 3 }, \n\n02 = {}; \n\n( { a: o2.x, b: o2.y, c: o2.z } = ol ); \n\nconsole. log ( o2.x, o2.y, o2.z ); //I 23 \n\nOr you can map an object to an array, such as: \n\nvar ol = { a: 1, b: 2, c: 3 }, \na2 = []; \n\n( { a: a2[0], b: a2[l], c: a2[2] } = ol ); \n\n\nconsole. log( a2 ); // [1,2,3] \n\nOr the other way around: \n\nvar al = [ 1, 2, 3 ], \n\n02 = {};","metadata":{"loc":{"lines":{"from":215431,"to":215482}}}}],["1631",{"pageContent":"var ol = { a: 1, b: 2, c: 3 }, \na2 = []; \n\n( { a: a2[0], b: a2[l], c: a2[2] } = ol ); \n\n\nconsole. log( a2 ); // [1,2,3] \n\nOr the other way around: \n\nvar al = [ 1, 2, 3 ], \n\n02 = {}; \n\n\n[ o2.a, o2.b, o2.c ] = al; \n\n\nconsole. log ( o2.a, o2.b, o2.c ); // 1 23 \n\nOr you could reorder one array to another: \n\nvar al = [ 1, 2, 3 ], \na2 = []; \n\n\n[ a2[2], a2[0], a2[l] ] = al; \n\nconsole. log( a2 ); // [2,3,1] \n\n\nDestructuring | 27 \n\n\n\n\nYou can even solve the traditional “swap two variables” task without \na temporary variable: \n\nvar x = 10, y = 20; \n\n\n[ y. x ] = [ x, y ]; \n\nconsole. log( x, y ); // 20 10","metadata":{"loc":{"lines":{"from":215482,"to":215526}}}}],["1632",{"pageContent":"Destructuring | 27 \n\n\n\n\nYou can even solve the traditional “swap two variables” task without \na temporary variable: \n\nvar x = 10, y = 20; \n\n\n[ y. x ] = [ x, y ]; \n\nconsole. log( x, y ); // 20 10 \n\n\n\nBe careful: you shouldn’t mix in declaration with \nassignment unless you want all of the assign¬ \nment expressions also to be treated as declara¬ \ntions. Otherwise, you’ll get syntax errors. That’s \nwhy in the earlier example I had to do var a2 = \n[] separately from the [ a2[0], .. ] = .. \ndestructuring assignment. It wouldn’t make any \nsense to try var [ a2[0], .. ] = .., because \na2[0] isn’t a valid declaration identifier; it also \nobviously couldn’t implicitly create a var a2 = \n[] declaration. \n\n\nRepeated Assignments \n\nThe object destructuring form allows a source property (holding any \nvalue type) to be listed multiple times. For example: \n\nvar { a: X, a: Y } = { a: 1 }; \n\nX; // 1 \nY; // i","metadata":{"loc":{"lines":{"from":215526,"to":215564}}}}],["1633",{"pageContent":"Repeated Assignments \n\nThe object destructuring form allows a source property (holding any \nvalue type) to be listed multiple times. For example: \n\nvar { a: X, a: Y } = { a: 1 }; \n\nX; // 1 \nY; // i \n\nThat also means you can both destructure a sub-object/array prop¬ \nerty and also capture the sub-object/arrays value itself. Consider: \n\nvar { a: { x: X, x: Y }, a } = { a: { x: 1 } }; \n\nX; // 1 \nY; // l \na; // { x: 1 } \n\n( { a: X, a: Y, a: [ Z ] } = { a: [ 1 ] } ); \n\nX.push( 2 ); \n\nY [ 0 ] = 10; \n\n\nX; // [10,2] \nY; // [10,2] \nZ; // 1 \n\n\n28 | Chapter 2:Syntax \n\n\n\n\n\n\n\nA word of caution about destructuring: it may be tempting to list \ndestructuring assignments all on a single line as has been done thus \nfar in our discussion. However, it’s a much better idea to spread \ndestructuring assignment patterns over multiple lines, using proper \nindentation—much like you would in JSON or with an object literal \nvalue—for readability’s sake. \n\n// harder to read:","metadata":{"loc":{"lines":{"from":215564,"to":215610}}}}],["1634",{"pageContent":"// harder to read: \n\nvar { a: { b: [ c, d ], e: { f } }, g } = obj; \n\n// better: \n\nvar { \na: { \n\nb: [ c, d ], \ne: { f } \n\n}, \n\n9 \n\n} = obj; \n\nRemember: the purpose of destructuring is not just less typing, but \nmore declarative readability. \n\nDestructuring Assignment Expressions \n\nThe assignment expression with object or array destructuring has as \nits completion value the full righthand object/array value. Consider: \n\nvar o = { a: 1, b:2, c:3 }, \na, b, c, p; \n\np = { a, b, c } = o; \n\nconsole. log( a, b, c ); // 1 2 3 \n\np === o; // true \n\nIn the previous snippet, p was assigned the o object reference, not \none of the a, b, or c values. The same is true of array destructuring: \n\nvar o = [1,2,3], \nb, c, p; \n\np = { a, b, c } = o; \n\nconsole. log ( a, b, c ); // 1 2 3 \n\np === o; // true \n\nBy carrying the object/array value through as the completion, you \ncan chain destructuring assignment expressions together: \n\nvar o = { a: 1, b:2, c:3 }, \n\nP = [4,5,6], \n\n\nDestructuring | 29","metadata":{"loc":{"lines":{"from":215610,"to":215665}}}}],["1635",{"pageContent":"By carrying the object/array value through as the completion, you \ncan chain destructuring assignment expressions together: \n\nvar o = { a: 1, b:2, c:3 }, \n\nP = [4,5,6], \n\n\nDestructuring | 29 \n\n\n\na, b, c, x, y, z; \n\n\n( {a} = {b,c} = o ); \n\n[x,y] = [z] = p; \n\nconsole. log ( a, b, c ); // 1 2 3 \n\nconsole. log ( x, y, z ); // 4 5 4 \n\nToo Many, Too Few, Just Enough \n\nWith both array destructuring assignment and object destructuring \nassignment, you do not have to assign all the values that are present. \nFor example: \n\nvar [,b] = foo(); \nvar { x, z } = bar(); \n\nconsole. log ( b, x, z ); // 2 4 6 \n\nThe 1 and 3 values that came back from foo() are discarded, as is \nthe 5 value from ba r (). \n\nSimilarly, if you try to assign more values than are present in the \nvalue you’re destructuring/decomposing, you get graceful fallback to \nundefined, as you’d expect: \n\nvar [, ,c,d] = foo(); \nvar { w, z } = bar(); \n\nconsole. log( c, z ); // 3 6 \n\nconsole. log ( d, w ); // undefined undefined","metadata":{"loc":{"lines":{"from":215665,"to":215711}}}}],["1636",{"pageContent":"var [, ,c,d] = foo(); \nvar { w, z } = bar(); \n\nconsole. log( c, z ); // 3 6 \n\nconsole. log ( d, w ); // undefined undefined \n\nThis behavior follows symmetrically from the earlier stated “unde \nfined is missing” principle. \n\nWe examined the ... operator earlier in this chapter, and saw that it \ncan sometimes be used to spread an array value out into its separate \nvalues, and sometimes it can be used to do the opposite: to gather a \nset of values together into an array. \n\nIn addition to the gather/rest usage in function declarations, ... can \nperform the same behavior in destructuring assignments. To illus¬ \ntrate, let’s recall a snippet from earlier in this chapter: \n\nvar a = [2,3,4]; \n\nvar b = [ 1, ...a, 5]; \n\nconsole. log( b ); // [1,2,3,4,5] \n\n\n30 | Chapter 2:Syntax \n\n\n\n\nHere we see that ... a is spreading a out, because it appears in the \narray [ .. ] value position. If ... a appears in an array destructur¬ \ning position, it performs the gather behavior:","metadata":{"loc":{"lines":{"from":215711,"to":215744}}}}],["1637",{"pageContent":"Here we see that ... a is spreading a out, because it appears in the \narray [ .. ] value position. If ... a appears in an array destructur¬ \ning position, it performs the gather behavior: \n\nvar a = [2,3,4]; \nvar [ b, .. .c ] = a; \n\nconsole. log ( b, c ); // 2 [3,4] \n\nThe var [ .. ] = a destructuring assignment spreads a out to be \nassigned to the pattern described inside the [ .. ]. The first part \nnames b for the first value in a (2). But then ... c gathers the rest of \nthe values (3 and 4) into an array and calls it c. \n\n\n\nWe’ve seen how ... works with arrays, but what \nabout with objects? It’s not an ES6 feature, but \nsee Chapter 8 for discussion of a possible \n“beyond ES6” feature where ... works with \nspreading or gathering objects. \n\n\nDefault Value Assignment \n\nBoth forms of destructuring can offer a default value option for an \nassignment, using the = syntax similar to the default function argu¬ \nment values discussed earlier. \n\nConsider:","metadata":{"loc":{"lines":{"from":215744,"to":215773}}}}],["1638",{"pageContent":"Both forms of destructuring can offer a default value option for an \nassignment, using the = syntax similar to the default function argu¬ \nment values discussed earlier. \n\nConsider: \n\nvar [a = 3, b = 6, c = 9, d = 12 ] = foo(); \n\nvar { x = 5, y = 10, z = 15, w = 20 } = bar(); \n\nconsole. log( a, b, c, d ); // 1 2 3 12 \n\nconsole, log ( x,y,z,w); // 4 5 6 20 \n\nYou can combine the default value assignment with the alternative \nassignment expression syntax covered earlier. For example: \n\nvar { x, y, z, w: WW = 20 } = bar(); \n\nconsole. log ( x, y, z, WW ); // 4 5 6 20 \n\nBe careful about confusing yourself (or other developers who read \nyour code) if you use an object or array as the default value in a \ndestructuring. You can create some really hard-to-understand code: \n\nvar x = 200, y = 300, z = 100; \n\nvar ol = { x: { y: 42 }, z: { y: z } }; \n\n\nDestructuring | 31 \n\n\n\n\n\n( { y: X = { y: y } } = ol ); \n\n( { z: y = { y: z } } = ol ); \n\n( { x: z = { y: x } } = ol );","metadata":{"loc":{"lines":{"from":215773,"to":215813}}}}],["1639",{"pageContent":"var x = 200, y = 300, z = 100; \n\nvar ol = { x: { y: 42 }, z: { y: z } }; \n\n\nDestructuring | 31 \n\n\n\n\n\n( { y: X = { y: y } } = ol ); \n\n( { z: y = { y: z } } = ol ); \n\n( { x: z = { y: x } } = ol ); \n\nCan you tell from that snippet what values x, y, and z have at the \n\nend? Takes a moment of pondering, I would imagine. I’ll end the \nsuspense: \n\nconsole. log ( x.y, y.y, z.y); // 300 100 42 \n\nThe takeaway here: destructuring is great and can be very useful, but \nit’s also a sharp sword that can cause injury (to someone’s brain) if \nused unwisely. \n\nNested Destructuring \n\nIf the values you’re destructuring have nested objects or arrays, you \ncan destructure those nested values as well: \n\nvar al = [ 1, [2, 3, 4], 5 ]; \n\nvar ol = { x: { y: { z: 6 } } }; \n\nvar [ a, [ b, c, d ], e ] = al; \n\nvar { x: { y: { z: w } } } = ol; \n\nconsole. log ( a, b, c, d, e); // 1 2 3 4 5 \n\nconsole. log ( w ); // 6 \n\nNested destructuring can be a simple way to flatten out object name- \nspaces. For example:","metadata":{"loc":{"lines":{"from":215813,"to":215859}}}}],["1640",{"pageContent":"console. log ( a, b, c, d, e); // 1 2 3 4 5 \n\nconsole. log ( w ); // 6 \n\nNested destructuring can be a simple way to flatten out object name- \nspaces. For example: \n\nvar App = { \nmodel: { \n\nUser: function(){ .. } \n\n} \n\n}; \n\n\n// instead of: \n\n// var User = App.model.User; \nvar { model: { User } } = App; \n\nDestructuring Parameters \n\nIn the following snippet, can you spot the assignment? \n\nfunction foo(x) { \n\nconsole. log( x ); \n\n} \n\nfoo( 42 ); \n\n\n32 | Chapter 2:Syntax \n\n\n\n\n\n\nThe assignment is kinda hidden: 42 (the argument) is assigned to x \n(the parameter) when foo(42) is executed. If parameter/argument \npairing is an assignment, then it stands to reason that it’s an assign¬ \nment that could be destructured, right? Of course! \n\nConsider array destructuring for parameters: \n\nfunction foo( [ x, y ] ) { \nconsole. log( x, y ); \n\n} \n\nfoo( [ 1, 2 ] ); // 1 2 \n\nfoo( [ 1 ] ); // 1 undefined \n\nfoo( [] ); // undefined undefined \n\nObject destructuring for parameters works, too:","metadata":{"loc":{"lines":{"from":215859,"to":215919}}}}],["1641",{"pageContent":"function foo( [ x, y ] ) { \nconsole. log( x, y ); \n\n} \n\nfoo( [ 1, 2 ] ); // 1 2 \n\nfoo( [ 1 ] ); // 1 undefined \n\nfoo( [] ); // undefined undefined \n\nObject destructuring for parameters works, too: \n\nfunction foo( { x, y } ) { \nconsole. log( x, y ); \n\n} \n\nfoo( { y: 1, x: 2 } ); // 2 1 \n\nfoo( { y: 42 } ); // undefined 42 \n\nfoo( {} ); // undefined undefined \n\nThis technique is an approximation of named arguments (a long \nrequested feature for JS!), in that the properties on the object map to \nthe destructured parameters of the same names. That also means \nthat we get optional parameters (in any position) for free; as you can \nsee, leaving off the x “parameter” worked as we’d expect.","metadata":{"loc":{"lines":{"from":215919,"to":215947}}}}],["1642",{"pageContent":"Of course, all the previously discussed variations of destructuring \nare available to us with parameter destructuring, including nested \ndestructuring, default values, and more. Destructuring also mixes \nfine with other ES6 function parameter capabilities, like default \nparameter values and rest/gather parameters. \n\nConsider these quick illustrations (certainly not exhaustive of the \npossible variations): \n\nfunction fl([ x=2, y=3, z ]) { .. } \nfunction f2 ([ x, y, ...z], w) { .. } \n\nfunction f 3 ([ x, y, ...z], ...w) { .. } \n\nfunction f4({ x: X, y }) { .. } \n\nfunction f5 ({ x: X = 10, y = 20 }) { .. } \n\nfunction f 6( { x = 10 } = {}, { y } = { y: 10 }) { .. } \n\nLet’s take one example from this snippet and examine it, for illustra¬ \ntion purposes: \n\n\nDestructuring | 33 \n\n\n\nfunction f3([ x, y, ...z], ...w) { \nconsole. log( x, y, z, w ); \n\n} \n\nf3( [] ); // undefined undefined [] [] \n\nf3( [1,2, 3,4], 5, 6 ); // 1 2 [3,4] [5,6]","metadata":{"loc":{"lines":{"from":215949,"to":215984}}}}],["1643",{"pageContent":"Destructuring | 33 \n\n\n\nfunction f3([ x, y, ...z], ...w) { \nconsole. log( x, y, z, w ); \n\n} \n\nf3( [] ); // undefined undefined [] [] \n\nf3( [1,2, 3,4], 5, 6 ); // 1 2 [3,4] [5,6] \n\nThere are two ... operators in use here, and they’re both gathering \nvalues in arrays (z and w), though ... z gathers from the rest of the \nvalues left over in the first array argument, while ... w gathers from \nthe rest of the main arguments left over after the first. \n\nDestructuring Defaults + Parameter Defaults \n\nThere’s one subtle point you should be particularly careful to notice \n—the difference in behavior between a destructuring default value \nand a function parameter default value. For example: \n\nfunction f6({x = 10} = {}, { y } = { y: 10}) { \nconsole. log( x, y ); \n\n} \n\nf6(); // 10 10","metadata":{"loc":{"lines":{"from":215984,"to":216013}}}}],["1644",{"pageContent":"function f6({x = 10} = {}, { y } = { y: 10}) { \nconsole. log( x, y ); \n\n} \n\nf6(); // 10 10 \n\nAt first, it would seem that we’ve declared a default value of 10 for \nboth the x and y parameters, but in two different ways. However, \nthese two different approaches will behave differently in certain \ncases, and the difference is awfully subtle. \n\nConsider: \n\nf 6( {},{}); // 10 undefined \n\nWait, why did that happen? It’s pretty clear that named parameter x \nis defaulting to 10 if not passed as a property of that same name in \nthe first argument’s object. \n\nBut what about y being undefined? The { y: 10 } value is an \nobject as a function parameter default value, not a destructuring \ndefault value. As such, it only applies if the second argument is not \npassed at all, or is passed as undefined. \n\nIn the previous snippet, we are passing a second argument ({}), so \nthe default { y: 10 } value is not used, and the { y } destructuring \noccurs against the passed-in {} empty object value.","metadata":{"loc":{"lines":{"from":216013,"to":216040}}}}],["1645",{"pageContent":"In the previous snippet, we are passing a second argument ({}), so \nthe default { y: 10 } value is not used, and the { y } destructuring \noccurs against the passed-in {} empty object value. \n\nNow, compare { y } = { y: 10 } to { x = 10 } = {}. \n\n\n34 | Chapter 2:Syntax \n\n\n\n\nFor the x’s form usage, if the first function argument is omitted or \nundefined, the {} empty object default applies. Then, whatever \nvalue is in the first argument position—either the default {} or \nwhatever you passed in—is destructured with the { x = 10 }, \nwhich checks to see if an x property is found, and if not found (or \nundefined), the 10 default value is applied to the x named \nparameter. \n\nDeep breath. Read back over those last few paragraphs a couple of \ntimes. Let’s review via code: \n\n\nfunction f6 ({ x = 10 } = {},{ y } = { y: 10 }) { \nconsole. log( x, y ); \n\n} \n\nf6(); // 10 10 \n\nf6( undefined, undefined ); // 10 10 \n\nf6( {}, undefined ); // 10 10 \n\n\nf6( {}, {} ); \n\nf6( undefined, {} );","metadata":{"loc":{"lines":{"from":216040,"to":216078}}}}],["1646",{"pageContent":"} \n\nf6(); // 10 10 \n\nf6( undefined, undefined ); // 10 10 \n\nf6( {}, undefined ); // 10 10 \n\n\nf6( {}, {} ); \n\nf6( undefined, {} ); \n\n\n// 10 undefined \n// 10 undefined \n\n\nf6( { x: 2 }, { y: 3 } ); // 2 3 \n\nIt would generally seem that the defaulting behavior of the x param¬ \neter is probably the more desirable and sensible case compared to \nthat of y. As such, it’s important to understand why and how { x = \n10 } = {} form is different from { y } = { y: 10 } form. \n\nIf that’s still a bit fuzzy, go back and read it again, and play with this \nyourself. Your future self will thank you for taking the time to get \nthis very subtle gotcha nuance detail straight. \n\n\nNested Defaults: Destructured and Restructured \n\nAlthough it may at first be difficult to grasp, an interesting idiom \nemerges for setting defaults for a nested object’s properties: using \nobject destructuring along with what I’d call restructuring. \n\nConsider a set of defaults in a nested object structure, like the fol¬ \nlowing:","metadata":{"loc":{"lines":{"from":216078,"to":216115}}}}],["1647",{"pageContent":"Consider a set of defaults in a nested object structure, like the fol¬ \nlowing: \n\n// taken fron: \n\n// http://es-discourse.eom/t/partial-default-argunents/120/7 \n\nvar defaults = { \noptions: { \n\nremove: true. \n\n\nDestructuring | 35 \n\n\n\n\nenable: false. \n\nInstance: {} \n\n}. \n\nlog: { \n\nwarn: true, \nerror: true \n\n} \n\n}; \n\nNow, let’s say you have an object called conf Ig, which has some of \nthese applied, but perhaps not all, and you’d like to set all the \ndefaults into this object in the missing spots, but not override spe¬ \ncific settings already present: \n\nvar config = { \noptions: { \n\nremove: false, \ninstance: null \n\n} \n\n}; \n\nYou can of course do so manually, as you might have done in the \npast: \n\nconfig.options = config.options || {}; \n\nconfig.options . remove = (config.options . remove !== undefined) ? \nconfig.options . remove : defaults.options.remove; \n\nconfig.options.enable = (config.options.enable !== undefined) ? \nconfig.options.enable : defaults.options.enable; \n\n\nYuck.","metadata":{"loc":{"lines":{"from":216115,"to":216175}}}}],["1648",{"pageContent":"config.options.enable = (config.options.enable !== undefined) ? \nconfig.options.enable : defaults.options.enable; \n\n\nYuck. \n\nOthers may prefer the assign-overwrite approach to this task. You \nmight be tempted by the ES6 Object.assign (..) utility (see Chap¬ \nter 6) to clone the properties first from defaults and then overwrit¬ \nten with the cloned properties from config, as so: \n\nconfig = Object. assign( {}, defaults, config ); \n\nThat looks way nicer, huh? But there’s a major problem! \nObject.assign( ..) is shallow, which means when it copies \ndefaults.options, it just copies that object reference, not deep \ncloning that object’s properties to a config .options object. \nOb ject. assign (..) would need to be applied (sort of “recursively”) \nat all levels of your object’s tree to get the deep cloning you’re \nexpecting. \n\n\n36 | Chapter 2:Syntax","metadata":{"loc":{"lines":{"from":216175,"to":216197}}}}],["1649",{"pageContent":"36 | Chapter 2:Syntax \n\n\n\n\n\nMany JS utility libraries/frameworks provide \ntheir own option for deep cloning of an object, \nbut those approaches and their gotchas are \nbeyond our scope to discuss here. \n\n\nSo let’s examine if ES6 object destructuring with defaults can help at \nall: \n\n\nconfig.options = conflg.options || {}; \nconfig.iog = config.iog || {}; \n\n{ \n\noptions: { \n\nremove: config . options . remove = default. options . remove, \nenable: config.options.enable = default. options.enable, \ninstance: config.options.instance = \n\ndefault. options.instance \n\n} = {}, \n\nlog: { \n\nwarn: config.log.warn = default. log.warn, \nerror: config.log.error = default. log.error \n\n} = {} \n\n} = config; \n\nNot as nice as the false promise of Object.assign(..) (being that \nit’s shallow only), but it’s better than the manual approach by a fair \nbit, I think. It is still unfortunately verbose and repetitive, though.","metadata":{"loc":{"lines":{"from":216197,"to":216239}}}}],["1650",{"pageContent":"The previous snippet’s approach works because I’m hacking the \ndestructuring and defaults mechanism to do the property === unde \nfined checks and assignment decisions for me. It’s a trick in that I’m \ndestructuring config (see the = config at the end of the snippet), \nbut I’m reassigning all the destructured values right back into \nconfig, with the config. options. enable assignment references. \n\nStill too much, though. Let’s see if we can make anything better. \n\nThe following trick works best if you know that all the various prop¬ \nerties you’re destructuring are uniquely named. You can still do it \neven if that’s not the case, but it’s not as nice—you’ll have to do the \ndestructuring in stages, or create unique local variables as temporary \naliases. \n\nIf we fully destructure all the properties into top-level variables, we \ncan then immediately restructure to reconstitute the original nested \nobject structure. \n\n\nDestructuring | 37","metadata":{"loc":{"lines":{"from":216241,"to":216261}}}}],["1651",{"pageContent":"If we fully destructure all the properties into top-level variables, we \ncan then immediately restructure to reconstitute the original nested \nobject structure. \n\n\nDestructuring | 37 \n\n\n\n\n\n\n\nBut all those temporary variables hanging around would pollute \nscope. So, let’s use block scoping (see “Block-Scoped Declarations” \non page 7 earlier in this chapter) with a general { } enclosing block: \n\n//merge 'defaults' into 'config' \n\n{ \n\n// destructure (with default value assignments) \n\nlet { \n\noptions: { \n\nremove = defaults.options.remove, \nenable = defaults.options.enable. \n\nInstance = defaults.options.Instance \n} = {}, \nlog: { \n\nwarn = defaults.log.warn, \nerror = defaults.log.error \n} = {} \n\n} = config; \n\n// restructure \nconfig = { \n\noptions: { remove, enable. Instance }, \nlog: { warn, error } \n\n}; \n\n} \n\nThat seems a fair bit nicer, huh?","metadata":{"loc":{"lines":{"from":216261,"to":216311}}}}],["1652",{"pageContent":"} = config; \n\n// restructure \nconfig = { \n\noptions: { remove, enable. Instance }, \nlog: { warn, error } \n\n}; \n\n} \n\nThat seems a fair bit nicer, huh? \n\n\n\nYou could also accomplish the scope enclosure \nwith an arrow IIFE instead of the general { } \nblock and let declarations. Your destructuring \nassignments/defaults would be in the parameter \nlist and your restructuring would be the return \nstatement in the function body. \n\n\nThe { warn, error } syntax in the restructuring part may look \nnew to you; that’s called “concise properties” and we cover it in the \nnext section! \n\nObject Literal Extensions \n\nES6 adds a number of important convenience extensions to the \nhumble { .. } object literal. \n\nConcise Properties \n\nYou’re certainly familiar with declaring object literals in this form: \n\n\n38 | Chapter 2:Syntax \n\n\n\n\nvar x = 2, y = 3, \no = { \n\nx: x, \ny: y \n\n};","metadata":{"loc":{"lines":{"from":216311,"to":216360}}}}],["1653",{"pageContent":"Concise Properties \n\nYou’re certainly familiar with declaring object literals in this form: \n\n\n38 | Chapter 2:Syntax \n\n\n\n\nvar x = 2, y = 3, \no = { \n\nx: x, \ny: y \n\n}; \n\nIf it’s always felt redundant to say x: x all over, there’s good news. If \nyou need to define a property that is the same name as a lexical \nidentifier, you can shorten it from x: x to x. Consider: \n\nvar x = 2, y = 3, \no = { \n\nX, \n\ny \n\n}; \n\nConcise Methods \n\nIn a similar spirit to concise properties we just examined, functions \nattached to properties in object literals also have a concise form, for \nconvenience. \n\nThe old way: \n\nvar o = { \n\nx: function( ){ \n\n// •• \n\n}. \n\ny: functlon(){ \n\n// •• \n\n} \n\n} \n\nAnd as of ES6: \n\nvar o = { \n\nx() { \n\n// •• \n\n}. \n\ny() { \n\n// \n\n} \n\n} \n\n\n\nWhile x() { .. } seems to just be shorthand \nfor x: function(){ .. }, concise methods \n\nhave special behaviors that their older counter¬ \nparts don’t; specifically, the allowance for super \n(see “Object super” on page 47 later in this chap¬ \nter).","metadata":{"loc":{"lines":{"from":216360,"to":216441}}}}],["1654",{"pageContent":"have special behaviors that their older counter¬ \nparts don’t; specifically, the allowance for super \n(see “Object super” on page 47 later in this chap¬ \nter). \n\n\nObject Literal Extensions | 39 \n\n\n\n\n\nGenerators (see Chapter 4) also have a concise method form: \n\nvar o = { \n\n*f°o() { } \n\n}; \n\nConcisely Unnamed \n\nWhile that convenience shorthand is quite attractive, there’s a subtle \ngotcha to be aware of. To illustrate, let’s examine pre-ES6 code like \nthe following, which you might try to refactor to use concise \nmethods: \n\nfunction runSomething(o) { \nvar x = Math. random( ), \ny = Math. random( ); \n\nreturn o.something( x, y ); \n\n} \n\nrunSomething( { \n\nsomething: function something(x,y) { \nif (x > y) { \n\n// recursively call with 'x' \n\n// and 'y' swapped \nreturn something( y, x ); \n\n} \n\nreturn y - x; \n\n} \n\n} );","metadata":{"loc":{"lines":{"from":216441,"to":216492}}}}],["1655",{"pageContent":"} \n\nrunSomething( { \n\nsomething: function something(x,y) { \nif (x > y) { \n\n// recursively call with 'x' \n\n// and 'y' swapped \nreturn something( y, x ); \n\n} \n\nreturn y - x; \n\n} \n\n} ); \n\nThis obviously silly code just generates two random numbers and \nsubtracts the smaller from the bigger. But what’s important here isn’t \nwhat it does, but rather how it’s defined. Let’s focus on the object lit¬ \neral and function definition, as we see here: \n\nrunSomething( { \n\nsomething: function something(x,y) { \n\n// \n\n} \n\n} ); \n\nWhy do we say both something: and function something? Isn’t \nthat redundant? Actually, no, both are needed for different purposes. \nThe property something is how we can call o.something( ..), sort \nof like its public name. But the second something is a lexical name \nto refer to the function from inside itself, for recursion purposes. \n\n\n40 | Chapter 2:Syntax","metadata":{"loc":{"lines":{"from":216492,"to":216534}}}}],["1656",{"pageContent":"40 | Chapter 2:Syntax \n\n\n\n\nCan you see why the line return somethlng(y,x) needs the name \nsomething to refer to the function? There’s no lexical name for the \nobject, such that it could have said return o.somethlng(y,x) or \nsomething of that sort. \n\nThat’s actually a pretty common practice when the object literal does \nhave an identifying name, such as: \n\nvar controller = { \n\nmakeRequest : functlon( ..){ \n\n// •• \n\ncontroller . makeRequest (..); \n\n} \n\n}; \n\nIs this a good idea? Perhaps, perhaps not. You’re assuming that the \nname controller will always point to the object in question. But it \nvery well may not—the makeRequest(..) function doesn’t control \nthe outer code and so can’t force that to be the case. This could come \nback to bite you. \n\nOthers prefer to use this to define such things: \n\nvar controller = { \n\nmakeRequest: function! ..){ \n\n// •• \n\nthis .makeRequest! ..); \n\n} \n\n};","metadata":{"loc":{"lines":{"from":216534,"to":216577}}}}],["1657",{"pageContent":"Others prefer to use this to define such things: \n\nvar controller = { \n\nmakeRequest: function! ..){ \n\n// •• \n\nthis .makeRequest! ..); \n\n} \n\n}; \n\nThat looks fine, and should work if you always invoke the method as \ncontroller.makeRequest!..). But you now have a this binding \ngotcha if you do something like: \n\nbtn.addEventLlstener! \"click\", controller.makeRequest, false ); \n\nOf course, you can solve that by passing controller.makeRe \nquest.blnd(controller) as the handler reference to bind the event \nto. But yuck—it isn’t very appealing. \n\nOr what if your inner this .makeRequest! • ■) call needs to be made \nfrom a nested function? You’ll have another this binding hazard, \nwhich people will often solve with the hacky va r self = this, such \nas: \n\n\nvar controller = { \n\nmakeRequest: function! ..){ \nvar self = this; \n\n\nObject Literal Extensions | 41 \n\n\n\n\nbtn.addEventl_istener( \"click\", functxon(){ \n\n// \n\nself .makeRequest( ..); \n\n}, false ); \n\n} \n\n}; \n\nMore yuck.","metadata":{"loc":{"lines":{"from":216577,"to":216630}}}}],["1658",{"pageContent":"makeRequest: function! ..){ \nvar self = this; \n\n\nObject Literal Extensions | 41 \n\n\n\n\nbtn.addEventl_istener( \"click\", functxon(){ \n\n// \n\nself .makeRequest( ..); \n\n}, false ); \n\n} \n\n}; \n\nMore yuck. \n\n\n\nFor more information on this binding rules \nand gotchas, see Chapters 1-2 of the this & \nObject Prototypes title of this series. \n\n\nOK, what does all this have to do with concise methods? Recall our \nsomething(..) method definition: \n\nrunSomething( { \n\nsomething: function something(x,y) { \n\n// •• \n\n} \n\n} ); \n\nThe second something here provides a super convenient lexical \nidentifier that will always point to the function itself, giving us the \nperfect reference for recursion, event binding/unbinding, and so on \n—no messing around with this or trying to use an untrustable \nobject reference. \n\nGreat! \n\nSo, now we try to refactor that function reference to this ES6 concise \nmethod form: \n\nrunSomething( { \n\nsomething(x,y) { \nif (x > y) { \n\nreturn something! y, x ); \n\n} \n\nreturn y - x; \n\n}","metadata":{"loc":{"lines":{"from":216630,"to":216695}}}}],["1659",{"pageContent":"Great! \n\nSo, now we try to refactor that function reference to this ES6 concise \nmethod form: \n\nrunSomething( { \n\nsomething(x,y) { \nif (x > y) { \n\nreturn something! y, x ); \n\n} \n\nreturn y - x; \n\n} \n\n1 ); \n\nSeems fine at first glance, except this code will break. The return \nsomething (..) call will not find a something identifier, so you’ll get \na ReferenceError. Oops. But why? \n\nThe above ES6 snippet is interpreted as meaning: \n\n\n42 | Chapter 2:Syntax \n\n\n\n\n\nrunSomethi.ng( { \n\nsomething: function(x,y){ \nif (x > y) { \n\nreturn something( y, x ); \n\n} \n\n\nreturn y - x; \n\n} \n\n} ); \n\nLook closely. Do you see the problem? The concise method defini¬ \ntion implies something: function(x,y). See how the second some \nthing we were relying on has been omitted? In other words, concise \nmethods imply anonymous function expressions. \n\nYeah, yuck.","metadata":{"loc":{"lines":{"from":216695,"to":216749}}}}],["1660",{"pageContent":"Yeah, yuck. \n\n\n\nYou may be tempted to think that => arrow \nfunctions are a good solution here, but they’re \nequally insufficient, as they’re also anonymous \nfunction expressions. We’ll cover them in \n“Arrow Functions” on page 54 later in this chap¬ \nter. \n\n\nThe partially redeeming news is that our something(x,y) concise \nmethod won’t be totally anonymous. See “Function Names” on page \n200 in Chapter 7 for information about ES6 function name infer¬ \nence rules. That won’t help us for our recursion, but it helps with \ndebugging at least. \n\nSo what are we left to conclude about concise methods? They’re \nshort and sweet, and a nice convenience. But you should only use \nthem if you’re never going to need them to do recursion or event \nbinding/unbinding. Otherwise, stick to your old-school something: \nfunction something (..) method definitions.","metadata":{"loc":{"lines":{"from":216749,"to":216771}}}}],["1661",{"pageContent":"A lot of your methods are probably going to benefit from concise \nmethod definitions, so that’s great news! Just be careful of the few \nwhere there’s an un-naming hazard. \n\nES5 Getter/Setter \n\nTechnically, ES5 defined getter/setter literals forms, but they didn’t \nseem to get used much, mostly due to the lack of transpilers to han¬ \ndle that new syntax (the only major new syntax added in ES5, \nreally). So while it’s not a new ES6 feature, we’ll briefly refresh on \n\n\nObject Literal Extensions | 43 \n\n\n\n\n\n\nthat form, as it’s probably going to be much more useful with ES6 \ngoing forward. \n\nConsider: \n\nvar o = { \n\n_id: 10, \n\nget id() { return this. _ id++; }, \n\nset id(v) { this. _id = v; } \n\n} \n\n\no.id; \n\n// 10 \n\no.id; \n\n// 11 \n\no.id = 20; \no.id; \n\n// 20 \n\n// and: \n\no._id; \n\n// 21 \n\no._id; \n\n// 21--still! \n\n\nThese getter and setter literal forms are also present in classes; see \nChapter 3.","metadata":{"loc":{"lines":{"from":216773,"to":216833}}}}],["1662",{"pageContent":"o.id; \n\n// 10 \n\no.id; \n\n// 11 \n\no.id = 20; \no.id; \n\n// 20 \n\n// and: \n\no._id; \n\n// 21 \n\no._id; \n\n// 21--still! \n\n\nThese getter and setter literal forms are also present in classes; see \nChapter 3. \n\n\n\nIt may not be obvious, but the setter literal must \nhave exactly one declared parameter; omitting it \nor listing others is illegal syntax. The single \nrequired parameter can use destructuring and \ndefaults (e.g., set id({ id: v = 0 }) { .. }), \nbut the gather/rest ... is not allowed (set \nid(.. .v) { .. }). \n\n\nComputed Property Names \n\nYou’ve probably been in a situation like the following snippet, where \nyou have one or more property names that come from some sort of \nexpression and thus can’t be put into the object literal: \n\nvar prefix = \"user_\"; \nvar o = { \n\nbaz: function( ..){ .. } \n\n}; \n\n\no[ prefix + \"foo\" ] = function! ..){ •• }; \no[ prefix + \"bar\" ] = function( ..){ .. }; \n\n\n44 | Chapter 2: Syntax","metadata":{"loc":{"lines":{"from":216833,"to":216889}}}}],["1663",{"pageContent":"var prefix = \"user_\"; \nvar o = { \n\nbaz: function( ..){ .. } \n\n}; \n\n\no[ prefix + \"foo\" ] = function! ..){ •• }; \no[ prefix + \"bar\" ] = function( ..){ .. }; \n\n\n44 | Chapter 2: Syntax \n\n\n\n\n\nES6 adds a syntax to the object literal definition that allows you to \nspecify an expression that should be computed, whose result is the \nproperty name assigned. Consider: \n\nvar prefix = \"user_\"; \nvar o = { \n\nbaz: function! ..){ .. }, \n\n[ prefix + \"foo\" ]: function( ..){ .. }, \n\n[ prefix + \"bar\" ]: function! ..){ •• } \n\n}; \n\nAny valid expression can appear inside the [ .. ] that sits in the \nproperty name position of the object literal definition. \n\nProbably the most common use of computed property names will be \nwith Symbols (which we cover in “Symbols” on page 80 later in this \nchapter), such as: \n\nvar o = { \n\n[Symbot. toStringTag]: \"really cool thing\". \n\n\n};","metadata":{"loc":{"lines":{"from":216889,"to":216934}}}}],["1664",{"pageContent":"var o = { \n\n[Symbot. toStringTag]: \"really cool thing\". \n\n\n}; \n\nSymbol.toStringTag is a special built-in value, which we evaluate \nwith the [ .. ] syntax, so we can assign the \"really cool thing\" \nvalue to the special property name. \n\nComputed property names can also appear as the name of a concise \nmethod or a concise generator: \n\nvar o = { \n\n[\"f\" + \"oo\"]() { .. } // computed concise method \n\n*[\"b\" + \"ar\"]() { .. } // computed concise generator \n\n}; \n\nSetting [[Prototype]] \n\nWe won’t cover prototypes in detail here, so for more information, \nsee the this & Object Prototypes title of this series. \n\nSometimes it will be helpful to assign the [[Prototype]] of an \nobject at the same time you’re declaring its object literal. The follow¬ \ning has been a nonstandard extension in many JS engines for a \nwhile, but is standardized as of ES6: \n\nvar ol = { \n\n// ■■ \n\n}; \n\n\nObject Literal Extensions | 45 \n\n\n\nvar o2 = { \n\n_proto_: ol, \n\n// •• \n\n};","metadata":{"loc":{"lines":{"from":216934,"to":216983}}}}],["1665",{"pageContent":"var ol = { \n\n// ■■ \n\n}; \n\n\nObject Literal Extensions | 45 \n\n\n\nvar o2 = { \n\n_proto_: ol, \n\n// •• \n\n}; \n\no2 is declared with a normal object literal, but it’s also \n\n[ [Prototype] ]-linked to ol. The_ proto _property name here \n\ncan also be a string \"_ proto _\", but note that it cannot be the \n\nresult of a computed property name (see the previous section). \n\n_proto _is controversial, to say the least. It’s a decades-old propri¬ \netary extension to JS that is finally standardized, somewhat begrudg¬ \ningly it seems, in ES6. Many developers feel it shouldn’t ever be used. \nIn fact, it’s in “Annex B” of ES6, which is the section that lists things \nJS feels it has to standardize for compatibility reasons only. \n\n\n\nThough I’m narrowly endorsing_ proto _as a \n\nkey in an object literal definition, I definitely do \nnot endorse using it in its object property form, \n\nlike o._proto _. That form is both a getter and","metadata":{"loc":{"lines":{"from":216983,"to":217023}}}}],["1666",{"pageContent":"key in an object literal definition, I definitely do \nnot endorse using it in its object property form, \n\nlike o._proto _. That form is both a getter and \n\nsetter (again for compatibility reasons), but \nthere are definitely better options. See the this & \nObject Prototypes title of this series for more \ninformation. \n\n\nFor setting the [ [Prototype] ] of an existing object, you can use the \nES6 utility Object. setPrototypeOf (..). Consider: \n\nvar ol = { \n\n// \n\n}; \n\nvar o2 = { \n\n// \n\n}; \n\n\nObject. setPrototypeOf ( o2, ol ); \n\n\n\nWe’ll discuss Object again in Chapter 6. \n“Object. setPrototypeOf! ..) Static Function” \nprovides additional details on Object.setProto \ntypeOf(..). Also see “Object.assign(..) Static \nFunction” on page 188 for another form that \nrelates o2 prototypically to ol. \n\n\n46 | Chapter 2:Syntax \n\n\n\n\n\n\n\n\nObject super","metadata":{"loc":{"lines":{"from":217023,"to":217071}}}}],["1667",{"pageContent":"46 | Chapter 2:Syntax \n\n\n\n\n\n\n\n\nObject super \n\nsuper is typically thought of as being only related to classes. How¬ \never, due to JS’s classless-objects-with-prototypes nature, super is \nequally effective, and nearly the same in behavior, with plain objects’ \nconcise methods. \n\nConsider: \n\nvar ol = { \nfoo() { \n\nconsole. log( \"ol:foo\" ); \n\n} \n\n}; \n\n\nvar o2 = { \nfoo() { \n\nsuper. foo(); \n\nconsole. log( \"o2:foo\" ); \n\n} \n\n}; \n\n\nObject.setPrototypeOf( o2, ol ); \n\no2.foo(); // ol:foo \n\n// o2:foo \n\n\n\nsuper is only allowed in concise methods, not \nregular function expression properties. It also is \nonly allowed in super.XXX form (for property/ \nmethod access), not in super( ) form. \n\n\nThe super reference in the o2.foo() method is locked statically to \no2, and specifically to the [[Prototype]] of o2. super here would \nbasically be Object.getPrototypeOf(o2)— resolves to ol of course \n—which is how it finds and calls ol. f oo().","metadata":{"loc":{"lines":{"from":217071,"to":217128}}}}],["1668",{"pageContent":"For complete details on super, see “Classes” on page 135 in Chap¬ \nter 3. \n\nTemplate Literals \n\nAt the very outset of this section, I’m going to have to call out the \nname of this ES6 feature as being awfully... misleading, depending \non your experiences with what the word template means. \n\n\nTemplate Literals | 47 \n\n\n\n\nMany developers think of templates as being reusable renderable \npieces of text, such as the capability provided by most template \nengines (Mustache, Handlebars, etc.). ES6’s use of the word template \nwould imply something similar, like a way to declare inline template \nliterals that can be re-rendered. However, that’s not at all the right \nway to think about this feature. \n\nSo, before we go on, I’m renaming it to what it should have been \ncalled: interpolated string literals (or interpoliterals for short).","metadata":{"loc":{"lines":{"from":217130,"to":217153}}}}],["1669",{"pageContent":"So, before we go on, I’m renaming it to what it should have been \ncalled: interpolated string literals (or interpoliterals for short). \n\nYou’re already well aware of declaring string literals with \" or ' \ndelimiters, and you also know that these are not smart strings (as \nsome languages have), where the contents would be parsed for inter¬ \npolation expressions. \n\nHowever, ES6 introduces a new type of string literal, using the \nbacktick as the delimiter. These string literals allow basic string \ninterpolation expressions to be embedded, which are then automati¬ \ncally parsed and evaluated. \n\nHere’s the old pre-ES6 way: \n\nvar name = \"Kyle\"; \n\n\nvar greeting = \"Hello \" + name + \n\nconsole. log( greeting ); // \"Hello Kyle! \n\nconsole. log( typeof greeting ); // \"string\" \n\nNow, consider the new ES6 way: \n\nvar name = \"Kyle\"; \n\nvar greeting = 'Hello ${name}!'; \n\n\nconsole. log( greeting ); // \"Hello Kyle!\" \n\nconsole. log( typeof greeting ); // \"string\"","metadata":{"loc":{"lines":{"from":217153,"to":217186}}}}],["1670",{"pageContent":"Now, consider the new ES6 way: \n\nvar name = \"Kyle\"; \n\nvar greeting = 'Hello ${name}!'; \n\n\nconsole. log( greeting ); // \"Hello Kyle!\" \n\nconsole. log( typeof greeting ); // \"string\" \n\nAs you can see, we used the '..' around a series of characters, \nwhich are interpreted as a string literal, but any expressions of the \nform ${..} are parsed and evaluated inline immediately. The fancy \nterm for such parsing and evaluating is interpolation (much more \naccurate than templating). \n\nThe result of the interpolated string literal expression is just a plain \nold normal string, assigned to the greeting variable. \n\n\n48 | Chapter 2:Syntax","metadata":{"loc":{"lines":{"from":217186,"to":217207}}}}],["1671",{"pageContent":"The result of the interpolated string literal expression is just a plain \nold normal string, assigned to the greeting variable. \n\n\n48 | Chapter 2:Syntax \n\n\n\n\n\ntypeof greeting == \"string\" illustrates why \nit’s important not to think of these entities as \nspecial template values, as you cannot assign the \nunevaluated form of the literal to something and \nreuse it. The '..' string literal is more like an \nIIFE in the sense that it’s automatically evaluated \ninline. The result of a '..' string literal is, sim¬ \nply, just a string. \n\n\nOne really nice benefit of interpolated string literals is they are \nallowed to split across multiple lines: \n\nvar text = \n\n'Now is the tine for all good nen \nto cone to the aid of their \ncountry!' ; \n\nconsole. log ( text ); \n\n// Now is the tine for all good nen \n// to cone to the aid of their \n// country! \n\nThe line breaks (newlines) in the interpolated string literal were pre¬ \nserved in the string value.","metadata":{"loc":{"lines":{"from":217207,"to":217243}}}}],["1672",{"pageContent":"// Now is the tine for all good nen \n// to cone to the aid of their \n// country! \n\nThe line breaks (newlines) in the interpolated string literal were pre¬ \nserved in the string value. \n\nUnless appearing as explicit escape sequences in the literal value, the \nvalue of the \\r carriage return character (code point U+000D) or the \nvalue of the \\r\\n carriage return + line feed sequence (code points U \n+000D and U+000A) are both normalized to a \\n line feed character \n(code point U+000A). Don’t worry though; this normalization is rare \nand would likely only happen if copy-pasting text into your JS file. \n\nInterpolated Expressions \n\nAny valid expression is allowed to appear inside ${..} in an inter¬ \npolated string literal, including function calls, inline function \nexpression calls, and even other interpolated string literals! \n\nConsider: \n\nfunction upper(s) { \n\nreturn s.totlpperCaseQ; \n\n1 \n\nvar who = \"reader\"; \nvar text = \n\n'A very ${upper( \"warn\" )} welcome \n\n\nTemplate Literals | 49","metadata":{"loc":{"lines":{"from":217243,"to":217277}}}}],["1673",{"pageContent":"Consider: \n\nfunction upper(s) { \n\nreturn s.totlpperCaseQ; \n\n1 \n\nvar who = \"reader\"; \nvar text = \n\n'A very ${upper( \"warn\" )} welcome \n\n\nTemplate Literals | 49 \n\n\n\n\nto all of you ${upper( '${who}s' )}!'; \n\n\nconsole. log ( text ); \n\n// A very WARM welcome \n// to all of you READERS! \n\nHere, the inner '${who}s' interpolated string literal was a little bit \nnicer convenience for us when combining the who variable with the \n\"s\" string, as opposed to who + \"s\". There will be cases where nest¬ \ning interpolated string literals is helpful, but be wary if you find \nyourself doing that kind of thing often, or if you find yourself nest¬ \ning several levels deep. \n\nIf that’s the case, the odds are good that your string value production \ncould benefit from some abstractions.","metadata":{"loc":{"lines":{"from":217277,"to":217312}}}}],["1674",{"pageContent":"If that’s the case, the odds are good that your string value production \ncould benefit from some abstractions. \n\n\n\nAs a word of caution, be very careful about the \nreadability of your code with such newfound \npower. Just like with default value expressions \nand destructuring assignment expressions, just \nbecause you can do something doesn’t mean you \nshould do it. Never go so overboard with new \nES6 tricks that your code becomes more clever \nthan you or your other team members. \n\n\nExpression Scope \n\nOne quick note about the scope that is used to resolve variables in \nexpressions. I mentioned earlier that an interpolated string literal is \nkind of like an IIFE, and it turns out thinking about it like that \nexplains the scoping behavior as well. \n\nConsider: \n\nfunction foo(str) { \nvar name = \"foo\"; \nconsole. log( str ); \n\n} \n\nfunction bar() { \n\nvar name = \"bar\"; \n\nfoo( 'Hello from ${name}!' ); \n\n} \n\nvar name = \"global\"; \n\nbar(); // \"Hello from bar!\" \n\n\n50 | Chapter 2:Syntax","metadata":{"loc":{"lines":{"from":217312,"to":217355}}}}],["1675",{"pageContent":"} \n\nfunction bar() { \n\nvar name = \"bar\"; \n\nfoo( 'Hello from ${name}!' ); \n\n} \n\nvar name = \"global\"; \n\nbar(); // \"Hello from bar!\" \n\n\n50 | Chapter 2:Syntax \n\n\n\n\n\nAt the moment the '..' string literal is expressed, inside the bar() \nfunction, the scope available to it finds bar()’s name variable with \nvalue \"bar\". Neither the global name nor foo(..) s name matter. In \nother words, an interpolated string literal is just lexically scoped \nwhere it appears, not dynamically scoped in any way. \n\nTagged Template Literals \n\nAgain, renaming the feature for sanity sake: tagged string literals. \n\nTo be honest, this is one of the cooler tricks that ES6 offers. It may \nseem a little strange, and perhaps not all that generally practical at \nfirst. But once you’ve spent some time with it, tagged string literals \nmay just surprise you in their usefulness. \n\nFor example: \n\nfunction foo(strings, ...vatues) { \nconsole. log( strings ); \nconsole. log( values ); \n\n} \n\nvar desc = \"awesome\";","metadata":{"loc":{"lines":{"from":217355,"to":217399}}}}],["1676",{"pageContent":"For example: \n\nfunction foo(strings, ...vatues) { \nconsole. log( strings ); \nconsole. log( values ); \n\n} \n\nvar desc = \"awesome\"; \n\nfoo' Everything is ${desc}!'; \n\n// [ \"Everything is \", \"!\"] \n\n// [ \"awesome\" ] \n\nLet’s take a moment to consider what’s happening in the previous \nsnippet. First, the most jarring thing that jumps out is foo'Every \nthing...'; . That doesn’t look like anything we’ve seen before. What is \nit? \n\nIt’s essentially a special kind of function call that doesn’t need the \n( .. ). The tag —the foo part before the '..' string literal—is a \nfunction value that should be called. Actually, it can be any expres¬ \nsion that results in a function, even a function call that returns \nanother function, like: \n\nfunction bar() { \n\nreturn function foo(strings, ...values) { \nconsole. log( strings ); \nconsole. log( values ); \n\n} \n\n} \n\nvar desc = \"awesome\"; \n\n\nTemplate Literals | 51 \n\n\n\nbar()' Everything is ${desc}!'; \n\n// [ \"Everything is \", \"!\"] \n\n// [ \"awesome\" ]","metadata":{"loc":{"lines":{"from":217399,"to":217447}}}}],["1677",{"pageContent":"} \n\n} \n\nvar desc = \"awesome\"; \n\n\nTemplate Literals | 51 \n\n\n\nbar()' Everything is ${desc}!'; \n\n// [ \"Everything is \", \"!\"] \n\n// [ \"awesome\" ] \n\nBut what gets passed to the foo(..) function when invoked as a tag \nfor a string literal? \n\nThe first argument—we called it strings—is an array of all the \nplain strings (the stuff between any interpolated expressions). We \nget two values in the strings array: \"Everything is \" and \"!\", \n\nFor convenience sake in our example, we then gather up all subse¬ \nquent arguments into an array called values using the ... gather/ \nrest operator (see “Spread/Rest” on page 15 earlier in this chapter), \nthough you could of course have left them as individually named \nparameters following the strings parameter. \n\nThe argument(s) gathered into our values array are the results of \nthe already-evaluated interpolation expressions found in the string \nliteral. So obviously the only element in values in our example is \n\"awesome\".","metadata":{"loc":{"lines":{"from":217447,"to":217480}}}}],["1678",{"pageContent":"You can think of these two arrays as: the values in values are the \nseparators if you were to splice them in between the values in \nstrings, and then if you joined everything together, youd get the \ncomplete interpolated string value. \n\nA tagged string literal is like a processing step after the interpolation \nexpressions are evaluated but before the final string value is com¬ \npiled, allowing you more control over generating the string from the \nliteral. \n\nTypically, the string literal tag function (foo(..) in the previous \nsnippets) should compute an appropriate string value and return it, \nso that you can use the tagged string literal as a value just like untag¬ \nged string literals: \n\nfunction tag(strings, ...values) { \n\nreturn strings . reduce( function(s,v,idx){ \n\nreturn s + (idx > 0 ? values[idx-l] : \"\") + v; \n\n}. \"\" ); \n\n1 \n\nvar desc = \"awesome\"; \n\nvar text = tag' Everything is ${desc}!'; \n\nconsole. log ( text ); // Everything is awesome! \n\n\n52 | Chapter 2:Syntax","metadata":{"loc":{"lines":{"from":217482,"to":217514}}}}],["1679",{"pageContent":"}. \"\" ); \n\n1 \n\nvar desc = \"awesome\"; \n\nvar text = tag' Everything is ${desc}!'; \n\nconsole. log ( text ); // Everything is awesome! \n\n\n52 | Chapter 2:Syntax \n\n\n\nIn this snippet, tag(..) is a pass-through operation, in that it \ndoesn’t perform any special modifications, but just uses reduce(..) \nto loop over and splice/interleave strings and values together the \nsame way an untagged string literal would have done. \n\nSo what are some practical uses? There are many advanced ones that \nare beyond our scope to discuss here. But here’s a simple idea that \nformats numbers as U.S. dollars (sort of like basic localization): \n\nfunction dollabillsyall(strings, ...vatues) { \nreturn strings . reduce( function(s, v,idx){ \nif (idx > 0) { \n\nif (typeof valuesfidx- 1] == \"number\") { \n\n// look, also using interpolated \n// string literals! \ns += '$${vatues[idx-l].toFixed( 2 )}'; \n\n} \n\nelse { \n\ns += valuesfidx- 1]; \n\n} \n\n} \n\nreturn s + v; \n\n}. \"\" ); \n\n} \n\nvar amtl = 11.99,","metadata":{"loc":{"lines":{"from":217514,"to":217564}}}}],["1680",{"pageContent":"// look, also using interpolated \n// string literals! \ns += '$${vatues[idx-l].toFixed( 2 )}'; \n\n} \n\nelse { \n\ns += valuesfidx- 1]; \n\n} \n\n} \n\nreturn s + v; \n\n}. \"\" ); \n\n} \n\nvar amtl = 11.99, \n\namt2 = amtl * 1.08, \nname = \"Kyle\"; \n\nvar text = dollabillsyall \n'Thanks for your purchase, ${name}! Your \nproduct cost was ${amtl}, which with tax \ncomes out to ${amt2}.' \n\nconsole. log ( text ); \n\n// Thanks for your purchase, Kyle! Your \n// product cost was $11.99, which with tax \n// cones out to $12.95. \n\nIf a number value is encountered in the values array, we put \"$\" in \nfront of it and format it to two decimal places with toFixed(2). \nOtherwise, we let the value pass-through untouched. \n\nRaw Strings \n\nIn the previous snippets, our tag functions receive the first argument \nwe called strings, which is an array. But there’s an additional bit of \n\n\nTemplate Literals | SB","metadata":{"loc":{"lines":{"from":217564,"to":217610}}}}],["1681",{"pageContent":"Raw Strings \n\nIn the previous snippets, our tag functions receive the first argument \nwe called strings, which is an array. But there’s an additional bit of \n\n\nTemplate Literals | SB \n\n\n\ndata included: the raw unprocessed versions of all the strings. You \ncan access those raw string values using the . raw property, like this: \n\nfunction showraw(strings, ...values) { \nconsole. log( strings ); \nconsole. log( strings.raw ); \n\n} \n\nshowraw'Hello\\nWorld' ; \n\n// [ \"Hello \n// World\" ] \n\n// [ \"Hello\\nWorld\" ] \n\nThe raw version of the value preserves the raw escaped \\n sequence \n(the \\ and the n are separate characters), while the processed version \nconsiders it a single newline character. However, the earlier men¬ \ntioned line-ending normalization is applied to both values. \n\nES6 comes with a built-in function that can be used as a string literal \ntag: String. raw(.. ). It simply passes through the raw versions of \nthe strings: \n\nconsole. log( 'Hello\\nWorld' ); \n\n// Hello \n// World","metadata":{"loc":{"lines":{"from":217610,"to":217648}}}}],["1682",{"pageContent":"console. log( 'Hello\\nWorld' ); \n\n// Hello \n// World \n\n\nconsole. log( String. raw'Hello\\nWorld' ); \n\n// Hello\\nWorld \n\nString .raw' Hello\\nWorld' . length ; \n\n// 12 \n\nOther uses for string literal tags include special processing for inter¬ \nnationalization, localization, and more! \n\nArrow Functions \n\nWe’ve touched on this binding complications with functions earlier \nin this chapter, and they’re covered at length in the this & Object \nPrototypes title of this series. It’s important to understand the frus¬ \ntrations that this-based programming with normal functions \nbrings, because that is the primary motivation for the new ES6 => \narrow function feature. \n\nLet’s first illustrate what an arrow function looks like, as compared \nto normal functions: \n\n\n54 | Chapter 2:Syntax \n\n\n\n\nfunction foo(x,y) { \nreturn x + y; \n\n} \n\n// versus \n\nvar foo = (x,y) => x + y;","metadata":{"loc":{"lines":{"from":217648,"to":217690}}}}],["1683",{"pageContent":"54 | Chapter 2:Syntax \n\n\n\n\nfunction foo(x,y) { \nreturn x + y; \n\n} \n\n// versus \n\nvar foo = (x,y) => x + y; \n\nThe arrow function definition consists of a parameter list (of zero or \nmore parameters, and surrounding ( .. ) if there’s not exactly one \nparameter), followed by the => marker, followed by a function body. \n\nSo, in the previous snippet, the arrow function is just the (x,y) => \nx + y part, and that function reference happens to be assigned to \nthe variable foo. \n\nThe body only needs to be enclosed by { .. } if there’s more than \none expression, or if the body consists of a non-expression state¬ \nment. If there’s only one expression, and you omit the surrounding \n{ .. }, there’s an implied return in front of the expression, as illus¬ \ntrated in the previous snippet. \n\nHere’s some other arrow function variations to consider: \n\nvar ft = () => 12; \nvar f2 = x => x * 2; \nvar f3 = (x,y) => { \nvar z = x * 2 + y; \n\ny++; \n\nx *= 3; \n\nreturn (x + y + z) / 2; \n\n};","metadata":{"loc":{"lines":{"from":217690,"to":217731}}}}],["1684",{"pageContent":"Here’s some other arrow function variations to consider: \n\nvar ft = () => 12; \nvar f2 = x => x * 2; \nvar f3 = (x,y) => { \nvar z = x * 2 + y; \n\ny++; \n\nx *= 3; \n\nreturn (x + y + z) / 2; \n\n}; \n\nArrow functions are always function expressions; there is no arrow \nfunction declaration. It also should be clear that they are anonymous \nfunction expressions—they have no named reference for the pur¬ \nposes of recursion or event binding/unbinding—though “Function \nNames” on page 200 in Chapter 7 will describe ES6’s function name \ninference rules for debugging purposes. \n\n\n\nAll the capabilities of normal function parame¬ \nters are available to arrow functions, including \ndefault values, destructuring, rest parameters, \nand so on. \n\n\nArrow Functions | 55","metadata":{"loc":{"lines":{"from":217731,"to":217761}}}}],["1685",{"pageContent":"All the capabilities of normal function parame¬ \nters are available to arrow functions, including \ndefault values, destructuring, rest parameters, \nand so on. \n\n\nArrow Functions | 55 \n\n\n\n\n\n\n\nArrow functions have a nice, shorter syntax, which makes them on \nthe surface very attractive for writing terser code. Indeed, nearly all \nliterature on ES6 (other than the titles in this series) seems to imme¬ \ndiately and exclusively adopt the arrow function as “the new func¬ \ntion.” \n\nIt is telling that nearly all examples in our discussion of arrow func¬ \ntions are short single statement utilities, such as those passed as call¬ \nbacks to various utilities. For example: \n\nvar a = [1,2, 3,4, 5]; \na = a.map( v => v * 2 ); \n\nconsole. log( a ); // [2,4,6,8,10]","metadata":{"loc":{"lines":{"from":217761,"to":217788}}}}],["1686",{"pageContent":"var a = [1,2, 3,4, 5]; \na = a.map( v => v * 2 ); \n\nconsole. log( a ); // [2,4,6,8,10] \n\nIn those cases, where you have such inline function expressions, and \nthey fit the pattern of computing a quick calculation in a single \nstatement and returning that result, arrow functions indeed look to \nbe an attractive and lightweight alternative to the more verbose f unc \ntion keyword and syntax. \n\nMost people tend to ooh and aah at nice terse examples like that, as I \nimagine you just did! \n\nHowever, I would caution you that it would seem to me somewhat a \nmisapplication of this feature to use arrow function syntax with \notherwise normal, multistatement functions, especially those that \nwould otherwise be naturally expressed as function declarations. \n\nRecall the dollabillsyall(..) string literal tag function from ear¬ \nlier in this chapter—let’s change it to use => syntax: \n\nvar dollablllsyall = (strings, ...values) => \nstrings . reduce( (s,v,idx) => { \nif (idx > 0) {","metadata":{"loc":{"lines":{"from":217788,"to":217812}}}}],["1687",{"pageContent":"var dollablllsyall = (strings, ...values) => \nstrings . reduce( (s,v,idx) => { \nif (idx > 0) { \n\nif (typeof valuesfidx- 1] == \"number\") { \n\n// look, also using interpolated \n// string literals! \ns += '$${values[idx-l].toFixed( 2 )}'; \n\n} \n\nelse { \n\ns += values[idx- 1]; \n\n} \n\n} \n\nreturn s + v; \n\n}. \"\" ); \n\n\n56 | Chapter 2:Syntax \n\n\n\n\nIn this example, the only modifications I made were the removal of \nfunction, return, and some { .. and then the insertion of => \nand a var. Is this a significant improvement in the readability of the \ncode? Meh. \n\nI’d actually argue that the lack of return and outer { .. } partially \nobscures the fact that the reduce(..) call is the only statement in \nthe dollabillsyall(..) function and that its result is the intended \nresult of the call. Also, the trained eye, which is so used to hunting \nfor the word function in code to find scope boundaries, now needs \nto look for the => marker, which can definitely be harder to find in \nthe thick of the code.","metadata":{"loc":{"lines":{"from":217812,"to":217853}}}}],["1688",{"pageContent":"While not a hard-and-fast rule, I’d say that the readability gains \nfrom => arrow function conversion are inversely proportional to the \nlength of the function being converted. The longer the function, the \nless => helps; the shorter the function, the more => can shine. \n\nI think it’s probably more sensible and reasonable to adopt => for the \nplaces in code where you do need short inline function expressions, \nbut leave your normal-length main functions as is. \n\nNot Just Shorter Syntax, But this \n\nMost of the popular attention toward => has been on saving those \nprecious keystrokes by dropping function, return, and { .. } \nfrom your code. \n\nBut there’s a big detail we’ve skipped over so far. I said at the begin¬ \nning of the section that => functions are closely related to this bind¬ \ning behavior. In fact, => arrow functions are primarily designed to \nalter this behavior in a specific way, solving a particular and com¬ \nmon pain point with this-aware coding.","metadata":{"loc":{"lines":{"from":217855,"to":217874}}}}],["1689",{"pageContent":"The saving of keystrokes is a red herring, a misleading sideshow at \nbest. \n\nLet’s revisit another example from earlier in this chapter: \n\nvar controller = { \n\nmakeRequest : function( ..){ \nvar self = this; \n\nbtn.addEventListener( \"click\", function(){ \n\n// \n\nself .nakeRequest( ..); \n\n\nArrow Functions | 57 \n\n\n\n}, false ); \n\n} \n\n}; \n\nWe used the var self = this hack, and then referenced self .mak \neRequest(..), because inside the callback function we’re passing to \naddEventListener(..), the this binding will not be the same as it \nis in makeRequest(..) itself. In other words, because this bindings \nare dynamic, we fall back to the predictability of lexical scope via the \nself variable. \n\nHerein we finally can see the primary design characteristic of => \narrow functions. Inside arrow functions, the this binding is not \ndynamic, but is instead lexical. In the previous snippet, if we used an \narrow function for the callback, this will be predictably what we \nwanted it to be. \n\nConsider:","metadata":{"loc":{"lines":{"from":217876,"to":217916}}}}],["1690",{"pageContent":"Consider: \n\nvar controller = { \n\nmakeRequest: functlon( ..){ \n\nbtn.addEventListener( \"click\", () => { \n\n// \n\nthis. makeRequest ( ..); \n\n}, false ); \n\n} \n\n}; \n\nLexical this in the arrow function callback in the previous snippet \nnow points to the same value as in the enclosing makeRequest(..) \nfunction. In other words, => is a syntactic stand-in for var self = \nthis. \n\nIn cases where var self = this (or, alternatively, a func¬ \ntion .bind(this) call) would normally be helpful, => arrow func¬ \ntions are a nicer alternative operating on the same principle. Sounds \ngreat, right? \n\nNot quite so simple. \n\nIf => replaces var self = this or .bind(this) and it helps, guess \nwhat happens if you use => with a this-aware function that doesn’t \nneed var self = this to work? You might be able to guess that it’s \ngoing to mess things up. Yeah. \n\n\n58 | Chapter 2:Syntax \n\n\n\n\nConsider: \n\n\nvar controller = { \n\nmakeRequest: (..) => { \n// •• \n\nthis .helper( ..); \n\n}, \n\nhelper: (..) => { \n\n// •• \n\n}","metadata":{"loc":{"lines":{"from":217916,"to":217973}}}}],["1691",{"pageContent":"58 | Chapter 2:Syntax \n\n\n\n\nConsider: \n\n\nvar controller = { \n\nmakeRequest: (..) => { \n// •• \n\nthis .helper( ..); \n\n}, \n\nhelper: (..) => { \n\n// •• \n\n} \n\n\ncontroller.makeRequest( ..); \n\nAlthough we invoke as controller.makeRequest( ..), the \nthis.helper reference fails, because this here doesn’t point to con \ntroller as it normally would. Where does it point? It lexically \ninherits this from the surrounding scope. In this previous snippet, \nthat’s the global scope, where this points to the global object. Ugh. \n\nIn addition to lexical this, arrow functions also have lexical argu \nments—they don’t have their own arguments array but instead \ninherit from their parent—as well as lexical super and new.target \n(see “Classes” on page 135 in Chapter 3). \n\nSo now we can conclude a more nuanced set of rules for when => is \nappropriate and when it is not:","metadata":{"loc":{"lines":{"from":217973,"to":218011}}}}],["1692",{"pageContent":"So now we can conclude a more nuanced set of rules for when => is \nappropriate and when it is not: \n\n• If you have a short, single-statement inline function expression, \nwhere the only statement is a return of some computed value, \nand that function doesn’t already make a this reference inside \nit, and there’s no self-reference (recursion, event binding/ \nunbinding), and you don’t reasonably expect the function to \never be that way, you can probably safely refactor it to be an => \narrow function. \n\n• If you have an inner function expression that’s relying on a var \nself = this hack or a .bind(this) call on it in the enclosing \nfunction to ensure proper this binding, that inner function \nexpression can probably safely become an => arrow function. \n\n\nArrow Functions | 59","metadata":{"loc":{"lines":{"from":218011,"to":218028}}}}],["1693",{"pageContent":"Arrow Functions | 59 \n\n\n\n\n• If you have an inner function expression that’s relying on some¬ \nthing like var args = Array.prototype.slice.call(argu \nmerits) in the enclosing function to make a lexical copy of \narguments, that inner function expression can probably safely \nbecome an => arrow function. \n\n• For everything else—normal function declarations, longer mul¬ \ntistatement function expressions, functions that need a lexical \nname identifier self-reference (recursion, etc.), and any other \nfunction that doesn’t fit the previous characteristics—you \nshould probably avoid => function syntax. \n\nBottom line: => is about lexical binding of this, arguments, and \nsuper. These are intentional features designed to fix some common \nproblems, not bugs, quirks, or mistakes in ES6.","metadata":{"loc":{"lines":{"from":218028,"to":218047}}}}],["1694",{"pageContent":"Bottom line: => is about lexical binding of this, arguments, and \nsuper. These are intentional features designed to fix some common \nproblems, not bugs, quirks, or mistakes in ES6. \n\nDon’t believe any hype that => is primarily, or even mostly, about \nfewer keystrokes. Whether you save keystrokes or waste them, you \nshould know exactly what you are intentionally doing with every \ncharacter typed. \n\nIf you have a function that for any of these \narticulated reasons is not a good match for an => \narrow function, but it’s being declared as part of \nan object literal, recall from “Concise Methods” \non page 39 earlier in this chapter that there’s \nanother option for shorter function syntax. \n\nvisual decision chart for how/why to pick an arrow \n\n\n\n'm \n\n\nIf you prefer a \nfunction: \n\n\n60 | Chapter 2:Syntax \n\n\n\n\n\nfor..of Loops \n\nJoining the for and for..in loops from the JavaScript we’re all \nfamiliar with, ES6 adds a for. .of loop, which loops over the set of \nvalues produced by an iterator.","metadata":{"loc":{"lines":{"from":218047,"to":218084}}}}],["1695",{"pageContent":"for..of Loops \n\nJoining the for and for..in loops from the JavaScript we’re all \nfamiliar with, ES6 adds a for. .of loop, which loops over the set of \nvalues produced by an iterator. \n\nThe value you loop over with for.. of must be an iterable, or it must \nbe a value that can be coerced/boxed to an object (see the Types & \n\n\nfor..of Loops | 61 \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nGrammar title of this series) that is an iterable. An iterable is simply \nan object that is able to produce an iterator, which the loop then \nuses. \n\nLet’s compare for.. of to for.. in to illustrate the difference: \nvar a = [\"a\",\"b\",\"c\",\"d\" , \"e\"] ; \n\nfor (var idx in a) { \nconsole. log( idx ); \n\n} \n\n// 0 1 2 3 4 \n\nfor (var vat of a) { \nconsole. log( val ); \n\n} \n\n// \"a\" \"b\" \"c\" \"d\" \"e\" \n\nAs you can see, for. .in loops over the keys/indexes in the a array, \nwhile for..of loops over the values in a. \n\nHere’s the pre-ES6 version of the for..of from that previous \nsnippet:","metadata":{"loc":{"lines":{"from":218084,"to":218163}}}}],["1696",{"pageContent":"As you can see, for. .in loops over the keys/indexes in the a array, \nwhile for..of loops over the values in a. \n\nHere’s the pre-ES6 version of the for..of from that previous \nsnippet: \n\nvar a = [\"a\" , \"b\" , \"c\" , \"d\" , \"e\"] , \nk = Object. keys( a ); \n\nfor (var val, i = 0; i < k.length; i++) { \nval = a[ k[i] ]; \nconsole. log( val ); \n\n} \n\n// \"a\" \"b\" \"c\" \"d\" \"e\" \n\nAnd here’s the ES6 but non-for. .of equivalent, which also gives a \nglimpse at manually iterating an iterator (see “Iterators” on page 87 \nin Chapter 3): \n\nvar a = [\"a\" , \"b\" , \"c\" , \"d\" , \"e\"]; \n\nfor (var val, ret, it = afSynbol.iterator]!); \n\n(ret = it.next()) && ! ret.done; \n\n) ( \n\nval = ret.value; \nconsole. log( val ); \n\n} \n\n// \"a\" \"b\" \"c\" \"d\" \"e\" \n\nUnder the covers, the for. .of loop asks the iterable for an iterator \n(using the built-in Symbol.iterator; see “Well-Known Symbols” on \n\n\n62 | Chapter 2:Syntax","metadata":{"loc":{"lines":{"from":218163,"to":218203}}}}],["1697",{"pageContent":"} \n\n// \"a\" \"b\" \"c\" \"d\" \"e\" \n\nUnder the covers, the for. .of loop asks the iterable for an iterator \n(using the built-in Symbol.iterator; see “Well-Known Symbols” on \n\n\n62 | Chapter 2:Syntax \n\n\n\n\npage 203 in Chapter 7), then it repeatedly calls the iterator and \nassigns its produced value to the loop iteration variable. \n\nStandard built-in values in JavaScript that are by default iterables (or \nprovide them) include: \n\n• Arrays \n\n• Strings \n\n• Generators (see Chapter 3) \n\n• Collections / TypedArrays (see Chapter 5) \n\n\n\nPlain objects are not by default suitable for \nfor. .of looping. That’s because they don’t have \na default iterator, which is intentional, not a mis¬ \ntake. However, we won’t go any further into \nthose nuanced reasonings here. In “Iterators” on \npage 87 in Chapter 3, we’ll see how to define \niterators for our own objects, which lets for. .of \nloop over any object to get a set of values we \ndefine. \n\n\nHere’s how to loop over the characters in a primitive string:","metadata":{"loc":{"lines":{"from":218203,"to":218243}}}}],["1698",{"pageContent":"Here’s how to loop over the characters in a primitive string: \n\nfor (var c of \"hello\") { \nconsole. log( c ); \n\n} \n\n// \"h\" \"e\" \"l\" \"l\" \"o\" \n\nThe \"hello\" primitive string value is coerced/boxed to the String \nobject wrapper equivalent, which is an iterable by default. \n\nIn for (XYZ of ABC) .., the XYZ clause can either be an assignment \nexpression or a declaration, identical to that same clause in for and \nfor.. In loops. So you can do stuff like this: \n\nvar o = {}; \n\nfor (o.a of [1,2,3]) { \nconsole. log( o.a ); \n\n} \n\n// 1 2 3 \n\nfor ({x: o.a} of [ {x: 1}, {x: 2}, {x: 3} ]) { \nconsole. log( o.a ); \n\n\nfor..of Loops | 63 \n\n\n\n\n\n\n} \n\n// 1 2 3 \n\n\nfor..of loops can be prematurely stopped, just like other loops, \nwith break, continue, return (if in a function), and thrown excep¬ \ntions. In any of these cases, the iterators return (..) function is \nautomatically called (if one exists) to let the iterator perform cleanup \ntasks, if necessary.","metadata":{"loc":{"lines":{"from":218243,"to":218288}}}}],["1699",{"pageContent":"See “Iterators” on page 87 in Chapter 3 for more \ncomplete coverage on iterables and iterators. \n\n\nRegular Expressions \n\nLet’s face it: regular expressions haven’t changed much in JS in a \nlong time. So it’s a great thing that they’ve finally learned a couple of \nnew tricks in ES6. We’ll briefly cover the additions here, but the \noverall topic of regular expressions is so dense that you’ll need to \nturn to chapters/books dedicated to it (of which there are many!) if \nyou need a refresher. \n\nUnicode Flag \n\nWe’ll cover the topic of Unicode in more detail in “Unicode” on page \n73 later in this chapter. Here, we’ll just look briefly at the new u flag \nfor ES6+ regular expressions, which turns on Unicode matching for \nthat expression.","metadata":{"loc":{"lines":{"from":218292,"to":218310}}}}],["1700",{"pageContent":"JavaScript strings are typically interpreted as sequences of 16-bit \ncharacters, which correspond to the characters in the Basic Multilin¬ \ngual Plane (BMP). But there are many UTF-16 characters that fall \noutside this range, and so strings may have these multibyte charac¬ \nters in them. \n\nPrior to ES6, regular expressions could only be matched based on \nBMP characters, which means that those extended characters were \ntreated as two separate characters for matching purposes. This is \noften not ideal. \n\n\n64 | Chapter 2:Syntax \n\n\n\n\n\n\n\nSo, as of ES6, the u flag tells a regular expression to process a string \nwith the interpretation of Unicode (UTF-16) characters, such that \nsuch an extended character will be matched as a single entity. \n\n\n\nDespite the name implication, “UTF-16” doesn’t \nstrictly mean 16 bits. Modern Unicode uses 21 \nbits, and standards like UTF-8 and UTF-16 refer \nroughly to how many bits are used in the repre¬ \nsentation of a character.","metadata":{"loc":{"lines":{"from":218312,"to":218342}}}}],["1701",{"pageContent":"An example (straight from the ES6 specification): | the musical \nsymbol G-clef) is Unicode point U+1D11E (OxlDllE). \n\nIf this character appears in a regular expression pattern (like /$/), \nthe standard BMP interpretation would be that it’s two separate \ncharacters (0xD834 and OxDDlE) to match with. But the new ES6 \nUnicode-aware mode means that /|/u (or the escaped Unicode \nform /\\u{1D11E}/u) will match in a string as a single matched \ncharacter. \n\nYou might be wondering why this matters? In non-Unicode BMP \nmode, the pattern is treated as two separate characters, but would \nstill find the match in a string with the character in it, as you \ncan see if you try: \n\n/4/.test( ); // true \n\nThe length of the match is what matters. For example: \n\n/ A .-clef/ .test( \"4-clef\" ); // false \n\n/ A .-clef/u . test( \"4-clef\" ); // true","metadata":{"loc":{"lines":{"from":218345,"to":218366}}}}],["1702",{"pageContent":"/4/.test( ); // true \n\nThe length of the match is what matters. For example: \n\n/ A .-clef/ .test( \"4-clef\" ); // false \n\n/ A .-clef/u . test( \"4-clef\" ); // true \n\nThe A . - clef in the pattern says to match only a single character at \nthe beginning before the normal \"-clef\" text. In standard BMP \nmode, the match fails (two characters), but with u Unicode mode \nflagged on, the match succeeds (one character). \n\nIt’s also important to note that u makes quantifiers like + and * apply \nto the entire Unicode code point as a single character, not just the \nlower surrogate (aka rightmost half of the symbol) of the character. \nThe same goes for Unicode characters appearing in character \nclasses, like /[^-^.J/u. \n\n\nRegular Expressions | 65 \n\n\n\n\n\n\nThere’s plenty more nitty-gritty details about u \nbehavior in regular expressions, which Mathias \nBynens has written extensively about. \n\n\nSticky Flag","metadata":{"loc":{"lines":{"from":218366,"to":218398}}}}],["1703",{"pageContent":"Regular Expressions | 65 \n\n\n\n\n\n\nThere’s plenty more nitty-gritty details about u \nbehavior in regular expressions, which Mathias \nBynens has written extensively about. \n\n\nSticky Flag \n\nAnother flag mode added to ES6 regular expressions is y, which is \noften called “sticky mode.” Sticky essentially means the regular \nexpression has a virtual anchor at its beginning that keeps it rooted \nto matching at only the position indicated by the regular expression’s \nlastlndex property. \n\nTo illustrate, let’s consider two regular expressions—the first without \nsticky mode and the second with: \n\nvar rel = /foo/, \n\nstr = \"++foo++\"; \n\n\nrel . lastlndex; \n\n// O \n\nrel.test( str ); \n\n// true \n\nrel . lastlndex; \n\n// 0--not updated \n\nrel . lastlndex = 4; \n\n\nrel.test( str ); \n\n// true--ignored 'lastlndex \n\nrel . lastlndex; \n\n// 4--not updated \n\n\nThree things to observe about this snippet:","metadata":{"loc":{"lines":{"from":218398,"to":218450}}}}],["1704",{"pageContent":"rel . lastlndex; \n\n// 0--not updated \n\nrel . lastlndex = 4; \n\n\nrel.test( str ); \n\n// true--ignored 'lastlndex \n\nrel . lastlndex; \n\n// 4--not updated \n\n\nThree things to observe about this snippet: \n\n• test(. .) doesn’t pay any attention to lastlndex’s value, and \nalways just performs its match from the beginning of the input \nstring. \n\n• Because our pattern does not have a A start-of-input anchor, the \nsearch for \"foo\" is free to move ahead through the whole string \nlooking for a match. \n\n• lastlndex is not updated by test(..). \n\nNow, let’s try a sticky mode regular expression: \n\nvar re2 = /foo/y, // <-- notice the 'y' sticky flag \nstr = \"++foo++\"; \n\nre2.lastlndex; // 0 \n\nre2.test( str ); // false--\"foo\" not found at 'O' \n\nre2.lastlndex; // 0 \n\n\n66 | Chapter 2:Syntax \n\n\n\n\n\n\n\nre2.lastlndex = 2; \nre2.test( str ); \nre2.lastlndex; \n\n\n// true \n\n// 5 --updated to after previous natch \n\n\nre2.test( str ); // false \n\nre2.lastlndex; // 0--reset after previous natch failure","metadata":{"loc":{"lines":{"from":218450,"to":218510}}}}],["1705",{"pageContent":"re2.lastlndex = 2; \nre2.test( str ); \nre2.lastlndex; \n\n\n// true \n\n// 5 --updated to after previous natch \n\n\nre2.test( str ); // false \n\nre2.lastlndex; // 0--reset after previous natch failure \n\nAnd so our new observations about sticky mode: \n\n• test(. .) uses lastlndex as the exact and only position in str \nto look to make a match. There is no moving ahead to look for \nthe match—it’s either there at the lastlndex position or not. \n\n• If a match is made, test(.. ) updates lastlndex to point to the \ncharacter immediately following the match. If a match fails, \ntest(. .) resets lastlndex back to 0. \n\nNormal nonsticky patterns that aren’t otherwise A -rooted to the \nstart-of-input are free to move ahead in the input string looking for \na match. But sticky mode restricts the pattern to matching just at the \nposition of lastlndex.","metadata":{"loc":{"lines":{"from":218510,"to":218537}}}}],["1706",{"pageContent":"As I suggested at the beginning of this section, another way of look¬ \ning at this is that y implies a virtual anchor at the beginning of the \npattern that is relative (aka constrains the start of the match) to \nexactly the lastlndex position. \n\n\n\nIn previous literature on the topic, it has alterna¬ \ntively been asserted that this behavior is like y \nimplying a A (start-of-input) anchor in the pat¬ \ntern. This is inaccurate. Well explain in further \ndetail in “Anchored Sticky” on page 70. \n\n\nSticky Positioning \n\nIt may seem strangely limiting that to use y for repeated matches, \nyou have to manually ensure lastlndex is in the exact right posi¬ \ntion, as it has no move-ahead capability for matching.","metadata":{"loc":{"lines":{"from":218539,"to":218557}}}}],["1707",{"pageContent":"It may seem strangely limiting that to use y for repeated matches, \nyou have to manually ensure lastlndex is in the exact right posi¬ \ntion, as it has no move-ahead capability for matching. \n\nHere’s one possible scenario: if you know that the match you care \nabout is always going to be at a position that’s a multiple of a num¬ \nber (e.g., 0, 10, 20, etc.), you can just construct a limited pattern \nmatching what you care about, but then manually set lastlndex \neach time before matching to those fixed positions. \n\nConsider: \n\n\nRegular Expressions | 67 \n\n\n\n\nfar \n\n\nfad\" ; \n\n\nvar re = /f. ,/y, \n\nstr = \"foo \n\nstr.match( re ); // [\"foo\"] \n\nre.lastlndex = 10; \n\nstr.match( re ); // [\"far\"] \n\nre.lastlndex = 20; \n\nstr.match( re ); // [\"fad\"] \n\nHowever, if you’re parsing a string that isn’t formatted in fixed posi¬ \ntions like that, figuring out what to set lastlndex to before each \nmatch is likely going to be untenable.","metadata":{"loc":{"lines":{"from":218557,"to":218597}}}}],["1708",{"pageContent":"However, if you’re parsing a string that isn’t formatted in fixed posi¬ \ntions like that, figuring out what to set lastlndex to before each \nmatch is likely going to be untenable. \n\nThere’s a saving nuance to consider here, y requires that lastlndex \nbe in the exact position for a match to occur. But it doesn’t strictly \nrequire that you manually set lastlndex. \n\nInstead, you can construct your expressions in such a way that they \ncapture in each main match everything before and after the thing \nyou care about, up to right before the next thing you’ll care to \nmatch. \n\nBecause lastlndex will set to the next character beyond the end of a \nmatch, if you’ve matched everything up to that point, lastlndex will \nalways be in the correct position for the y pattern to start from the \nnext time. \n\n\n\nIf you can’t predict the structure of the input \nstring in a sufficiently patterned way like that, \nthis technique may not be suitable and you may \nnot be able to use y.","metadata":{"loc":{"lines":{"from":218597,"to":218620}}}}],["1709",{"pageContent":"If you can’t predict the structure of the input \nstring in a sufficiently patterned way like that, \nthis technique may not be suitable and you may \nnot be able to use y. \n\n\nHaving structured string input is likely the most practical scenario \nwhere y will be capable of performing repeated matching through¬ \nout a string. Consider: \n\nvar re = /\\d+\\.\\s(.*?)(?:\\s|$)/y \n\nstr = \"1. foo 2. bar 3. baz\"; \n\nstr.match( re ); // [ \"1. foo \", \"foo\" ] \n\nre.lastlndex; // 7--correct position! \n\nstr.match( re ); // [ \"2. bar \", \"bar\" ] \n\n\n68 | Chapter 2:Syntax \n\n\n\n\n\nre.lastlndex; // 14--correct position! \n\nstr.match( re ); // [\"3. baz\", \"baz\"]","metadata":{"loc":{"lines":{"from":218620,"to":218649}}}}],["1710",{"pageContent":"re.lastlndex; // 7--correct position! \n\nstr.match( re ); // [ \"2. bar \", \"bar\" ] \n\n\n68 | Chapter 2:Syntax \n\n\n\n\n\nre.lastlndex; // 14--correct position! \n\nstr.match( re ); // [\"3. baz\", \"baz\"] \n\nThis works because I knew something ahead of time about the \nstructure of the input string: there is always a numeral prefix like \n\"1. \" before the desired match (\"foo\", etc.), and either a space after \nit, or the end of the string ($ anchor). So the regular expression I \nconstructed captures all of that in each main match, and then I use a \nmatching group ( ) so that the stuff I really care about is separated \nout for convenience. \n\nAfter the first match (\"1. foo \"), the lastlndex is 7, which is \nalready the position needed to start the next match, for \"2. bar \", \nand so on. \n\nIf you’re going to use y sticky mode for repeated matches, you’ll \nprobably want to look for opportunities to have lastlndex automat¬ \nically positioned as we’ve just demonstrated. \n\n\nSticky Versus Global","metadata":{"loc":{"lines":{"from":218649,"to":218681}}}}],["1711",{"pageContent":"Sticky Versus Global \n\nSome readers may be aware that you can emulate something like this \nlastlndex-relative matching with the g global match flag and the \nexec(..) method, as so: \n\nvar re = / o+./g, // <-- look, 'g'! \n\nstr = \"foot book more\"; \n\n\nre.exec( str ); // [\"oof 7 \n\nre.tastlndex; // 4 \n\n\nre.exec( str ); // [\"ook\"] \n\nre.tastlndex; // 9 \n\n\nre.exec( str ); // [\"or\"] \n\nre.tastlndex; // 13 \n\n\nre.exec( str ); // null--no nore notches! \n\nre.tastlndex; // 0--starts over now! \n\nWhile it’s true that g pattern matches with exec(..) start their \nmatching from lastlndex’s current value, and also update lastln \ndex after each match (or failure), this is not the same thing as y’s \nbehavior. \n\n\nNotice in the previous snippet that \"ook\", located at position 6, was \nmatched and found by the second exec( ..) call, even though at the \n\n\nRegular Expressions | 69","metadata":{"loc":{"lines":{"from":218681,"to":218721}}}}],["1712",{"pageContent":"Notice in the previous snippet that \"ook\", located at position 6, was \nmatched and found by the second exec( ..) call, even though at the \n\n\nRegular Expressions | 69 \n\n\n\ntime, lastlndex was 4 (from the end of the previous match). Why? \nBecause as we said earlier, nonsticky matches are free to move ahead \nin their matching. A sticky mode expression would have failed here, \nbecause it would not be allowed to move ahead. \n\nIn addition to perhaps undesired move-ahead matching behavior, \nanother downside to just using g instead of y is that g changes the \nbehavior of some matching methods, like str .match (re). \n\nConsider: \n\nvar re = /o+./g, // <-- look, 'g'! \n\nstr = \"foot book more\"; \n\nstr.match( re ); // [\"oot\", \"ook\", \"or\"] \n\nSee how all the matches were returned at once? Sometimes that’s \nOK, but sometimes that’s not what you want.","metadata":{"loc":{"lines":{"from":218721,"to":218747}}}}],["1713",{"pageContent":"str = \"foot book more\"; \n\nstr.match( re ); // [\"oot\", \"ook\", \"or\"] \n\nSee how all the matches were returned at once? Sometimes that’s \nOK, but sometimes that’s not what you want. \n\nThe y sticky flag will give you one-at-a-time progressive matching \nwith utilities like test(.. ) and match(.. ). Just make sure the las \ntlndex is always in the right position for each match! \n\nAnchored Sticky \n\nAs we warned earlier, it’s inaccurate to think of sticky mode as \nimplying a pattern starts with A . The A anchor has a distinct mean¬ \ning in regular expressions, which is not altered by sticky mode. A is \nan anchor that always refers to the beginning of the input, and is not \nin any way relative to lastlndex. \n\nBesides poor/inaccurate documentation on this topic, the confusion \nis unfortunately strengthened further because an older pre-ES6 \nexperiment with sticky mode in Firefox did make A relative to las \ntlndex, so that behavior has been around for years.","metadata":{"loc":{"lines":{"from":218747,"to":218769}}}}],["1714",{"pageContent":"ES6 elected not to do it that way. A in a pattern means start-of-input \nabsolutely and only. \n\nAs a consequence, a pattern like / A foo/y will always and only find a \n\"foo\" match at the beginning of a string, if it’s allowed to match \nthere. If lastlndex is not 0, the match will fail. Consider: \n\nvar re = / A foo/y, \nstr = \"foo\"; \n\nre.test( str ); // true \n\nre.test( str ); // false \n\n\n70 | Chapter 2:Syntax \n\n\n\n\nre.lastlndex; \n\n\n// 6--reset after failure \n\n\nre.lastlndex = 1; \n\nre.test( str ); // false--failed for positioning \n\nre.lastlndex; // 0--reset after failure \n\nBottom line: y plus A plus lastlndex > 0 is an incompatible combi¬ \nnation that will always cause a failed match.","metadata":{"loc":{"lines":{"from":218771,"to":218804}}}}],["1715",{"pageContent":"re.lastlndex; // 0--reset after failure \n\nBottom line: y plus A plus lastlndex > 0 is an incompatible combi¬ \nnation that will always cause a failed match. \n\n\n\nWhile y does not alter the meaning of A in any \nway, the m multiline mode does, such that A \nmeans start-of-input or start of text after a new- \nline. So, if you combine y and m flags together \nfor a pattern, you can find multiple A -rooted \nmatches in a string. But remember: because it’s y \nsticky, you’ll have to make sure lastlndex is \npointing at the correct new line position (likely \nby matching to the end of the line) each subse¬ \nquent time, or no subsequent matches will be \nmade. \n\n\nRegular Expression flags \n\nPrior to ES6, if you wanted to examine a regular expression object to \nsee what flags it had applied, you needed to parse them out—ironi¬ \ncally, probably with another regular expression—from the content \nof the source property, such as: \n\nvar re = / foo/ig; \n\nre.toStringQ; // \"/foo/ig\"","metadata":{"loc":{"lines":{"from":218804,"to":218833}}}}],["1716",{"pageContent":"var re = / foo/ig; \n\nre.toStringQ; // \"/foo/ig\" \n\nvar flags = re.toString().match( /\\/([gln]*)$/ )[1]; \n\nflags; // \"ig\" \n\nAs of ES6, you can now get these values directly, with the new flags \nproperty: \n\nvar re = /foo/ig; \n\nre.flags; // \"gi\" \n\nIt’s a small nuance, but the ES6 specification calls for the expressions \n\nflags to be listed in this order: \"gimuy\", regardless of what order the \noriginal pattern was specified with. That’s the reason for the differ¬ \nence between /ig and \"gi\". \n\n\nRegular Expressions | 71 \n\n\n\n\nNo, the order of flags specified or listed doesn’t matter. \n\nAnother tweak from ES6 is that the Reg Exp (..) constructor is now \nflags-aware if you pass it an existing regular expression: \n\n\nvar rel = /foo*/y; \n\n\n\n\nrel.source; \n\n\n\n// \n\n\"foo*\" \n\nrel.flags; \n\n\n\n// \n\n\"y\" \n\nvar re2 = new \nre2.source; \n\nRegExp( \n\nrel ); \n\n// \n\n\"foo* 11 \n\nre2.flags; \n\n\n\n// \n\n\"y\" \n\nvar re3 = new \nre3.source; \n\nRegExp( \n\nrel, \"ig\" ) \n\n// \n\n\"foo* 11 \n\nre3.flags; \n\n\n\n// \n\n\"gi \"","metadata":{"loc":{"lines":{"from":218833,"to":218923}}}}],["1717",{"pageContent":"// \n\n\"y\" \n\nvar re2 = new \nre2.source; \n\nRegExp( \n\nrel ); \n\n// \n\n\"foo* 11 \n\nre2.flags; \n\n\n\n// \n\n\"y\" \n\nvar re3 = new \nre3.source; \n\nRegExp( \n\nrel, \"ig\" ) \n\n// \n\n\"foo* 11 \n\nre3.flags; \n\n\n\n// \n\n\"gi \" \n\nPrior to ES6, the \n\nre3 construction would throw \n\n\nES6 you can override the flags when duplicating. \n\n\nNumber Literal Extensions \n\nPrior to ES5, number literals looked like the following—the octal \nform was not officially specified, only allowed as an extension that \nbrowsers had come to de facto agreement on: \n\nvar dec = 42, \noct = 052, \nhex = 0x2a; \n\n\n\nThough you are specifying a number in different \nbases, the number’s mathematic value is what is \nstored, and the default output interpretation is \nalways base-10. The three variables in the previ¬ \nous snippet all have the 42 value stored in them. \n\n\nTo further illustrate that 052 was a nonstandard form extension, \nconsider: \n\nHumbert \"42\" ); // 42 \n\nHumbert \"052\" ); // 52 \n\nNumber( \"0x2a\" ); // 42","metadata":{"loc":{"lines":{"from":218923,"to":218999}}}}],["1718",{"pageContent":"To further illustrate that 052 was a nonstandard form extension, \nconsider: \n\nHumbert \"42\" ); // 42 \n\nHumbert \"052\" ); // 52 \n\nNumber( \"0x2a\" ); // 42 \n\nES5 continued to permit the browser-extended octal form (includ¬ \ning such inconsistencies), except that in strict mode, the octal literal \n(052) form is disallowed. This restriction was done mainly because \nmany developers had the habit (from other languages) of seemingly \n\n\n72 | Chapter 2:Syntax \n\n\n\n\ninnocuously prefixing otherwise base-10 numbers with ' 0' s for code \nalignment purposes, and then running into the accidental fact that \ntheyd changed the number value entirely!","metadata":{"loc":{"lines":{"from":218999,"to":219021}}}}],["1719",{"pageContent":"innocuously prefixing otherwise base-10 numbers with ' 0' s for code \nalignment purposes, and then running into the accidental fact that \ntheyd changed the number value entirely! \n\nES6 continues the legacy of changes/variations to how number liter¬ \nals outside base-10 numbers can be represented. There’s now an offi¬ \ncial octal form, an amended hexadecimal form, and a brand-new \nbinary form. For web compatibility reasons, the old octal 052 form \nwill continue to be legal (though unspecified) in nonstrict mode, but \nshould really never be used anymore. \n\nHere are the new ES6 number literal forms: \n\n\nvar dec = 42, \n\noct = 0052, // or '0052' :( \n\nhex = 0x2a, // or '0X2a' :/ \n\nbin = 0bl01010; // or '0B1O1O16' :/ \n\nThe only decimal form allowed is base-10. Octal, hexadecimal, and \nbinary are all integer forms. \n\nAnd the string representations of these forms are all able to be \ncoerced/converted to their number equivalent: \n\n\nNunber( \n\n\"42\" ); \n\n// 42 \n\nNumber! \n\n\"0052\" ); \n\n// 42","metadata":{"loc":{"lines":{"from":219021,"to":219060}}}}],["1720",{"pageContent":"And the string representations of these forms are all able to be \ncoerced/converted to their number equivalent: \n\n\nNunber( \n\n\"42\" ); \n\n// 42 \n\nNumber! \n\n\"0052\" ); \n\n// 42 \n\nNumber! \n\n\"0x2a\" ); \n\n// 42 \n\nNumber! \n\n\"0bl01010\" ). \n\n: // 42 \n\n\nThough not strictly new to ES6, it’s a little-known fact that you can \nactually go the opposite direction of conversion (well, sort of): \n\nvar a = 42; \n\n\na.toString(); \na.toString( 8 ); \na.toString( 16 ); \na.toString( 2 ); \n\n\n// \"42\"--also 'a.toString( 10 )' \n// \"52\" \n\n// \"2a\" \n\n// \" 101010 \" \n\n\nIn fact, you can represent a number this way in any base from 2 to \n36, though it’d be rare that you’d go outside the standard bases: 2, 8, \n10, and 16. \n\n\nUnicode \n\nLet me just say that this section is not an exhaustive everything-you- \never-wanted-to-know-about-Unicode resource. I want to cover what \nyou need to know that’s changing for Unicode in ES6, but we won’t \n\n\nUnicode | 73","metadata":{"loc":{"lines":{"from":219060,"to":219121}}}}],["1721",{"pageContent":"Unicode | 73 \n\n\n\ngo much deeper than that. Mathias Bynens has written/spoken \nextensively and brilliantly about JS and Unicode (see https://mathias \nbynens.be/notes/javascript-unicode and http://fluentconf.com/ \njavascript-html-2015/public/content/2015/02/18-javascript-loves- \nunicode). \n\nThe Unicode characters that range from 0x0000 to OxFFFF contain \nall the standard printed characters (in various languages) that you’re \nlikely to have seen or interacted with. This group of characters is \ncalled the Basic Multilingual Plane (BMP). The BMP even contains \nfun symbols like this cool snowman: (U+2603). \n\nThere are lots of other extended Unicode characters beyond this \nBMP set, which range up to 0xl0FFFF. These symbols are often \nreferred to as astral symbols, as that’s the name given to the set of 16 \nplanes (e.g., layers/groupings) of characters beyond the BMP. Exam¬ \nples of astral symbols include if U+1D11E) and ,A U+1F4A9).","metadata":{"loc":{"lines":{"from":219121,"to":219141}}}}],["1722",{"pageContent":"Prior to ES6, JavaScript strings could specify Unicode characters \nusing Unicode escaping, such as: \n\nvar snowman = \"\\u2603\"; \n\nconsole. log( snowman ); // \n\nHowever, the \\uXXXX Unicode escaping only supports four hexadeci¬ \nmal characters, so you can only represent the BMP set of characters \nin this way. To represent an astral character using Unicode escaping \nprior to ES6, you need to use a surrogate pair —basically two spe¬ \ncially calculated Unicode-escaped characters side by side, which JS \ninterprets together as a single astral character: \n\nvar gclef = \"\\uD834\\uDD1E\" ; \n\nconsole. log ( gclef ); // \"f\" \n\nAs of ES6, we now have a new form for Unicode escaping (in strings \nand regular expressions), called Unicode code point escaping: \n\nvar gclef = \"\\ U {1 D 11E}\"; \n\nconsole. log ( gclef ); // \"f\"","metadata":{"loc":{"lines":{"from":219143,"to":219166}}}}],["1723",{"pageContent":"As of ES6, we now have a new form for Unicode escaping (in strings \nand regular expressions), called Unicode code point escaping: \n\nvar gclef = \"\\ U {1 D 11E}\"; \n\nconsole. log ( gclef ); // \"f\" \n\nAs you can see, the difference is the presence of the { } in the escape \nsequence, which allows it to contain any number of hexadecimal \ncharacters. Because you only need six to represent the highest possi¬ \nble code point value in Unicode (i.e., OxlOFFFF), this is sufficient. \n\n\n74 | Chapter 2:Syntax \n\n\n\n\nUnicode-Aware String Operations \n\nBy default, JavaScript string operations and methods are not sensi¬ \ntive to astral symbols in string values. So, they treat each BMP char¬ \nacter individually, even the two surrogate halves that make up an \notherwise single astral character. Consider: \n\n\nvar snowman = \"ft\"; \n\n\nsnowman.length; \n\n// 1 \n\nvar gclef = \n\n\ngclef.length; \n\n// 2 \n\n\nSo, how do we accurately calculate the length of such a string? In \nthis scenario, the following trick will work:","metadata":{"loc":{"lines":{"from":219166,"to":219208}}}}],["1724",{"pageContent":"snowman.length; \n\n// 1 \n\nvar gclef = \n\n\ngclef.length; \n\n// 2 \n\n\nSo, how do we accurately calculate the length of such a string? In \nthis scenario, the following trick will work: \n\nvar gclef = \n\n[.. .gclef].length; // 1 \n\nArray. fron( gclef ). length; // 1 \n\nRecall from “for..of Loops” on page 61 earlier in this chapter that \nES6 strings have built-in iterators. This iterator happens to be \nUnicode-aware, meaning it will automatically output an astral sym¬ \nbol as a single value. We take advantage of that using the ... spread \noperator in an array literal, which creates an array of the strings \nsymbols. Then we just inspect the length of that resultant array. \nES6’s Array.from( ..) does basically the same thing as [.. .XYZ], \nbut we’ll cover that utility in detail in Chapter 6.","metadata":{"loc":{"lines":{"from":219208,"to":219236}}}}],["1725",{"pageContent":"It should be noted that constructing and \nexhausting an iterator just to get the length of a \nstring is quite expensive on performance, rela¬ \ntively speaking, compared to what a theoretically \noptimized native utility/property would do. \n\n\nUnfortunately, the full answer is not as simple or straightforward. In \naddition to the surrogate pairs (which the string iterator takes care \nof), there are special Unicode code points that behave in other spe¬ \ncial ways, which is much harder to account for. For example, there’s \na set of code points that modify the previous adjacent character, \nknown as Combining Diacritical Marks. \n\nConsider these two string outputs: \n\nconsole. log ( si ); // \"e\" \n\nconsole. log ( s2 ); // \"e\" \n\n\nUnicode | 75 \n\n\n\n\nThey look the same, but they’re not! Here’s how we created si and \ns2: \n\n\nvar si = \"\\xE9\", \ns2 = \"e\\u0301\" ; \n\nAs you can probably guess, our previous length trick doesn’t work \nwith s2: \n\n\n[ .. .si].length; \n\n// 1 \n\n[ ...s2] .length; \n\n// 2","metadata":{"loc":{"lines":{"from":219240,"to":219283}}}}],["1726",{"pageContent":"var si = \"\\xE9\", \ns2 = \"e\\u0301\" ; \n\nAs you can probably guess, our previous length trick doesn’t work \nwith s2: \n\n\n[ .. .si].length; \n\n// 1 \n\n[ ...s2] .length; \n\n// 2 \n\nSo what can we do? In this case, we can perform a Unicode normal¬ \nization on the value before inquiring about its length, using the ES6 \nString#nomalize(..) utility (which we’ll cover more in Chap- \n\nter 6): \n\n\nvar si = \"\\xE9\", \n\n\ns2 = \"e\\u0301\" ; \n\n\nsi. normalizeQ .length; \n\n// 1 \n\ns2.normalizeQ.length; \n\n// 1 \n\nsi === s2; \n\n// false \n\nsi === s2.normalizeQ; \n\n// true \n\nEssentially, nornallze(..) takes \n\na sequence like \"e\\u0301\" and \n\nnormalizes it to \"\\xE9\". Normalization can even combine multiple \nadjacent combining marks if there’s a suitable Unicode character \n\nthey combine to: \n\n\nvar si = \"o\\u0302\\u0300\" , \n\n\ns2 = si . normalize( ) , \ns3 = \"6\"; \n\n\nsi.length; \n\n// 3 \n\ns2.length; \n\n// i \n\ns3.length; \n\n// i \n\ns2 === S3; \n\n// true","metadata":{"loc":{"lines":{"from":219283,"to":219358}}}}],["1727",{"pageContent":"they combine to: \n\n\nvar si = \"o\\u0302\\u0300\" , \n\n\ns2 = si . normalize( ) , \ns3 = \"6\"; \n\n\nsi.length; \n\n// 3 \n\ns2.length; \n\n// i \n\ns3.length; \n\n// i \n\ns2 === S3; \n\n// true \n\n\nUnfortunately, normalization isn’t fully perfect here, either. If you \nhave multiple combining marks modifying a single character, you \nmay not get the length count you’d expect, because there may not be \na single defined normalized character that represents the combina¬ \ntion of all the marks. For example: \n\nvar si = \"e\\u0301\\u0330\" ; \n\nconsole. log( si ); // \"e\" \n\n\n76 | Chapter 2:Syntax \n\n\n\n\nsi . normalizeQ .length; \n\n\n// 2 \n\nThe further you go down this rabbit hole, the more you realize that \nit’s difficult to get one precise definition for “length.” What we see \nvisually rendered as a single character—more precisely called a \ngrapheme —doesn’t always strictly relate to a single “character” in the \nprogram processing sense.","metadata":{"loc":{"lines":{"from":219358,"to":219410}}}}],["1728",{"pageContent":"If you want to see just how deep this rabbit hole \ngoes, check out the “Grapheme Cluster Bound¬ \naries” algorithm. \n\n\nCharacter Positioning \n\nSimilar to length complications, what does it actually mean to ask, \n“what is the character at position 2?” The naive pre-ES6 answer \ncomes from charAt( ..), which will not respect the atomicity of an \nastral character, nor will it take into account combining marks. \n\nConsider: \n\n\nvar si = \"abc\\u0301d\" , \ns2 = \"ab\\u0107d\" , \ns3 = \"ab\\u{ld49e}d\" ; \n\nconsole. log( si ); \n\n// \n\n\"abed\" \n\n\nconsole. log( s2 ); \n\n// \n\n\"abed\" \n\n\nconsole. log( s3 ); \n\n// \n\n\"ab W \n\n\nsl.charAt( 2 ); \n\n// \n\n\"c \" \n\n\ns2.charAt( 2 ); \n\n// \n\n\"c\" \n\n\ns3.charAt( 2 ); \n\n// \n\n\"\" < - - \n\nunprintable surrogate \n\ns3.charAt( 3 ); \n\n// \n\n\"\" <- - \n\nunprintable surrogate \n\n\nSo, is ES6 giving us a Unicode-aware version of charAt(..)? \nUnfortunately, no. At the time of this writing, there’s a proposal for \nsuch a utility that’s under consideration for post-ES6.","metadata":{"loc":{"lines":{"from":219414,"to":219487}}}}],["1729",{"pageContent":"So, is ES6 giving us a Unicode-aware version of charAt(..)? \nUnfortunately, no. At the time of this writing, there’s a proposal for \nsuch a utility that’s under consideration for post-ES6. \n\nBut with what we explored in the previous section (and of course \nwith the limitations noted thereof!), we can hack an ES6 answer: \n\nvar si = \"abc\\u0301d\" , \ns2 = \"ab\\u0107d\" , \ns3 = \"ab\\u{ld49e}d\" ; \n\n[... si.normalize! )1[2]; // \"c\" \n\n\nUnicode | 77 \n\n\n\n\n\n[... s2.normalize( )][2]; \n[... s3.normalize ()][2]; \n\n\n// \"c\" \n// \"9\" \n\n\n\nReminder of an earlier warning: constructing \nand exhausting an iterator each time you want \nto get at a single character is... very not ideal, \nperformance-wise. Let’s hope we get a built-in \nand optimized utility for this soon, post-ES6. \n\n\nWhat about a Unicode-aware version of the charCodeAt(..) utility? \nES6 gives us codePointAt(..): \n\nvar si = \"abc\\u0301d\" , \ns2 = \"ab\\u0107d\", \ns3 = \"ab\\u{ld49e}d\" ; \n\nsi.normalize?).codePolntAt( 2 ).toString( 16 ); \n\n// \"167\"","metadata":{"loc":{"lines":{"from":219487,"to":219532}}}}],["1730",{"pageContent":"var si = \"abc\\u0301d\" , \ns2 = \"ab\\u0107d\", \ns3 = \"ab\\u{ld49e}d\" ; \n\nsi.normalize?).codePolntAt( 2 ).toString( 16 ); \n\n// \"167\" \n\ns2.normalize?).codePointAt( 2 ).toString( 16 ); \n\n// \"167\" \n\ns3.normalize?).codePointAt? 2 ).toString( 16 ); \n\n// \"ld49e\" \n\nWhat about the other direction? A Unicode-aware version of \nString. fromCharCode(..) is ES6’s String. fromCodePoint(.. \n\nString. fromCodePoint? 0x107 ); // \"c\" \n\nString.fromCodePoint? 0xld49e ); // \" ff' \n\nSo wait, can we just combine String.fronCodePoint(..) and code \nPointAt(..) to get a better version of a Unicode-aware charAt(..) \nfrom earlier? Yep! \n\nvar si = \"abc\\u0301d\" , \ns2 = \"ab\\u0107d\", \ns3 = \"ab\\u{ld49e}d\" ; \n\nString.fromCodePoint? si.normalize?).codePointAt? 2 ) ); \n\n// \"c\" \n\nString.fromCodePoint? s2.normalize?).codePointAt? 2 ) ); \n\n// \n\nString.fromCodePoint? s3.normalize?).codePointAt? 2 ) ); \n\n// * 8 \" \n\n\n78 | Chapter 2:Syntax","metadata":{"loc":{"lines":{"from":219532,"to":219576}}}}],["1731",{"pageContent":"// \"c\" \n\nString.fromCodePoint? s2.normalize?).codePointAt? 2 ) ); \n\n// \n\nString.fromCodePoint? s3.normalize?).codePointAt? 2 ) ); \n\n// * 8 \" \n\n\n78 | Chapter 2:Syntax \n\n\n\n\n\nThere’s quite a few other string methods we haven’t addressed here, \nincluding toUpperCaseQ, toLowerCaseQ, substring(.. ), \nindexOf (..), slice(..), and a dozen others. None of these have \nbeen changed or augmented for full Unicode awareness, so you \nshould be very careful—probably just avoid them!—when working \nwith strings containing astral symbols. \n\nThere are also several string methods that use regular expressions \nfor their behavior, like replace (..) and match (..). Thankfully, ES6 \nbrings Unicode awareness to regular expressions, as we covered in \n“Unicode Flag” on page 64. \n\nOK, there we have it! JavaScript’s Unicode string support is signifi¬ \ncantly better over pre-ES6 (though still not perfect) with the various \nadditions we’ve just covered. \n\nUnicode Identifier Names","metadata":{"loc":{"lines":{"from":219576,"to":219609}}}}],["1732",{"pageContent":"Unicode Identifier Names \n\nUnicode can also be used in identifier names (variables, properties, \netc.). Prior to ES6, you could do this with Unicode-escapes, like: \n\nvar \\u03A9 = 42; \n\n// sane as: var 0 = 42; \n\nAs of ES6, you can also use the earlier explained code point escape \nsyntax: \n\nvar \\u{2B400} = 42; \n\n// sane as: var II = 42; \n\nThere’s a complex set of rules around exactly which Unicode charac¬ \nters are allowed. Furthermore, some are allowed only if they’re not \nthe first character of the identifier name. \n\n\n\nMathias Bynens has a great post on all the nitty- \ngritty details. \n\n\nThe reasons for using such unusual characters in identifier names \nare rather rare and academic. You typically won’t be best served by \nwriting code that relies on these esoteric capabilities. \n\n\nUnicode | 79 \n\n\n\n\n\nSymbols","metadata":{"loc":{"lines":{"from":219609,"to":219646}}}}],["1733",{"pageContent":"Unicode | 79 \n\n\n\n\n\nSymbols \n\nWith ES6, for the first time in quite a while, a new primitive type has \nbeen added to JavaScript: the symbol. Unlike the other primitive \ntypes, however, symbols don’t have a literal form. \n\nHere’s how you create a symbol: \n\nvar sym = Symbol( \"some optional description\" ); \n\ntypeof syn; // \"symbol\" \n\nSome things to note: \n\n\n• You cannot and should not use new with Symbol (..). It’s not a \nconstructor, nor are you producing an object. \n\n• The parameter passed to Symbol (..) is optional. If passed, it \nshould be a string that gives a friendly description for the sym¬ \nbol’s purpose. \n\n• The typeof output is a new value (\"symbol\") that is the primary \nway to identify a symbol. \n\nThe description, if provided, is solely used for the stringification \nrepresentation of the symbol: \n\nsym.toStrlngO; // \"Synbol(sone optional description)\"","metadata":{"loc":{"lines":{"from":219646,"to":219680}}}}],["1734",{"pageContent":"The description, if provided, is solely used for the stringification \nrepresentation of the symbol: \n\nsym.toStrlngO; // \"Synbol(sone optional description)\" \n\nSimilar to how primitive string values are not instances of String, \nsymbols are also not instances of Symbol. If, for some reason, you \nwant to construct a boxed wrapper object form of a symbol value, \nyou can do the following: \n\nsym Instanceof Symbol; // false \n\nvar symObj = Object( sym ); \nsymObj Instanceof Symbol; // true \n\nsymObj.valueOf( ) === sym; // true \n\n\n\nsymObj in this snippet is interchangeable with \nsym; either form can be used in all places sym¬ \nbols are utilized. There’s not much reason to use \nthe boxed wrapper object form (symObj) instead \nof the primitive form (sym). Keeping with simi¬ \nlar advice for other primitives, it’s probably best \nto prefer sym over symObj. \n\n\n80 | Chapter 2:Syntax","metadata":{"loc":{"lines":{"from":219680,"to":219708}}}}],["1735",{"pageContent":"80 | Chapter 2:Syntax \n\n\n\n\n\nThe internal value of a symbol itself—referred to as its name—is hid¬ \nden from the code and cannot be obtained. You can think of this \nsymbol value as an automatically generated, unique (within your \napplication) string value. \n\nBut if the value is hidden and unobtainable, what’s the point of hav¬ \ning a symbol at all? \n\nThe main point of a symbol is to create a string-like value that can’t \ncollide with any other value. So, for example, consider using a sym¬ \nbol as a constant representing an event name: \n\nconst EVT_L0GIN = Symbol( \"event.login\" ); \n\nYou’d then use EVT_L0GIN in place of a generic string literal like \n\"event.login\": \n\nevthub.llsten( EVT_LOGIN, function(data){ \n\n// ■■ \n\n} ); \n\nThe benefit here is that EVT_L0GIN holds a value that cannot be \nduplicated (accidentally or otherwise) by any other value, so it is \nimpossible for there to be any confusion of which event is being dis¬ \npatched or handled.","metadata":{"loc":{"lines":{"from":219708,"to":219740}}}}],["1736",{"pageContent":"Under the covers, the evthub utility assumed in \nthe previous snippet would almost certainly be \nusing the symbol value from the EVT_LOGIN \nargument directly as the property/key in some \ninternal object (hash) that tracks event handlers. \nIf evthub instead needed to use the symbol value \nas a real string, it would need to explicitly coerce \nwith String(..) or toStringQ, as implicit \nstring coercion of symbols is not allowed. \n\n\nYou may use a symbol directly as a property name/key in an object, \nsuch as a special property you want to treat as hidden or meta in \nusage. It’s important to know that although you intend to treat it as \nsuch, it is not actually a hidden or untouchable property. \n\nConsider this module that implements the singleton pattern behav¬ \nior—that is, it only allows itself to be created once: \n\nconst INSTANCE = Symbol( \"instance\" ); \nfunction HappyFaceQ { \n\n\nSymbols | 81 \n\n\n\n\n\n\n\nif (HappyFace[INSTANCE]) return HappyFacefINSTANCE] ; \n\n\nfunction smileQ { .. }","metadata":{"loc":{"lines":{"from":219744,"to":219778}}}}],["1737",{"pageContent":"const INSTANCE = Symbol( \"instance\" ); \nfunction HappyFaceQ { \n\n\nSymbols | 81 \n\n\n\n\n\n\n\nif (HappyFace[INSTANCE]) return HappyFacefINSTANCE] ; \n\n\nfunction smileQ { .. } \n\nreturn HappyFaceflNSTANCE] = { \nsnile: smile \n\n}; \n\n} \n\nvar me = HappyFaceQ, \nyou = HappyFaceQ; \n\nme === you; // true \n\nThe INSTANCE symbol value here is a special, almost hidden, meta- \nlike property stored statically on the HappyFace() function object. \n\nIt could alternatively have been a plain old property like \n\n_instance, and the behavior would have been identical. The usage \n\nof a symbol simply improves the metaprogramming style, keeping \nthis INSTANCE property set apart from any other normal properties. \n\nSymbol Registry","metadata":{"loc":{"lines":{"from":219778,"to":219817}}}}],["1738",{"pageContent":"of a symbol simply improves the metaprogramming style, keeping \nthis INSTANCE property set apart from any other normal properties. \n\nSymbol Registry \n\nOne mild downside to using symbols as in the last few examples is \nthat the EVT_L0GIN and INSTANCE variables had to be stored in an \nouter scope (perhaps even the global scope), or otherwise somehow \nstored in a publicly available location, so that all parts of the code \nthat need to use the symbols can access them. \n\nTo aid in organizing code with access to these symbols, you can cre¬ \nate symbol values with the global symbol registry. For example: \n\nconst EVT_L0GIN = Symbol. for( \"event.login\" ); \nconsole. log( EVT_L0GIN ); // Synbol(event.login) \n\nAnd: \n\nfunction HappyFaceQ { \n\nconst INSTANCE = Symbol. for( \"instance\" ); \n\nif (HappyFace[INSTANCE]) return HappyFace[INSTANCE] ; \n\n// \n\nreturn HappyFace[INSTANCE] = { .. }; \n\n} \n\n\n82 | Chapter 2:Syntax","metadata":{"loc":{"lines":{"from":219817,"to":219849}}}}],["1739",{"pageContent":"const INSTANCE = Symbol. for( \"instance\" ); \n\nif (HappyFace[INSTANCE]) return HappyFace[INSTANCE] ; \n\n// \n\nreturn HappyFace[INSTANCE] = { .. }; \n\n} \n\n\n82 | Chapter 2:Syntax \n\n\n\n\nSymbol. for(.. ) looks in the global symbol registry to see if a sym¬ \nbol is already stored with the provided description text, and returns \nit if so. If not, it creates one to return. In other words, the global \nsymbol registry treats symbol values, by description text, as single- \ntons themselves. \n\nBut that also means that any part of your application can retrieve the \nsymbol from the registry using Symbol.for( ..), as long as the \nmatching description name is used. \n\nIronically, symbols are basically intended to replace the use of magic \nstrings (arbitrary string values given special meaning) in your appli¬ \ncation. But you precisely use magic description string values to \nuniquely identify/locate them in the global symbol registry!","metadata":{"loc":{"lines":{"from":219849,"to":219878}}}}],["1740",{"pageContent":"To avoid accidental collisions, you’ll probably want to make your \nsymbol descriptions quite unique. One easy way of doing that is to \ninclude prefix/context/namespacing information in them. \n\nFor example, consider a utility such as the following: \n\nfunction extractValues(str) { \n\nvar key = Symbol. for( \"extractValues.parse\" ), \nre = extractValuesfkey] | | \n\n/[ A =&]+?=([ A &]+?)(?=&l$)/g, \n\nvalues = [], match; \n\nwhile (match = re.exec( str )) { \nvalues.push( matchfl] ); \n\n} \n\nreturn values; \n\n} \n\nWe use the magic string value \"extractValues. parse\" because it’s \nquite unlikely that any other symbol in the registry would ever col¬ \nlide with that description. \n\nIf a user of this utility wants to override the parsing regular expres¬ \nsion, they can also use the symbol registry: \n\nextractValues[Symbol.for( \"extractValues.parse\" )] = \n\n/..some pattern.. /g; \n\nextractValues( \"..some string..\" ); \n\n\nSymbols | 83","metadata":{"loc":{"lines":{"from":219880,"to":219918}}}}],["1741",{"pageContent":"extractValues[Symbol.for( \"extractValues.parse\" )] = \n\n/..some pattern.. /g; \n\nextractValues( \"..some string..\" ); \n\n\nSymbols | 83 \n\n\n\n\nAside from the assistance the symbol registry provides in globally \nstoring these values, everything we’re seeing here could have been \ndone by just actually using the magic string \"extractVal \nues.parse\" as the key, rather than the symbol. The improvements \nexist at the metaprogramming level more than the functional level. \n\nYou may have occasion to use a symbol value that has been stored in \nthe registry to look up what description text (key) it’s stored under. \nFor example, you may need to signal to another part of your appli¬ \ncation how to locate a symbol in the registry because you cannot \npass the symbol value itself. \n\nYou can retrieve a registered symbol’s description text (key) using \nSymbol.keyFor(..): \n\nvar s = Symbol. for( \"something cool\" ); \nvar desc = Symbol. keyFor( s ); \n\nconsole. log( desc ); // \"something cool\"","metadata":{"loc":{"lines":{"from":219918,"to":219948}}}}],["1742",{"pageContent":"var s = Symbol. for( \"something cool\" ); \nvar desc = Symbol. keyFor( s ); \n\nconsole. log( desc ); // \"something cool\" \n\n// get the symbol from the registry again \nvar s2 = Symbol. for( desc ); \n\ns2 === s; // true \n\nSymbols as Object Properties \n\nIf a symbol is used as a property/key of an object, it’s stored in a spe¬ \ncial way so that the property will not show up in a normal enumera¬ \ntion of the object’s properties: \n\nvar o = { \nfoo: 42, \n\n[ Symbol( \"bar\" ) ]: \"hello world\", \nbaz: true \n\n}; \n\n\nObject.getOwnPropertyNames( o ); // [ \"foo\",\"baz\" ] \n\nTo retrieve an object’s symbol properties: \n\nObject. getOwnPropertySymbols( o ); // [ Symbol(bar) ] \n\nThis makes it clear that a property symbol is not actually hidden or \ninaccessible, as you can always see it in the Object.getOwnProperty \nSymbols (..) list. \n\n\n84 | Chapter 2:Syntax \n\n\n\n\nBuilt-In Symbols","metadata":{"loc":{"lines":{"from":219948,"to":219989}}}}],["1743",{"pageContent":"84 | Chapter 2:Syntax \n\n\n\n\nBuilt-In Symbols \n\nES6 comes with a number of predefined built-in symbols that \nexpose various meta behaviors on JavaScript object values. However, \nthese symbols are not registered in the global symbol registry, as one \nmight expect. \n\nInstead, they’re stored as properties on the Symbol function object. \nFor example, in “for..of Loops” on page 61 earlier in this chapter, we \nintroduced the Symbol. Iterator value: \n\nvar a = [1,2,3]; \n\na[Symbot.iterator]; // native function \n\nThe specification uses the @@ prefix notation to refer to the built-in \nsymbols, the most common ones being: @@iterator, @@toString \nTag, @@toPrimltive. Several others are defined as well, though they \nprobably won’t be used as often. \n\n\n\nSee “Well-Known Symbols” on page 203 in \nChapter 7 for detailed information about how \nthese built-in symbols are used for meta pro¬ \ngramming purposes. \n\n\nReview \n\nES6 adds a heap of new syntax forms to JavaScript, so there’s plenty \nto learn!","metadata":{"loc":{"lines":{"from":219989,"to":220025}}}}],["1744",{"pageContent":"Review \n\nES6 adds a heap of new syntax forms to JavaScript, so there’s plenty \nto learn! \n\nMost of these are designed to ease the pain points of common pro¬ \ngramming idioms, such as setting default values to function parame¬ \nters and gathering the “rest” of the parameters into an array. \nDestructuring is a powerful tool for more concisely expressing \nassignments of values from arrays and nested objects. \n\nWhile features like => arrow functions appear to also be all about \nshorter and nicer-looking syntax, they actually have very specific \nbehaviors that you should intentionally use only in appropriate sit¬ \nuations. \n\nExpanded Unicode support, new tricks for regular expressions, and \neven a new primitive symbol type round out the syntactic evolution \nof ES6. \n\n\nReview | 85 \n\n\n\n\n\n\n\nCHAPTER 3 \n\n\nOrganization","metadata":{"loc":{"lines":{"from":220025,"to":220057}}}}],["1745",{"pageContent":"Expanded Unicode support, new tricks for regular expressions, and \neven a new primitive symbol type round out the syntactic evolution \nof ES6. \n\n\nReview | 85 \n\n\n\n\n\n\n\nCHAPTER 3 \n\n\nOrganization \n\n\nIt’s one thing to write JS code, but it’s another to properly organize \nit. Utilizing common patterns for organization and reuse goes a long \nway to improving the readability and understandability of your \ncode. Remember: code is at least as much about communicating to \nother developers as it is about feeding the computer instructions. \n\nES6 has several important features that help significantly improve \nthese patterns, including iterators, generators, modules, and classes. \n\nIterators","metadata":{"loc":{"lines":{"from":220057,"to":220085}}}}],["1746",{"pageContent":"ES6 has several important features that help significantly improve \nthese patterns, including iterators, generators, modules, and classes. \n\nIterators \n\nAn iterator is a structured pattern for pulling information from a \nsource in one-at-a-time fashion. This pattern has been found in pro¬ \ngramming for a long time. And to be sure, JS developers have been \nad hoc designing and implementing iterators in JS programs since \nbefore anyone can remember, so it’s not at all a new topic. \n\nWhat ES6 has done is introduce an implicit standardized interface \nfor iterators. Many of the built-in data structures in JavaScript will \nnow expose an iterator implementing this standard. And you can \nalso construct your own iterators adhering to the same standard, for \nmaximal interoperability. \n\nIterators are a way of organizing ordered, sequential, pull-based \nconsumption of data.","metadata":{"loc":{"lines":{"from":220085,"to":220103}}}}],["1747",{"pageContent":"Iterators are a way of organizing ordered, sequential, pull-based \nconsumption of data. \n\nFor example, you may implement a utility that produces a new \nunique identifier each time it’s requested. Or you may produce an \n\n\n87 \n\n\n\n\ninfinite series of values that rotate through a fixed list, in round- \nrobin fashion. Or you could attach an iterator to a database query \nresult to pull out new rows one at a time. \n\nAlthough they have not commonly been used in JS in such a man¬ \nner, iterators can also be thought of as controlling behavior one step \nat a time. This can be illustrated quite clearly when considering gen¬ \nerators (see “Generators” on page 98 later in this chapter), though \nyou can certainly do the same without generators. \n\nInterfaces \n\nAt the time of this writing, ES6 section 25.1.1.2 details the Iterator \ninterface as having the following requirement: \n\nIterator [required] \n\nnext() {method}: retrieves next IteratorResult","metadata":{"loc":{"lines":{"from":220103,"to":220132}}}}],["1748",{"pageContent":"At the time of this writing, ES6 section 25.1.1.2 details the Iterator \ninterface as having the following requirement: \n\nIterator [required] \n\nnext() {method}: retrieves next IteratorResult \n\nThere are two optional members that some iterators are extended \nwith: \n\nIterator [optional] \n\nreturn() {method}: stops iterator and returns IteratorResult \nthrow() {method}: signals error and returns IteratorResult \n\nThe IteratorResult interface is specified as: \n\nIteratorResult \n\nvalue {property}: current iteration value or final return \nvalue (optional if 'undefined') \ndone {property}: boolean, indicates completion status","metadata":{"loc":{"lines":{"from":220132,"to":220153}}}}],["1749",{"pageContent":"IteratorResult \n\nvalue {property}: current iteration value or final return \nvalue (optional if 'undefined') \ndone {property}: boolean, indicates completion status \n\n\n\nI call these interfaces implicit not because they’re \nnot explicitly called out in the specification— \nthey are!—but because they’re not exposed as \ndirect objects accessible to code. JavaScript does \nnot, in ES6, support any notion of “interfaces,” \nso adherence for your own code is purely con¬ \nventional. However, wherever JS expects an iter¬ \nator—a for..of loop, for instance—what you \nprovide must adhere to these interfaces or the \ncode will fail. \n\n\nThere’s also an Iterable interface, which describes objects that must \nbe able to produce iterators: \n\n\n88 | Chapter 3: Organization \n\n\n\n\n\nIterable \n\n@@iterator() {method}: produces an Iterator \n\nIf you recall from “Built-In Symbols” on page 85 in Chapter 2, \n@@iterator is the special built-in symbol representing the method \nthat can produce iterator(s) for the object.","metadata":{"loc":{"lines":{"from":220153,"to":220189}}}}],["1750",{"pageContent":"If you recall from “Built-In Symbols” on page 85 in Chapter 2, \n@@iterator is the special built-in symbol representing the method \nthat can produce iterator(s) for the object. \n\n\nIteratorResult \n\nThe IteratorResult interface specifies that the return value from \nany iterator operation will be an object of the form: \n\n{ value: .. , done: true / false } \n\nBuilt-in iterators will always return values of this form, but more \nproperties are, of course, allowed to be present on the return value, \nas necessary. \n\nFor example, a custom iterator may add additional metadata to the \nresult object (e.g., where the data came from, how long it took to \nretrieve, cache expiration length, frequency for the appropriate next \nrequest, etc.).","metadata":{"loc":{"lines":{"from":220189,"to":220208}}}}],["1751",{"pageContent":"Technically, value is optional if it would other¬ \nwise be considered absent or unset, such as in \nthe case of the value undefined. Because access¬ \ning res.value will produce undefined whether \nit’s present with that value or absent entirely, the \npresence/absence of the property is more an \nimplementation detail or an optimization (or \nboth), rather than a functional issue. \n\n\nnext() Iteration \n\nLet’s look at an array, which is an iterable, and the iterator it can pro¬ \nduce to consume its values: \n\nvar arr = [1,2,3]; \n\nvar it = arr[Symbol.iterator](); \n\n\nit.next(); \n\nit.nextQ; \n\nit.nextQ; \n\nit.nextQ; \n\n\n// { value: \n// { value: \n// { value: \n\n// { value: \n\n\n1, done: false } \n\n2, done: false } \n\n3, done: false } \n\nundefined, done: true } \n\n\nIterators | 89","metadata":{"loc":{"lines":{"from":220212,"to":220257}}}}],["1752",{"pageContent":"it.nextQ; \n\nit.nextQ; \n\nit.nextQ; \n\n\n// { value: \n// { value: \n// { value: \n\n// { value: \n\n\n1, done: false } \n\n2, done: false } \n\n3, done: false } \n\nundefined, done: true } \n\n\nIterators | 89 \n\n\n\n\n\n\n\nEach time the method located at Symbol. iterator (see Chapter 2 \nand Chapter 7) is invoked on this arr value, it will produce a new \nfresh iterator. Most structures will do the same, including all the \nbuilt-in data structures in JS. \n\nHowever, a structure like an event queue consumer might only ever \nproduce a single iterator (singleton pattern). Or a structure might \nonly allow one unique iterator at a time, requiring the current one to \nbe completed before a new one can be created.","metadata":{"loc":{"lines":{"from":220257,"to":220296}}}}],["1753",{"pageContent":"The it iterator in the previous snippet doesn’t report done: true \nwhen you receive the 3 value. You have to call next() again, in \nessence going beyond the end of the arrays values, to get the com¬ \nplete signal done: true. It may not be clear why until later in this \nsection, but that design decision will typically be considered a best \npractice. \n\nPrimitive string values are also iterables by default: \n\nvar greeting = \"hello world\"; \n\nvar it = greetlng[Synbol.iterator](); \n\nit.nextQ; // { value: \"h\", done: false } \n\ntt.nextQ; // { value: \"e\", done: false } \n\n\n\nTechnically, the primitive value itself isn’t itera- \nble, but thanks to “boxing”, \"hello world\" is \ncoerced/converted to its String object wrapper \nform, which is an iterable. See the Types & \nGrammar title of this series for more informa¬ \ntion.","metadata":{"loc":{"lines":{"from":220298,"to":220322}}}}],["1754",{"pageContent":"ES6 also includes several new data structures, called collections (see \nChapter 5). These collections are not only iterables themselves, but \nthey also provide API method(s) to generate an iterator, such as: \n\nvar m = new Map(); \nm.set( \"foo\", 42 ); \n\nm.set( { cool: true }, \"hello world\" ); \n\nvar itl = m[Symbol.iterator]!); \nvar it2 = m.entries!); \n\nitl.next(); // { value: [ \"foo\", 42 ], done: false } \n\n\n90 | Chapter 3: Organization \n\n\n\n\n\n\nIt2.next(); \n\n\n// { value: [ \"foo\", 42 ], done: false } \n\n\nThe next(..) method of an iterator can optionally take one or more \narguments. The built-in iterators mostly do not exercise this capa¬ \nbility, though a generator’s iterator definitely does (see “Generators” \non page 98 later in this chapter). \n\nBy general convention, including all the built-in iterators, calling \nnext(..) on an iterator that’s already been exhausted is not an error, \nbut will simply continue to return the result { value: undefined, \ndone: true }.","metadata":{"loc":{"lines":{"from":220325,"to":220361}}}}],["1755",{"pageContent":"Optional: return(..) and throw(..) \n\nThe optional methods on the iterator interface—return(..) and \nthrow(..)—are not implemented on most of the built-in iterators. \nHowever, they definitely do mean something in the context of gen¬ \nerators, so see “Generators” on page 98 for more specific informa¬ \ntion. \n\nreturn( • •) is defined as sending a signal to an iterator that the con¬ \nsuming code is complete and will not be pulling any more values \nfrom it. This signal can be used to notify the producer (the iterator \nresponding to next(..) calls) to perform any cleanup it may need \nto do, such as releasing/closing network, database, or file handle \nresources. \n\nIf an iterator has a return!. •) present and any condition occurs \nthat can automatically be interpreted as abnormal or early termina¬ \ntion of consuming the iterator, return!..) will automatically be \ncalled. You can call return!..) manually as well.","metadata":{"loc":{"lines":{"from":220363,"to":220381}}}}],["1756",{"pageContent":"return! • •) will return an IteratorResult object just like next(..) \ndoes. In general, the optional value you send to return!. •) would \nbe sent back as value in this IteratorResult, though there are \nnuanced cases where that might not be true. \n\nthrow!..) is used to signal an exception/error to an iterator, which \npossibly may be used differently by the iterator than the completion \nsignal implied by return!. • )■ It does not necessarily imply a com¬ \nplete stop of the iterator as return!. •) generally does. \n\nFor example, with generator iterators, throw!. •) actually injects a \nthrown exception into the generator’s paused execution context, \n\n\nIterators | 91 \n\n\n\nwhich can be caught with a try. .catch. An uncaught throw(..) \nexception would end up abnormally aborting the generator’s \niterator. \n\n\nS \n\n\nBy general convention, an iterator should not \nproduce any more results after having called \nreturn( ..) or throw(..). \n\n\nIterator Loop","metadata":{"loc":{"lines":{"from":220383,"to":220414}}}}],["1757",{"pageContent":"S \n\n\nBy general convention, an iterator should not \nproduce any more results after having called \nreturn( ..) or throw(..). \n\n\nIterator Loop \n\n\nAs we covered in “for.. of Loops” on page 61 in Chapter 2, the ES6 \nfor.. of loop directly consumes a conforming iterable. \n\nIf an iterator is also an iterable, it can be used directly with the \nfor..of loop. You make an iterator an iterable by giving it a \nSymbol. iterator method that simply returns the iterator itself: \n\nvar it = { \n\n// nake the 'it' iterator an iterable \n[Symbol. iterator]() { return this; }, \n\nnext() { .. }, \n\n\n}; \n\n\nit[Symbol.iterator]() === it; \n\n\n// true \n\n\nNow we can consume the it iterator with a for.. of loop: \n\nfor (var v of it) { \nconsole. log( v ); \n\n} \n\nTo fully understand how such a loop works, recall the for equivalent \nof a for.. of loop from Chapter 2: \n\nfor (var v, res; (res = It.nextQ) && Ires.done; ) { \nv = res.value; \nconsole. log( v ); \n\n}","metadata":{"loc":{"lines":{"from":220414,"to":220463}}}}],["1758",{"pageContent":"for (var v, res; (res = It.nextQ) && Ires.done; ) { \nv = res.value; \nconsole. log( v ); \n\n} \n\nIf you look closely, you’ll see that it.next () is called before each \niteration, and then res.done is consulted. If res.done is true, the \nexpression evaluates to false and the iteration doesn’t occur. \n\n\n92 | Chapter 3: Organization \n\n\n\n\n\n\n\nRecall earlier that we suggested iterators should in general not \nreturn done: true along with the final intended value from the iter¬ \nator. Now you can see why. \n\nIf an iterator returned { done: true, value: 42 }, the for..of \nloop would completely discard the 42 value and it’d be lost. For this \nreason, assuming that your iterator may be consumed by patterns \nlike the for..of loop or its manual for equivalent, you should \nprobably wait to return done: true for signaling completion until \nafter you’ve already returned all relevant iteration values.","metadata":{"loc":{"lines":{"from":220463,"to":220491}}}}],["1759",{"pageContent":"You can, of course, intentionally design your \niterator to return some relevant value at the \nsame time as returning done: true. But don’t \ndo this unless you’ve documented that as the \ncase, and thus implicitly forced consumers of \nyour iterator to use a different pattern for itera¬ \ntion than is implied by for. .of or its manual \nequivalent as we depicted. \n\n\nCustom Iterators \n\nIn addition to the standard built-in iterators, you can make your \nown! All it takes to make them interoperate with ES6’s consumption \nfacilities (e.g., the for.. of loop and the ... operator) is to adhere to \nthe proper interface(s). \n\nLet’s try constructing an iterator that produces the infinite series of \nnumbers in the Fibonacci sequence: \n\nvar Fib = { \n\n[Symbol. iterator]() { \nvar nl = 1, n2 = 1; \n\nreturn { \n\n// nake the iterator an iterable \n[Symbol. iterator]() { return this; }, \n\nnext() { \n\nvar current = n2; \nn2 = nl; \n\nnl = nl + current; \n\nreturn { value: current, done: false }; \n\n}.","metadata":{"loc":{"lines":{"from":220495,"to":220534}}}}],["1760",{"pageContent":"return { \n\n// nake the iterator an iterable \n[Symbol. iterator]() { return this; }, \n\nnext() { \n\nvar current = n2; \nn2 = nl; \n\nnl = nl + current; \n\nreturn { value: current, done: false }; \n\n}. \n\n\nreturn(v) { \n\n\nIterators | 93 \n\n\n\n\nconsole. log( \n\n\"Fibonacci sequence abandoned. \n\n); \n\nreturn { value: v, done: true }; \n\n} \n\n}; \n\n} \n\n}; \n\n\nfor (var v of Fib) { \nconsole. log( v ); \n\nif (v > 50) break; \n\n} \n\n// 1 1 2 3 5 8 13 21 34 55 \n// Fibonacci sequence abandoned. \n\n\n\nIf we hadn’t inserted the break condition, this \nfor. .of loop would have run forever, which is \nprobably not the desired result in terms of \nbreaking your program! \n\n\nThe Fib[Symbol. iterator] () method when called returns the iter¬ \nator object with next() and return(..) methods on it. State is \nmaintained via nl and n2 variables, which are kept by the closure. \n\nLet’s next consider an iterator that is designed to run through a ser¬ \nies (aka a queue) of actions, one item at a time: \n\nvar tasks = {","metadata":{"loc":{"lines":{"from":220534,"to":220601}}}}],["1761",{"pageContent":"Let’s next consider an iterator that is designed to run through a ser¬ \nies (aka a queue) of actions, one item at a time: \n\nvar tasks = { \n\n[Symbol. iterator]!) 1 \n\nvar steps = this. actions.slice(); \n\nreturn { \n\n// nake the iterator an iterable \n[Symbol. iterator]!) { return this; }, \n\nnext!••.args) { \n\nif (steps.length > 0) { \n\nlet res = steps.shift()( ...args ); \nreturn { value: res, done: false }; \n\n} \n\nelse { \n\nreturn { done: true } \n\n} \n\n}. \n\n\nreturn(v) { \n\nsteps.length = 0; \n\n\n94 | Chapter 3: Organization \n\n\n\n\n\nreturn { value: v, done: true }; \n\n} \n\n}; \n\n}. \n\nactions: [] \n\n}; \n\nThe iterator on tasks steps through functions found in the actions \narray property, if any, and executes them one at a time, passing in \nwhatever arguments you pass to next(.. ), and returning any return \nvalue to you in the standard IteratorResult object. \n\nHere’s how we could could use this tasks queue: \n\ntasks.actions . push( \nfunction stepl(x){ \n\nconsole. log( \"step 1:\", x ); \n\nreturn x * 2; \n\n},","metadata":{"loc":{"lines":{"from":220601,"to":220670}}}}],["1762",{"pageContent":"Here’s how we could could use this tasks queue: \n\ntasks.actions . push( \nfunction stepl(x){ \n\nconsole. log( \"step 1:\", x ); \n\nreturn x * 2; \n\n}, \n\nfunction step2(x,y){ \n\nconsole. log( \"step 2:\", x, y ); \nreturn x + (y * 2); \n\n}. \n\nfunction step3(x,y,z){ \n\nconsole. log( \"step 3:\", x, y, z ); \nreturn (x * y) + z; \n\n} \n\n); \n\n\nvar it = tasks[Synbol.iterator](); \n\nit.next( 10 ); // step 1: 10 \n\n// { value: 20, done: false } \n\nit.next( 20, 50 ); // step 2: 20 50 \n\n// { value: 120, done: false } \n\nit.next ( 20, 50, 120 ); // step 3: 20 50 120 \n\n// { value: 1120, done: false } \n\nit.next(); // { done: true } \n\nThis particular usage reinforces that iterators can be a pattern for \norganizing functionality, not just data. It’s also reminiscent of what \nwe’ll see with generators in the next section.","metadata":{"loc":{"lines":{"from":220670,"to":220716}}}}],["1763",{"pageContent":"This particular usage reinforces that iterators can be a pattern for \norganizing functionality, not just data. It’s also reminiscent of what \nwe’ll see with generators in the next section. \n\nYou could even get creative and define an iterator that represents \nmeta operations on a single piece of data. For example, we could \ndefine an iterator for numbers that by default ranges from 0 up to \n(or down to, for negative numbers) the number in question. \n\n\nIterators | 95 \n\n\n\nConsider: \n\nif (! Number . prototype[Symbol . iterator]) { \n\nObject .defineProperty( \n\nNumber . prototype. \n\nSymbol. iterator, \n\n{ \n\nwritable: true, \nconfigurable: true, \nenumerable: false, \nvalue: function iterator(){ \n\nvar i, inc, done = false, top = +this; \n\n// iterate positively or negatively? \ninc = 1 * (top < 0 ? -1 : 1); \n\nreturn { \n\n// nake the iterator itself an iterable! \n[Symbol. iterator](){ return this; }, \n\nnext() { \n\nif (!done) { \n\n// initial iteration always 0 \n\nif (i == null) { \n\n1 = 0 ; \n\n}","metadata":{"loc":{"lines":{"from":220716,"to":220767}}}}],["1764",{"pageContent":"return { \n\n// nake the iterator itself an iterable! \n[Symbol. iterator](){ return this; }, \n\nnext() { \n\nif (!done) { \n\n// initial iteration always 0 \n\nif (i == null) { \n\n1 = 0 ; \n\n} \n\n// iterating positively \nelse if (top >= 0) { \n\ni = Math.min(top,i + inc); \n\n} \n\n// iterating negatively \n\nelse { \n\ni = Math.max(top,i + inc); \n\n} \n\n\n// done after this iteration? \nif (i == top) done = true; \n\nreturn { value: i, done: false }; \n\n} \n\nelse { \n\nreturn { done: true }; \n\n} \n\n\nNow, what tricks does this creativity afford us? \n\n\n96 | Chapter B: Organization \n\n\n\n\nfor (var i of 3) { \nconsole. log( 1 ); \n\n} \n\n// 0 1 2 3 \n\n[...-3]; // [0,-1,-2,-3] \n\nThose are some fun tricks, though the practical utility is somewhat \ndebatable. But then again, one might wonder why ES6 didn’t just \nship with such a minor but delightful feature easter egg!","metadata":{"loc":{"lines":{"from":220767,"to":220833}}}}],["1765",{"pageContent":"Those are some fun tricks, though the practical utility is somewhat \ndebatable. But then again, one might wonder why ES6 didn’t just \nship with such a minor but delightful feature easter egg! \n\nI’d be remiss if I didn’t at least remind you that extending native pro¬ \ntotypes as I’m doing in the previous snippet is something you \nshould only do with caution and awareness of potential hazards. \n\nIn this case, the chances that you’ll have a collision with other code \nor even a future JS feature is probably exceedingly low. But just \nbeware of the slight possibility. And document what you’re doing \nverbosely for posterity’s sake. \n\n\n\nI’ve expounded on this particular technique in \nthis blog post if you want more details. And this \ncomment even suggests a similar trick but for \nmaking string character ranges. \n\n\nIterator Consumption \n\nWe’ve already shown consuming an iterator item by item with the \nfor. .of loop. But there are other ES6 structures that can consume \niterators.","metadata":{"loc":{"lines":{"from":220833,"to":220858}}}}],["1766",{"pageContent":"Iterator Consumption \n\nWe’ve already shown consuming an iterator item by item with the \nfor. .of loop. But there are other ES6 structures that can consume \niterators. \n\nLet’s consider the iterator attached to this array (though any iterator \nwe choose would have the following behaviors): \n\nvar a = [1,2,3, 4, 5]; \n\nThe ... spread operator fully exhausts an iterator. Consider: \n\nfunction foo(x,y,z,w,p) { \n\nconsole. log( x+y+z+w+p ); \n\n} \n\nfoo( ...a ); //IS \n\n... can also spread an iterator inside an array: \n\nvar b = [ 0, .. .a, 6 ]; \nb; // [0,1,2,3,4,5, 6] \n\n\nIterators | 97 \n\n\n\n\n\nArray destructuring (see “Destructuring” on page 23 in Chapter 2) \ncan partially or completely (if paired with a ... rest/gather opera¬ \ntor) consume an iterator: \n\nvar it = a[Synbol.tterator](); \nvar [x,y] = it; \n\n// take just the first two elements from 'it' \n\nvar [z, .. .w] = it; \n\n// take the third, then the rest all at once \n\n\n// is 'it' fully exhausted? Yep.","metadata":{"loc":{"lines":{"from":220858,"to":220905}}}}],["1767",{"pageContent":"// take just the first two elements from 'it' \n\nvar [z, .. .w] = it; \n\n// take the third, then the rest all at once \n\n\n// is 'it' fully exhausted? Yep. \n\nit.next(); // { value: undefined, done: true } \n\n\nx; \n\ny; \n\nz; \n\nw; \n\n\n// 1 \n// 2 \n// 3 \n// [4,5] \n\n\nGenerators \n\n\nAll functions run to completion, right? In other words, once a func¬ \ntion starts running, it finishes before anything else can interrupt. \n\nAt least that’s how it’s been for the whole history of JavaScript up to \nthis point. As of ES6, a new somewhat exotic form of function is \nbeing introduced, called a generator. A generator can pause itself in \nmid-execution, and can be resumed either right away or at a later \ntime. So it clearly does not hold the run-to-completion guarantee \nthat normal functions do. \n\nMoreover, each pause/resume cycle in mid-execution is an opportu¬ \nnity for two-way message passing, where the generator can return a \nvalue, and the controlling code that resumes it can send a value back \nin.","metadata":{"loc":{"lines":{"from":220905,"to":220948}}}}],["1768",{"pageContent":"As with iterators in the previous section, there are multiple ways to \nthink about what a generator is, or rather what it’s most useful for. \nThere’s no one right answer, but we’ll try to consider several angles. \n\n\n\nSee the Async & Performance title of this series \nfor more information about generators, and also \nsee Chapter 4 of this current title. \n\n\n98 | Chapter 3: Organization \n\n\n\n\n\nSyntax \n\nThe generator function is declared with this new syntax: \n\nfunction *foo() { \n\n// •• \n\n} \n\nThe position of the * is not functionally relevant. The same declara¬ \ntion could be written as any of the following: \n\nfunction *foo() { .. } \nfunction* foo() { .. } \nfunction * foo() { .. } \nfunction*foo() { .. } \n\nThe only difference here is stylistic preference. Most other literature \nseems to prefer function* foo(..) { .. }. I prefer \n\nfunction *foo(..) { .. }, so that’s how I’ll present them for the \nrest of this title.","metadata":{"loc":{"lines":{"from":220950,"to":220989}}}}],["1769",{"pageContent":"function *foo(..) { .. }, so that’s how I’ll present them for the \nrest of this title. \n\nMy reason is purely didactic in nature. In this text, when referring to \na generator function, I will use *foo(..), as opposed to foo(..) for \na normal function. I observe that *foo(..) more closely matches \nthe * positioning of function *foo(..) { .. }. \n\nMoreover, as we saw in Chapter 2 with concise methods, there’s a \nconcise generator form in object literals: \n\nvar a = { \n\n*foo() { .. } \n\nI; \n\nI would say that with concise generators, *foo() { .. } is rather \nmore natural than * foo() { .. }. So that further argues for \nmatching the consistency with *foo(). \n\nConsistency eases understanding and learning. \n\nExecuting a Generator \n\nThough a generator is declared with *, you still execute it like a nor¬ \nmal function: \n\nfoo(); \n\nYou can still pass it arguments, as in: \n\n\nGenerators | 99 \n\n\n\n\nfunction *foo(x,y) { \n\n// ■■ \n\n} \n\nfoo( 5, 10 );","metadata":{"loc":{"lines":{"from":220989,"to":221033}}}}],["1770",{"pageContent":"foo(); \n\nYou can still pass it arguments, as in: \n\n\nGenerators | 99 \n\n\n\n\nfunction *foo(x,y) { \n\n// ■■ \n\n} \n\nfoo( 5, 10 ); \n\nThe major difference is that executing a generator, like foo(5,10), \ndoesn’t actually run the code in the generator. Instead, it produces \nan iterator that will control the generator to execute its code. \n\nWe’ll come back to this later in “Iterator Control” on page 105, but \nbriefly: \n\nfunction *foo() { \n\n// \n\n} \n\nvar it = foo(); \n\n// to start/advanced '*foo()', call \n// 'it. next(..) ' \n\nyield \n\nGenerators also have a new keyword you can use inside them, to sig¬ \nnal the pause point: yield. Consider: \n\nfunction *foo() { \nvar x = 10; \nvar y = 20; \n\n\nyield; \n\nvar z = x + y; \n\n} \n\nIn this *foo() generator, the operations on the first two lines would \nrun at the beginning, then yield would pause the generator. If and \nwhen resumed, the last line of *foo() would run. yield can appear \nany number of times (or not at all, technically!) in a generator.","metadata":{"loc":{"lines":{"from":221033,"to":221088}}}}],["1771",{"pageContent":"You can even put yield inside a loop, and it can represent a \nrepeated pause point. In fact, a loop that never completes just means \na generator that never completes, which is completely valid, and \nsometimes entirely what you need. \n\nyield is not just a pause point. It’s an expression that sends out a \nvalue when pausing the generator. Here’s a while, .true loop in a \ngenerator that for each iteration yields a new random number: \n\n\n100 | Chapter 3: Organization \n\n\n\nfunction *foo() { \nwhile (true) { \n\nyield Math. randon( ); \n\n} \n\n} \n\nThe yield .. expression not only sends a value—yield without a \nvalue is the same as yield undefined—but also receives (i.e., is \nreplaced by) the eventual resumption value. Consider: \n\nfunction *foo() { \n\nvar x = yield 10; \nconsole. log( x ); \n\n}","metadata":{"loc":{"lines":{"from":221090,"to":221122}}}}],["1772",{"pageContent":"function *foo() { \n\nvar x = yield 10; \nconsole. log( x ); \n\n} \n\nThis generator will first yield out the value 10 when pausing itself. \nWhen you resume the generator—using the it.next(..) we \nreferred to earlier—whatever value (if any) you resume with will \nreplace/complete the whole yield 10 expression, meaning that the \nvalue will be assigned to the x variable. \n\nA yield .. expression can appear anywhere a normal expression \ncan. For example: \n\nfunction *foo() { \n\nvar arr = [ yield 1 , yield 2, yield 3 ]; \nconsole. log( arr, yield 4 ); \n\n} \n\n*foo() here has four yield .. expressions. Each yield results in \nthe generator pausing to wait for a resumption value that’s then used \nin the various expression contexts. \n\nyield is not technically an operator, though when used like yield 1 \nit sure looks like it. Because yield can be used all by itself as in var \nx = yield;, thinking of it as an operator can sometimes be confus¬ \ning.","metadata":{"loc":{"lines":{"from":221122,"to":221152}}}}],["1773",{"pageContent":"Technically, yield .. is of the same “expression precedence”—simi¬ \nlar conceptually to operator precedence—as an assignment expres¬ \nsion like a = 3. That means yield .. can basically appear \nanywhere a = 3 can validly appear. \n\nLet’s illustrate the symmetry: \n\nvar a, b; \n\na = 3; // valid \n\nb = 2 + a = 3; // invalid \n\n\nGenerators | 101 \n\n\n\n\n\nb = 2 + (a = 3); \n\n\n// valid \n\n\nyield 3; // valid \n\na = 2 + yield 3; // invalid \n\na = 2 + (yield 3); // valid \n\n\n\nIf you think about it, it makes a sort of concep¬ \ntual sense that a yield .. expression would \nbehave similar to an assignment expression. \nWhen a paused yield expression is resumed, it’s \ncompleted/replaced by the resumption value in \na way that’s not terribly dissimilar from being \n“assigned” that value. \n\n\nThe takeaway: if you need yield .. to appear in a position where \nan assignment like a = 3 would not itself be allowed, it needs to be \nwrapped in a( ).","metadata":{"loc":{"lines":{"from":221154,"to":221199}}}}],["1774",{"pageContent":"The takeaway: if you need yield .. to appear in a position where \nan assignment like a = 3 would not itself be allowed, it needs to be \nwrapped in a( ). \n\nBecause of the low precedence of the yield keyword, almost any \nexpression after a yield .. will be computed first before being sent \nwith yield. Only the ... spread operator and the , comma operator \nhave lower precedence, meaning theyd bind after the yield has \nbeen evaluated. \n\nSo just like with multiple operators in normal statements, another \ncase where ( ) might be needed is to override (elevate) the low \nprecedence of yield, such as the difference between these expres¬ \nsions: \n\nyield 2+3; // sane as 'yield (2+3)' \n\n(yield 2) + 3; // 'yield 2' first, then '+ 3'","metadata":{"loc":{"lines":{"from":221199,"to":221216}}}}],["1775",{"pageContent":"yield 2+3; // sane as 'yield (2+3)' \n\n(yield 2) + 3; // 'yield 2' first, then '+ 3' \n\nJust like = assignment, yield is also “right-associative,” which means \nthat multiple yield expressions in succession are treated as having \nbeen ( .. ) grouped from right to left. So, yield yield yield 3 is \ntreated as yield (yield (yield 3)). A “left-associative” interpre¬ \ntation like ((yield) yield) yield 3 would make no sense. \n\nJust like with operators, it’s a good idea to use ( .. ) grouping, even \nif not strictly required, to disambiguate your intent if yield is com¬ \nbined with other operators or yields. \n\n\n102 | Chapter 3: Organization \n\n\n\n\n\n\nSee the Types & Grammar title of this series for \nmore information about operator precedence \nand associativity. \n\n\nyield*","metadata":{"loc":{"lines":{"from":221216,"to":221243}}}}],["1776",{"pageContent":"102 | Chapter 3: Organization \n\n\n\n\n\n\nSee the Types & Grammar title of this series for \nmore information about operator precedence \nand associativity. \n\n\nyield* \n\nIn the same way that the * makes a function declaration into func \ntion * generator declaration, a * makes yield into yield *, which \nis a very different mechanism, called yield delegation. Grammati¬ \ncally, yield *.. will behave the same as a yield .., as discussed in \nthe previous section. \n\nyield * .. requires an iterable; it then invokes that iterable’s itera¬ \ntor, and delegates its own host generator’s control to that iterator \nuntil it’s exhausted. Consider: \n\nfunction *foo() { \nyield *[1,2,3]; \n\n} \n\n\n\nAs with the * position in a generator’s declara¬ \ntion (discussed earlier), the * positioning in \nyield * expressions is stylistically up to you. \nMost other literature prefers yield* .., but I \nprefer yield *.., for very symmetrical reasons \nas already discussed.","metadata":{"loc":{"lines":{"from":221243,"to":221279}}}}],["1777",{"pageContent":"The [1,2,3] value produces an iterator that will step through its \nvalues, so the *foo() generator will yield those values out as it’s con¬ \nsumed. Another way to illustrate the behavior is in yield delegating \nto another generator: \n\nfunction *foo() { \nyield 1; \nyield 2 ; \nyield 3; \n\n} \n\nfunction *bar() { \nyield *foo(); \n\n} \n\nThe iterator produced when *bar() calls *foo() is delegated to via \nyield *, meaning whatever value(s) *foo() produces will be pro¬ \nduced by *bar(). \n\n\nGenerators | 103 \n\n\n\n\n\n\n\n\n\nWhereas with yield .. the completion value of the expression \ncomes from resuming the generator with it. next(..), the comple¬ \ntion value of the yield *.. expression comes from the return value \n(if any) from the delegated-to iterator.","metadata":{"loc":{"lines":{"from":221282,"to":221317}}}}],["1778",{"pageContent":"Built-in iterators generally don’t have return values, as we covered at \nthe end of “Iterator Loop” on page 92 earlier in this chapter. But if \nyou define your own custom iterator (or generator), you can design \nit to return a value, which yield *.. would capture: \n\nfunction *foo() { \nyield 1; \nyield 2; \nyield 3; \nreturn 4; \n\n} \n\nfunction *bar() { \n\nvar x = yield *foo(); \nconsole. log( \"x:\", x ); \n\n} \n\nfor (var v of bar()) { \nconsole. log( v ); \n\n} \n\n// 1 2 3 \n// x: 4 \n\nWhile the 1, 2, and 3 values are yielded out of *foo() and then out \nof *bar(), the 4 value returned from *foo() is the completion value \nof the yield *foo() expression, which then gets assigned to x. \n\nBecause yield * can call another generator (by way of delegating to \nits iterator), it can also perform a sort of generator recursion by call¬ \ning itself: \n\nfunction *foo(x) { \nif (x < 3) { \n\nx = yield *foo( x + 1 ); \n\n} \n\nreturn x * 2; \n\n} \n\nfoo( 1 );","metadata":{"loc":{"lines":{"from":221319,"to":221366}}}}],["1779",{"pageContent":"function *foo(x) { \nif (x < 3) { \n\nx = yield *foo( x + 1 ); \n\n} \n\nreturn x * 2; \n\n} \n\nfoo( 1 ); \n\nThe result from foo(l) and then calling the iterator’s next() to run \nit through its recursive steps will be 24. The first *foo(..) run has x \nat value 1, which is x < 3. x + 1 is passed recursively to *foo(..), \nso x is then 2. One more recursive call results in x of 3. \n\n\n104 | Chapter 3: Organization \n\n\n\nNow, because x < 3 fails, the recursion stops, and return 3*2 \ngives 6 back to the previous call’s yield *.. expression, which is \nthen assigned to x. Another return 6*2 returns 12 back to the \nprevious call’s x. Finally 12 * 2, or 24, is returned from the comple¬ \nted run of the *foo(..) generator. \n\nIterator Control \n\nEarlier, we briefly introduced the concept that generators are con¬ \ntrolled by iterators. Let’s fully dig into that now. \n\nRecall the recursive *foo(..) from the previous section. Here’s how \nwe’d run it: \n\nfunction *foo(x) { \nif (x < 3) { \n\nx = yield *foo( x + 1 );","metadata":{"loc":{"lines":{"from":221366,"to":221406}}}}],["1780",{"pageContent":"Recall the recursive *foo(..) from the previous section. Here’s how \nwe’d run it: \n\nfunction *foo(x) { \nif (x < 3) { \n\nx = yield *foo( x + 1 ); \n\n} \n\nreturn x * 2; \n\n1 \n\nvar it = foo( 1 ); \n\nit.next(); // { value: 24, done: true } \n\nIn this case, the generator doesn’t really ever pause, as there’s no \nyield .. expression. Instead, yield * just keeps the current itera¬ \ntion step going via the recursive call. So, just one call to the iterator’s \nnext() function fully runs the generator. \n\nNow let’s consider a generator that will have multiple steps and thus \nmultiple produced values: \n\nfunction *foo() { \nyield 1; \nyield 2; \nyield 3; \n\n1 \n\nWe already know we can consume an iterator, even one attached to a \ngenerator like *foo(), with a for.. of loop: \n\nfor (var v of foo()) { \nconsole. log( v ); \n\n1 \n\n// 1 2 3 \n\n\nGenerators | 105","metadata":{"loc":{"lines":{"from":221406,"to":221450}}}}],["1781",{"pageContent":"We already know we can consume an iterator, even one attached to a \ngenerator like *foo(), with a for.. of loop: \n\nfor (var v of foo()) { \nconsole. log( v ); \n\n1 \n\n// 1 2 3 \n\n\nGenerators | 105 \n\n\n\nThe for. .of loop requires an iterable. A genera¬ \ntor function reference (like foo) by itself is not \nan iterable; you must execute it with foo() to \nget the iterator (which is also an iterable, as we \nexplained earlier in this chapter). You could the¬ \noretically extend the GeneratorPrototype (the \nprototype of all generator functions) with a Sym \nbol. iterator function that essentially just does \nreturn this(). That would make the foo refer¬ \nence itself an iterable, which means for (var v \nof foo) { .. } (notice no () on foo) will \nwork. \n\nLet’s instead iterate the generator manually: \n\nfunction *foo() { \nyield 1; \nyield 2 ; \nyield 3; \n\n} \n\nvar It = foo(); \n\ntt.nextQ; \ntt.nextQ; \ntt.nextQ; \n\ntt.nextQ;","metadata":{"loc":{"lines":{"from":221450,"to":221493}}}}],["1782",{"pageContent":"Let’s instead iterate the generator manually: \n\nfunction *foo() { \nyield 1; \nyield 2 ; \nyield 3; \n\n} \n\nvar It = foo(); \n\ntt.nextQ; \ntt.nextQ; \ntt.nextQ; \n\ntt.nextQ; \n\nIf you look closely, there are three yield statements and four next() \ncalls. That may seem like a strange mismatch. In fact, there will \nalways be one more next() call than yield expression, assuming all \nare evaluated and the generator is fully run to completion. \n\nBut if you look at it from the opposite perspective (inside-out \ninstead of outside-in), the matching between yield and nextQ \nmakes more sense. \n\nRecall that the yield .. expression will be completed by the value \nyou resume the generator with. That means the argument you pass \nto next(..) completes whatever yield .. expression is currently \npaused waiting for a completion. \n\nLet’s illustrate this perspective this way: \n\nfunction *foo() { \nvar x = yield 1; \nvar y = yield 2; \n\n\n// { value: 1, done: false } \n\n// { value: 2, done: false }","metadata":{"loc":{"lines":{"from":221493,"to":221533}}}}],["1783",{"pageContent":"Let’s illustrate this perspective this way: \n\nfunction *foo() { \nvar x = yield 1; \nvar y = yield 2; \n\n\n// { value: 1, done: false } \n\n// { value: 2, done: false } \n\n// { value: 3, done: false } \n\n// { value: undefined, done: true } \n\n\n\n106 | Chapter 3: Organization \n\n\n\n\n\n\n\n\nvar z = yield 3; \nconsole. log( x, y, z ); \n\n} \n\nIn this snippet, each yield .. is sending a value out (1, 2, 3), but \nmore directly, it’s pausing the generator to wait for a value. In other \nwords, it’s almost like asking the question, “What value should I use \nhere? I’ll wait to hear back.” \n\nNow, here’s how we control *foo() to start it up: \n\nvar it = foo(); \n\ntt.nextQ; // { value: 1, done: false }","metadata":{"loc":{"lines":{"from":221533,"to":221573}}}}],["1784",{"pageContent":"Now, here’s how we control *foo() to start it up: \n\nvar it = foo(); \n\ntt.nextQ; // { value: 1, done: false } \n\nThat first nextQ call is starting up the generator from its initial \npaused state, and running it to the first yield. At the moment you \ncall that first nextQ, there’s no yield .. expression waiting for a \ncompletion. If you passed a value to that first nextQ call, it would \ncurrently just be thrown away, because no yield is waiting to receive \nsuch a value. \n\n\n\nAn early proposal for the “beyond ES6” time- \nframe would let you access a value passed to an \ninitial next( ..) call via a separate meta property \n(see Chapter 7) inside the generator. \n\n\nNow, let’s answer the currently pending question, “What value \nshould I assign to x?” We’ll answer it by sending a value to the next \nnext(..) call: \n\ntt.next( \"foo\" ); // { value: 2, done: false } \n\nNow, the x will have the value \"foo\", but we’ve also asked a new \nquestion, “What value should I assign to y?” And we answer:","metadata":{"loc":{"lines":{"from":221573,"to":221601}}}}],["1785",{"pageContent":"tt.next( \"foo\" ); // { value: 2, done: false } \n\nNow, the x will have the value \"foo\", but we’ve also asked a new \nquestion, “What value should I assign to y?” And we answer: \n\nit.next( \"bar\" ); // { value: 3, done: false } \n\nAnswer given, another question asked. Final answer: \n\nit.next( \"baz\" ); // \"foo\" \"bar\" \"baz\" \n\n// { value: undefined, done: true } \n\nNow it should be clearer how each yield .. “question” is answered \nby the next next(..) call, and so the “extra” nextQ call we observed \nis always just the initial one that starts everything going. \n\nLet’s put all those steps together: \n\n\nGenerators | 107 \n\n\n\n\n\n\n\nvar it = foo(); \n\n\n// start up the generator \n\nit.nextQ; // { value: 1, done: false } \n\n// answer first question \n\nit.next( \"foo\" ); // { value: 2, done: false } \n\n// answer second question \n\nit.next( \"bar\" ); // { value: 3, done: false } \n\n\n// answer third question \n\nit.next( \"baz\" ); // \"foo\" \"bar\" \"baz\" \n\n// { value: undefined, done: true }","metadata":{"loc":{"lines":{"from":221601,"to":221649}}}}],["1786",{"pageContent":"// answer second question \n\nit.next( \"bar\" ); // { value: 3, done: false } \n\n\n// answer third question \n\nit.next( \"baz\" ); // \"foo\" \"bar\" \"baz\" \n\n// { value: undefined, done: true } \n\nYou can think of a generator as a producer of values, in which case \neach iteration is simply producing a value to be consumed. \n\nBut in a more general sense, perhaps it’s appropriate to think of gen¬ \nerators as controlled, progressive code execution, much like the \ntasks queue example from the earlier section “Custom Iterators” on \npage 93. \n\n\n\nThat perspective is exactly the motivation for \nhow we’ll revisit generators in Chapter 4. Specif¬ \nically, there’s no reason that next( ..) has to be \ncalled right away after the previous next(..) \nfinishes. While the generator’s inner execution \ncontext is paused, the rest of the program con¬ \ntinues unblocked, including the ability for asyn¬ \nchronous actions to control when the generator \nis resumed. \n\n\nEarly Completion","metadata":{"loc":{"lines":{"from":221649,"to":221681}}}}],["1787",{"pageContent":"Early Completion \n\nAs we covered earlier in this chapter, the iterator attached to a gen¬ \nerator supports the optional return(..) and throw(..) methods. \nBoth of them have the effect of aborting a paused generator immedi¬ \nately. \n\nConsider: \n\nfunction *foo() { \nyield 1; \nyield 2 ; \nyield 3; \n\n} \n\n\n108 | Chapter 3: Organization \n\n\n\n\n\nvar it = foo(); \n\n\nit.nextQ; \n\n\n// { value: 1, done: false } \n\n\nit.return( 42 ); \n\n\n// { value: 42, done: true } \n\n\nit.nextQ; \n\n\n// { value: undefined, done: true } \n\n\nreturn(x) is kind of like forcing a return x to be processed at \nexactly that moment, such that you get the specified value right \nback. Once a generator is completed, either normally or early as \nshown, it no longer processes any code or returns any values. \n\nIn addition to return(..) being callable manually, it’s also called \nautomatically at the end of iteration by any of the ES6 constructs \nthat consume iterators, such as the for.. of loop and the ... spread \noperator.","metadata":{"loc":{"lines":{"from":221681,"to":221733}}}}],["1788",{"pageContent":"The purpose of this capability is to notify the generator if the con¬ \ntrolling code is no longer going to iterate over it anymore, so that it \ncan perhaps do any cleanup tasks (freeing up resources, resetting \nstatus, etc.). Identical to a normal function cleanup pattern, the \nmain way to accomplish this is to use a finally clause: \n\nfunction *foo() { \ntry { \n\nyield 1; \nyield 2 ; \nyield 3; \n\n\n} \n\n\nfinally { \n\nconsole. log( \"cleanup!\" ); \n\n} \n\n\nfor (var v of fooQ) { \nconsole. log( v ); \n\n1 \n\n// 1 2 3 \n// cleanup! \n\nvar it = foo(); \n\nit.next(); // { value: 1, done: false } \n\nit.return( 42 ); // cleanup! \n\n\n// { value: 42, done: true } \n\n\nGenerators | 109","metadata":{"loc":{"lines":{"from":221735,"to":221777}}}}],["1789",{"pageContent":"1 \n\n// 1 2 3 \n// cleanup! \n\nvar it = foo(); \n\nit.next(); // { value: 1, done: false } \n\nit.return( 42 ); // cleanup! \n\n\n// { value: 42, done: true } \n\n\nGenerators | 109 \n\n\n\n\n\nDo not put a yield statement inside the finally \nclause! It’s valid and legal, but it’s a really terrible \nidea. It acts in a sense as deferring the comple¬ \ntion of the return(..) call you made, as any \nyield .. expressions in the finally clause are \nrespected to pause and send messages; you don’t \nimmediately get a completed generator as \nexpected. There’s basically no good reason to opt \nin to that crazy bad part, so avoid doing so! \n\nIn addition to the previous snippet showing how return( ..) aborts \nthe generator while still triggering the finally clause, it also dem¬ \nonstrates that a generator produces a whole new iterator each time \nit’s called. In fact, you can use multiple iterators attached to the same \ngenerator concurrently: \n\nfunction *foo() { \nyield 1; \nyield 2 ; \nyield 3; \n\n}","metadata":{"loc":{"lines":{"from":221777,"to":221819}}}}],["1790",{"pageContent":"function *foo() { \nyield 1; \nyield 2 ; \nyield 3; \n\n} \n\nvar itl = foo(); \nitl.next(); \nitl.next(); \n\nvar it2 = foo(); \nit2.next(); \n\nitl.next(); \n\nit2.next(); \nit2.next(); \n\nit2.next(); \nitl.next(); \n\n\n// { value: 1, done: false } \n// { value: 2, done: false } \n\n\n// { value: 1, done: false } \n\n// { value: 3, done: false } \n\n// { value: 2, done: false } \n\n// { value: 3, done: false } \n\n// { value: undefined, done: true } \n// { value: undefined, done: true } \n\n\n\nEarly Abort \n\nInstead of calling return(..), you can call throw(..). Just like \nreturn(x) is essentially injecting a return x into the generator at its \ncurrent pause point, calling throw(x) is essentially like injecting a \nthrow x at the pause point. \n\nOther than the exception behavior (we cover what that means to try \nclauses in the next section), throw(. .) produces the same sort of \n\n\n110 | Chapter 3: Organization \n\n\n\n\nearly completion that aborts the generator’s run at its current pause \npoint. For example:","metadata":{"loc":{"lines":{"from":221819,"to":221876}}}}],["1791",{"pageContent":"110 | Chapter 3: Organization \n\n\n\n\nearly completion that aborts the generator’s run at its current pause \npoint. For example: \n\nfunction *foo() { \nyield 1; \nyield 2 ; \nyield 3; \n\n} \n\nvar it = foo(); \n\nit.next(); // { value: 1, done: false } \n\ntry { \n\nit.throw( \"Oops!\" ); \n\n} \n\ncatch (err) { \n\nconsole. log( err ); // Exception: Oops! \n\n} \n\nit.next(); // { value: undefined, done: true } \n\nBecause throw( ..) basically injects a throw .. in replacement of \nthe yield 1 line of the generator, and nothing handles this excep¬ \ntion, it immediately propagates back out to the calling code, which \nhandles it with a try.. catch. \n\nUnlike return( ..), the iterator’s throw(. .) method is never called \nautomatically. \n\nOf course, though not shown in the previous snippet, if a \ntry.. finally clause was waiting inside the generator when you call \nthrow(. .), the finally clause would be given a chance to complete \nbefore the exception is propagated back to the calling code. \n\nError Handling","metadata":{"loc":{"lines":{"from":221876,"to":221922}}}}],["1792",{"pageContent":"Error Handling \n\nAs we’ve already hinted, error handling with generators can be \nexpressed with try. .catch, which works in both inbound and out¬ \nbound directions: \n\nfunction *foo() { \ntry { \n\nyield 1; \n\n} \n\ncatch (err) { \n\nconsole. log( err ); \n\n} \n\n\nGenerators | 111 \n\n\n\n\n\nyield 2; \n\n\nthrow \"Hello!\"; \n\n} \n\n\nvar it = foo(); \n\n\nit.next(); \n\n// { value: 1, done: false } \n\ntry { \n\n\nit.throw( \"Hi!\" ) \n\ni; //Hi! \n\n\n// { value: 2, done: false } \n\n\nlt.next(); \n\nconsole. log( \"never gets here\" ); \n\n} \n\ncatch (err) { \n\nconsole. log( err ); // Hello! \n\n} \n\nErrors can also propagate in both directions through yield * dele¬ \ngation: \n\nfunction *foo() { \ntry { \n\nyield 1; \n\n} \n\ncatch (err) { \n\nconsole. log( err ); \n\n} \n\nyield 2; \n\nthrow \"foo: e2\"; \n\n} \n\nfunction *bar() { \ntry { \n\nyield *foo(); \n\nconsole. log( \"never gets here\" ); \n\n} \n\ncatch (err) { \n\nconsole. log( err ); \n\n} \n\n\nvar it = bar(); \ntry { \n\nit.next(); // { value: 1, done: false } \n\n\n112 | Chapter 3: Organization","metadata":{"loc":{"lines":{"from":221922,"to":222030}}}}],["1793",{"pageContent":"console. log( \"never gets here\" ); \n\n} \n\ncatch (err) { \n\nconsole. log( err ); \n\n} \n\n\nvar it = bar(); \ntry { \n\nit.next(); // { value: 1, done: false } \n\n\n112 | Chapter 3: Organization \n\n\n\nlt.throw( \"el\" ); // el \n\n// { value: 2, done: false } \n\nit.next(); // foo: e2 \n\n// { value: undefined, done: true } \n\n} \n\ncatch (err) { \n\nconsole. log( \"never gets here\" ); \n\n} \n\nlt.next(); // { value: undefined, done: true } \n\nWhen *foo() calls yield 1, the 1 value passes through *bar() \nuntouched, as we’ve already seen. \n\nBut what’s most interesting about this snippet is that when *foo() \ncalls throw \"foo: e2\", this error propagates to *bar() and is \nimmediately caught by *bar()’s try. .catch block. The error doesn’t \npass through *bar( ) like the 1 value did. \n\n*bar()’s catch then does a normal output of err (\"foo: e2\") and \nthen *bar() finishes normally, which is why the { value: unde \nfined, done: true } iterator result comes back from it. next().","metadata":{"loc":{"lines":{"from":222030,"to":222079}}}}],["1794",{"pageContent":"*bar()’s catch then does a normal output of err (\"foo: e2\") and \nthen *bar() finishes normally, which is why the { value: unde \nfined, done: true } iterator result comes back from it. next(). \n\nIf *bar() didn’t have a try. .catch around the yield *. . expres¬ \nsion, the error would of course propagate all the way out, and on the \nway through it still would complete (abort) *bar( ). \n\nTranspiling a Generator \n\nIs it possible to represent a generator’s capabilities prior to ES6? It \nturns out it is, and there are several great tools that do so, including \nmost notably Facebook’s Regenerator tool. \n\nBut just to better understand generators, let’s try our hand at man¬ \nually converting. Basically, we’re going to create a simple closure- \nbased state machine. \n\nWe’ll keep our source generator really simple: \n\nfunction *foo() { \n\nvar x = yield 42; \nconsole. log( x ); \n\n} \n\nTo start, we’ll need a function called foo() that we can execute, \nwhich needs to return an iterator:","metadata":{"loc":{"lines":{"from":222079,"to":222107}}}}],["1795",{"pageContent":"function *foo() { \n\nvar x = yield 42; \nconsole. log( x ); \n\n} \n\nTo start, we’ll need a function called foo() that we can execute, \nwhich needs to return an iterator: \n\n\nGenerators | 113 \n\n\n\n\nfunction foo() { \n\n// ■■ \n\nreturn { \n\nnext: function(v) { \n\n// \n\n} \n\n// we'll skip ' return(..)' and 'throw(..)' \n\n}; \n\n} \n\nNow, we need some inner variable to keep track of where we are in \nthe steps of our “generator's logic. We’ll call it state. There will be \nthree states: 0 initially, 1 while waiting to fulfill the yield expression, \nand 2 once the generator is complete. \n\nEach time next( ..) is called, we need to process the next step, and \nthen increment state. For convenience, we’ll put each step into a \ncase clause of a switch statement, and we’ll hold that in an inner \nfunction called nextState( ..) that next( ..) can call. Also, because \nx is a variable across the overall scope of the “generator,” it needs to \nlive outside the nextState(.. ) function.","metadata":{"loc":{"lines":{"from":222107,"to":222151}}}}],["1796",{"pageContent":"Here it is all together (obviously somewhat simplified, to keep the \nconceptual illustration clearer): \n\nfunction foo() { \n\nfunction nextState(v) { \nswitch (state) { \ncase 0: \n\nstate++; \n\n// the 'yield' expression \n\nreturn 42; \ncase 1: \n\nstate++; \n\n// 'yield' expression fulfilled \nx = v; \n\nconsole. tog( x ); \n\n// the implicit 'return' \n\nreturn undefined; \n\n// no need to handle state '2' \n\n} \n\n} \n\n\n114 | Chapter 3: Organization \n\n\n\n\nvar state = 0, x; \n\n\nreturn { \n\nnext: function(v) { \n\nvar ret = nextState( v ); \n\nreturn { value: ret, done: (state == 2) }; \n\n} \n\n// we'll skip 'return(..)~ and 'throw(..) ' \n\n}; \n\n} \n\nAnd finally, let’s test our pre-ES6 “generator”: \nvar it = foo(); \n\ntt.next(); // { value: 42, done: false } \n\ntt.next( 10 ); // 16 \n\n// { value: undefined, done: true } \n\nNot bad, huh? Hopefully this exercise solidifies in your mind that \ngenerators are actually just simple syntax for state machine logic. \nThat makes them widely applicable. \n\nGenerator Uses","metadata":{"loc":{"lines":{"from":222153,"to":222224}}}}],["1797",{"pageContent":"Not bad, huh? Hopefully this exercise solidifies in your mind that \ngenerators are actually just simple syntax for state machine logic. \nThat makes them widely applicable. \n\nGenerator Uses \n\nSo, now that we much more deeply understand how generators \nwork, what are they useful for? \n\nWe’ve seen two major patterns: \n\nProducing a series of values \n\nThis usage can be simple (e.g., random strings or incremented \nnumbers), or it can represent more structured data access (e.g., \niterating over rows returned from a database query). \n\nEither way, we use the iterator to control a generator so that \nsome logic can be invoked for each call to next(.. ). Normal \niterators on data structures merely pull values without any con¬ \ntrolling logic. \n\nQueue of tasks to perform serially","metadata":{"loc":{"lines":{"from":222224,"to":222246}}}}],["1798",{"pageContent":"Queue of tasks to perform serially \n\nThis usage often represents flow control for the steps in an algo¬ \nrithm, where each step requires retrieval of data from some \nexternal source. The fulfillment of each piece of data may be \nimmediate, or may be asynchronously delayed. \n\n\nGenerators | 115 \n\n\n\nFrom the perspective of the code inside the generator, the \ndetails of sync or async at a yield point are entirely opaque. \nMoreover, these details are intentionally abstracted away, such \nas not to obscure the natural sequential expression of steps with \nsuch implementation complications. Abstraction also means the \nimplementations can be swapped/refactored often without \ntouching the code in the generator at all. \n\nWhen generators are viewed in light of these uses, they become a lot \nmore than just a different or nicer syntax for a manual state \nmachine. They are a powerful abstraction tool for organizing and \ncontrolling orderly production and consumption of data. \n\nModules","metadata":{"loc":{"lines":{"from":222246,"to":222271}}}}],["1799",{"pageContent":"Modules \n\nI don’t think it’s an exaggeration to suggest that the single most \nimportant code organization pattern in all of JavaScript is, and \nalways has been, the module. For myself, and I think for a large \ncross-section of the community, the module pattern drives the vast \nmajority of code. \n\nThe Old Way \n\nThe traditional module pattern is based on an outer function with \ninner variables and functions, and a returned “public API” with \nmethods that have closure over the inner data and capabilities. It’s \noften expressed like this: \n\nfunction Hello(name) { \nfunction greeting() { \n\nconsole. log( \"Hello \" + name + \"!\" ); \n\n} \n\n// public API \n\nreturn { \n\ngreeting: greeting \n\n1 ; \n\n1 \n\nvar me = Hello( \"Kyle\" ); \nme.greetingO; // Hello Kyle!","metadata":{"loc":{"lines":{"from":222271,"to":222304}}}}],["1800",{"pageContent":"console. log( \"Hello \" + name + \"!\" ); \n\n} \n\n// public API \n\nreturn { \n\ngreeting: greeting \n\n1 ; \n\n1 \n\nvar me = Hello( \"Kyle\" ); \nme.greetingO; // Hello Kyle! \n\nThis Hello (..) module can produce multiple instances by being \ncalled subsequent times. Sometimes, a module is only called for as a \nsingleton (i.e., it just needs one instance), in which case a slight var¬ \niation on the previous snippet, using an IIFE, is common: \n\n\n116 | Chapter 3: Organization \n\n\n\nvar me = (function Hello(name){ \nfunction greeting() { \n\nconsole. log( \"Hello \" + name + \"!\" ); \n\n} \n\n// public API \n\nreturn { \n\ngreeting: greeting \n\n}; \n\n})( \"Kyle\" ); \n\nme.greeting(); // Hello Kyle! \n\nThis pattern is tried and tested. It’s also flexible enough to have a \nwide assortment of variations for a number of different scenarios.","metadata":{"loc":{"lines":{"from":222304,"to":222351}}}}],["1801",{"pageContent":"}; \n\n})( \"Kyle\" ); \n\nme.greeting(); // Hello Kyle! \n\nThis pattern is tried and tested. It’s also flexible enough to have a \nwide assortment of variations for a number of different scenarios. \n\nOne of the most common is the Asynchronous Module Definition \n(AMD), and another is the Universal Module Definition (UMD). \nWe won’t cover the particulars of these patterns and techniques \nhere, but they’re explained extensively in many places online. \n\nMoving Forward \n\nAs of ES6, we no longer need to rely on the enclosing function and \nclosure to provide us with module support. ES6 modules have first \nclass syntactic and functional support. \n\nBefore we get into the specific syntax, it’s important to understand \nsome fairly significant conceptual differences with ES6 modules \ncompared to how you may have dealt with modules in the past: \n\n• ES6 uses file-based modules, meaning one module per file. At \nthis time, there is no standardized way of combining multiple \nmodules into a single file.","metadata":{"loc":{"lines":{"from":222351,"to":222377}}}}],["1802",{"pageContent":"• ES6 uses file-based modules, meaning one module per file. At \nthis time, there is no standardized way of combining multiple \nmodules into a single file. \n\nThat means that if you are going to load ES6 modules directly \ninto a browser web application, you will be loading them indi¬ \nvidually, not as a large bundle in a single file as has been com¬ \nmon in performance optimization efforts. \n\nIt’s expected that the contemporaneous advent of HTTP/2 will \nsignificantly mitigate any such performance concerns, as it \noperates on a persistent socket connection and thus can very \nefficiently load many smaller files in parallel and interleaved \nwith one another. \n\n\nModules | 117 \n\n\n\n\n• The API of an ES6 module is static. That is, you define statically \nwhat all the top-level exports are on your module’s public API, \nand those cannot be amended later.","metadata":{"loc":{"lines":{"from":222377,"to":222400}}}}],["1803",{"pageContent":"Modules | 117 \n\n\n\n\n• The API of an ES6 module is static. That is, you define statically \nwhat all the top-level exports are on your module’s public API, \nand those cannot be amended later. \n\nSome uses are accustomed to being able to provide dynamic \nAPI definitions, where methods can be added/removed/ \nreplaced in response to runtime conditions. Either these uses \nwill have to change to fit with ES6 static APIs, or they will have \nto restrain the dynamic changes to properties/methods of a \nsecond-level object. \n\n• ES6 modules are singletons. That is, there’s only one instance of \nthe module, which maintains its state. Every time you import \nthat module into another module, you get a reference to the one \ncentralized instance. If you want to be able to produce multiple \nmodule instances, your module will need to provide some sort \nof factory to do it.","metadata":{"loc":{"lines":{"from":222400,"to":222421}}}}],["1804",{"pageContent":"• The properties and methods you expose on a module’s public \nAPI are not just normal assignments of values or references. \nThey are actual bindings (almost like pointers) to the identifiers \nin your inner module definition. \n\nIn pre-ES6 modules, if you put a property on your public API \nthat holds a primitive value like a number or string, that prop¬ \nerty assignment was by value-copy, and any internal update of a \ncorresponding variable would be separate and not affect the \npublic copy on the API object. \n\nWith ES6, exporting a local private variable, even if it currently \nholds a primitive string/number/etc., exports a binding to the \nvariable. If the module changes the variable’s value, the external \nimport binding now resolves to that new value.","metadata":{"loc":{"lines":{"from":222423,"to":222437}}}}],["1805",{"pageContent":"• Importing a module is the same thing as statically requesting it \nto load (if it hasn’t already). If you’re in a browser, that implies a \nblocking load over the network. If you’re on a server (i.e., \nNode.js), it’s a blocking load from the filesystem. \n\nHowever, don’t panic about the performance implications. \nBecause ES6 modules have static definitions, the import \nrequirements can be statically scanned, and loads will happen \npreemptively, even before you’ve used the module. \n\nES6 doesn’t actually specify or handle the mechanics of how \nthese load requests work. There’s a separate notion of a Module \nLoader, where each hosting environment (browser, Node.js, \n\n\n118 | Chapter 3: Organization \n\n\n\netc.) provides a default Loader appropriate to the environment. \nThe importing of a module uses a string value to represent \nwhere to get the module (URL, file path, etc.), but this value is \nopaque in your program and only meaningful to the Loader \nitself.","metadata":{"loc":{"lines":{"from":222439,"to":222462}}}}],["1806",{"pageContent":"You can define your own custom Loader if you want more fine¬ \ngrained control than the default Loader affords—which is basi¬ \ncally none, as it’s totally hidden from your program’s code. \n\nAs you can see, ES6 modules will serve the overall use case of organ¬ \nizing code with encapsulation, controlling public APIs, and refer¬ \nencing dependency imports. But they have a very particular way of \ndoing so, and that may or may not fit very closely with how you’ve \nalready been doing modules for years. \n\nCommonJS \n\nThere’s a similar, but not fully compatible, module syntax called \nCommonJS, which is familiar to those in the Node.js ecosystem. \n\nFor lack of a more tactful way to say this, in the long run, ES6 mod¬ \nules essentially are bound to supercede all previous formats and \nstandards for modules, even CommonJS, as they are built on syntac¬ \ntic support in the language. This will, in time, inevitably win out as \nthe superior approach, if for no other reason than ubiquity.","metadata":{"loc":{"lines":{"from":222464,"to":222483}}}}],["1807",{"pageContent":"We face a fairly long road to get to that point, though. There are lit¬ \nerally hundreds of thousands of CommonJS style modules in the \nserver-side JavaScript world, and 10 times that many modules of \nvarying format standards (UMD, AMD, ad hoc) in the browser \nworld. It will take many years for the transitions to make any signifi¬ \ncant progress. \n\nIn the interim, module transpilers/converters will be an absolute \nnecessity. You might as well just get used to that new reality. \nWhether you author in regular modules, AMD, UMD, CommonJS, \nor ES6, these tools will have to parse and convert to a format that is \nsuitable for whatever environment your code will run in. \n\nFor Node.js, that probably means (for now) that the target is Com¬ \nmonJS. For the browser, it’s probably UMD or AMD. Expect lots of \nflux on this over the next few years as these tools mature and best \npractices emerge. \n\n\nModules | 119","metadata":{"loc":{"lines":{"from":222485,"to":222504}}}}],["1808",{"pageContent":"Modules | 119 \n\n\n\nFrom here on out, my best advice on modules is this: whatever for¬ \nmat you’ve been religiously attached to with strong affinity, also \ndevelop an appreciation for and understanding of ES6 modules, \nsuch as they are, and let your other module tendencies fade. They \nare the future of modules in JS, even if that reality is a bit of a ways \noff. \n\nThe New Way \n\nThe two main new keywords that enable ES6 modules are import \nand export. There’s lots of nuance to the syntax, so let’s take a \ndeeper look. \n\n\n\nAn important detail that’s easy to overlook: both \nimport and export must always appear in the \ntop-level scope of their respective usage. For \nexample, you cannot put either an import or \nexport inside an if conditional; they must \nappear outside of all blocks and functions. \n\n\nExporting API Members \n\nThe export keyword is either put in front of a declaration, or used \nas an operator (of sorts) with a special list of bindings to export. \nConsider:","metadata":{"loc":{"lines":{"from":222504,"to":222535}}}}],["1809",{"pageContent":"Exporting API Members \n\nThe export keyword is either put in front of a declaration, or used \nas an operator (of sorts) with a special list of bindings to export. \nConsider: \n\nexport function foo() { \n\n// \n\n} \n\nexport var awesome = 42; \n\nvar bar = [1,2,3]; \nexport { bar }; \n\nAnother way of expressing the same exports: \n\nfunction foo() { \n\n// •• \n\n} \n\nvar awesome = 42; \nvar bar = [1,2,3]; \n\nexport { foo, awesome, bar }; \n\n\n120 | Chapter 3: Organization \n\n\n\n\n\nThese are all called named exports, as you are in effect exporting the \nname bindings of the variables/functions/etc. \n\nAnything you don’t label with export stays private inside the scope \nof the module. That is, although something like var bar = .. looks \nlike it’s declaring at the top-level global scope, the top-level scope is \nactually the module itself; there is no global scope in modules.","metadata":{"loc":{"lines":{"from":222535,"to":222578}}}}],["1810",{"pageContent":"Modules do still have access to window and all \nthe “globals” that hang off it, just not as lexical \ntop-level scope. However, you really should stay \naway from the globals in your modules if at all \npossible. \n\n\nYou can also “rename” (aka alias) a module member during named \nexport: \n\nfunction foo() { .. } \nexport { foo as bar }; \n\nWhen this module is imported, only the bar member name is avail¬ \nable to import; foo stays hidden inside the module. \n\nModule exports are not just normal assignments of values or refer¬ \nences, as you’re accustomed to with the = assignment operator. \nActually, when you export something, you’re exporting a binding \n(kinda like a pointer) to that thing (variable, etc.). \n\nWithin your module, if you change the value of a variable you \nalready exported a binding to, even if it’s already been imported (see \nthe next section), the imported binding will resolve to the current \n(updated) value. \n\nConsider: \n\nvar awesome = 42; \nexport { awesome };","metadata":{"loc":{"lines":{"from":222582,"to":222611}}}}],["1811",{"pageContent":"Consider: \n\nvar awesome = 42; \nexport { awesome }; \n\n// later \nawesome = 100; \n\nWhen this module is imported, regardless of whether that’s before or \nafter the awesome = 100 setting, once that assignment has hap¬ \npened, the imported binding resolves to the 100 value, not 42. \n\n\nModules | 121 \n\n\n\n\n\nThat’s because the binding is, in essence, a reference to, or a pointer \nto, the awesome variable itself, rather than a copy of its value. This is \na mostly unprecedented concept for JS introduced with ES6 module \nbindings. \n\nThough you can clearly use export multiple times inside a modules \ndefinition, ES6 definitely prefers the approach that a module has a \nsingle export, which is known as a default export. In the words of \nsome members of the TC39 committee, you’re “rewarded with sim¬ \npler import syntax” if you follow that pattern, and conversely \n“penalized” with more verbose syntax if you don’t.","metadata":{"loc":{"lines":{"from":222611,"to":222640}}}}],["1812",{"pageContent":"A default export sets a particular exported binding to be the default \nwhen importing the module. The name of the binding is literally \ndefault. As you’ll see later, when importing module bindings you \ncan also rename them, as you commonly will with a default export. \n\nThere can only be one default per module definition. We’ll cover \nimport in the next section, and you’ll see how the import syntax is \nmore concise if the module has a default export. \n\nThere’s a subtle nuance to default export syntax that you should pay \nclose attention to. Compare these two snippets: \n\nfunction foo( ..) { \n\n// \n\n1 \n\nexport default foo; \n\nAnd this one: \n\nfunction foo( ..) { \n\n// \n\n1 \n\nexport { foo as default };","metadata":{"loc":{"lines":{"from":222642,"to":222670}}}}],["1813",{"pageContent":"function foo( ..) { \n\n// \n\n1 \n\nexport default foo; \n\nAnd this one: \n\nfunction foo( ..) { \n\n// \n\n1 \n\nexport { foo as default }; \n\nIn the first snippet, you are exporting a binding to the function \nexpression value at that moment, not to the identifier foo. In other \nwords, export default .. takes an expression. If you later assign \nfoo to a different value inside your module, the module import still \nreveals the function originally exported, not the new value. \n\n\n122 | Chapter 3: Organization \n\n\n\n\nBy the way, the first snippet could also have been written as: \n\nexport default function foo(..) { \n\n// •• \n\n}","metadata":{"loc":{"lines":{"from":222670,"to":222706}}}}],["1814",{"pageContent":"122 | Chapter 3: Organization \n\n\n\n\nBy the way, the first snippet could also have been written as: \n\nexport default function foo(..) { \n\n// •• \n\n} \n\n\n\nAlthough the function foo. . part here is tech¬ \nnically a function expression, for the purposes of \nthe internal scope of the module, it’s treated like \na function declaration, in that the foo name is \nbound in the module’s top-level scope (often \ncalled “hoisting”). The same is true for export \ndefault class Foo. .. However, while you can \ndo export var foo = .., you currently cannot \ndo export default var foo = .. (or let or \nconst), in a frustrating case of inconsistency. At \nthe time of this writing, there’s already discus¬ \nsion of adding that capability in soon, post-ES6, \nfor consistency’s sake. \n\n\nRecall the second snippet again: \n\nfunction foo( ..) { \n\n// •• \n\n} \n\nexport { foo as default };","metadata":{"loc":{"lines":{"from":222706,"to":222744}}}}],["1815",{"pageContent":"Recall the second snippet again: \n\nfunction foo( ..) { \n\n// •• \n\n} \n\nexport { foo as default }; \n\nIn this version of the module export, the default export binding is \nactually to the foo identifier rather than its value, so you get the pre¬ \nviously described binding behavior (i.e., if you later change foo’s \nvalue, the value seen on the import side will also be updated). \n\nBe very careful of this subtle gotcha in default export syntax, espe¬ \ncially if your logic calls for export values to be updated. If you never \nplan to update a default exports value, export default .. is fine. If \nyou do plan to update the value, you must use export { .. as \ndefault }. Either way, make sure to comment your code to explain \nyour intent! \n\nBecause there can only be one default per module, you may be \ntempted to design your module with one default export of an object \nwith all your API methods on it, such as: \n\n\nModules | 123 \n\n\n\n\n\nexport default { \n\nfoo() { \nbar( ) { .. }, \n\n\n};","metadata":{"loc":{"lines":{"from":222744,"to":222783}}}}],["1816",{"pageContent":"Modules | 123 \n\n\n\n\n\nexport default { \n\nfoo() { \nbar( ) { .. }, \n\n\n}; \n\nThat pattern seems to map closely to how a lot of developers have \nalready structured their pre-ES6 modules, so it seems like a natural \napproach. Unfortunately, it has some downsides and is officially dis¬ \ncouraged. \n\nIn particular, the JS engine cannot statically analyze the contents of a \nplain object, which means it cannot do some optimizations for static \nimport performance. The advantage of having each member indi¬ \nvidually and explicitly exported is that the engine can do the static \nanalysis and optimization. \n\nIf your API has more than one member already, it seems like these \nprinciples—one default export per module, and all API members as \nnamed exports—are in conflict, doesn’t it? But you can have a single \ndefault export as well as other named exports; they are not mutually \nexclusive. \n\nSo, instead of this (discouraged) pattern: \nexport default function foo() { .. }","metadata":{"loc":{"lines":{"from":222783,"to":222815}}}}],["1817",{"pageContent":"So, instead of this (discouraged) pattern: \nexport default function foo() { .. } \n\nfoo.bar = function() { .. }; \nfoo.baz = function!) { .. }; \n\nYou can do: \n\nexport default function foo() { .. } \n\nexport function bar() { .. } \nexport function baz() { .. } \n\n\n\nIn this previous snippet, I used the name foo for \nthe function that default labels. That foo name, \nhowever, is ignored for the purposes of export— \ndefault is actually the exported name. When \nyou import this default binding, you can give it \nwhatever name you want, as you’ll see in the \nnext section. \n\n\nAlternatively, some will prefer: \n\n\n124 | Chapter 3: Organization \n\n\n\n\n\nfunction foo() { .. } \n\nfunction bar() { .. } \n\nfunction baz() { .. } \n\nexport { foo as default, bar, baz, .. };","metadata":{"loc":{"lines":{"from":222815,"to":222854}}}}],["1818",{"pageContent":"Alternatively, some will prefer: \n\n\n124 | Chapter 3: Organization \n\n\n\n\n\nfunction foo() { .. } \n\nfunction bar() { .. } \n\nfunction baz() { .. } \n\nexport { foo as default, bar, baz, .. }; \n\nThe effects of mixing default and named exports will be more clear \nwhen we cover import shortly. But essentially it means that the most \nconcise default import form would only retrieve the foo( ) function. \nThe user could additionally manually list bar and baz as named \nimports, if they want them. \n\nYou can probably imagine how tedious that’s going to be for con¬ \nsumers of your module if you have lots of named export bindings. \nThere is a wildcard import form where you import all of a modules \nexports within a single namespace object, but there’s no way to wild¬ \ncard import to top-level bindings.","metadata":{"loc":{"lines":{"from":222854,"to":222881}}}}],["1819",{"pageContent":"Again, the ES6 module mechanism is intentionally designed to dis¬ \ncourage modules with lots of exports; relatively speaking, it’s desired \nthat such approaches be a little more difficult, as a sort of social \nengineering to encourage simple module design in favor of large/ \ncomplex module design. \n\nI would probably recommend that you avoid mixing default export \nwith named exports, especially if you have a large API and refactor¬ \ning to separate modules isn’t practical or desired. In that case, just \nuse all named exports, and document that consumers of your mod¬ \nule should probably use the import * as .. (namespace import, \ndiscussed in the next section) approach to bring the whole API in at \nonce on a single namespace.","metadata":{"loc":{"lines":{"from":222883,"to":222895}}}}],["1820",{"pageContent":"We mentioned this earlier, but let’s come back to it in more detail. \nOther than the export default .. . form that exports an expres¬ \nsion value binding, all other export forms are exporting bindings to \nlocal identifiers. For those bindings, if you change the value of a \nvariable inside a module after exporting, the external imported \nbinding will access the updated value: \n\nvar foo = 42; \n\nexport { foo as default }; \n\nexport var bar = \"hello world\"; \n\nfoo = 10; \nbar = \"cool\"; \n\n\nModules | 125 \n\n\n\nWhen you import this module, the default and bar exports will be \nbound to the local variables foo and bar, meaning they will reveal \nthe updated 10 and \"cool\" values. The values at time of export are \nirrelevant. The values at time of import are irrelevant. The bindings \nare live links, so all that matters is what the current value is when \nyou access the binding.","metadata":{"loc":{"lines":{"from":222897,"to":222923}}}}],["1821",{"pageContent":"Two-way bindings are not allowed. If you \nimport a foo from a module, and try to change \nthe value of your imported foo variable, an error \nwill be thrown! We’ll revisit that in the next \nsection. \n\n\nYou can also re-export another module’s exports, such as: \n\nexport { foo, bar } from \"baz\"; \n\nexport { foo as FOO, bar as BAR } from \"baz\"; \n\nexport * from \"baz\"; \n\nThose forms are similar to just first importing from the \"baz\" mod¬ \nule then listing its members explicitly for export from your module. \nHowever, in these forms, the members of the \"baz\" module are \nnever imported to your module’s local scope; they sort of pass \nthrough untouched. \n\nImporting API Members \n\nTo import a module, unsurprisingly you use the import statement. \nJust as export has several nuanced variations, so does import, so \nspend plenty of time considering the following issues and experi¬ \nmenting with your options.","metadata":{"loc":{"lines":{"from":222927,"to":222953}}}}],["1822",{"pageContent":"If you want to import certain specific named members of a module’s \nAPI into your top-level scope, you use this syntax: \n\nimport { foo, bar, baz } from \"foo\"; \n\n\n\nThe { .. } syntax here may look like an object \nliteral, or even an object destructuring syntax. \nHowever, its form is special just for modules, so \nbe careful not to confuse it with other { .. } \npatterns elsewhere. \n\n\n126 | Chapter 3: Organization \n\n\n\n\n\n\nThe \"foo\" string is called a module specifier. Because the whole goal \nis statically analyzable syntax, the module specifier must be a string \nliteral; it cannot be a variable holding the string value. \n\nFrom the perspective of your ES6 code and the JS engine itself, the \ncontents of this string literal are completely opaque and meaning¬ \nless. The module loader will interpret this string as an instruction of \nwhere to find the desired module, either as a URL path or a local \nfilesystem path.","metadata":{"loc":{"lines":{"from":222955,"to":222984}}}}],["1823",{"pageContent":"The foo, bar, and baz identifiers listed must match named exports \non the module’s API (static analysis and error assertion apply). They \nare bound as top-level identifiers in your current scope: \n\nimport { foo } from \"foo\"; \nfoo(); \n\nYou can rename the bound identifiers imported, as: \nimport { foo as theFooFunc } from \"foo\"; \ntheFooFunc( ); \n\nIf the module has just a default export that you want to import and \nbind to an identifier, you can opt to skip the { .. } surrounding \nsyntax for that binding. The import in this preferred case gets the \nnicest and most concise of the import syntax forms: \n\nimport foo from \"foo\"; \n\n// or: \n\nimport { default as foo } from \"foo\";","metadata":{"loc":{"lines":{"from":222986,"to":223006}}}}],["1824",{"pageContent":"import foo from \"foo\"; \n\n// or: \n\nimport { default as foo } from \"foo\"; \n\n\n\nAs explained in the previous section, the \ndefault keyword in a module’s export specifies \na named export where the name is actually \ndefault, as is illustrated by the second more \nverbose syntax option. The renaming from \ndefault to, in this case, foo, is explicit in the lat¬ \nter syntax and is identical yet implicit in the for¬ \nmer syntax. \n\n\nYou can also import a default export along with other named \nexports, if the module has such a definition. Recall this module defi¬ \nnition from earlier: \n\n\nModules | 127 \n\n\n\n\nexport default function foo() { .. } \n\n\nexport function bar() { .. } \nexport function baz() { .. } \n\nTo import that module’s default export and its two named exports: \nimport FOOFN, { bar, baz as BAZ } from \"foo\"; \n\nFOOFNQ; \n\nbar(); \n\nBAZ ();","metadata":{"loc":{"lines":{"from":223006,"to":223047}}}}],["1825",{"pageContent":"To import that module’s default export and its two named exports: \nimport FOOFN, { bar, baz as BAZ } from \"foo\"; \n\nFOOFNQ; \n\nbar(); \n\nBAZ (); \n\nThe strongly suggested approach from ES6’s module philosophy is \nthat you only import the specific bindings from a module that you \nneed. If a module provides 10 API methods, but you only need two \nof them, some believe it wasteful to bring in the entire set of API \nbindings. \n\nOne benefit, besides code being more explicit, is that narrow \nimports make static analysis and error detection (accidentally using \nthe wrong binding name, for instance) more robust. \n\nOf course, that’s just the standard position influenced by ES6 design \nphilosophy; there’s nothing that requires adherence to that \napproach.","metadata":{"loc":{"lines":{"from":223047,"to":223068}}}}],["1826",{"pageContent":"Of course, that’s just the standard position influenced by ES6 design \nphilosophy; there’s nothing that requires adherence to that \napproach. \n\nMany developers would be quick to point out that such approaches \ncan be more tedious, requiring you to regularly revisit and update \nyour import statement(s) each time you realize you need something \nelse from a module. The trade-off is in exchange for convenience. \n\nIn that light, the preference might be to import everything from the \nmodule into a single namespace, rather than importing individual \nmembers, each directly into the scope. Fortunately, the import state¬ \nment has a syntax variation that can support this style of module \nconsumption, called namespace import. \n\nConsider a \"foo\" module exported as: \n\nexport function bar() { .. } \n\nexport var x = 42; \n\nexport function baz() { .. } \n\nYou can import that entire API to a single module namespace bind¬ \ning: \n\nimport * as foo from \"foo\"; \nfoo . ba r ();","metadata":{"loc":{"lines":{"from":223068,"to":223095}}}}],["1827",{"pageContent":"export var x = 42; \n\nexport function baz() { .. } \n\nYou can import that entire API to a single module namespace bind¬ \ning: \n\nimport * as foo from \"foo\"; \nfoo . ba r (); \n\n\n128 | Chapter 3: Organization \n\n\n\n\nfoo.x; \n\nfoo.bazQ; \n\n\n// 42 \n\n\n\nThe * as .. clause requires the * wildcard. In \nother words, you cannot do something like \ninport { bar, x } as foo from \"foo\" to \nbring in only part of the API but still bind to the \nfoo namespace. I would have liked something \nlike that, but for ES6 it’s all or nothing with the \nnamespace import. \n\n\nIf the module you’re importing with * as .. has a default export, it \nis named default in the namespace specified. You can additionally \nname the default import outside of the namespace binding, as a top- \nlevel identifier. Consider a \"world\" module exported as: \n\nexport default function foo() { .. } \nexport function bar() { .. } \nexport function baz() { .. } \n\nAnd this import: \n\nimport foofn, * as hello from \"world\"; \nfoofnQ;","metadata":{"loc":{"lines":{"from":223095,"to":223141}}}}],["1828",{"pageContent":"export default function foo() { .. } \nexport function bar() { .. } \nexport function baz() { .. } \n\nAnd this import: \n\nimport foofn, * as hello from \"world\"; \nfoofnQ; \n\nhello.default!); \nhello.bar (); \nhello.baz(); \n\nWhile this syntax is valid, it can be rather confusing that one \nmethod of the module (the default export) is bound at the top-level \nof your scope, whereas the rest of the named exports (and one called \ndefault) are bound as properties on a differently named (hello) \nidentifier namespace. \n\nAs I mentioned earlier, my suggestion would be to avoid designing \nyour module exports in this way, to reduce the chances that your \nmodule’s users will suffer these strange quirks. \n\nAll imported bindings are immutable and/or read-only. Consider \nthe previous import; all of these subsequent assignment attempts \nwill throw TypeErrors: \n\nimport foofn, * as hello from \"world\"; \n\nfoofn = 42; // (runtime) TypeError! \n\nhello.default = 42; // (runtime) TypeError! \n\n\nModules | 129","metadata":{"loc":{"lines":{"from":223141,"to":223175}}}}],["1829",{"pageContent":"import foofn, * as hello from \"world\"; \n\nfoofn = 42; // (runtime) TypeError! \n\nhello.default = 42; // (runtime) TypeError! \n\n\nModules | 129 \n\n\n\n\nhello.bar = 42; // (runtime) TypeError! \n\nhello.baz = 42; // (runtime) TypeError! \n\nRecall earlier in “Exporting API Members” on page 120 that we \ntalked about how the bar and baz bindings are bound to the actual \nidentifiers inside the \"world\" module. That means if the module \nchanges those values, hello.bar and hello.baz now reference the \nupdated values. \n\nBut the immutable/read-only nature of your local imported bind¬ \nings enforces that you cannot change them from the imported bind¬ \nings, hence the TypeErrors. That’s pretty important, because \nwithout those protections, your changes would end up affecting all \nother consumers of the module (remember: singleton), which could \ncreate some very surprising side effects!","metadata":{"loc":{"lines":{"from":223175,"to":223202}}}}],["1830",{"pageContent":"Moreover, though a module can change its API members from the \ninside, you should be very cautious of intentionally designing your \nmodules in that fashion. ES6 modules are intended to be static, so \ndeviations from that principle should be rare and should be carefully \nand verbosely documented. \n\n\n\nThere are module design philosophies where \nyou actually intend to let a consumer change the \nvalue of a property on your API, or module \nAPIs designed to be “extended” by having other \n“plug-ins” added to the API namespace. As we \njust asserted, ES6 module APIs should be \nthought of and designed as static and unchange¬ \nable, which strongly restricts and discourages \nthese alternative module design patterns. You \ncan get around these limitations by exporting a \nplain object, which of course can then be \nchanged at will. But be careful and think twice \nbefore going down that road.","metadata":{"loc":{"lines":{"from":223204,"to":223224}}}}],["1831",{"pageContent":"Declarations that occur as a result of an import are “hoisted” (see \nthe Scope & Closures title of this series). Consider: \n\nfoo( ); \n\nimport { foo } from \"foo\"; \n\nfoo() can run because not only did the static resolution of the \nimport .. statement figure out what foo is during compilation, but \n\n\n130 | Chapter 3: Organization \n\n\n\n\nit also “hoisted” the declaration to the top of the module’s scope, \nthus making it available throughout the module. \n\nFinally, the most basic form of the import looks like this: \n\nimport \"foo\"; \n\nThis form does not actually import any of the modules bindings \ninto your scope. It loads (if not already loaded), compiles (if not \nalready compiled), and evaluates (if not already run) the \"foo\" \nmodule.","metadata":{"loc":{"lines":{"from":223227,"to":223253}}}}],["1832",{"pageContent":"In general, that sort of import is probably not going to be terribly \nuseful. There may be niche cases where a modules definition has \nside effects (such as assigning things to the window/global object). \nYou could also envision using import \"foo\" as a sort of preload for \na module that may be needed later. \n\nCircular Module Dependency \n\nA imports B. B imports A. How does this actually work? \n\nI’ll state off the bat that designing systems with intentional circular \ndependency is generally something I try to avoid. That having been \nsaid, I recognize there are reasons people do this and it can solve \nsome sticky design situations. \n\nLet’s consider how ES6 handles this. First, module \"A\": \nimport bar from \"B\"; \n\nexport default function foo(x) { \n\nif (x > 10) return bar( x - 1 ); \nreturn x * 2 ; \n\n} \n\nNow, module \"B\": \n\nimport foo from \"A\"; \n\nexport default function bar(y) { \nif (y > 5) return foo( y / 2 ); \nreturn y * 3; \n\n}","metadata":{"loc":{"lines":{"from":223255,"to":223288}}}}],["1833",{"pageContent":"if (x > 10) return bar( x - 1 ); \nreturn x * 2 ; \n\n} \n\nNow, module \"B\": \n\nimport foo from \"A\"; \n\nexport default function bar(y) { \nif (y > 5) return foo( y / 2 ); \nreturn y * 3; \n\n} \n\nThese two functions, foo(.. ) and bar(..), would work as standard \nfunction declarations if they were in the same scope, because the \ndeclarations are “hoisted” to the whole scope and thus available to \neach other regardless of authoring order. \n\n\nModules | 131 \n\n\n\nWith modules, you have declarations in entirely different scopes, so \nES6 has to do extra work to help make these circular references \nwork. \n\nIn a rough conceptual sense, this is how circular import dependen¬ \ncies are validated and resolved: \n\n• If the \"A\" module is loaded first, the first step is to scan the file \nand analyze all the exports, so it can register all those bindings \navailable for import. Then it processes the import .. from \n\" B\", which signals that it needs to go fetch \" B\".","metadata":{"loc":{"lines":{"from":223288,"to":223323}}}}],["1834",{"pageContent":"• Once the engine loads \"B\", it does the same analysis of its \nexport bindings. When it sees the import .. from \"A\", it \nknows the API of \"A\" already, so it can verify the import is \nvalid. Now that it knows the \"B\" API, it can also validate the \nimport .. from \"B\" in the waiting \"A\" module. \n\nIn essence, the mutual imports, along with the static verification \nthat’s done to validate both import statements, virtually composes \nthe two separate module scopes (via the bindings), such that \nfoo(..) can call bar(..) and vice versa. This is symmetric to if they \nhad originally been declared in the same scope. \n\nNow let’s try using the two modules together. First, we’ll try \nfoo(..): \n\nimport foo from \"foo\"; \nfoo( 25 ); // 11 \n\nOr we can try ba r ( .. ): \n\nimport bar from \"bar\"; \n\nbar( 25 ); // 11.S","metadata":{"loc":{"lines":{"from":223325,"to":223347}}}}],["1835",{"pageContent":"Now let’s try using the two modules together. First, we’ll try \nfoo(..): \n\nimport foo from \"foo\"; \nfoo( 25 ); // 11 \n\nOr we can try ba r ( .. ): \n\nimport bar from \"bar\"; \n\nbar( 25 ); // 11.S \n\nBy the time either the foo(25) or bar(25) calls are executed, all the \nanalysis/compilation of all modules has completed. That means \nfoo( ..) internally knows directly about bar( ..) and bar( ..) inter¬ \nnally knows directly about foo(..). \n\nIf all we need is to interact with foo(. .), then we only need to \nimport the \"foo\" module. Likewise with bar(..) and the \"bar\" \nmodule. \n\nOf course, we can import and use both of them if we want to: \n\n\n1B2 | Chapter 3: Organization \n\n\n\n\nimport foo from \"foo\"; \nimport bar from \"bar\"; \n\n\nfoo( 25 ); // 11 \n\nbar( 25 ); // 11.5","metadata":{"loc":{"lines":{"from":223347,"to":223382}}}}],["1836",{"pageContent":"Of course, we can import and use both of them if we want to: \n\n\n1B2 | Chapter 3: Organization \n\n\n\n\nimport foo from \"foo\"; \nimport bar from \"bar\"; \n\n\nfoo( 25 ); // 11 \n\nbar( 25 ); // 11.5 \n\nThe static loading semantics of the import statement mean a \"foo\" \nand \"bar\" that mutually depend on each other via import will \nensure that both are loaded, parsed, and compiled before either of \nthem runs. So their circular dependency is statically resolved and \nthis works as youd expect. \n\nModule Loading \n\nWe asserted at the beginning of “Modules” on page 116 that the \nimport statement uses a separate mechanism, provided by the host¬ \ning environment (browser, Node.js, etc.), to actually resolve the \nmodule specifier string into some useful instruction for finding and \nloading the desired module. That mechanism is the system Module \nLoader.","metadata":{"loc":{"lines":{"from":223382,"to":223411}}}}],["1837",{"pageContent":"The default module loader provided by the environment will inter¬ \npret a module specifier as a URL if in the browser, and (generally) as \na local filesystem path if on a server such as Node.js. The default \nbehavior is to assume the loaded file is authored in the ES6 standard \nmodule format. \n\nMoreover, you will be able to load a module into the browser via an \nHTML tag, similar to how current script programs are loaded. At \nthe time of this writing, it’s not fully clear if this tag will be <scri.pt \ntype=\"module\"> or <module>. ES6 doesn’t control that decision, but \ndiscussions in the appropriate standards bodies are already well \nalong in parallel of ES6. \n\nWhatever the tag looks like, you can be sure that under the covers it \nwill use the default loader (or a customized one you’ve prespecified, \nas we’ll discuss in the next section).","metadata":{"loc":{"lines":{"from":223413,"to":223428}}}}],["1838",{"pageContent":"Whatever the tag looks like, you can be sure that under the covers it \nwill use the default loader (or a customized one you’ve prespecified, \nas we’ll discuss in the next section). \n\nJust like the tag you’ll use in markup, the module loader itself is not \nspecified by ES6. It is a separate, parallel standard controlled cur¬ \nrently by the WHATWG browser standards group. \n\nAt the time of this writing, the following discussions reflect an early \npass at the API design, and things are likely to change. \n\n\nModules | 133 \n\n\n\n\nLoading Modules Outside of Modules \n\nOne use for interacting directly with the module loader is if a non¬ \nmodule needs to load a module. Consider: \n\n// normal script loaded in browser via '<script>', \n\n// 'import' is illegal here \n\nReftect. Loader.lmport( \"foo\" ) // returns a promise for '\"foo\"' \n.then( function ( foo ){ \nfoo.bar(); \n\n} );","metadata":{"loc":{"lines":{"from":223428,"to":223458}}}}],["1839",{"pageContent":"// normal script loaded in browser via '<script>', \n\n// 'import' is illegal here \n\nReftect. Loader.lmport( \"foo\" ) // returns a promise for '\"foo\"' \n.then( function ( foo ){ \nfoo.bar(); \n\n} ); \n\nThe Reflect. Loader. import(..) utility imports the entire module \nonto the named parameter (as a namespace), just like the import * \nas foo .. namespace import we discussed earlier. \n\n\n\nThe Reflect. Loader. import(. .) utility returns \na promise that is fulfilled once the module is \nready. To import multiple modules, you can \ncompose promises from multiple \nReflect. Loader.import( ..) calls using \nPromise.all([ .. ]). For more information \nabout Promises, see “Promises” on page 147 in \nChapter 4.","metadata":{"loc":{"lines":{"from":223458,"to":223481}}}}],["1840",{"pageContent":"You can also use Reflect.Loader.import( ..) in a real module to \ndynamically/conditionally load a module, where import itself would \nnot work. You might, for instance, choose to load a module contain¬ \ning a polyfill for some ES7+ feature if a feature test reveals it’s not \ndefined by the current engine. \n\nFor performance reasons, you’ll want to avoid dynamic loading \nwhenever possible, as it hampers the ability of the JS engine to fire \noff early fetches from its static analysis. \n\nCustomized Loading \n\nAnother use for directly interacting with the module loader is if you \nwant to customize its behavior through configuration or even rede¬ \nfinition. \n\nAt the time of this writing, there’s a polyfill for the module loader \nAPI being developed. While details are scarce and highly subject to \nchange, we can explore what possibilities may eventually land. \n\n\n134 | Chapter 3: Organization","metadata":{"loc":{"lines":{"from":223484,"to":223505}}}}],["1841",{"pageContent":"134 | Chapter 3: Organization \n\n\n\n\nThe Reflect.Loader.import(. .) call may support a second argu¬ \nment for specifying various options to customize the import/load \ntask. For example: \n\nReftect. Loader.import( \"foo\", { address: \"/path/to/foo.js\" } ) \n.then( function ( foo ){ \n\n// \n\n} ) \n\nIt’s also expected that a customization will be provided (through \nsome means) for hooking into the process of loading a module, \nwhere a translation/transpilation could occur after load but before \nthe engine compiles the module. \n\nFor example, you could load something that’s not already an ES6- \ncompliant module format (e.g., CoffeeScript, TypeScript, Com- \nmonJS, AMD). Your translation step could then convert it to an \nES6-compliant module for the engine to then process. \n\nClasses","metadata":{"loc":{"lines":{"from":223505,"to":223531}}}}],["1842",{"pageContent":"Classes \n\nFrom nearly the beginning of JavaScript, syntax and development \npatterns have all strived (read: struggled) to put on a facade of sup¬ \nporting class-oriented development. With things like new and \ninstanceof and a .constructor property, who couldn’t help but be \nteased that JS had classes hidden somewhere inside its prototype \nsystem? \n\nOf course, JS “classes” aren’t nearly the same as classical classes. The \ndifferences are well documented, so I won’t belabor that point any \nfurther here. \n\n\n\nTo learn more about the patterns used in JS to \nfake “classes,” and an alternative view of proto¬ \ntypes called “delegation,” see the second half of \nthe this & Object Prototypes title of this series. \n\n\nclass","metadata":{"loc":{"lines":{"from":223531,"to":223552}}}}],["1843",{"pageContent":"class \n\nAlthough JS’s prototype mechanism doesn’t work like traditional \nclasses, that doesn’t stop the strong tide of demand on the language \nto extend the syntactic sugar so that expressing “classes” looks more \nlike real classes. Enter the ES6 class keyword and its associated \nmechanism. \n\n\nClasses | 135 \n\n\n\n\n\n\nThis feature is the result of a highly contentious and drawn-out \ndebate, and represents a smaller subset compromise from several \nstrongly opposed views on how to approach JS classes. Most devel¬ \nopers who want full classes in JS will find parts of the new syntax \nquite inviting, but will find important bits still missing. Don’t worry, \nthough. TC39 is already working on additional features to augment \nclasses in the post-ES6 timeframe. \n\nAt the heart of the new ES6 class mechanism is the class keyword, \nwhich identifies a block where the contents define the members of a \nfunctions prototype. Consider: \n\nclass Foo { \n\nconstructor^,b) { \nthis.x = a; \nthis.y = b; \n\n}","metadata":{"loc":{"lines":{"from":223552,"to":223586}}}}],["1844",{"pageContent":"class Foo { \n\nconstructor^,b) { \nthis.x = a; \nthis.y = b; \n\n} \n\ngimmeXY() { \n\nreturn this.x * this.y; \n\n} \n\n} \n\nSome things to note: \n\n• class Foo implies creating a (special) function of the name Foo, \nmuch like you did pre-ES6. \n\n• constructor ..) identifies the signature of that Foo(.. ) func¬ \ntion, as well as its body contents. \n\n• Class methods use the same “concise method” syntax available \nto object literals, as discussed in Chapter 2. This also includes \nthe concise generator form as discussed earlier in this chapter, \nas well as the ES5 getter/setter syntax. However, class methods \nare non-enumerable whereas object methods are by default enu¬ \nmerable. \n\n• Unlike object literals, there are no commas separating members \nin a class body! In fact, they’re not even allowed. \n\nThe class syntax definition in the previous snippet can be roughly \nthought of as this pre-ES6 equivalent, which probably will look fairly \nfamiliar to those who’ve done prototype-style coding before:","metadata":{"loc":{"lines":{"from":223586,"to":223622}}}}],["1845",{"pageContent":"function Foo(a,b) { \nthis.x = a; \nthis.y = b; \n\n\n1B6 | Chapter 3: Organization \n\n\n\n\n} \n\n\nFoo.prototype.glmmeXY = functlonQ { \nreturn this.x * thts.y; \n\n} \n\nIn either the pre-ES6 form or the new ES6 class form, this “class” \ncan now be instantiated and used just as youd expect: \n\nvar f = new Foo( 5, 15 ); \n\n\nf-x; \n\nf.y; \n\nf .gtmmeXYQ; \n\n\n// 5 \n// IS \n// 75 \n\n\nCaution! Though class Foo seems much like function Foo(), \nthere are important differences: \n\n• A Foo(..) call of class Foo must be made with new, as the pre- \nES6 option of Foo. call( obj ) will not work. \n\n• While function Foo is “hoisted” (see the Scope & Closures title \nof this series), class Foo is not; the extends .. clause specifies \nan expression that cannot be “hoisted.” So, you must declare a \nclass before you can instantiate it. \n\n• class Foo in the top global scope creates a lexical Foo identifier \nin that scope, but unlike function Foo does not create a global \nobject property of that name.","metadata":{"loc":{"lines":{"from":223624,"to":223673}}}}],["1846",{"pageContent":"• class Foo in the top global scope creates a lexical Foo identifier \nin that scope, but unlike function Foo does not create a global \nobject property of that name. \n\nThe established Instanceof operator still works with ES6 classes, \nbecause class just creates a constructor function of the same name. \nHowever, ES6 introduces a way to customize how Instanceof \nworks, using Symbol.haslnstance (see “Well-Known Symbols” on \npage 203 in Chapter 7). \n\nAnother way of thinking about class, which I find more conve¬ \nnient, is as a macro that is used to automatically populate a proto \ntype object. Optionally, it also wires up the [[Prototype]] \nrelationship if using extends (see the next section). \n\nAn ES6 class isn’t really an entity itself, but a meta concept that \nwraps around other concrete entities, such as functions and proper¬ \nties, and ties them together. \n\n\nClasses | 137","metadata":{"loc":{"lines":{"from":223673,"to":223693}}}}],["1847",{"pageContent":"An ES6 class isn’t really an entity itself, but a meta concept that \nwraps around other concrete entities, such as functions and proper¬ \nties, and ties them together. \n\n\nClasses | 137 \n\n\n\n\nIn addition to the declaration form, a class can \nalso be an expression, as in: var x = class Y \n{ .. This is primarily useful for passing a \ni class definition (technically, the constructor \nitself) as a function argument or assigning it to \nan object property. \n\nextends and super \n\nES6 classes also have syntactic sugar for establishing the [[Proto \ntype]] delegation link between two function prototypes—com¬ \nmonly mislabeled “inheritance” or confusingly labeled “prototype \ninheritance”—using the class-oriented familiar terminology \nextends: \n\nclass Bar extends Foo { \nconstructor^, b,c) { \nsuper( a, b ); \nthis.z = c; \n\n} \n\ngimmeXYZQ { \n\nreturn super. gimmeXYQ * this.z; \n\n} \n\n} \n\nvar b = new Bar( 5, 15, 25 ); \n\nb.x; // 5 \n\nb.y; // 15 \n\nb.z; // 25 \n\nb. gimmeXYZQ; // 1875","metadata":{"loc":{"lines":{"from":223693,"to":223741}}}}],["1848",{"pageContent":"} \n\ngimmeXYZQ { \n\nreturn super. gimmeXYQ * this.z; \n\n} \n\n} \n\nvar b = new Bar( 5, 15, 25 ); \n\nb.x; // 5 \n\nb.y; // 15 \n\nb.z; // 25 \n\nb. gimmeXYZQ; // 1875 \n\nA significant new addition is super, which is actually something not \ndirectly possible pre-ES6 (without some unfortunate hack trade¬ \noffs). In the constructor, super automatically refers to the “parent \nconstructor,” which in the previous example is Foo(..). In a \nmethod, it refers to the “parent object,” such that you can then make \na property/method access off it, such as super. gimmeXY(). \n\nBar extends Foo of course means to link the [[Prototype]] of \nBar.prototype to Foo.prototype. So, super in a method like gin \nmeXYZ() specifically means Foo.prototype, whereas super means \nFoo when used in the Bar constructor. \n\n\n\n138 | Chapter 3: Organization","metadata":{"loc":{"lines":{"from":223741,"to":223775}}}}],["1849",{"pageContent":"138 | Chapter 3: Organization \n\n\n\n\n\n\nsuper is not limited to class declarations. It \nalso works in object literals, in much the same \nway were discussing here. See “Object super” on \npage 47 in Chapter 2 for more information. \n\n\nThere Be super Dragons \n\nIt is not insignificant to note that super behaves differently depend¬ \ning on where it appears. In fairness, most of the time, that won’t be a \nproblem. But surprises await if you deviate from a narrow norm. \n\nThere may be cases where in the constructor you would want to ref¬ \nerence the Foo. prototype, such as to directly access one of its prop¬ \nerties/methods. However, super in the constructor cannot be used \nin that way; super.prototype will not work. super(..) means \nroughly to call new Foo(.. ), but isn’t actually a usable reference to \nFoo itself.","metadata":{"loc":{"lines":{"from":223775,"to":223799}}}}],["1850",{"pageContent":"Symmetrically, you may want to reference the Foo(..) function \nfrom inside a nonconstructor method, super.constructor will \npoint at Foo( ..) the function, but beware that this function can only \nbe invoked with new. new super .constructor! • • ) would be valid, \nbut it wouldn’t be terribly useful in most cases, because you can’t \nmake that call use or reference the current this object context, \nwhich is likely what you’d want. \n\nAlso, super looks like it might be driven by a function’s context just \nlike this— that is, that they’d both be dynamically bound. However, \nsuper is not dynamic like this is. When a constructor or method \nmakes a super reference inside it at declaration time (in the class \nbody), that super is statically bound to that specific class hierarchy \nand cannot be overridden (at least in ES6).","metadata":{"loc":{"lines":{"from":223801,"to":223814}}}}],["1851",{"pageContent":"What does that mean? It means that if you’re in the habit of taking a \nmethod from one “class” and “borrowing” it for another class by \noverriding its this, say with call(. .) or apply! • • ), that may very \nwell create surprises if the method you’re borrowing has a super in \nit. Consider this class hierarchy: \n\nclass ParentA { \n\nconstructor!) 1 this. Id = \"a\"; } \n\nfoo() { console. log( \"ParentA:\", this. id ); } \n\n1 \n\nclass ParentB { \n\n\nClasses | 139 \n\n\n\n\n\n\nconstructorQ { this. id = \"b\"; } \n\nfoo() { console. log( \"ParentB:\", this. id ); } \n\n} \n\nclass ChildA extends ParentA { \nfoo() { \n\nsuper. foo(); \n\nconsole. log( \"ChildA:\", this. id ); \n\n} \n\n} \n\nclass ChildB extends ParentB { \nfoo() { \n\nsuper. foo(); \n\nconsole. log( \"ChildB:\", this. id ); \n\n} \n\n} \n\nvar a = new ChildAQ; \n\na. foo(); // ParentA: a \n\n// ChildA: a \n\nvar b = new ChildBQ; // ParentB: b \n\nb. fooQ; // ChildB: b","metadata":{"loc":{"lines":{"from":223816,"to":223876}}}}],["1852",{"pageContent":"super. foo(); \n\nconsole. log( \"ChildB:\", this. id ); \n\n} \n\n} \n\nvar a = new ChildAQ; \n\na. foo(); // ParentA: a \n\n// ChildA: a \n\nvar b = new ChildBQ; // ParentB: b \n\nb. fooQ; // ChildB: b \n\nAll seems fairly natural and expected in this previous snippet. How¬ \never, if you try to borrow b. foo() and use it in the context of a—by \nvirtue of dynamic this binding, such borrowing is quite common \nand used in many different ways, including mixins most notably— \nyou may find this result an ugly surprise: \n\n// borrow 'b.foo()' to use in 'a' context \nb.foo.call( a ); // ParentB: a \n\n// ChildB: a \n\nAs you can see, the this. id reference was dynamically rebound so \nthat : a is reported in both cases instead of : b. But b.foo()’s \nsuper.foo() reference wasn’t dynamically rebound, so it still \nreported ParentB instead of the expected ParentA.","metadata":{"loc":{"lines":{"from":223876,"to":223908}}}}],["1853",{"pageContent":"Because b.fooQ references super, it is statically bound to the \nChildB/ParentB hierarchy and cannot be used against the ChildA/ \nParentA hierarchy. There is no ES6 solution to this limitation. \n\nsuper seems to work intuitively if you have a static class hierarchy \nwith no cross-pollination. But in all fairness, one of the main bene¬ \nfits of doing this-aware coding is exactly that sort of flexibility. Sim¬ \nply, class + super requires you to avoid such techniques. \n\n\n140 | Chapter 3: Organization \n\n\n\n\nThe choice boils down to narrowing your object design to these \nstatic hierarchies—class, extends, and super will be quite nice—or \ndropping all attempts to “fake” classes and instead embrace dynamic \nand flexible, classless objects and [ [Prototype] ] delegation (see the \nthis & Object Prototypes title of this series). \n\nSubclass Constructor","metadata":{"loc":{"lines":{"from":223910,"to":223931}}}}],["1854",{"pageContent":"Subclass Constructor \n\nConstructors are not required for classes or subclasses; a default \nconstructor is substituted in both cases if omitted. However, the \ndefault substituted constructor is different for a direct class versus \nan extended class. \n\nSpecifically, the default subclass constructor automatically calls the \nparent constructor, and passes along any arguments. In other words, \nyou could think of the default subclass constructor sort of like this: \n\nconstructor . . .args) { \nsuper( .. . args) ; \n\n} \n\nThis is an important detail to note. Not all class languages have the \nsubclass constructor automatically call the parent constructor. C++ \ndoes, but Java does not. But more importantly, in pre-ES6 classes, \nsuch automatic “parent constructor” calling does not happen. Be \ncareful when converting to the ES6 class if you’ve been relying on \nsuch calls not happening.","metadata":{"loc":{"lines":{"from":223931,"to":223952}}}}],["1855",{"pageContent":"Another perhaps surprising deviation/limitation of ES6 subclass \nconstructors: in a constructor of a subclass, you cannot access this \nuntil super(..) has been called. The reason is nuanced and compli¬ \ncated, but it boils down to the fact that the parent constructor is \nactually the one creating/initializing your instances this. Pre-ES6, it \nworks oppositely; the this object is created by the “subclass con¬ \nstructor,” and then you call a “parent constructor” with the context \nof the “subclass” this. \n\nLet’s illustrate. This works pre-ES6: \n\nfunction Foo() { \nthis. a = 1; \n\n} \n\nfunction Bar() { \nthis.b = 2; \n\nFoo.call( this ); \n\n} \n\n\nClasses | 141 \n\n\n\n// 'Bar' \"extends\" 'Foo' \n\nBar . prototype = Object. create( Foo.prototype ); \nBut this ES6 equivalent is not allowed: \nclass Foo { \n\nconstructor ) { this. a = 1; } \n\n} \n\n\nclass Bar extends Foo { \nconstructor ) { \nthls.b = 2; \n\nsuper( ); \n\n} \n\n} \n\n\n// not allowed before ~super()' \n\n// to fix swap these two statements","metadata":{"loc":{"lines":{"from":223954,"to":224006}}}}],["1856",{"pageContent":"constructor ) { this. a = 1; } \n\n} \n\n\nclass Bar extends Foo { \nconstructor ) { \nthls.b = 2; \n\nsuper( ); \n\n} \n\n} \n\n\n// not allowed before ~super()' \n\n// to fix swap these two statements \n\n\nIn this case, the fix is simple. Just swap the two statements in the \nsubclass Bar constructor. However, if you’ve been relying pre-ES6 on \nbeing able to skip calling the “parent constructor,” beware because \nthat won’t be allowed anymore. \n\nextending Natives \n\nOne of the most heralded benefits to the new class and extend \ndesign is the ability to (finally!) subclass the built-in natives, like \nArray. Consider: \n\nclass MyCoolArray extends Array { \nfirst() { return this[0]; } \nlast() { return this[this. length - 1]; } \n\n} \n\nvar a = new MyCoolArray( 1, 2, 3 ); \n\n\na.length; \na; \n\na.first(); \n\na.lastQ; \n\n\n// ^ \n\n// [1,2,3] \n\n// 1 \n// 3","metadata":{"loc":{"lines":{"from":224006,"to":224060}}}}],["1857",{"pageContent":"} \n\nvar a = new MyCoolArray( 1, 2, 3 ); \n\n\na.length; \na; \n\na.first(); \n\na.lastQ; \n\n\n// ^ \n\n// [1,2,3] \n\n// 1 \n// 3 \n\n\nPrior to ES6, a fake “subclass” of Array using manual object creation \nand linking to Array .prototype only partially worked. It missed out \non the special behaviors of a real array, such as the automatically \nupdating length property. ES6 subclasses should fully work with \n“inherited” and augmented behaviors as expected! \n\nAnother common pre-ES6 “subclass” limitation is with the Error \nobject, in creating custom error “subclasses.” When genuine Error \n\n\n142 | Chapter 3: Organization \n\n\n\nobjects are created, they automatically capture special stack infor¬ \nmation, including the line number and file where the error is cre¬ \nated. Pre-ES6 custom error “subclasses” have no such special \nbehavior, which severely limits their usefulness. \n\nES6 to the rescue: \n\nclass Oops extends Error { \nconstructor(reason) { \nthis. oops = reason; \n\n} \n\n} \n\n// later:","metadata":{"loc":{"lines":{"from":224060,"to":224110}}}}],["1858",{"pageContent":"ES6 to the rescue: \n\nclass Oops extends Error { \nconstructor(reason) { \nthis. oops = reason; \n\n} \n\n} \n\n// later: \n\nvar ouch = new Oops( \"I messed up!\" ); \nthrow ouch; \n\nThe ouch custom error object in this previous snippet will behave \nlike any other genuine error object, including capturing stack. \nThat’s a big improvement! \n\nnew.target \n\nES6 introduces a new concept called a meta property (see Chapter 7), \nin the form of new.target. \n\nIf that looks strange, it is; pairing a keyword with a . and a property \nname is definitely an out-of-the-ordinary pattern for JS. \n\nnew.target is a new “magical” value available in all functions, \nthough in normal functions it will always be undefined. In any con¬ \nstructor, new.target always points at the constructor that new \nactually directly invoked, even if the constructor is in a parent class \nand was delegated to by a super( ..) call from a child constructor. \nConsider: \n\nclass Foo { \n\nconstructor ) {","metadata":{"loc":{"lines":{"from":224110,"to":224146}}}}],["1859",{"pageContent":"class Foo { \n\nconstructor ) { \n\nconsole. log( \"Foo: \", new. target.name ); \n\n} \n\n} \n\nclass Bar extends Foo { \nconstructor) { \nsuper( ); \n\nconsole. log( \"Bar: \", new. target.name ); \n\n} \n\nbaz() { \n\nconsole. log( \"baz: \", new.target ); \n\n\nClasses | 143 \n\n\n\n} \n\n} \n\nvar a = new Foo(); \n\n// Foo: Foo \n\nvar b = new Bar(); \n\n// Foo: Bar <-- respects the 'new' call-site \n// Bar: Bar \n\nb.bazQ; \n\n// baz: undefined \n\nThe new. target meta property doesn’t have much purpose in class \nconstructors, except accessing a static property/method (see the next \nsection). \n\nIf new.target is undefined, you know the function was not called \nwith new. You can then force a new invocation if that’s necessary. \n\nstatic \n\nWhen a subclass Bar extends a parent class Foo, we already observed \nthat Bar.prototype is [ [Prototype] ]-linked to Foo. prototype. But \nadditionally, Bar() is [ [Prototype] ]-linked to Foo(). That part \nmay not have such an obvious reasoning.","metadata":{"loc":{"lines":{"from":224146,"to":224202}}}}],["1860",{"pageContent":"However, it’s quite useful in the case where you declare static \nmethods (not just properties) for a class, as these are added directly \nto that class’s function object, not to the function object’s prototype \nobject. Consider: \n\nclass Foo { \n\nstatic cool() { console. log( \"cool\" ); } \nwow() { console. log( \"wow\" ); } \n\n} \n\nclass Bar extends Foo { \nstatic awesomeQ { \nsuper. cool(); \nconsole. log( \"awesome\" ); \n\n} \n\nneat() { \n\nsuper. wow(); \nconsole. log( \"neat\" ); \n\n} \n\n} \n\nFoo.coolQ; // \"cool\" \n\n\n144 | Chapter 3: Organization \n\n\n\n\nBar.coolQ; \n\n// \n\n\"cool\" \n\nBar . awesome( ); \n\n// \n\n\"cool\" \n\n\n// \n\n\"awesone\" \n\nvar b = new Bar(); \n\nb.neat(); \n\n// \n\n\"wow\" \n\n\n// \n\n\"neat\" \n\nb.awesome; \n\n// undefined \n\nb.cool; \n\n// undefined \n\n\nBe careful not to get confused that static members are on the \nclass’s prototype chain. They’re actually on the dual/parallel chain \nbetween the function constructors. \n\nSymbol.species Constructor Getter","metadata":{"loc":{"lines":{"from":224204,"to":224283}}}}],["1861",{"pageContent":"Symbol.species Constructor Getter \n\nOne place where static can be useful is in setting the Symbol.spe \ncies getter (known internally in the specification as @@species) for \na derived (child) class. This capability allows a child class to signal to \na parent class what constructor should be used—when not intending \nthe child class’s constructor itself—if any parent class method needs \nto vend a new instance. \n\nFor example, many methods on Array create and return a new \nArray instance. If you define a derived class from Array, but you \nwant those methods to continue to vend actual Array instances \ninstead of from your derived class, this works: \n\nclass MyCoolArray extends Array { \n\n// force 'species' to be parent constructor \nstatic get [Symbol. species]() { return Array; } \n\n} \n\nvar a = new MyCoolArray( 1, 2, 3 ), \n\nb = a.map( function(v){ return v * 2; } ); \n\nb instanceof MyCoolArray; // false \n\nb instanceof Array; // true","metadata":{"loc":{"lines":{"from":224283,"to":224310}}}}],["1862",{"pageContent":"} \n\nvar a = new MyCoolArray( 1, 2, 3 ), \n\nb = a.map( function(v){ return v * 2; } ); \n\nb instanceof MyCoolArray; // false \n\nb instanceof Array; // true \n\nTo illustrate how a parent class method can use a child’s species dec¬ \nlaration somewhat like Array#map(.. ) is doing, consider: \n\nclass Foo { \n\n// defer 'species' to derived constructor \nstatic get [Symbol. species]() { return this; } \nspawn() { \n\nreturn new this.constructor[Symbol.species](); \n\n} \n\n\nClasses | 145 \n\n\n\n} \n\n\nclass Bar extends Foo { \n\n// force 'species' to be parent constructor \nstatic get [Symbol. species] () { return Foo; } \n\n\n} \n\n\nvar a = new Foo(); \nvar b = a.spawnQ; \nb instanceof Foo; \n\n\n// true \n\n\nvar x = new Bar(); \nvar y = x.spawnQ; \ny instanceof Bar; \ny instanceof Foo; \n\n\n// false \n// true","metadata":{"loc":{"lines":{"from":224310,"to":224365}}}}],["1863",{"pageContent":"} \n\n\nvar a = new Foo(); \nvar b = a.spawnQ; \nb instanceof Foo; \n\n\n// true \n\n\nvar x = new Bar(); \nvar y = x.spawnQ; \ny instanceof Bar; \ny instanceof Foo; \n\n\n// false \n// true \n\n\nThe parent class Symbol.species does return this to defer to any \nderived class, as youd normally expect. Bar then overrides to man¬ \nually declare Foo to be used for such instance creation. Of course, a \nderived class can still vend instances of itself using new this.con \nstructor(..). \n\n\nReview \n\n\nES6 introduces several new features that aid in code organization: \n\n• Iterators provide sequential access to data or operations. They \ncan be consumed by new language features like for..of \nand .... \n\n• Generators are locally pause/resume capable functions con¬ \ntrolled by an iterator. They can be used to programmatically \n(and interactively, through yield/next( ..) message passing) \ngenerate values to be consumed via iteration.","metadata":{"loc":{"lines":{"from":224365,"to":224405}}}}],["1864",{"pageContent":"• Modules allow private encapsulation of implementation details \nwith a publicly exported API. Module definitions are file-based, \nsingleton instances, and statically resolved at compile time. \n\n• Classes provide cleaner syntax around prototype-based coding. \nThe addition of super also solves tricky issues with relative ref¬ \nerences in the [[Prototype]] chain. \n\nThese new tools should be your first stop when trying to improve \nthe architecture of your JS projects by embracing ES6. \n\n\n146 | Chapter 3: Organization \n\n\n\n\nCHAPTER 4 \n\n\nAsync Flow Control \n\n\nIt’s no secret if you’ve written any significant amount of JavaScript \nthat asynchronous programming is a required skill. The primary \nmechanism for managing asynchrony has been the function call¬ \nback.","metadata":{"loc":{"lines":{"from":224407,"to":224433}}}}],["1865",{"pageContent":"However, ES6 adds a new feature that helps address significant \nshortcomings in the callbacks-only approach to async: Promises. In \naddition, we can revisit generators (from the previous chapter) and \nsee a pattern for combining the two that’s a major step forward in \nasync flow control programming in JavaScript. \n\nPromises \n\nLet’s clear up some misconceptions: Promises are not about replac¬ \ning callbacks. Promises provide a trustable intermediary—that is, \nbetween your calling code and the async code that will perform the \ntask—to manage callbacks. \n\nAnother way of thinking about a Promise is as an event listener, \nupon which you can register to listen for an event that lets you know \nwhen a task has completed. It’s an event that will only ever fire once, \nbut it can be thought of as an event nonetheless.","metadata":{"loc":{"lines":{"from":224435,"to":224451}}}}],["1866",{"pageContent":"Promises can be chained together, which can sequence a series of \nasychronously completing steps. Together with higher-level abstrac¬ \ntions like the all(. .) method (in classic terms, a “gate”) and the \nrace(. .) method (in classic terms, a “latch”), promise chains pro¬ \nvide an approximation of async flow control. \n\n\n147 \n\n\n\n\nYet another way of conceptualizing a Promise is that it’s a future \nvalue, a time-independent container wrapped around a value. This \ncontainer can be reasoned about identically whether the underlying \nvalue is final or not. Observing the resolution of a Promise extracts \nthis value once available. In other words, a Promise is said to be the \nasync version of a sync function’s return value.","metadata":{"loc":{"lines":{"from":224453,"to":224470}}}}],["1867",{"pageContent":"A Promise can only have one of two possible resolution outcomes: \nfulfilled or rejected, with an optional single value. If a Promise is ful¬ \nfilled, the final value is called a fulfillment. If it’s rejected, the final \nvalue is called a reason (as in, a “reason for rejection”). Promises can \nonly be resolved (fulfillment or rejection) once. Any further attempts \nto fulfill or reject are simply ignored. Thus, once a Promise is \nresolved, it’s an immutable value that cannot be changed. \n\nClearly, there are several different ways to think about what a \nPromise is. No single perspective is fully sufficient, but each pro¬ \nvides a separate aspect of the whole. The big takeaway is that they \noffer a significant improvement over callbacks-only async, namely \nthat they provide order, predictability, and trustability. \n\nMaking and Using Promises \n\nTo construct a promise instance, use the Promise(..) constructor: \n\nvar p = new Promise( function(resotve,reject){ \n\n// ■■ \n\n} );","metadata":{"loc":{"lines":{"from":224472,"to":224494}}}}],["1868",{"pageContent":"Making and Using Promises \n\nTo construct a promise instance, use the Promise(..) constructor: \n\nvar p = new Promise( function(resotve,reject){ \n\n// ■■ \n\n} ); \n\nThe two parameters provided to the Promise!..) constructor are \nfunctions, and are generally named resolve(..) and reject(..), \nrespectively. They are used as: \n\n• If you call reject(..), the promise is rejected, and if any value \nis passed to re ject(..), it is set as the reason for rejection. \n\n• If you call resolve (..) with no value, or any nonpromise value, \nthe promise is fulfilled. \n\n• If you call resolve (..) and pass another promise, this promise \nsimply adopts the state—whether immediate or eventual—of \nthe passed promise (either fulfillment or rejection). \n\nHere’s how you’d typically use a promise to refactor a callback- \nreliant function call. If you start out with an ajax(..) utility that \nexpects to be able to call an error-first style callback: \n\n\n148 | Chapter 4: Async Flow Control \n\n\n\n\nfunction ajax(url,cb) {","metadata":{"loc":{"lines":{"from":224494,"to":224528}}}}],["1869",{"pageContent":"148 | Chapter 4: Async Flow Control \n\n\n\n\nfunction ajax(url,cb) { \n\n// nake request, eventually call 'cb(..)' \n\n} \n\n// •• \n\najax( \"http://some.url.1\" , function handler(err,contents){ \nif (err) { \n\n// handle ajax error \n\n} \n\nelse { \n\n// handle 'contents' success \n\n} \n\n} ); \n\nYou can convert it to: \nfunction ajax(url) { \n\nreturn new Promise( function pr(resolve,reject){ \n\n// nake request, eventually call \n// either 'resolve(..)' or 'reject(..)' \n\n} ); \n\n} \n\n// •• \n\najax( \"http://some.url.l\" ) \n\n. then( \n\nfunction fulfilled(contents){ \n\n// handle 'contents' success \n\n}, \n\nfunction rejected(reason){ \n\n// handle ajax error reason \n\n} \n\n); \n\nPromises have a then(..) method that accepts one or two callback \nfunctions. The first function (if present) is treated as the handler to \ncall if the promise is fulfilled successfully. The second function (if \npresent) is treated as the handler to call if the promise is rejected \nexplicitly, or if any error/exception is caught during resolution.","metadata":{"loc":{"lines":{"from":224528,"to":224592}}}}],["1870",{"pageContent":"If one of the arguments is omitted or otherwise not a valid function \n—typically you’ll use null instead—a default placeholder equivalent \nis used. The default success callback passes its fulfillment value \nalong and the default error callback propagates its rejection reason \nalong. \n\nThe shorthand for calling then(null,handleRejection) is \ncatch(handleRejection). \n\n\nPromises | 149 \n\n\n\nBoth then(..) and catch(..) automatically construct and return \nanother promise instance, which is wired to receive the resolution \nfrom whatever the return value is from the original promises fulfill¬ \nment or rejection handler (whichever is actually called). Consider: \n\najax( \"http://sone.url.1\" ) \n\n. then( \n\nfunction fulftlled(contents){ \n\nreturn contents.tollpperCase(); \n\n}. \n\nfunction rejected(reason){ \nreturn \"DEFAULT VALUE\"; \n\n} \n\n) \n\n.then( function fulfilled(data){ \n\n// handle data from original promise's \n// handlers \n\n} );","metadata":{"loc":{"lines":{"from":224594,"to":224635}}}}],["1871",{"pageContent":"return contents.tollpperCase(); \n\n}. \n\nfunction rejected(reason){ \nreturn \"DEFAULT VALUE\"; \n\n} \n\n) \n\n.then( function fulfilled(data){ \n\n// handle data from original promise's \n// handlers \n\n} ); \n\nIn this snippet, we’re returning an immediate value from either f ul \nfilled(..) or rejected(..), which then is received on the next \nevent turn in the second then(. .)’s fulfilled(..). If we instead \nreturn a new promise, that new promise is subsumed and adopted \nas the resolution: \n\najax( \"http://sone.url.1\" ) \n\n. then( \n\nfunction fulfilled(contents){ \nreturn ajax( \n\n\"http://some.urL.2?v=\" + contents \n\n); \n\n}. \n\nfunction rejected(reason){ \nreturn ajax( \n\n\"http://backup.url.3?err=\" + reason \n\n); \n\n} \n\n) \n\n.then( function fulfilled(contents){ \n\n// 'contents' cones from the subsequent \n// 'ajax(..)' call, whichever it was \n\n} );","metadata":{"loc":{"lines":{"from":224635,"to":224688}}}}],["1872",{"pageContent":"\"http://backup.url.3?err=\" + reason \n\n); \n\n} \n\n) \n\n.then( function fulfilled(contents){ \n\n// 'contents' cones from the subsequent \n// 'ajax(..)' call, whichever it was \n\n} ); \n\nIt’s important to note that an exception (or rejected promise) in the \nfirst fulfilled(..) will not result in the first rejected(..) being \ncalled, as that handler only responds to the resolution of the first \noriginal promise. Instead, the second promise, which the second \nthen(..) is called against, receives that rejection. \n\n\n150 | Chapter 4: Async Flow Control \n\n\n\n\nIn this previous snippet, we are not listening for that rejection, \nwhich means it will be silently held onto for future observation. If \nyou never observe it by calling a then(..) or catch(..), then it will \ngo unhandled. Some browser developer consoles may detect these \nunhandled rejections and report them, but this is not reliably guar¬ \nanteed; you should always observe promise rejections.","metadata":{"loc":{"lines":{"from":224688,"to":224720}}}}],["1873",{"pageContent":"This was just a brief overview of Promise theory \nand behavior. For a much more in-depth explo¬ \nration, see Chapter 3 of the Async & Perfor¬ \nmance title of this series. \n\n\nThenables \n\nPromises are genuine instances of the Promise(..) constructor. \nHowever, there are promise-like objects called thenables that gener¬ \nally can interoperate with the Promise mechanisms. \n\nAny object (or function) with a then( ..) function on it is assumed \nto be a thenable. Any place where the Promise mechanisms can \naccept and adopt the state of a genuine promise, they can also han¬ \ndle a thenable. \n\nThenables are basically a general label for any promise-like value \nthat may have been created by some other system than the actual \nPromise( ..) constructor. In that perspective, a thenable is generally \nless trustable than a genuine Promise. Consider this misbehaving \nthenable, for example: \n\nvar th = { \n\nthen: function thener( fulfilled ) {","metadata":{"loc":{"lines":{"from":224724,"to":224749}}}}],["1874",{"pageContent":"var th = { \n\nthen: function thener( fulfilled ) { \n\n// call 'fulfilled(..)' once every 100ns forever \nsetlnterval( fulfilled, 100 ); \n\n} \n\n}; \n\nIf you received that thenable and chained it with th. then(.. ), youd \nlikely be surprised that your fulfillment handler is called repeatedly, \nwhen normal Promises are supposed to only ever be resolved once. \n\nGenerally, if you’re receiving what purports to be a promise or then- \nable back from some other system, you shouldn’t just trust it blindly. \nIn the next section, we’ll see a utility included with ES6 Promises \nthat helps address this trust concern. \n\n\nPromises | 151 \n\n\n\n\n\n\nBut to further understand the perils of this issue, consider that any \nobject in any piece of code that’s ever been defined to have a method \non it called then(. .) can be potentially confused as a thenable—if \nused with Promises, of course—regardless of if that thing was ever \nintended to even remotely be related to Promise-style async coding.","metadata":{"loc":{"lines":{"from":224749,"to":224781}}}}],["1875",{"pageContent":"Prior to ES6, there was never any special reservation made on meth¬ \nods called then( ..), and as you can imagine there’s been at least a \nfew cases where that method name has been chosen prior to Prom¬ \nises ever showing up on the radar screen. The most likely case of \nmistaken thenable will be async libraries that use then(..) but \nwhich are not strictly Promises-compliant—there are several out in \nthe wild. \n\nThe onus will be on you to guard against directly using values with \nthe Promise mechanism that would be incorrectly assumed to be a \nthenable. \n\nPromise API \n\nThe Promise API also provides some static methods for working \nwith Promises. \n\nPromise, resolvef ..) creates a promise resolved to the value \npassed in. Let’s compare how it works to the more manual approach: \n\nvar pi = Promise. resol ve( 42 ); \n\nvar p2 = new Promise( function pr(resolve){ \nresolve( 42 ); \n\n} ); \n\npi and p2 will have essentially identical behavior. The same goes for \nresolving with a promise:","metadata":{"loc":{"lines":{"from":224783,"to":224811}}}}],["1876",{"pageContent":"var p2 = new Promise( function pr(resolve){ \nresolve( 42 ); \n\n} ); \n\npi and p2 will have essentially identical behavior. The same goes for \nresolving with a promise: \n\nvar theP = ajax( .. ); \n\nvar pi = Promise. resol ve( theP ); \n\nvar p2 = new Promise( function pr(resolve){ \nresolve( theP ); \n\n} ); \n\n\n152 | Chapter 4: Async Flow Control \n\n\n\n\nPromise. resolve(..) is the solution to the \nthenable trust issue raised in the previous sec¬ \ntion. Any value that you are not already certain \nk is a trustable promise—even if it could be an \nimmediate value—can be normalized by passing \nit to Promise. resolve(..). If the value is \nalready a recognizable promise or thenable, its \nstate/resolution will simply be adopted, insulat¬ \ning you from misbehavior. If it’s instead an \nimmediate value, it will be “wrapped” in a genu¬ \nine promise, thereby normalizing its behavior to \nbe async.","metadata":{"loc":{"lines":{"from":224811,"to":224845}}}}],["1877",{"pageContent":"Promise, reject(..) creates an immediately rejected promise, the \nsame as its Promise(..) constructor counterpart: \n\nvar pi = Promise. reject( \"Oops\" ); \n\nvar p2 = new Promise! function pr(resolve, reject){ \nreject! \"Oops\" ); \n\n} ); \n\nWhile resolve(..) and Promise, resolve!..) can accept a \npromise and adopt its state/resolution, reject!..) and \nPromise.reject!. •) do not differentiate what value they receive. \nSo, if you reject with a promise or thenable, the promise/thenable \nitself will be set as the rejection reason, not its underlying value. \n\nPromise. all([ .. ]) accepts an array of one or more values (e.g., \nimmediate values, promises, thenables). It returns a promise back \nthat will be fulfilled if all the values fulfill, or reject immediately once \nthe first of any of them rejects. \n\nStarting with these values/promises: \n\nvar pi = Promise. resolve! 42 ); \nvar p2 = new Promise! function pr(resolve)! \nsetTimeout( function! ){ \nresolve! 43 ); \n\n}, 100 ); \n\n} ); \n\nvar v3 = 44;","metadata":{"loc":{"lines":{"from":224847,"to":224879}}}}],["1878",{"pageContent":"Starting with these values/promises: \n\nvar pi = Promise. resolve! 42 ); \nvar p2 = new Promise! function pr(resolve)! \nsetTimeout( function! ){ \nresolve! 43 ); \n\n}, 100 ); \n\n} ); \n\nvar v3 = 44; \n\nvar p4 = new Promise! function pr( resolve, reject)! \nsetTimeout( function!)! \n\nreject! \"Oops\" ); \n\n}, 10 ); \n\n} ); \n\n\n\nPromises | 153 \n\n\n\n\nLet’s consider how Promise. all( [ .. ]) works with combinations \nof those values: \n\nPromise. alt( [pl,p2,v3] ) \n\n.then( function fulfilled(vals){ \n\nconsole. log( vals ); // [42,43,44] \n\n} ); \n\nPromise. alt( [pl,p2,v3,p4] ) \n\n. then( \n\nfunction fulfilled(vals){ \n\n// never gets here \n\n}, \n\nfunction rejected(reason){ \n\nconsole. log( reason ); // Oops \n\n} \n\n); \n\nWhile Promise.all([ .. ]) waits for all fulfillments (or the first \nrejection), Promise. race( [ .. ]) waits only for either the first ful¬ \nfillment or rejection. Consider: \n\n// NOTE: re-setup all test values to \n// avoid timing issues misleading you! \n\nPromise. race( [p2,pl,v3] )","metadata":{"loc":{"lines":{"from":224879,"to":224944}}}}],["1879",{"pageContent":"// NOTE: re-setup all test values to \n// avoid timing issues misleading you! \n\nPromise. race( [p2,pl,v3] ) \n\n.then( function fulfilled(val){ \n\nconsole. log( val ); // 42 \n\n} ); \n\nPromise. race( [p2,p4] ) \n\n. then( \n\nfunction fulfilled(val){ \n\n// never gets here \n\n}, \n\nfunction rejected(reason){ \n\nconsole. log( reason ); // Oops \n\n} \n\n); \n\n\n\nWhile Promise.all ([]) will fulfill right away \n(with no values), Promise. race([]) will hang \nforever. This is a strange inconsistency, and \nspeaks to the suggestion that you should never \nuse these methods with empty arrays. \n\n\n154 | Chapter 4: Async Flow Control \n\n\n\n\n\nGenerators + Promises \n\nIt is possible to express a series of promises in a chain to represent \nthe async flow control of your program. Consider: \n\nstepl() \n\n. then( \nstep2, \nstep2Failed \n\n) \n\n. then( \n\nfunction(msg) { \n\nreturn Promise. all( [ \nstep3a( msg ), \nstep3b( msg ), \nstep3c( msg ) \n\n1 ) \n\n} \n\n) \n\n. then(step4) ;","metadata":{"loc":{"lines":{"from":224944,"to":225016}}}}],["1880",{"pageContent":"stepl() \n\n. then( \nstep2, \nstep2Failed \n\n) \n\n. then( \n\nfunction(msg) { \n\nreturn Promise. all( [ \nstep3a( msg ), \nstep3b( msg ), \nstep3c( msg ) \n\n1 ) \n\n} \n\n) \n\n. then(step4) ; \n\nHowever, there’s a much better option for expressing async flow \ncontrol, and it will probably be much more preferable in terms of \ncoding style than long promise chains. We can use what we learned \nin Chapter 3 about generators to express our async flow control. \n\nThe important pattern to recognize: a generator can yield a promise, \nand that promise can then be wired to resume the generator with its \nfulfillment value. \n\nConsider the previous snippet’s async flow control expressed with a \ngenerator: \n\nfunction *main() { \n\nvar ret = yield stepl(); \n\ntry { \n\nret = yield step2( ret ); \n\n} \n\ncatch (err) { \n\nret = yield step2Failed( err ); \n\n} \n\nret = yield Promise. all( [ \nstep3a( ret ), \nstep3b( ret ), \nstep3c( ret ) \n\n1 ); \n\n\nGenerators + Promises | 155 \n\n\n\n\nyield step4( ret ); \n\n}","metadata":{"loc":{"lines":{"from":225016,"to":225084}}}}],["1881",{"pageContent":"catch (err) { \n\nret = yield step2Failed( err ); \n\n} \n\nret = yield Promise. all( [ \nstep3a( ret ), \nstep3b( ret ), \nstep3c( ret ) \n\n1 ); \n\n\nGenerators + Promises | 155 \n\n\n\n\nyield step4( ret ); \n\n} \n\nOn the surface, this snippet may seem more verbose than the \npromise chain equivalent in the earlier snippet. However, it offers a \nmuch more attractive—and more importantly, a more understanda¬ \nble and reason-able—synchronous-looking coding style (with = \nassignment of “return” values, etc.) That’s especially true in that \ntry. .catch error handling can be used across those hidden async \nboundaries. \n\nWhy are we using Promises with the generator? It’s certainly possi¬ \nble to do async generator coding without Promises.","metadata":{"loc":{"lines":{"from":225084,"to":225116}}}}],["1882",{"pageContent":"Why are we using Promises with the generator? It’s certainly possi¬ \nble to do async generator coding without Promises. \n\nPromises are a trustable system that uninverts the inversion of con¬ \ntrol of normal callbacks or thunks (see the Async & Performance title \nof this series). So, combining the trustability of Promises and the \nsynchronicity of code in generators effectively addresses all the \nmajor deficiencies of callbacks. Also, utilities like \nPromise. all( [ .. ]) are a nice, clean way to express concurrency \nat a generator’s single yield step. \n\nSo how does this magic work? We’re going to need a runner that can \nrun our generator, receive a yielded promise, and wire it up to \nresume the generator with either the fulfillment success value, or \nthrow an error into the generator with the rejection reason.","metadata":{"loc":{"lines":{"from":225116,"to":225130}}}}],["1883",{"pageContent":"Many async-capable utilities/libraries have such a “runner”; for \nexample, Q.spawn(..) and my asynquence’s runner(..) plug-in. \nBut here’s a stand-alone runner to illustrate how the process works: \n\nfunction run(gen) { \n\nvar args = [] .slice.call( arguments, 1), it; \n\nit = gen.apply( this, args ); \n\nreturn Promise. resolve? ) \n\n.then? function handleNext(value){ \nvar next = it.next? value ); \n\nreturn (function handleResult(next){ \nif (next.done) { \n\nreturn next.value; \n\n} \n\nelse { \n\nreturn Promise. resolve? next.value ) \n\n. then( \n\nhandleNext, \n\n\n156 | Chapter 4: Async Flow Control \n\n\n\n\n} \n\n\n} \n\n})( next ); \n\n} ); \n\n\n); \n\n\nfunction handleErr(err) { \nreturn Promise . resolve( \nit.throw( err ) \n\n) \n\n.then( handleResult );","metadata":{"loc":{"lines":{"from":225132,"to":225187}}}}],["1884",{"pageContent":"handleNext, \n\n\n156 | Chapter 4: Async Flow Control \n\n\n\n\n} \n\n\n} \n\n})( next ); \n\n} ); \n\n\n); \n\n\nfunction handleErr(err) { \nreturn Promise . resolve( \nit.throw( err ) \n\n) \n\n.then( handleResult ); \n\n\n\nFor a more prolifically commented version of \nthis utility, see the Async & Performance title of \nthis series. Also, the run utilities provided with \nvarious async libraries are often more powerful/ \ncapable than what we’ve shown here. For exam¬ \nple, asynquence’s runner(..) can handle \nyielded promises, sequences, thunks, and \nimmediate (nonpromise) values, giving you ulti¬ \nmate flexibility. \n\n\nSo now running *rnain() as listed in the earlier snippet is as easy as: \n\nrun( main ) \n\n. then( \n\nfunction fulfilled(){ \n\n// '*nain()' completed successfully \n\n}, \n\nfunction rejected(reason){ \n\n// Oops, something went wrong \n\n} \n\n);","metadata":{"loc":{"lines":{"from":225187,"to":225247}}}}],["1885",{"pageContent":"run( main ) \n\n. then( \n\nfunction fulfilled(){ \n\n// '*nain()' completed successfully \n\n}, \n\nfunction rejected(reason){ \n\n// Oops, something went wrong \n\n} \n\n); \n\nEssentially, anywhere that you have more than two asynchronous \nsteps of flow control logic in your program, you can and should use \na promise-yielding generator driven by a run utility to express the \nflow control in a synchronous fashion. This will make for much eas¬ \nier to understand and maintain code. \n\nThis yield-a-promise-resume-the-generator pattern is going to be so \ncommon and so powerful, the next version of JavaScript is almost \ncertainly going to introduce a new function type that will do it auto¬ \nmatically without needing the run utility. We’ll cover async func \ntions (as they’re expected to be called) in Chapter 8. \n\n\nGenerators + Promises | 157 \n\n\n\n\n\n\n\nReview","metadata":{"loc":{"lines":{"from":225247,"to":225286}}}}],["1886",{"pageContent":"Generators + Promises | 157 \n\n\n\n\n\n\n\nReview \n\nAs JavaScript continues to mature and grow in its widespread adop¬ \ntion, asynchronous programming is more and more of a central \nconcern. Callbacks are not fully sufficient for these tasks, and totally \nfall down the more sophisticated the need. \n\nThankfully, ES6 adds Promises to address one of the major short¬ \ncomings of callbacks: lack of trust in predictable behavior. Promises \nrepresent the future completion value from a potentially async task, \nnormalizing behavior across sync and async boundaries. \n\nBut it’s the combination of Promises with generators that fully real¬ \nizes the benefits of rearranging our async flow control code to de- \nemphasize and abstract away that ugly callback soup (aka “hell”). \n\nRight now, we can manage these interactions with the aide of vari¬ \nous async libraries’ runners, but JavaScript is eventually going to \nsupport this interaction pattern with dedicated syntax alone!","metadata":{"loc":{"lines":{"from":225286,"to":225312}}}}],["1887",{"pageContent":"158 | Chapter 4: Async Flow Control \n\n\n\nCHAPTER 5 \n\n\nCollections \n\n\nStructured collection and access to data is a critical component of \njust about any JS program. From the beginning of the language up \nto this point, the array and the object have been our primary mecha¬ \nnism for creating data structures. Of course, many higher-level data \nstructures have been built on top of these, as user-land libraries. \n\nAs of ES6, some of the most useful (and performance-optimizing!) \ndata structure abstractions have been added as native components of \nthe language. \n\nWe’ll start this chapter first by looking at TypedArrays, which were \ntechnically contemporary to ES5 efforts several years ago, but only \nstandardized as companions to WebGL and not JavaScript itself. As \nof ES6, these have been adopted directly by the language specifica¬ \ntion, which gives them first-class status.","metadata":{"loc":{"lines":{"from":225315,"to":225339}}}}],["1888",{"pageContent":"Maps are like objects (key/value pairs), but instead of just a string \nfor the key, you can use any value—even another object or map! Sets \nare similar to arrays (lists of values), but the values are unique; if you \nadd a duplicate, it’s ignored. There are also weak (in relation to \nmemory/garbage collection) counterparts: WeakMap and WeakSet. \n\nTypedArrays \n\nAs we cover in the Types & Grammar title of this series, JS does have \na set of built-in types, like number and string. It’d be tempting to \nlook at a feature named “typed array” and assume it means an array \nof a specific type of values, like an array of only strings. \n\n\n159","metadata":{"loc":{"lines":{"from":225341,"to":225355}}}}],["1889",{"pageContent":"159 \n\n\n\n\nHowever, typed arrays are really more about providing structured \naccess to binary data using array-like semantics (indexed access, \netc.). The “type” in the name refers to a “view” layered on type of the \nbucket of bits, which is essentially a mapping of whether the bits \nshould be viewed as an array of 8-bit signed integers, 16-bit signed \nintegers, and so on. \n\nHow do you construct such a bit-bucket? It’s called a “buffer,” and \nyou construct it most directly with the ArrayBuffer( ..) construc¬ \ntor: \n\n\nvar buf = new ArrayBuffer( 32 ); \n\nbuf . byteLength; // 32 \n\nbuf is now a binary buffer that is 32-bytes long (256-bits), that’s pre¬ \ninitialized to all 0s. A buffer by itself doesn’t really allow you any \ninteraction exception for checking its byteLength property. \n\n\n\nSeveral web platform features use or return \narray buffers, such as FileReader#readAsArray \nBuffer(..), XMLHttpRequest#send( ..), and \nInageData (canvas data).","metadata":{"loc":{"lines":{"from":225355,"to":225385}}}}],["1890",{"pageContent":"Several web platform features use or return \narray buffers, such as FileReader#readAsArray \nBuffer(..), XMLHttpRequest#send( ..), and \nInageData (canvas data). \n\n\nBut on top of this array buffer, you can then layer a “view,” which \ncomes in the form of a typed array. Consider: \n\nvar arr = new Uintl6Array( buf ); \n\narr.Length; // 16 \n\narr is a typed array of 16-bit unsigned integers mapped over the \n256-bit buf buffer, meaning you get 16 elements. \n\nEndianness \n\nIt’s very important to understand that the arr is mapped using the \nendian-setting (big-endian or little-endian) of the platform the JS is \nrunning on. This can be an issue if the binary data is created with \none endianness but interpreted on a platform with the opposite \nendianness. \n\nEndian means if the low-order byte (collection of 8-bits) of a multi¬ \nbyte number—such as the 16-bit unsigned ints we created in the ear¬ \nlier snippet—is on the right or the left of the number’s bytes. \n\n\n160 | Chapter 5: Collections","metadata":{"loc":{"lines":{"from":225385,"to":225414}}}}],["1891",{"pageContent":"160 | Chapter 5: Collections \n\n\n\n\n\nFor example, let’s imagine the base-10 number 3085, which takes 16- \nbits to represent. If you have just one 16-bit number container, it’d \nbe represented in binary as 0000110000001101 (hexadecimal 0c0d) \nregardless of endianness. \n\nBut if 3085 was represented with two 8-bit numbers, the endianness \nwould significantly affect its storage in memory: \n\n• 0000110000001101 / 0c0d (big-endian) \n\n. 0000110100001100 / 0d0c (little-endian) \n\nIf you received the bits of 3085 as 0000110100001100 from a little- \nendian system, but you layered a view on top of it in a big-endian \nsystem, you’d instead see value 3340 (base-10) and 0d0c (base-16). \n\nLittle-endian is the most common representation on the Web these \ndays, but there are definitely browsers where that’s not true. It’s \nimportant that you understand the endianness of both the producer \nand consumer of a chunk of binary data.","metadata":{"loc":{"lines":{"from":225414,"to":225439}}}}],["1892",{"pageContent":"From MDN, here’s a quick way to test the endianness of your Java¬ \nScript: \n\nvar littleEndian = (function! ) { \n\nvar buffer = new ArrayBuffer( 2 ); \n\nnew DataView( buffer ).setlntl6( 0, 256, true ); \n\nreturn new Intl6Array( buffer )[0] === 256; \n\n})(); \n\nlittleEndian will be true or false; for most browsers, it should \nreturn true. This test uses DataView(. .), which allows more low- \nlevel, fine-grained control over accessing (setting/getting) the bits \nfrom the view you layer over the buffer. The third parameter of the \nsetlntl6( ..) method in the previous snippet is for telling the Data \nView what endianness you’re wanting it to use for that operation. \n\n\nTyped Arrays | 161","metadata":{"loc":{"lines":{"from":225441,"to":225462}}}}],["1893",{"pageContent":"Typed Arrays | 161 \n\n\n\n\nDo not confuse endianness of underlying binary \nstorage in array buffers with how a given num¬ \nber is represented when exposed in a JS pro¬ \ngram. For example, (3085). toString(2) \nreturns \"110000001101\", which with an \nassumed leading four \"0\"s appears to be the big- \nendian representation. In fact, this representa¬ \ntion is based on a single 16-bit view, not a view \nof two 8-bit bytes. The DataView test above is \nthe best way to determine endianness for your JS \nenvironment. \n\n\nMultiple Views \n\nA single buffer can have multiple views attached to it, such as: \n\nvar buf = new ArrayBuffer( 2 ); \n\nvar vlew8 = new Ulnt8Array( buf ); \nvar vlewl6 = new Uintl6Array( buf ); \n\n\nviewl6[0] = 3085; \n\nview8[0]; // 13 \n\nview8[l]; // 12 \n\nvlew8[0].toStrlng( 16 ); // \"d\" \n\nview8[l].toStrlng( 16 ); // \"c\" \n\n\n// swap (as if endian!) \nvar tmp = vlew8[0]; \nview8[0] = vlew8[l]; \nview8[l] = tmp; \n\nvlewl6[0] ; // 3340","metadata":{"loc":{"lines":{"from":225462,"to":225506}}}}],["1894",{"pageContent":"view8[l]; // 12 \n\nvlew8[0].toStrlng( 16 ); // \"d\" \n\nview8[l].toStrlng( 16 ); // \"c\" \n\n\n// swap (as if endian!) \nvar tmp = vlew8[0]; \nview8[0] = vlew8[l]; \nview8[l] = tmp; \n\nvlewl6[0] ; // 3340 \n\nThe typed array constructors have multiple signature variations. \nWe’ve shown so far only passing them an existing buffer. However, \nthat form also takes two extra parameters: byteOffset and length. \nIn other words, you can start the typed array view at a location other \nthan 0 and you can make it span less than the full length of the \nbuffer. \n\nIf the buffer of binary data includes data in nonuniform size/loca¬ \ntion, this technique can be quite useful. \n\nFor example, consider a binary buffer that has a 2-byte number (aka \n“word”) at the beginning, followed by two 1-byte numbers, followed \n\n\n162 | Chapter 5: Collections \n\n\n\n\nby a 32-bit floating-point number. Here’s how you can access that \ndata with multiple views on the same buffer, offsets, and lengths:","metadata":{"loc":{"lines":{"from":225506,"to":225540}}}}],["1895",{"pageContent":"162 | Chapter 5: Collections \n\n\n\n\nby a 32-bit floating-point number. Here’s how you can access that \ndata with multiple views on the same buffer, offsets, and lengths: \n\nvar first = new Uintl6Array( buf, 0, 2 )[0], \nsecond = new Uint8Array( buf, 2, 1 )[0], \nthird = new Uint8Array( buf, 3, 1 )[0], \nfourth = new Ftoat32Array( buf, 4, 4 )[0]; \n\nTyped Array Constructors \n\nIn addition to the (buffer,[offset, [length]]) form examined \nin the previous section, typed array constructors also support these \nforms: \n\n• [constructor\\] (length): Creates a new view over a new buffer \nof length bytes \n\n• [constructor!] (typedArr): Creates a new view and buffer, and \ncopies the contents from the typedArr view \n\n• [constructor!] (ob j): Creates a new view and buffer, and iterates \nover the array-like or object ob j to copy its contents \n\nThe following typed array constructors are available as of ES6: \n\n• Int8Array (8-bit signed integers), Uint8Array (8-bit unsigned \nintegers)","metadata":{"loc":{"lines":{"from":225540,"to":225571}}}}],["1896",{"pageContent":"The following typed array constructors are available as of ES6: \n\n• Int8Array (8-bit signed integers), Uint8Array (8-bit unsigned \nintegers) \n\n— Uint8ClampedArray (8-bit unsigned integers, each value \nclamped on setting to the 0-255 range) \n\n• Intl6Array (16-bit signed integers), Uintl6Array (16-bit \n\nunsigned integers) \n\n• Int32Array (32-bit signed integers), Uint32Array (32-bit \n\nunsigned integers) \n\n• Float32Array (32-bit floating point, IEEE-754) \n\n• Float64Array (64-bit floating point, IEEE-754) \n\nInstances of typed array constructors are almost the same as regular \nnative arrays. Some differences include having a fixed length and the \nvalues all being of the same “type.” \n\nHowever, they share most of the same prototype methods. As such, \nyou likely will be able to use them as regular arrays without needing \nto convert. \n\n\nTyped Arrays | 163 \n\n\n\nFor example: \n\nvar a = new Int32Array( 3 ); \na [0] = 10; \na [ 1 ] = 20; \na [ 2 ] = 30; \n\na.map( function(v){ \nconsole. log( v );","metadata":{"loc":{"lines":{"from":225571,"to":225612}}}}],["1897",{"pageContent":"Typed Arrays | 163 \n\n\n\nFor example: \n\nvar a = new Int32Array( 3 ); \na [0] = 10; \na [ 1 ] = 20; \na [ 2 ] = 30; \n\na.map( function(v){ \nconsole. log( v ); \n\n} ); \n\n// 10 20 30 \n\na.join( ); \n\n// \"10-20-30\" \n\n\n\nYou can’t use certain Array.prototype methods \nwith TypedArrays that don’t make sense, such as \nthe mutators (splice(..), push(..), etc.) and \nconcat(..). \n\n\nBe aware that the elements in TypedArrays really are constrained to \nthe declared bit sizes. If you have a Uint8Array and try to assign \nsomething larger than an 8 -bit value into one of its elements, the \nvalue wraps around so as to stay within the bit length. \n\nThis could cause problems if you were trying to, for instance, square \nall the values in a TypedArray. Consider: \n\nvar a = new Uint8Array( 3 ); \na[0] = 10; \na [ 1 ] = 20; \na [ 2 ] = 30; \n\nvar b = a.map( function(v){ \nreturn v * v; \n\n} ); \n\nb; // [100, 144, 132]","metadata":{"loc":{"lines":{"from":225612,"to":225660}}}}],["1898",{"pageContent":"var a = new Uint8Array( 3 ); \na[0] = 10; \na [ 1 ] = 20; \na [ 2 ] = 30; \n\nvar b = a.map( function(v){ \nreturn v * v; \n\n} ); \n\nb; // [100, 144, 132] \n\nThe 20 and 30 values, when squared, resulted in bit overflow. To get \naround such a limitation, you can use the TypedArray#f rom(..) \nfunction: \n\nvar a = new Uint8Array( 3 ); \na [0] = 10; \na [ 1 ] = 20; \na [ 2 ] = 30; \n\nvar b = Uintl6Array.fropi( a, function(v){ \n\n\n164 | Chapter 5: Collections \n\n\n\n\n\n\nreturn v * v; \n\n} ); \n\nb; // [100, 400, 900] \n\nSee “Array.from(..) Static Function” on page 177 in Chapter 6 for \nmore information about the Array .from(..) that is shared with \nTypedArrays. Specifically, “Mapping” on page 179 explains the map¬ \nping function accepted as its second argument. \n\nOne interesting behavior to consider is that TypedArrays have a \nsort(..) method much like regular arrays, but this one defaults to \nnumeric sort comparisons instead of coercing values to strings for \nlexicographic comparison. For example:","metadata":{"loc":{"lines":{"from":225660,"to":225705}}}}],["1899",{"pageContent":"var a = [ 10, 1, 2, ]; \n\na. sort(); // [1,10,2] \n\nvar b = new Uint8Array( [ 10, 1, 2 ] ); \n\nb. sort(); // [1,2,10] \n\nThe TypedArray#sort(..) takes an optional compare function \nargument just like Array#sort(..), which works in exactly the \nsame way. \n\nMaps \n\nIf you have a lot of JS experience, you know that objects are the pri¬ \nmary mechanism for creating unordered key/value-pair data struc¬ \ntures, otherwise known as maps. However, the major drawback with \nobjects-as-maps is the inability to use a nonstring value as the key. \n\nFor example, consider: \n\nvar m = {}; \n\nvar x = { td: 1 }, \ny = { id: 2 }; \n\nm[x] = \"foo\"; \nm [ y ] = \"bar\"; \n\nm[x]; \n\nn[y] ; \n\nWhat’s going on here? The two objects x and y both stringify to \n\" [object Object]\", so only that one key is being set in m. \n\n\n// \"bar \n// \"bar \n\n\nMaps | 165 \n\n\n\n\nSome have implemented fake maps by maintaining a parallel array \nof non-string keys alongside an array of the values, such as: \n\nvar keys = [], vats = [];","metadata":{"loc":{"lines":{"from":225707,"to":225756}}}}],["1900",{"pageContent":"// \"bar \n// \"bar \n\n\nMaps | 165 \n\n\n\n\nSome have implemented fake maps by maintaining a parallel array \nof non-string keys alongside an array of the values, such as: \n\nvar keys = [], vats = []; \n\nvar x = { id: 1 }, \ny = { id: 2 }; \n\nkeys.push( x ); \nvals.push( \"foo\" ); \n\nkeys.push( y ); \nvals.push( \"bar\" ); \n\n\nkeys[0] === x; \n\n// \n\ntrue \n\nvals[0]; \n\n// \n\n\"foo \n\nkeys[l] === y; \n\n// \n\ntrue \n\nvals[l] ; \n\n// \n\n\"bar \n\n\nOf course, you wouldn’t want to manage those parallel arrays your¬ \nself, so you could define a data structure with methods that auto¬ \nmatically do the management under the covers. Besides having to do \nthat work yourself, the main drawback is that access is no longer \n0(1) time-complexity, but instead is O(n). \n\nBut as of ES6, there’s no longer any need to do this! Just use Map(..): \nvar m = new Map(); \n\nvar x = { id: 1 }, \ny = { id: 2 }; \n\nm.set( x, \"foo\" ); \n\nm. set( y, \"bar\" ); \n\nn. get( x ); // \"foo\" \n\nm.get( y ); // \"bar\"","metadata":{"loc":{"lines":{"from":225756,"to":225823}}}}],["1901",{"pageContent":"var x = { id: 1 }, \ny = { id: 2 }; \n\nm.set( x, \"foo\" ); \n\nm. set( y, \"bar\" ); \n\nn. get( x ); // \"foo\" \n\nm.get( y ); // \"bar\" \n\nThe only drawback is that you can’t use the [ ] bracket access syn¬ \ntax for setting and retrieving values. But get(. .) and set(. .) work \nperfectly suitably instead. \n\nTo delete an element from a map, don’t use the delete operator, but \ninstead use the delete( ..) method: \n\nm.set( x, \"foo\" ); \nm.set( y, \"bar\" ); \n\nm.delete( y ); \n\n\n166 | Chapter 5: Collections \n\n\n\n\nYou can clear the entire map’s contents with clearQ. To get the \nlength of a map (i.e., the number of keys), use the size property \n(not length): \n\nm.set( x, \"foo\" ); \nm.set( y, \"bar\" ); \n\nm.stze; // 2 \n\nm.ctearQ; \n\nm.stze; // 0","metadata":{"loc":{"lines":{"from":225823,"to":225863}}}}],["1902",{"pageContent":"m.set( x, \"foo\" ); \nm.set( y, \"bar\" ); \n\nm.stze; // 2 \n\nm.ctearQ; \n\nm.stze; // 0 \n\nThe Map(..) constructor can also receive an iterable (see “Iterators” \non page 87 in Chapter 3), which must produce a list of arrays, where \nthe first item in each array is the key and the second item is the \nvalue. This format for iteration is identical to that produced by the \nentries() method, explained in the next section. That makes it easy \nto make a copy of a map: \n\nvar m2 = new Map( m.entriesQ ); \n\n// some as: \n\nvar m2 = new Map( m ); \n\nBecause a map instance is an iterable, and its default iterator is the \nsame as entries(), the second shorter form is preferable. \n\nOf course, you can just manually specify an entries list (array of key/ \nvalue arrays) in the Map(..) constructor form: \n\nvar x = { id: 1 }, \ny = { Id: 2 }; \n\nvar m = new Map( [ \n\n[ x, \"foo\" ], \n\n[ y, \"bar\" ] \n\n1 ); \n\nm.get( x ); \nm.get( y ); \n\nMap Values","metadata":{"loc":{"lines":{"from":225863,"to":225905}}}}],["1903",{"pageContent":"var x = { id: 1 }, \ny = { Id: 2 }; \n\nvar m = new Map( [ \n\n[ x, \"foo\" ], \n\n[ y, \"bar\" ] \n\n1 ); \n\nm.get( x ); \nm.get( y ); \n\nMap Values \n\nTo get the list of values from a map, use values(..), which returns \nan iterator. In Chapters 2 and 3, we covered various ways to process \nan iterator sequentially (like an array), such as the ... spread opera¬ \ntor and the for. .of loop. Also, “Creating Arrays and Subtypes” on \npage 179 in Chapter 6 covers the Array.from(..) method in detail. \nConsider: \n\n\n// \"foo \n// \"bar \n\n\nMaps | 167 \n\n\n\nvar m = new Map(); \n\n\nvar x = { Id: 1 }, \ny = { id: 2 }; \n\nn.set( x, \"foo\" ); \nn.set( y, \"bar\" ); \n\nvar vals = [ .. .m.valuesQ ]; \n\nvals; // [\"foo\", \"bar\"] \n\nArray. from( m.values() ); // [\"foo\", \"bar\"] \n\nAs discussed in the previous section, you can iterate over a map’s \nentries using entries() (or the default map iterator). Consider: \n\nvar m = new Map(); \n\nvar x = { id: 1 }, \ny = { id: 2 }; \n\nm.set( x, \"foo\" ); \nm.set( y, \"bar\" );","metadata":{"loc":{"lines":{"from":225905,"to":225961}}}}],["1904",{"pageContent":"var m = new Map(); \n\nvar x = { id: 1 }, \ny = { id: 2 }; \n\nm.set( x, \"foo\" ); \nm.set( y, \"bar\" ); \n\nvar vals = [ .. .m.entriesQ ]; \n\n\nvals[0][0] === x; // true \n\nvals[0] [1]; // \"foo \n\nvals[l] [0] === y; // true \n\nvals [ 1 ][ 1 ]; // \"bar \n\n\nMap Keys \n\nTo get the list of keys, use keys(), which returns an iterator over the \nkeys in the map: \n\nvar m = new Map(); \n\nvar x = { id: 1 }, \ny = { id: 2 }; \n\nm.set( x, \"foo\" ); \nm.set( y, \"bar\" ); \n\nvar keys = [ ...m.keys() ]; \n\nkeys[0] === x; // true \n\nkeys[l] === y; // true \n\n\n168 | Chapter 5: Collections \n\n\n\n\nTo determine if a map has a given key, use has(..): \nvar m = new Map(); \n\nvar x = { Id: 1 }, \ny = { Id: 2 }; \n\nm. set( x, \"foo\" ); \n\nn. has( x ); // true \n\nm.has( y ); // false \n\nMaps essentially let you associate some extra piece of information \n(the value) with an object (the key) without actually putting that \ninformation on the object itself.","metadata":{"loc":{"lines":{"from":225961,"to":226020}}}}],["1905",{"pageContent":"m.has( y ); // false \n\nMaps essentially let you associate some extra piece of information \n(the value) with an object (the key) without actually putting that \ninformation on the object itself. \n\nWhile you can use any kind of value as a key for a map, you typically \nwill use objects, as strings and other primitives are already eligible as \nkeys of normal objects. In other words, you’ll probably want to con¬ \ntinue to use normal objects for maps unless some or all of the keys \nneed to be objects, in which case map is more appropriate. \n\n\n\nIf you use an object as a map key and that object \nis later discarded (all references unset) in \nattempt to have garbage collection (GC) reclaim \nits memory, the map itself will still retain its \nentry. You will need to remove the entry from \nthe map for it to be GC-eligible. In the next sec¬ \ntion, we’ll see WeakMaps as a better option for \nobject keys and GC. \n\n\nWeakMaps","metadata":{"loc":{"lines":{"from":226020,"to":226044}}}}],["1906",{"pageContent":"WeakMaps \n\nWeakMaps are a variation on maps, which has most of the same \nexternal behavior but differs underneath in how the memory alloca¬ \ntion (specifically its GC) works. \n\nWeakMaps take (only) objects as keys. Those objects are held \nweakly, which means if the object itself is GC’d, the entry in the \nWeakMap is also removed. This isn’t observable behavior, though, as \nthe only way an object can be GC’d is if there’s no more references to \nit, but once there are no more references to it—you have no object \nreference to check if it exists in the WeakMap. \n\nOtherwise, the API for WeakMap is similar, though more limited: \n\n\nWeakMaps | 169 \n\n\n\n\nvar m = new WeakMapQ; \n\n\nvar x = { Id: 1 }, \ny = { id: 2 }; \n\nn.set( x, \"foo\" ); \n\nn.has( x ); // true \n\nm.has( y ); // false","metadata":{"loc":{"lines":{"from":226044,"to":226075}}}}],["1907",{"pageContent":"WeakMaps | 169 \n\n\n\n\nvar m = new WeakMapQ; \n\n\nvar x = { Id: 1 }, \ny = { id: 2 }; \n\nn.set( x, \"foo\" ); \n\nn.has( x ); // true \n\nm.has( y ); // false \n\nWeakMaps do not have a size property or clearQ method, nor do \nthey expose any iterators over their keys, values, or entries. So even \nif you unset the x reference, which will remove its entry from pi upon \nGC, there is no way to tell. You’ll just have to take JavaScript’s word \nfor it! \n\n\nJust like Maps, WeakMaps let you soft-associate information with an \nobject. But they are particularly useful if the object is not one you \ncompletely control, such as a DOM element. If the object you’re \nusing as a map key can be deleted and should be GC-eligible when it \nis, then a WeakMap is a more appropriate option. \n\nIt’s important to note that a WeakMap only holds its keys weakly, not \nits values. Consider: \n\nvar m = new WeakMapQ; \n\n\nvar x = { id: 1 }, \n\ny = { id: 2 }, \n\nz = { Id: 3 }, \nw = { id: 4 }; \n\n\nm.set( x, y ); \n\n\nx = null; \n\n//","metadata":{"loc":{"lines":{"from":226075,"to":226124}}}}],["1908",{"pageContent":"var m = new WeakMapQ; \n\n\nvar x = { id: 1 }, \n\ny = { id: 2 }, \n\nz = { Id: 3 }, \nw = { id: 4 }; \n\n\nm.set( x, y ); \n\n\nx = null; \n\n// \n\ny = null; \n\n// \n\n\n// \n\nm.set( z, w ); \n\n\nw = null; \n\n// \n\n\n{ id: 1 } is CC-eligible \n{ id: 2 } is GC-eligible \nonly because { id: 1 } is \n\n\n{ id: 4 } is not GC-eligible \n\n\nFor this reason, WeakMaps are in my opinion better named “Weak- \nKeyMaps.” \n\n\nSets \n\nA set is a collection of unique values (duplicates are ignored). \n\n\n170 | Chapter 5: Collections \n\n\n\n\nThe API for a set is similar to map. The add(..) method takes the \nplace of the set(..) method (somewhat ironically), and there is no \nget(..) method. \n\nConsider: \n\n\nvar s = new Set(); \n\n\nvar x = { id: 1 }, \ny = { id: 2 }; \n\n\ns.add( x ); \ns.add( y ); \ns.add( x ); \n\n\ns . size; \n\n// 2 \n\ns.detete( y ); \ns . size; \n\n// 1 \n\ns.ctearQ; \ns . size; \n\n// 0","metadata":{"loc":{"lines":{"from":226124,"to":226210}}}}],["1909",{"pageContent":"Consider: \n\n\nvar s = new Set(); \n\n\nvar x = { id: 1 }, \ny = { id: 2 }; \n\n\ns.add( x ); \ns.add( y ); \ns.add( x ); \n\n\ns . size; \n\n// 2 \n\ns.detete( y ); \ns . size; \n\n// 1 \n\ns.ctearQ; \ns . size; \n\n// 0 \n\n\nThe Set(..) constructor form is similar to Map( ..in that it can \nreceive an iterable, like another set or simply an array of values. \nHowever, unlike how Map(. .) expects an entries list (array of key/ \nvalue arrays), Set(..) expects a values list (array of values): \n\nvar x = { id: 1 }, \ny = { id: 2 }; \n\nvar s = new Set( [x,y] ); \n\nA set doesn’t need a get(..) because you don’t retrieve a value from \na set, but rather test if it is present or not, using has(..): \n\nvar s = new Set(); \n\nvar x = { id: 1 }, \ny = { id: 2 }; \n\ns.add( x ); \n\ns.has( x ); \ns.has( y ); \n\n\n// true \n// false \n\n\nSets | 171 \n\n\n\n\nThe comparison algorithm in has( ..) is almost \nidentical to Object.is( ..) (see Chapter 6), \nexcept that -0 and 0 are treated as the same \nrather than distinct. \n\n\nSet Iterators","metadata":{"loc":{"lines":{"from":226210,"to":226279}}}}],["1910",{"pageContent":"Sets | 171 \n\n\n\n\nThe comparison algorithm in has( ..) is almost \nidentical to Object.is( ..) (see Chapter 6), \nexcept that -0 and 0 are treated as the same \nrather than distinct. \n\n\nSet Iterators \n\nSets have the same iterator methods as maps. Their behavior is dif¬ \nferent for sets, but symmetric with the behavior of map iterators. \nConsider: \n\nvar s = new Set(); \n\nvar x = { id: 1 }, \ny = { id: 2 }; \n\ns.add( x ).add( y ); \n\nvar keys = [ ...s.keysQ ], \nvals = [ .. .s. values () ], \nentries = [ .. .s.entries() ]; \n\nkeys[0] === x; \nkeys[l] === y; \n\nvals[0] === x; \nvals[l] === y; \n\nentries[0] [0] === x; \nentries[0] [1] === x; \nentries[l] [0] === y; \nentries[l] [1] === y; \n\nThe keys() and values () iterators both yield a list of the unique \nvalues in the set. The entries () iterator yields a list of entry arrays, \nwhere both items of the array are the unique set value. The default \niterator for a set is its values () iterator.","metadata":{"loc":{"lines":{"from":226279,"to":226321}}}}],["1911",{"pageContent":"The inherent uniqueness of a set is its most useful trait. For example: \n\nvar s = new Set( [1,2,3,4, \"1\" ,2,4, \"5\" ] ), \nuniques = [ ... s ]; \n\nuniques; // [1,2,3,4, \"1\", \"S''] \n\nSet uniqueness does not allow coercion, so 1 and \" 1\" are considered \ndistinct values. \n\n\n172 | Chapter 5: Collections \n\n\n\n\n\n\n\nWeakSets \n\nWhereas a WeakMap holds its keys weakly (but its values strongly), \na WeakSet holds its values weakly (there aren’t really keys). \n\nvar s = new WeakSetQ; \n\nvar x = { td: 1 }, \ny = { Id: 2 }; \n\ns.add( x ); \ns.add( y ); \n\nx = null; // 'x' is GC-eligible \n\ny = null; // 'y' is CC-eligible \n\n\n\nWeakSet values must be objects, not primitive \nvalues as is allowed with sets. \n\n\nReview \n\nES6 defines a number of useful collections that make working with \ndata in structured ways more efficient and effective.","metadata":{"loc":{"lines":{"from":226323,"to":226368}}}}],["1912",{"pageContent":"Review \n\nES6 defines a number of useful collections that make working with \ndata in structured ways more efficient and effective. \n\nTypedArrays provide “view’s of binary data buffers that align with \nvarious integer types, like 8-bit unsigned integers and 32-bit floats. \nThe array access to binary data makes operations much easier to \nexpress and maintain, which enables you to more easily work with \ncomplex data like video, audio, canvas data, and so on. \n\nMaps are key-value pairs where the key can be an object instead of \njust a string/primitive. Sets are unique lists of values (of any type). \n\nWeakMaps are maps where the key (object) is weakly held, so that \nGC is free to collect the entry if it’s the last reference to an object. \nWeakSets are sets where the value is weakly held, again so that GC \ncan remove the entry if it’s the last reference to that object. \n\n\nWeakSets | 173 \n\n\n\n\n\n\nCHAPTER 6 \n\n\nAPI Additions","metadata":{"loc":{"lines":{"from":226368,"to":226398}}}}],["1913",{"pageContent":"WeakSets | 173 \n\n\n\n\n\n\nCHAPTER 6 \n\n\nAPI Additions \n\n\nFrom conversions of values to mathematic calculations, ES6 adds \nmany static properties and methods to various built-in natives and \nobjects to help with common tasks. In addition, instances of some of \nthe natives have new capabilities via various new prototype \nmethods. \n\n\n\nMost of these features can be faithfully polyfil- \nled. We will not dive into such details here, but \ncheck out “ES6 Shim” for standards-compliant \nshims/polyfills. \n\n\nArray \n\nOne of the most commonly extended features in JS by various user \nlibraries is the Array type. It should be no surprise that ES6 adds a \nnumber of helpers to Array, both static and prototype (instance). \n\nArray.of(..) Static Function","metadata":{"loc":{"lines":{"from":226398,"to":226431}}}}],["1914",{"pageContent":"Array.of(..) Static Function \n\nThere’s a well-known gotcha with the Array( ..) constructor, which \nis that if there’s only one argument passed, and that argument is a \nnumber, instead of making an array of one element with that num¬ \nber value in it, it constructs an empty array with a length property \nequal to the number. This action produces the unfortunate and \nquirky “empty slots” behavior that’s reviled about JS arrays. \n\n\n175 \n\n\n\n\n\n\nArray.of(..) replaces Array(..) as the preferred function-form \nconstructor for arrays, because Array.of(..) does not have that \nspecial single-number-argument case. Consider: \n\n\nvar a = Array( 3 ); \na.length; \n\n// i \n\na[0]; \n\n// undefined \n\nvar b = Array. of( 3 ); \nb.length; \n\n// 1 \n\nb[0] ; \n\n// 3 \n\nvar c = Array. of( 1, 2, 3 \nc. length; \n\n); \n\n//1 \n\nc; \n\n// [1,2,3] \n\nUnder what circumstances would you want to use Array.of(..) \n\ninstead of just creating an \n\narray with literal syntax, like c = \n\n[1,2,3]? There’s two possible \n\ncases.","metadata":{"loc":{"lines":{"from":226431,"to":226490}}}}],["1915",{"pageContent":"); \n\n//1 \n\nc; \n\n// [1,2,3] \n\nUnder what circumstances would you want to use Array.of(..) \n\ninstead of just creating an \n\narray with literal syntax, like c = \n\n[1,2,3]? There’s two possible \n\ncases. \n\nIf you have a callback that’s supposed to wrap argument(s) passed to \nit in an array, Array .of (..) fits the bill perfectly. That’s probably \nnot terribly common, but it may scratch an itch for you. \n\nThe other scenario is if you subclass Array (see “Classes” on page \n135 in Chapter 3) and want to be able to create and initialize ele¬ \nments in an instance of your subclass, such as: \n\nclass MyCoolArray extends Array { \n\nsum() { \n\n\nreturn this.reduce( function reducer(acc,curr){ \n\nreturn acc + curr; \n\n}. 0 ); \n\n} \n\n} \n\n\nvar x = new MyCoolArray( 3 \nx. length; \n\n); \n\n// 3--oops! \n\nx.sum(); \n\n// 0--oops! \n\nvar y = [3]; \n\n// Array, not MyCoolArray \n\ny.length; \n\n// 1 \n\ny.sumQ; \n\n// 'sun' is not a function \n\nvar z = MyCoolArray .of ( 3 \nz. length; \n\n); \n\n// i \n\nz.sum(); \n\n// 3","metadata":{"loc":{"lines":{"from":226490,"to":226564}}}}],["1916",{"pageContent":"x.sum(); \n\n// 0--oops! \n\nvar y = [3]; \n\n// Array, not MyCoolArray \n\ny.length; \n\n// 1 \n\ny.sumQ; \n\n// 'sun' is not a function \n\nvar z = MyCoolArray .of ( 3 \nz. length; \n\n); \n\n// i \n\nz.sum(); \n\n// 3 \n\nYou can’t just (easily) create \n\na constructor for MyCoolArray that \n\noverrides the behavior of the Array parent constructor, because that \n\n\n176 | Chapter 6: API Additions \n\n\n\nconstructor is necessary to actually create a well-behaving array \nvalue (initializing the this). The “inherited” static of (..) method \non the MyCoolArray subclass provides a nice solution. \n\nArray.from(..) Static Function \n\nAn “array-like object” in JavaScript is an object that has a length \nproperty on it, specifically with an integer value of zero or higher.","metadata":{"loc":{"lines":{"from":226564,"to":226609}}}}],["1917",{"pageContent":"Array.from(..) Static Function \n\nAn “array-like object” in JavaScript is an object that has a length \nproperty on it, specifically with an integer value of zero or higher. \n\nThese values have been notoriously frustrating to work with in JS; \nit’s been quite common to need to transform them into an actual \narray, so that the various Array.prototype methods (map(..), \nindexOf (..), etc.) are available to use with it. That process usually \nlooks like: \n\n// array-like object \nvar arrLike = { \nlength: 3, \n\n0: \"foo\", \n\n1: \"bar\" \n\n1 ; \n\n\nvar arr = Array. prototype.slice.call( arrLike ); \n\nAnother common task where slice( ..) is often used is in duplicat¬ \ning a real array: \n\nvar arr2 = arr.sltceQ; \n\nIn both cases, the new ES6 Array.fron( ..) method can be a more \nunderstandable and graceful—if also less verbose—approach: \n\nvar arr = Array. from( arrLike ); \nvar arrCopy = Array. frorn( arr );","metadata":{"loc":{"lines":{"from":226609,"to":226642}}}}],["1918",{"pageContent":"In both cases, the new ES6 Array.fron( ..) method can be a more \nunderstandable and graceful—if also less verbose—approach: \n\nvar arr = Array. from( arrLike ); \nvar arrCopy = Array. frorn( arr ); \n\nArray. from(.. ) looks to see if the first argument is an iterable (see \n“Iterators” on page 87 in Chapter 3), and if so, it uses the iterator to \nproduce values to “copy” into the returned array. Because real arrays \nhave an iterator for those values, that iterator is automatically used. \n\nBut if you pass an array-like object as the first argument to \nArray. from(..), it behaves basically the same as sliceQ (no argu¬ \nments!) or apply( ..) does, which is that it simply loops over the \nvalue, accessing numerically named properties from 0 up to what¬ \never the value of length is. \n\n\nArray | 177 \n\n\n\n\nConsider: \n\n\nvar arrLike = { \nlength: 4, \n2: \"foo\" \n\n}; \n\n\nArray. front arrLike ); \n\n// [ undefined, undefined, \"foo\", undefined ]","metadata":{"loc":{"lines":{"from":226642,"to":226677}}}}],["1919",{"pageContent":"Array | 177 \n\n\n\n\nConsider: \n\n\nvar arrLike = { \nlength: 4, \n2: \"foo\" \n\n}; \n\n\nArray. front arrLike ); \n\n// [ undefined, undefined, \"foo\", undefined ] \n\nBecause positions 0, 1, and 3 didn’t exist on arrLike, the result was \nthe undefined value for each of those slots. \n\nYou could produce a similar outcome like this: \n\nvar emptySlotsArr = []; \nemptySlotsArr . length = 4; \nemptySlotsArr[2] = \"foo\"; \n\nArray. fron( enptySlotsArr ); \n\n// [ undefined, undefined, \"foo\", undefined ] \n\nAvoiding Empty Slots \n\nThere’s a subtle but important difference in the previous snippet \nbetween the emptySlotsArr and the result of the Array.from(..) \ncall. Array. f rom( ..) never produces empty slots. \n\nPrior to ES6, if you wanted to produce an array initialized to a cer¬ \ntain length with actual undefined values in each slot (no empty \nslots!), you had to do extra work: \n\nvar a = Array( 4 ); \n\n// four empty slots! \n\nvar b = Array. apply( null, { length: 4 } ); \n\n// four 'undefined' values","metadata":{"loc":{"lines":{"from":226677,"to":226725}}}}],["1920",{"pageContent":"var a = Array( 4 ); \n\n// four empty slots! \n\nvar b = Array. apply( null, { length: 4 } ); \n\n// four 'undefined' values \n\nBut Array .from (..) now makes this easier: \n\nvar c = Array. fron( { length: 4 } ); \n\n// four 'undefined' values \n\n\n\nUsing an empty slot array like a in the previous \nsnippets would work with some array functions, \nbut others ignore empty slots (like map(..), \netc.). You should never intentionally work with \nempty slots, as it will almost certainly lead to \nstrange/unpredictable behavior in your pro¬ \ngrams. \n\n\n178 | Chapter 6: API Additions \n\n\n\n\n\nMapping \n\nThe Array.fron( ..) utility has another helpful trick up its sleeve. \nThe second argument, if provided, is a mapping callback (almost the \nsame as the regular Array#map( ..) expects), which is called to map/ \ntransform each value from the source to the returned target. Con¬ \nsider: \n\nvar arrLike = { \nlength: 4, \n\n2: \"foo\" \n\n};","metadata":{"loc":{"lines":{"from":226725,"to":226769}}}}],["1921",{"pageContent":"var arrLike = { \nlength: 4, \n\n2: \"foo\" \n\n}; \n\n\nArray. fron( arrLike, function napper(val,idx){ \nif (typeof vat == \"string\") { \nreturn val.tolIpperCaseQ; \n\n} \n\nelse { \n\nreturn idx; \n\n} \n\n} ); \n\n// [ 0, 1, \"FOO\", 3 ] \n\n\n\nAs with other array methods that take callbacks, \nArray .from( ..) takes an optional third argu¬ \nment that if set will specify the this binding for \nthe callback passed as the second argument. \nOtherwise, this will be undefined. \n\n\nSee “TypedArrays” on page 159 in Chapter 5 for an example of using \nArray.from(..) in translating values from an array of 8-bit values \nto an array of 16-bit values. \n\nCreating Arrays and Subtypes \n\nIn the last couple of sections, we’ve discussed Array.of(..) and \nArray. from(..), both of which create a new array in a similar way \nto a constructor. But what do they do in subclasses? Do they create \ninstances of the base Array or the derived subclass? \n\nclass MyCoolArray extends Array { \n\n}","metadata":{"loc":{"lines":{"from":226769,"to":226815}}}}],["1922",{"pageContent":"class MyCoolArray extends Array { \n\n} \n\nMyCoolArray.from( [1, 2] ) instanceof MyCoolArray; // true \nArray. fron( \n\n\nArray | 179 \n\n\n\n\nMyCoolArray .from( [1, 2] ) \n\n) instanceof MyCoolArray; // false \n\nBoth of (..) and f rom(..) use the constructor that they’re accessed \nfrom to construct the array. So if you use the base Array.of(..) \nyou’ll get an Array instance, but if you use MyCoolArray .of (..), \nyou’ll get a MyCoolArray instance. \n\nIn “Classes” on page 135 in Chapter 3, we covered the @@species \nsetting that all the built-in classes (like Array) have defined, which is \nused by any prototype methods if they create a new instance. \nslice(..) is a great example: \n\nvar x = new MyCoolArray( 1, 2, 3 ); \n\nx.slice( 1 ) Instanceof MyCoolArray; // true \n\nGenerally, that default behavior will probably be desired, but as we \ndiscussed in Chapter 3, you can override if you want: \n\nclass MyCoolArray extends Array {","metadata":{"loc":{"lines":{"from":226815,"to":226849}}}}],["1923",{"pageContent":"Generally, that default behavior will probably be desired, but as we \ndiscussed in Chapter 3, you can override if you want: \n\nclass MyCoolArray extends Array { \n\n// force 'species' to be parent constructor \nstatic get [Symbol. species]() { return Array; } \n\n} \n\nvar x = new MyCoolArray( 1, 2, 3 ); \n\nx.slice( 1 ) instanceof MyCoolArray; // false \n\nx.slice( 1 ) instanceof Array; // true \n\nIt’s important to note that the @@species setting is only used for the \nprototype methods, like sltce(..). It’s not used by of(..) and \nf rom(..); they both just use the this binding (whatever constructor \nis used to make the reference). Consider: \n\nclass MyCoolArray extends Array { \n\n// force 'species' to be parent constructor \nstatic get [Symbol. speciesJQ { return Array; } \n\n} \n\nvar x = new MyCoolArray( 1, 2, 3 ); \n\nMyCoolArray .from( x ) instanceof MyCoolArray; // true \n\nMyCoolArray .of ( [2, 3] ) instanceof MyCoolArray; // true \n\ncopyWithin(..) Prototype Method","metadata":{"loc":{"lines":{"from":226849,"to":226883}}}}],["1924",{"pageContent":"} \n\nvar x = new MyCoolArray( 1, 2, 3 ); \n\nMyCoolArray .from( x ) instanceof MyCoolArray; // true \n\nMyCoolArray .of ( [2, 3] ) instanceof MyCoolArray; // true \n\ncopyWithin(..) Prototype Method \n\nArray#copyWithin(..) is a new mutator method available to all \narrays (including typed arrays; see Chapter 5). copyWithin(..) \n\n\n180 | Chapter 6: API Additions \n\n\n\ncopies a portion of an array to another location in the same array, \noverwriting whatever was there before. \n\nThe arguments are target (the index to copy to), start (the inclusive \nindex to start the copying from), and optionally end (the exclusive \nindex to stop copying). If any of the arguments are negative, they’re \ntaken to be relative from the end of the array. \n\nConsider: \n\n\n[1.2.3.4.5] .copyWtthin( 3, 0 ); // [1,2,3,1,2] \n\n[1.2.3.4. 5] .copyWtthin( 3, 0, 1 ); // [1,2,3,1,5] \n\n\n[1,2,3, 4, 5] .copyWtthin( 0, -2 ); // [4,5,3,4,5] \n\n[1.2. 3. 4. 5] .copyWtthin( 0, -2, -1 ); // [4,2,3,4,5]","metadata":{"loc":{"lines":{"from":226883,"to":226919}}}}],["1925",{"pageContent":"[1.2.3.4. 5] .copyWtthin( 3, 0, 1 ); // [1,2,3,1,5] \n\n\n[1,2,3, 4, 5] .copyWtthin( 0, -2 ); // [4,5,3,4,5] \n\n[1.2. 3. 4. 5] .copyWtthin( 0, -2, -1 ); // [4,2,3,4,5] \n\nThe copy Within (..) method does not extend the arrays length, as \nthe first example in the previous snippet shows. Copying simply \nstops when the end of the array is reached. \n\nContrary to what you might think, the copying doesn’t always go in \nleft-to-right (ascending index) order. It’s possible this would result \nin repeatedly copying an already copied value if the from and target \nranges overlap, which is presumably not desired behavior. \n\nSo internally, the algorithm avoids this case by copying in reverse \norder to avoid that gotcha. Consider: \n\n[1.2.3. 4. 5] .copyWtthtn( 2, 1 ); // ???","metadata":{"loc":{"lines":{"from":226919,"to":226938}}}}],["1926",{"pageContent":"So internally, the algorithm avoids this case by copying in reverse \norder to avoid that gotcha. Consider: \n\n[1.2.3. 4. 5] .copyWtthtn( 2, 1 ); // ??? \n\nIf the algorithm was strictly moving left to right, then the 2 should \nbe copied to overwrite the 3, then that copied 2 should be copied to \noverwrite 4, then that copied 2 should be copied to overwrite 5, and \nyou’d end up with [1,2,2,2,2]. \n\nInstead, the copying algorithm reverses direction and copies 4 to \noverwrite 5, then copies 3 to overwrite 4, then copies 2 to overwrite \n3, and the final result is [1,2,2,3,4]. That’s probably more “cor¬ \nrect” in terms of expectation, but it can be confusing if you’re only \nthinking about the copying algorithm in a naive left-to-right \nfashion. \n\n\nArray | 181 \n\n\n\n\nfill(..) Prototype Method \n\nFilling an existing array entirely (or partially) with a specified value \nis natively supported as of ES6 with the Array#fill(..) method: \n\nvar a = Array( 4 ).ftll( undefined ); \na;","metadata":{"loc":{"lines":{"from":226938,"to":226967}}}}],["1927",{"pageContent":"Filling an existing array entirely (or partially) with a specified value \nis natively supported as of ES6 with the Array#fill(..) method: \n\nvar a = Array( 4 ).ftll( undefined ); \na; \n\n// [undefined,undefined,undefined,undefined] \n\nfill(..) optionally takes start and end parameters, which indicate \na subset portion of the array to fill, such as: \n\nvar a = [ null, null, null, null ]. fIII ( 42, 1, 3 ); \n\na; // [null,42,42,null] \n\nfind(..) Prototype Method \n\nThe most common way to search for a value in an array has gener¬ \nally been the indexOf(..) method, which returns the index the \nvalue is found at or -1 if not found: \n\nvar a = [1,2,3, 4, 5]; \n\n(a.lndexOf( 3 ) != -1); // true \n\n(a.lndexOf( 7 ) != -1); // false \n\n(a.lndexOf( \"2\" ) != -1); // false","metadata":{"loc":{"lines":{"from":226967,"to":226994}}}}],["1928",{"pageContent":"var a = [1,2,3, 4, 5]; \n\n(a.lndexOf( 3 ) != -1); // true \n\n(a.lndexOf( 7 ) != -1); // false \n\n(a.lndexOf( \"2\" ) != -1); // false \n\nThe indexOf(..) comparison requires a strict === match, so a \nsearch for \"2\" fails to find a value of 2, and vice versa. There’s no \nway to override the matching algorithm for IndexOf (..). It’s also \nunfortunate/ungraceful to have to make the manual comparison to \nthe -1 value. \n\nSee the Types & Grammar title of this series for \nan interesting (and controversially confusing) \ntechnique to work around the - 1 ugliness with \nthe ~ operator. \n\n\n\nSince ES5, the most common workaround to have control over the \nmatching logic has been the some(..) method. It works by calling a \nfunction callback for each element, until one of those calls returns a \ntrue/truthy value, and then it stops. Because you get to define the \ncallback function, you have full control over how a match is made: \n\n\n182 | Chapter 6: API Additions \n\n\n\n\nvar a = [1,2,3,4,51;","metadata":{"loc":{"lines":{"from":226994,"to":227027}}}}],["1929",{"pageContent":"182 | Chapter 6: API Additions \n\n\n\n\nvar a = [1,2,3,4,51; \n\n\na.some( function matcher(v){ \nreturn v == \"2\"; \n\n} ); // true \n\na.some( function matcher(v){ \nreturn v == 7; \n\n} ); // false \n\nBut the downside to this approach is that you only get the true/ \nfalse indicating if a suitably matched value was found, but not what \nthe actual matched value was. \n\nES6’s find(..) addresses this. It works basically the same as \nsome(. .except that once the callback returns a true/truthy value, \nthe actual array value is returned: \n\nvar a = [1,2,3, 4, 5]; \n\na.find( function matcher(v){ \nreturn v == \"2\"; \n\n} ); // 2 \n\na.find( function natcher(v){ \n\nreturn v == 7; // undefined \n\n}); \n\nUsing a custom matcher(. .) function also lets you match against \ncomplex values like objects: \n\nvar points = [ \n\n{ x: 10, y: 20 }, \n\n{ x: 20, y: 30 }, \n\n{ x: 30, y: 40 }, \n\n{ x: 40, y: 50 }, \n\n{ x: 50, y: 60 } \n\n1 ; \n\n\npoints.find( function matcher(point) { \n\nreturn ( \n\npoint.x % 3 == 0 && \npoint.y % 4 == 0 \n\n);","metadata":{"loc":{"lines":{"from":227027,"to":227091}}}}],["1930",{"pageContent":"{ x: 20, y: 30 }, \n\n{ x: 30, y: 40 }, \n\n{ x: 40, y: 50 }, \n\n{ x: 50, y: 60 } \n\n1 ; \n\n\npoints.find( function matcher(point) { \n\nreturn ( \n\npoint.x % 3 == 0 && \npoint.y % 4 == 0 \n\n); \n\n} ); // { x: 30, y: 40 } \n\n\nArray | 183 \n\n\n\n\n\nAs with other array methods that take callbacks, \nfind(..) takes an optional second argument \nthat if set will specify the this binding for the \ncallback passed as the first argument. Otherwise, \nthis will be undefined. \n\n\nfindlndex(..) Prototype Method \n\nWhile the previous section illustrates how some( ..) yields a boolean \nresult for a search of an array, and find(. .) yields the matched \nvalue itself from the array search, there’s also a need to find the posi¬ \ntional index of the matched value. \n\nindexOf (.. ) does that, but there’s no control over its matching \nlogic; it always uses === strict equality. So ES6’s findlndex(. .) is the \nanswer: \n\nvar points = [ \n\n{ x: 10, y: 20 }, \n\n{ x: 20, y: 30 }, \n\n{ x: 30, y: 40 }, \n\n{ x: 40, y: 50 },","metadata":{"loc":{"lines":{"from":227091,"to":227146}}}}],["1931",{"pageContent":"var points = [ \n\n{ x: 10, y: 20 }, \n\n{ x: 20, y: 30 }, \n\n{ x: 30, y: 40 }, \n\n{ x: 40, y: 50 }, \n\n{ x: 50, y: 60 } \n\n]; \n\n\npoints . findlndex( function natcher(point) { \nreturn ( \n\npoint.x % 3 == 0 && \npoint.y % 4 == 0 \n\n); \n\n} ); // 2 \n\npoints.findlndex( function natcher(point) { \nreturn ( \n\npoint.x % 6 == 0 && \npoint.y % 7 == 0 \n\n); \n\n} ); // -i \n\nDon’t use f indlndex(..) ! = -1 (the way it’s always been done with \nindexOf (..)) to get a boolean from the search, because some(..) \nalready yields the true/false you want. And don’t do a[ a.findln \ndex(..) ] to get the matched value, because that’s what find(..) \naccomplishes. And finally use indexOf (..) if you need the index of \na strict match, or findlndex(..) if you need the index of a more \ncustomized match. \n\n\n184 | Chapter 6: API Additions","metadata":{"loc":{"lines":{"from":227146,"to":227190}}}}],["1932",{"pageContent":"184 | Chapter 6: API Additions \n\n\n\n\n\n\n\n\n\n\nAs with other array methods that take callbacks, \nfind(..) takes an optional second argument \nthat if set will specify the this binding for the \ncallback passed as the first argument. Otherwise, \nthis will be undefined. \n\n\nentries(), values(), keys() Prototype Methods \n\nIn Chapter 3, we illustrated how data structures can provide a pat¬ \nterned item-by-item enumeration of their values, via an iterator. We \nthen expounded on this approach in Chapter 5, as we explored how \nthe new ES6 collections (Map, Set, etc.) provide several methods for \nproducing different kinds of iterations. \n\nBecause it’s not new to ES6, Array might not be thought of tradi¬ \ntionally as a “collection,” but it is one in the sense that it provides \nthese same iterator methods: entries(), values(), and keysQ. \nConsider: \n\nvar a = [1,2,3]; \n\n[...a.values()]; // [1,2,3] \n\n[...a.keys()]; // [6,1,2] \n\n[.. .a.entries!)]; // [ [6,1], [1,2], [2,3] ]","metadata":{"loc":{"lines":{"from":227190,"to":227227}}}}],["1933",{"pageContent":"var a = [1,2,3]; \n\n[...a.values()]; // [1,2,3] \n\n[...a.keys()]; // [6,1,2] \n\n[.. .a.entries!)]; // [ [6,1], [1,2], [2,3] ] \n\n[.. .a [Symbol. iterator]!)]; // [1,2,3] \n\nJust like with Set, the default Array iterator is the same as what val \nues() returns. \n\nIn “String Inspection Functions” on page 196, we illustrated how \nArray.from(..) treats empty slots in an array as just being present \nslots with undefined in them. That’s actually because under the cov¬ \ners, the array iterators behave that way: \n\nvar a = []; \na. length = 3; \na[l] = 2; \n\n[ .. .a.valuesQ] ; // [undefined,2,undefined] \n\n[...a.keysO]; // [0,1,2] \n\n[ ... a .entries! )]; // [ [0, undefined], [1,2], [2, undefined] ] \n\n\nArray | 185 \n\n\n\n\n\n\n\nObject \n\nA few additional static helpers have been added to Object. Tradi¬ \ntionally, functions of this sort have been seen as focused on the \nbehaviors/capabilities of object values.","metadata":{"loc":{"lines":{"from":227227,"to":227268}}}}],["1934",{"pageContent":"Object \n\nA few additional static helpers have been added to Object. Tradi¬ \ntionally, functions of this sort have been seen as focused on the \nbehaviors/capabilities of object values. \n\nHowever, starting with ES6, Object static functions will also be for \ngeneral-purpose global APIs of any sort that don’t already belong \nmore naturally in some other location (i.e.. Array .from(..)). \n\nObject.is(-) Static Function \n\nThe Object.is( ..) static function makes value comparisons in an \neven more strict fashion than the === comparison. \n\nObject.is( ..) invokes the underlying SameValue algorithm (ES6 \nspec, section 7.2.9). The SameValue algorithm is basically the same \nas the === Strict Equality Comparison Algorithm (ES6 spec, section \n7.2.13), with two important exceptions. \n\n\nConsider: \n\nvar x = NaN, y = 0, z = -0; \n\nx === x; // false \n\ny === z; // true \n\nObject. ts( x, x ); // true \n\nObject. ts( y, z ); // false \n\nYou should continue to use === for strict equality comparisons;","metadata":{"loc":{"lines":{"from":227268,"to":227301}}}}],["1935",{"pageContent":"var x = NaN, y = 0, z = -0; \n\nx === x; // false \n\ny === z; // true \n\nObject. ts( x, x ); // true \n\nObject. ts( y, z ); // false \n\nYou should continue to use === for strict equality comparisons; \n\n\nObject.is (..) shouldn’t be thought of as a replacement for the \noperator. However, in cases where you’re trying to strictly identify a \nNaN or -0 value, Object. is( ..) is now the preferred option. \n\n\n\nES6 also adds a Number.isNaN( ..) utility (dis¬ \ncussed later in this chapter), which may be a \nslightly more convenient test; you may prefer \nNumber.isNaN(x) over Object.is(x,NaN). You \ncan accurately test for -0 with a clumsy x == 0 \n&& 1 / x === -Infinity, but in this case \nObject.is(x,-0) is much better. \n\n\n186 | Chapter 6: API Additions \n\n\n\n\n\n\n\nObject.getOwnPropertySymbols(..) Static Function \n\n“Symbols” on page 80 in Chapter 2 discusses the new Symbol primi¬ \ntive value type in ES6.","metadata":{"loc":{"lines":{"from":227301,"to":227340}}}}],["1936",{"pageContent":"186 | Chapter 6: API Additions \n\n\n\n\n\n\n\nObject.getOwnPropertySymbols(..) Static Function \n\n“Symbols” on page 80 in Chapter 2 discusses the new Symbol primi¬ \ntive value type in ES6. \n\nSymbols are likely going to be mostly used as special (meta) proper¬ \nties on objects. So the Object.getOwnPropertySymbols( ..) utility \nwas introduced, which retrieves only the symbol properties directly \non an object: \n\nvar o = { \nfoo: 42, \n\n[ Symbol( \"bar\" ) ] \"hello world\", \nbaz: true \n\n}; \n\n\nObject. getOwnPropertySymbols( o ); // [ Synbol(bar) ] \n\nObject.setPrototypeOf(..) Static Function \n\nAlso in Chapter 2, we mentioned the Object. setPrototypeOf(..) \nutility, which (unsurprisingly) sets the [[Prototype]] of an object \nfor the purposes of behavior delegation (see the this & Object Proto¬ \ntypes title of this series). Consider: \n\nvar ol = { \n\nfoo() { console. log( \"foo\" ); } \n\n}; \n\nvar o2 = { \n\n// .. o2's definition .. \n\n}; \n\n\nObject. setPrototypeOf ( o2, ol ); \n\n// delegates to 'ol.fooO'","metadata":{"loc":{"lines":{"from":227340,"to":227391}}}}],["1937",{"pageContent":"var ol = { \n\nfoo() { console. log( \"foo\" ); } \n\n}; \n\nvar o2 = { \n\n// .. o2's definition .. \n\n}; \n\n\nObject. setPrototypeOf ( o2, ol ); \n\n// delegates to 'ol.fooO' \n\no2.foo(); // foo \n\nAlternatively: \n\nvar ol = { \n\nfoo() { console. log( \"foo\" ); } \n\n}; \n\n\nvar o2 = Object. setPrototypeOf ( { \n\n// .. o2's definition .. \n\n}, ol ); \n\n// delegates to 'ol.foo()~ \n\no2.foo(); // foo \n\n\nObject | 187 \n\n\n\nIn both previous snippets, the relationship between o2 and ol \nappears at the end of the o2 definition. More commonly, the rela¬ \ntionship between an o2 and ol is specified at the top of the o2 defini¬ \ntion, as it is with classes, and also with_proto_in object literals \n\n(see “Setting [[Prototype]]” on page 45 in Chapter 2). \n\n\n\nSetting a [[Prototype]] right after object cre¬ \nation is reasonable, as shown. But changing it \nmuch later is generally not a good idea and will \nusually lead to more confusion than clarity. \n\n\nObject.assign(..) Static Function","metadata":{"loc":{"lines":{"from":227391,"to":227449}}}}],["1938",{"pageContent":"Object.assign(..) Static Function \n\nMany JavaScript libraries/frameworks provide utilities for copying/ \nmixing one object’s properties into another (e.g., jQuery’s \nextend(. .)). There are various nuanced differences between these \ndifferent utilities, such as whether a property with value undefined \nis ignored or not. \n\nES6 adds Object. assign( ..), which is a simplified version of these \nalgorithms. The first argument is the target, and any other argu¬ \nments passed are the sources, which will be processed in listed order. \nFor each source, its enumerable and own (e.g., not “inherited”) keys, \nincluding symbols, are copied as if by plain = assignment. \nObject.assign( ..) returns the target object. \n\nConsider this object setup: \n\nvar target = {}, \n\nol = { a: 1 }, o2={b:2}, \no3={c:3}, o4={d:4}; \n\n// set up read-only property \n\nObject. defineProperty( o3, \"e\", { \nvalue: 5, \nenumerable: true, \nwritable: false, \nconfigurable: false \n\n} ); \n\n// set up non-enunerable property","metadata":{"loc":{"lines":{"from":227449,"to":227481}}}}],["1939",{"pageContent":"// set up read-only property \n\nObject. defineProperty( o3, \"e\", { \nvalue: 5, \nenumerable: true, \nwritable: false, \nconfigurable: false \n\n} ); \n\n// set up non-enunerable property \n\nObject. defineProperty( o3, \"f\", { \nvalue: 6, \nenumerable: false \n\n} ); \n\n\n188 | Chapter 6: API Additions \n\n\n\n\n\n\no3[ Symbol( \"g\" ) ] = 7; \n\n\n// set up non-enumerable symbol \n\n\nObject. defineProperty( o3, Symbol( \"h\" ), { \nvalue: 8, \nenumerable: false \n\n\n} ); \n\n\nObject.setPrototypeOf( o3, o4 ); \n\n\nOnly the properties a, b, c, e, and Symbol(\"g\") will be copied to tar \nget: \n\n\nObject. asslgn( target, ol, o2, o3 ); \n\n\n// 1 \n// 2 \n// 2 \n\n\ntarget. a; \ntarget. b; \ntarget. c; \n\n\nObject. getOwnPropertyDescriptor( target, \"e\" ); \n\n// { value: 5, writable: true, enumerable: true, \n\n// configurable: true } \n\nObject. getOwnPropertySymbols( target ); \n\n// [Symbol(\"g\")]","metadata":{"loc":{"lines":{"from":227481,"to":227549}}}}],["1940",{"pageContent":"Object. getOwnPropertyDescriptor( target, \"e\" ); \n\n// { value: 5, writable: true, enumerable: true, \n\n// configurable: true } \n\nObject. getOwnPropertySymbols( target ); \n\n// [Symbol(\"g\")] \n\nThe d, f, and Symbol(\"h\") properties are omitted from copying; \nnon-enumerable properties and non-owned properties are all exclu¬ \nded from the assignment. Also, e is copied as a normal property \nassignment, not duplicated as a read-only property. \n\nIn an earlier section, we showed using setPrototypeOf (..) to set \nup a [[Prototype]] relationship between an o2 and ol object. \nThere’s another form that leverages Object. assign(..): \n\nvar ol = { \n\nfoo() { console. log( \"foo\" ); } \n\n1 ; \n\nvar o2 = Object. asslgn( \n\nObject. create( ol ), \n\n{ \n\n// .. o2's definition .. \n\n\n} \n\n\n); \n\n\n// delegates to 'ol.fooO' \no2.foo(); \n\n\n// foo \n\n\nObject | 189","metadata":{"loc":{"lines":{"from":227549,"to":227596}}}}],["1941",{"pageContent":"1 ; \n\nvar o2 = Object. asslgn( \n\nObject. create( ol ), \n\n{ \n\n// .. o2's definition .. \n\n\n} \n\n\n); \n\n\n// delegates to 'ol.fooO' \no2.foo(); \n\n\n// foo \n\n\nObject | 189 \n\n\n\n\nObject.create( ..) is the ES5 standard utility \nthat creates an empty object that is \n[[Prototype] ]-linked. See the this & Object \nPrototypes title of this series for more informa¬ \ntion. \n\n\nMath \n\nES6 adds several new mathematic utilities that fill in holes or aid \nwith common operations. All of these can be manually calculated, \nbut most of them are now defined natively so that in some cases the \nJS engine can either more optimally perform the calculations, or \nperform them with better decimal precision than their manual \ncounterparts. \n\nIt’s likely that asm.js/transpiled JS code (see the Async & Perfor¬ \nmance title of this series) is the more likely consumer of many of \nthese utilities rather than direct developers. \n\nTrigonometry: \n\ncosh(..) \n\nHyperbolic cosine \n\nacosh(..) \n\nHyperbolic arccosine \n\nsinh(..)","metadata":{"loc":{"lines":{"from":227596,"to":227655}}}}],["1942",{"pageContent":"Trigonometry: \n\ncosh(..) \n\nHyperbolic cosine \n\nacosh(..) \n\nHyperbolic arccosine \n\nsinh(..) \n\nHyperbolic sine \n\nasinh(..) \n\nHyperbolic arcsine \n\ntanh(..) \n\nHyperbolic tangent \natanh(..) \n\nHyperbolic arctangent \nhypot(..) \n\nThe squareroot of the sum of the squares (i.e., the generalized \nPythagorean theorem) \n\n\n190 | Chapter 6: API Additions \n\n\n\n\n\n\n\nArithmetic: \n\ncbrt(..) \n\nCube root \n\nclz32(..) \n\nCount leading zeros in 32-bit binary representation \nexpml(..) \n\nThe same as exp(x) - 1 \nlog2(..) \n\nBinary logarithm (log base 2) \n\nlogl0(..) \n\nLog base 10 \n\nloglp(..) \n\nThe same as log(x + 1) \nimul(..) \n\n32-bit integer multiplication of two numbers \nMeta: \nstgn(..) \n\nReturns the sign of the number \ntrunc(..) \n\nReturns only the integer part of a number \nfround(..) \n\nRounds to nearest 32-bit (single precision) floating-point value \n\nNumber","metadata":{"loc":{"lines":{"from":227655,"to":227730}}}}],["1943",{"pageContent":"Returns the sign of the number \ntrunc(..) \n\nReturns only the integer part of a number \nfround(..) \n\nRounds to nearest 32-bit (single precision) floating-point value \n\nNumber \n\nImportantly, for your program to properly work, it must accurately \nhandle numbers. ES6 adds some additional properties and functions \nto assist with common numeric operations. \n\nTwo additions to Number are just references to the pre-existing glob- \nals: Number.parselnt(..) and Number. parseFloat(..). \n\nStatic Properties \n\nES6 adds some helpful numeric constants as static properties: \n\n\nNumber | 191 \n\n\n\nNumber.EPSILON \n\nThe minimum value between any two numbers: 2 A -52 (see \nChapter 2 of the Types & Grammar title of this series regarding \nusing this value as a tolerance for imprecision in floating-point \narithmetic) \n\nNumber.MAX_SAFE_INTEGER \n\nThe highest integer that can “safely” be represented unambigu¬ \nously in a JS number value: 2 A 53 - 1 \n\nNumber.MIN_SAFE_INTEGER","metadata":{"loc":{"lines":{"from":227730,"to":227768}}}}],["1944",{"pageContent":"Number.MAX_SAFE_INTEGER \n\nThe highest integer that can “safely” be represented unambigu¬ \nously in a JS number value: 2 A 53 - 1 \n\nNumber.MIN_SAFE_INTEGER \n\nThe lowest integer that can “safely” be represented unambigu- \nously in a JS number value: - ( 2 A 53 - l)or(-2) A 53 + 1 \n\n\n\nSee Chapter 2 of the Types & Grammar title of \nthis series for more information about “safe” \nintegers. \n\n\nNumber.isNaN(..) Static Function \n\nThe standard global isNaN(..) utility has been broken since its \ninception, in that it returns true for things that are not numbers, \nnot just for the actual NaN value, because it coerces the argument to a \nnumber type (which can falsely result in a NaN). ES6 adds a fixed \nutility Number.isNaN(..) that works as it should: \n\nvar a = NaN, b = \"NaN\", c = 42; \n\n\nlsNaN( a ); \n\nLsNaN( b ); \n\nLsNaN( c ); \n\nNumber . LsNaN( a ); \nNumber . lsNaN( b ); \nNumber . LsNaN( c ); \n\n\n// true \n// true--oops! \n// false \n\n// true \n\n// false--fixed! \n// false","metadata":{"loc":{"lines":{"from":227768,"to":227814}}}}],["1945",{"pageContent":"lsNaN( a ); \n\nLsNaN( b ); \n\nLsNaN( c ); \n\nNumber . LsNaN( a ); \nNumber . lsNaN( b ); \nNumber . LsNaN( c ); \n\n\n// true \n// true--oops! \n// false \n\n// true \n\n// false--fixed! \n// false \n\n\nNumber.isFinite(..) Static Function \n\nThere’s a temptation to look at a function name like isFinite(..) \nand assume it’s simply “not infinite”. That’s not quite correct, though. \nThere’s more nuance to this new ES6 utility. Consider: \n\nvar a = NaN, b = Infinity, c = 42; \n\n\n192 | Chapter 6: API Additions \n\n\n\n\n\nNumber . isFinite( a ); \nNumber . isFinite( b ); \n\n\n// false \n// false \n\n\nNumber. isFinite( c ); // true \n\nThe standard global isFinite(..) coerces its argument, but Nun \nber.isFinite(..) omits the coercive behavior: \n\nvar a = \"42\"; \n\ntsFlnite( a ); // true \n\nNumber. isFinite( a ); // false","metadata":{"loc":{"lines":{"from":227814,"to":227867}}}}],["1946",{"pageContent":"The standard global isFinite(..) coerces its argument, but Nun \nber.isFinite(..) omits the coercive behavior: \n\nvar a = \"42\"; \n\ntsFlnite( a ); // true \n\nNumber. isFinite( a ); // false \n\nYou may still prefer the coercion, in which case using the global \nisFinite(..) is a valid choice. Alternatively, and perhaps more sen¬ \nsibly, you can use Number.isFinite(+x), which explicitly coerces x \nto a number before passing it in (see Chapter 4 of the Types & \nGrammar title of this series). \n\nInteger-Related Static Functions \n\nJavaScript number valuess are always floating point (IEE-754). So \nthe notion of determining if a number is an “integer” is not about \nchecking its type, because JS makes no such distinction. \n\nInstead, you need to check if there’s any nonzero decimal portion of \nthe value. The easiest way to do that has commonly been: \n\nx === Math.floor( x ); \n\nES6 adds a Number. islnteger(..) helper utility that potentially can \ndetermine this quality slightly more efficiently:","metadata":{"loc":{"lines":{"from":227867,"to":227894}}}}],["1947",{"pageContent":"x === Math.floor( x ); \n\nES6 adds a Number. islnteger(..) helper utility that potentially can \ndetermine this quality slightly more efficiently: \n\nNumber. lslnteger( 4 ); // true \n\nNumber. tslnteger( 4.2 ); // false \n\n\n\nIn JavaScript, there’s no difference between 4, 4., \n4.0, or 4.0000. All of these would be considered \nan “integer,” and would thus yield true from \nNumber.islnteger(..). \n\n\nIn addition, Number.islnteger(..) filters out some clearly not- \ninteger values that x === Math, floor(x) could potentially mix up: \n\nNumber. tslnteger( NaN ); // false \n\nNumber. tslnteger( Infinity ); // false \n\n\nNumber | 193 \n\n\n\n\n\nWorking with “integers” is sometimes an important bit of informa¬ \ntion, as it can simplify certain kinds of algorithms. JS code by itself \nwill not run faster just from filtering for only integers, but there are \noptimization techniques the engine can take (e.g., asm.js) when only \nintegers are being used.","metadata":{"loc":{"lines":{"from":227894,"to":227929}}}}],["1948",{"pageContent":"Because of Number.islnteger( .. )’s handling of NaN and Infinity \nvalues, defining a isFloat( ..) utility would not be just as simple \nas ! Number. islnteger(.. ). Youd need to do something like: \n\nfunction isFloat(x) { \n\nreturn Number. tsFinite( x ) && INumber.isIntegerf x ); \n\n} \n\nisFIoat( 4.2 ); // true \n\nisFIoat( 4 ); // false \n\ntsFIoat( NaN ); // false \n\nisFIoat( Infinity ); // false \n\n\n\nIt may seem strange, but Infinity should nei¬ \nther be considered an integer nor a float. \n\n\nES6 also defines a Number.isSafeInteger(..) utility, which checks \nto make sure the value is both an integer and within the range of \nNumber.MIN_SAFE_INTEGER-Number.MAX_SAFE_INTEGER (inclusive). \n\nvar x = Math.powf 2, 53 ), \ny = Math.powf -2, 53 ); \n\nNumber. isSafelntegerf x - 1 ); // true \n\nNumber. isSafelntegerf y + 1 ); // true \n\nNumber. isSafelntegerf x ); // false \n\nNumber. isSafelntegerf y ); // false \n\nString","metadata":{"loc":{"lines":{"from":227931,"to":227970}}}}],["1949",{"pageContent":"Number. isSafelntegerf x - 1 ); // true \n\nNumber. isSafelntegerf y + 1 ); // true \n\nNumber. isSafelntegerf x ); // false \n\nNumber. isSafelntegerf y ); // false \n\nString \n\nStrings already have quite a few helpers prior to ES6, but even more \nhave been added to the mix. \n\n\n194 | Chapter 6: API Additions \n\n\n\n\n\n\n\nUnicode Functions \n\n“Unicode-Aware String Operations” on page 75 in Chapter 2 dis¬ \ncusses String.fromCodePoint(..), String#codePointAt( ..and \nString#nomalize( ..) in detail. They have been added to improve \nUnicode support in JS string values. \n\nString . fronCodePotnt( 0xld49e ); // \"HP \n\n\"ab%l.codePointAt( 2 ).toString( 16 ); // \"ld49e\" \n\nThe normalize(.. ) string prototype method is used to perform \nUnicode normalizations that either combine characters with adja¬ \ncent “combining marks” or decompose combined characters.","metadata":{"loc":{"lines":{"from":227970,"to":228005}}}}],["1950",{"pageContent":"The normalize(.. ) string prototype method is used to perform \nUnicode normalizations that either combine characters with adja¬ \ncent “combining marks” or decompose combined characters. \n\nGenerally, the normalization won’t create a visible effect on the con¬ \ntents of the string, but will change the contents of the string, which \ncan affect how things like the length property are reported, as well \nas how character access by position behaves: \n\n\nvar si = \"e\\u0301\"; \n\n\nsi.length; \n\n// 2 \n\nvar s2 = si . normalize! ); \n\n\ns2. length; \n\n// 1 \n\ns2 === \"\\xE9\"; \n\n// true \n\n\nnomallze(. .) takes an optional argument that specifies the nor¬ \nmalization form to use. This argument must be one of the following \nfour values: \"NFC\" (default), \"NFD\", \"NFKC\", or \"NFKD\". \n\n\n\nNormalization forms and their effects on strings \nis well beyond the scope of what we’ll discuss \nhere. See “Unicode Normalization Forms” for \nmore information. \n\n\nString.raw(..) Static Function","metadata":{"loc":{"lines":{"from":228005,"to":228046}}}}],["1951",{"pageContent":"Normalization forms and their effects on strings \nis well beyond the scope of what we’ll discuss \nhere. See “Unicode Normalization Forms” for \nmore information. \n\n\nString.raw(..) Static Function \n\nThe String. raw( ..) utility is provided as a built-in tag function to \nuse with template string literals (see Chapter 2) for obtaining the \nraw string value without any processing of escape sequences. \n\nThis function will almost never be called manually, but will be used \nwith tagged template literals: \n\n\nString | 195 \n\n\n\n\n\nvar str = \"be\"; \n\nString. raw'\\ta${str}d\\xE9' ; \n\n// \"\\tabcd\\xE9\", not \" abode\" \n\nIn the resultant string, \\ and t are separate raw characters, not the \none escape sequence character \\t. The same is true of the Unicode \nescape sequence. \n\nrepeat(..) Prototype Function \n\nIn languages like Python and Ruby, you can repeat a string as: \n\n\"foo\" * 3; // \"foofoofoo\"","metadata":{"loc":{"lines":{"from":228046,"to":228082}}}}],["1952",{"pageContent":"repeat(..) Prototype Function \n\nIn languages like Python and Ruby, you can repeat a string as: \n\n\"foo\" * 3; // \"foofoofoo\" \n\nThat doesn’t work in JS, because * multiplication is only defined for \nnumbers, and thus \"foo\" coerces to the NaN number. \n\nHowever, ES6 defines a string prototype method repeat(..) to \naccomplish the task: \n\n\"foo\" . repeat( 3 ); // \"foofoofoo\" \n\nString Inspection Functions \n\nIn addition to String#indexOf (..) and String#lastIndexOf(..) \nfrom prior to ES6, three new methods for searching/inspection have \nbeen added: startsWlth(..),endsWidth(..),and includes(..). \n\nvar palindrome = \"step on no pets\"; \npalindrome.startsklith( \"step on\" ); // true \n\n\npalindrome, start sklith( \n\n\"on\", 5 ); \n\n// true \n\npalindrome.endsWith( \" \n\nno pets\" ); \n\n// true \n\npalindrome.endsWith( \" \n\nno\", 10 ); \n\n// true \n\npalindrome.includes( \" \n\non\" ); \n\n// true \n\npalindrome.includes( \" \n\non\", 6 ); \n\n// false","metadata":{"loc":{"lines":{"from":228082,"to":228134}}}}],["1953",{"pageContent":"// true \n\npalindrome.endsWith( \" \n\nno pets\" ); \n\n// true \n\npalindrome.endsWith( \" \n\nno\", 10 ); \n\n// true \n\npalindrome.includes( \" \n\non\" ); \n\n// true \n\npalindrome.includes( \" \n\non\", 6 ); \n\n// false \n\n\nFor all the string search/inspection methods, if you look for an \nempty string \"\", it will either be found at the beginning or the end of \nthe string. \n\n\n\nThese methods will not by default accept a regu¬ \nlar expression for the search string. See “Regular \nExpression Symbols” on page 208 in Chapter 7 \nfor information about disabling the isRegExp \ncheck that is performed on this first argument. \n\n\n196 | Chapter 6: API Additions \n\n\n\n\nReview \n\nES6 adds many extra API helpers on the various built-in native \nobjects: \n\n• Array adds of (..) and f rom(..) static functions, as well as \nprototype functions like copyWithin(..) and fill(..). \n\n• Object adds static functions like is(..) and asstgn(..). \n\n• Math adds static functions like acosh(..) and clz32(..).","metadata":{"loc":{"lines":{"from":228134,"to":228189}}}}],["1954",{"pageContent":"• Object adds static functions like is(..) and asstgn(..). \n\n• Math adds static functions like acosh(..) and clz32(..). \n\n• Number adds static properties like Number.EPSILON, as well as \nstatic functions like Number.isFinite(..). \n\n• String adds static functions like String.fromCodePoint(..) \nand String. raw(..), as well as prototype functions like \nrepeat(..) and includes(..). \n\nMost of these additions can be polyfilled (see ES6 Shim), and were \ninspired by utilities in common JS libraries/frameworks. \n\n\nReview | 197 \n\n\n\nCHAPTER 7 \n\n\nMeta Programming \n\n\nMeta programming is programming where the operation targets the \nbehavior of the program itself. In other words, it’s programming the \nprogramming of your program. Yeah, a mouthful, huh?","metadata":{"loc":{"lines":{"from":228189,"to":228216}}}}],["1955",{"pageContent":"Meta programming is programming where the operation targets the \nbehavior of the program itself. In other words, it’s programming the \nprogramming of your program. Yeah, a mouthful, huh? \n\nFor example, if you probe the relationship between one object a and \nanother b— are they [[Prototype]] linked?—using a.isProto \ntype(b), this is commonly referred to as introspection, a form of \nmeta programming. Macros (which don’t exist in JS, yet)—where \nthe code modifies itself at compile time—are another obvious exam¬ \nple of meta programming. Enumerating the keys of an object with a \nfor. .in loop, or checking if an object is an instance of a “class con¬ \nstructor,” are other common meta programming tasks. \n\nMeta programming focuses on one or more of the following: code \ninspecting itself, code modifying itself, or code modifying default \nlanguage behavior so other code is affected.","metadata":{"loc":{"lines":{"from":228216,"to":228231}}}}],["1956",{"pageContent":"Meta programming focuses on one or more of the following: code \ninspecting itself, code modifying itself, or code modifying default \nlanguage behavior so other code is affected. \n\nThe goal of meta programming is to leverage the language’s own \nintrinsic capabilities to make the rest of your code more descriptive, \nexpressive, and/or flexible. Because of the meta nature of meta pro¬ \ngramming, it’s somewhat difficult to put a more precise definition \non it than that. The best way to understand meta programming is to \nsee it through examples. \n\nES6 adds several new forms/features for meta programming on top \nof what JS already had. \n\n\n199 \n\n\n\n\n\nFunction Names \n\nThere are cases where your code may want to introspect on itself \nand ask what the name of some function is. If you ask what a func¬ \ntion’s name is, the answer is surprisingly somewhat ambiguous. \nConsider: \n\nfunction daz() { \n\n// ■■ \n\n} \n\nvar obj = { \n\nfoo: functionQ { \n\n// •• \n\n}. \n\nbar: function baz() { \n\n// •• \n\n}.","metadata":{"loc":{"lines":{"from":228231,"to":228277}}}}],["1957",{"pageContent":"function daz() { \n\n// ■■ \n\n} \n\nvar obj = { \n\nfoo: functionQ { \n\n// •• \n\n}. \n\nbar: function baz() { \n\n// •• \n\n}. \n\nbarn: daz, \nzin() { \n\n// •• \n\n} \n\n}; \n\nIn this previous snippet, “what is the name of obj .fooQ\" is slightly \nnuanced. Is it \"foo\", or undefined? And what about obj .bar() \n—is it named \"bar\" or \"baz\"? Is obj . bani() named \"ban\" or \"daz\"? \nWhat about obj. zln()? \n\nMoreover, what about functions that are passed as callbacks, like: \n\nfunction foo(cb) { \n\n// what is the name of 'cb()' here? \n\nI \n\nfoo( function(){ \n\n// I'm anonymous! \n\nI ); \n\nThere are quite a few ways that functions can be expressed in pro¬ \ngrams, and it’s not always clear and unambiguous what the “name” \nof that function should be. \n\nMore importantly, we need to distinguish whether the “name” of a \nfunction refers to its name property—yes, functions have a property \ncalled nane— or whether it refers to the lexical binding name, such \nas bar in function bar() { ..","metadata":{"loc":{"lines":{"from":228277,"to":228332}}}}],["1958",{"pageContent":"The lexical binding name is what you use for things like recursion: \n\n\n200 | Chapter 7: Meta Programming \n\n\n\nfunction foo(i) { \n\nif (i < 10) return foo( i * 2 ); \n\nreturn i; \n\n} \n\nThe name properly is what you’d use for meta programming pur¬ \nposes, so that’s what we’ll focus on in this discussion. \n\nThe confusion comes because by default, the lexical name a function \nhas (if any) is also set as its name property. Actually, there was no \nofficial requirement for that behavior by the ES5 (and prior) specifi¬ \ncations. The setting of the name property was nonstandard but still \nfairly reliable. As of ES6, it has been standardized. \n\n\n\nIf a function has a name value assigned, that’s \ntypically the name used in stack traces in devel¬ \noper tools. \n\n\nInferences \n\n\nBut what happens to the name property if a function has no lexical \nname?","metadata":{"loc":{"lines":{"from":228334,"to":228369}}}}],["1959",{"pageContent":"Inferences \n\n\nBut what happens to the name property if a function has no lexical \nname? \n\nAs of ES6, there are now inference rules that can determine a sensi¬ \nble name property value to assign a function even if that function \ndoesn’t have a lexical name to use. \n\nConsider: \n\n\nvar abc = function() { \n// ■■ \n\n}; \n\n\nabc.name; // \"abc\" \n\nHad we given the function a lexical name like abc = function \ndef() { .. the name property would of course be \"def\". But in \nthe absence of the lexical name, intuitively the \"abc\" name seems \nappropriate. \n\nHere are other forms that will infer a name (or not) in ES6: \n\n(function(){ .. }); // nane: \n\n(function*! ){ }); // nane: \n\nwindow. foo = function(){ .. }; // nane: \n\nclass Awesome { \n\n\nFunction Names | 201 \n\n\n\n\nconstructorQ { .. } \nfunny() { .. } \n\n\n// name: Awesome \n// name: funny \n\n\nvar c = class Awesome { .. \n\n\n// name: Awesome \n\n\nvar o = { \n\nfoo() { .. }, \n\n*bar() { \n\nbaz: () => { .. }, \nbam: functlon(){ .. }, \nget qux() { .. \nset fuz() { ..","metadata":{"loc":{"lines":{"from":228369,"to":228434}}}}],["1960",{"pageContent":"var c = class Awesome { .. \n\n\n// name: Awesome \n\n\nvar o = { \n\nfoo() { .. }, \n\n*bar() { \n\nbaz: () => { .. }, \nbam: functlon(){ .. }, \nget qux() { .. \nset fuz() { .. \n\n[\"b\" + \"iz\"] \n\nfunctlon(){ .. }, \n[Symbol( \"buz\" )]: \nfunction(){ .. } \n\n\n// name: foo \n// name: bar \n// name: baz \n// name: bam \n// name: get qux \n// name: set fuz \n\n// name: biz \n\n// name: [buz] \n\n\nvar x = o. foo.bind ( o ); // name: bound foo \n\n(function( ){ .. }).bind( o ); // name: bound \n\n\nexport default functionQ { .. } // name: default \n\n\nvar y = new Functlon(); // name: anonymous \n\nvar GeneratorFunctlon = \n\nfunction* (){}. _proto_ .constructor; \n\nvar z = new GeneratorFunctionQ; // name: anonymous \n\nThe name property is not writable by default, but it is configurable, \nmeaning you can use Object.defineProperty( ..) to manually \nchange it if so desired. \n\n\nMeta Properties","metadata":{"loc":{"lines":{"from":228434,"to":228491}}}}],["1961",{"pageContent":"The name property is not writable by default, but it is configurable, \nmeaning you can use Object.defineProperty( ..) to manually \nchange it if so desired. \n\n\nMeta Properties \n\nIn “new.target” on page 143 in Chapter 3, we introduced a concept \nnew to JS in ES6: the meta property. As the name suggests, meta \nproperties are intended to provide special meta information in the \nform of a property access that would otherwise not have been possi¬ \nble. \n\nIn the case of new. target, the keyword new serves as the context for \na property access. Clearly new is itself not an object, which makes \nthis capability special. However, when new.target is used inside a \nconstructor call (a function/method invoked with new), new becomes \na virtual context, so that new.target can refer to the target con¬ \nstructor that new invoked. \n\n\n202 | Chapter 7: Meta Programming","metadata":{"loc":{"lines":{"from":228491,"to":228512}}}}],["1962",{"pageContent":"202 | Chapter 7: Meta Programming \n\n\n\n\nThis is a clear example of a meta programming operation, as the \nintent is to determine from inside a constructor call what the origi¬ \nnal new target was, generally for the purposes of introspection \n(examining typing/structure) or static property access. \n\nFor example, you may want to have different behavior in a construc¬ \ntor depending on if it’s directly invoked or invoked via a child class: \n\nclass Parent { \n\nconstructor/) { \n\nIf (new. target === Parent) { \n\nconsole. log( \"Parent instantiated\" ); \n\n} \n\nelse { \n\nconsole. log( \"A child instantiated\" ); \n\n} \n\n} \n\n} \n\nclass Child extends Parent {} \n\nvar a = new Parent/); \n\n// Parent instantiated \n\nvar b = new Child/); \n\n// A child instantiated \n\nThere’s a slight nuance here, which is that the constructor /) inside \nthe Parent class definition is actually given the lexical name of the \nclass (Parent), even though the syntax implies that the class is a sep¬ \narate entity from the constructor.","metadata":{"loc":{"lines":{"from":228512,"to":228558}}}}],["1963",{"pageContent":"As with all meta programming techniques, be \ncareful of creating code that’s too clever for your \nfuture self or others maintaining your code to \nunderstand. Use these tricks with caution. \n\n\nWell-Known Symbols \n\nIn “Symbols” on page 80 in Chapter 2, we covered the new ES6 \nprimitive type symbol. In addition to symbols you can define in \nyour own program, JS predefines a number of built-in symbols, \nreferred to as Well-Known Symbols (WKS). \n\n\nWell-Known Symbols | 203 \n\n\n\n\n\n\nThese symbol values are defined primarily to expose special meta \nproperties that are being exposed to your JS programs to give you \nmore control over JS’s behavior. \n\nWe’ll briefly introduce each and discuss their purpose. \n\nSymbol.iterator \n\nIn Chapters 2 and 3, we introduced and used the @@iterator sym¬ \nbol, automatically used by ... spreads and for. .of loops. We also \nsaw @@iterator as defined on the new ES6 collections as defined in \nChapter 5.","metadata":{"loc":{"lines":{"from":228562,"to":228594}}}}],["1964",{"pageContent":"Symbol.iterator represents the special location (property) on any \nobject where the language mechanisms automatically look to find a \nmethod that will construct an iterator instance for consuming that \nobjects values. Many objects come with a default one defined. \n\nHowever, we can define our own iterator logic for any object value \nby setting the Symbol.iterator property, even if that’s overriding \nthe default iterator. The meta programming aspect is that we are \ndefining behavior that other parts of JS (namely, operators and loop¬ \ning constructs) use when processing an object value we define. \n\nConsider: \n\nvar arr = [4,5, 6,7,8, 9]; \n\nfor (var v of arr) { \nconsole. log( v ); \n\n} \n\n// 4 5 6 7 8 9 \n\n// define iterator that only produces values \n// fron odd indexes \narr[Symbol.iterator] = function*!) { \nvar idx = 1; \ndo { \n\nyield thisjidx]; \n\n} while ((idx += 2) < this. length); \n\n}; \n\n\nfor (var v of arr) { \nconsole. log( v ); \n\n} \n\n//579 \n\n\n204 | Chapter 7: Meta Programming","metadata":{"loc":{"lines":{"from":228596,"to":228639}}}}],["1965",{"pageContent":"yield thisjidx]; \n\n} while ((idx += 2) < this. length); \n\n}; \n\n\nfor (var v of arr) { \nconsole. log( v ); \n\n} \n\n//579 \n\n\n204 | Chapter 7: Meta Programming \n\n\n\n\nSymbol.toStringTag and Symbol.haslnstance \n\nOne of the most common meta programming tasks is to introspect \non a value to find out what kind it is, usually to decide what opera¬ \ntions are appropriate to perform on it. With objects, the two most \ncommon inspection techniques are toStringQ and instanceof. \n\nConsider: \n\nfunction Foo() {} \nvar a = new Foo(); \n\na.toStringQ; // [object Object] \n\na instanceof Foo; // true \n\nAs of ES6, you can control the behavior of these operations: \n\nfunction Foo(greeting) { \n\nthis. greeting = greeting; \n\n} \n\nFoo.prototype[Symbol.toStringTag] = \"Foo\"; \n\nObject. defineProperty( Foo, Symbol. haslnstance, { \nvalue: function(inst) { \n\nreturn inst.greeting == \"hello\"; \n\n} \n\n} ); \n\nvar a = new Foo( \"hello\" ), \nb = new Foo( \"world\" ); \n\nb[Symbol.toStringTag] = \"cool\"; \n\n\na.toStringQ; \nString( b );","metadata":{"loc":{"lines":{"from":228639,"to":228701}}}}],["1966",{"pageContent":"return inst.greeting == \"hello\"; \n\n} \n\n} ); \n\nvar a = new Foo( \"hello\" ), \nb = new Foo( \"world\" ); \n\nb[Symbol.toStringTag] = \"cool\"; \n\n\na.toStringQ; \nString( b ); \n\n\n// [object Foo] \n// [object cool] \n\n\na instanceof Foo; // true \n\nb instanceof Foo; // false \n\nThe @@toStringTag symbol on the prototype (or instance itself) \nspecifies a string value to use in the [object _] stringification. \n\nThe @@haslnstance symbol is a method on the constructor function \nwhich receives the instance object value and lets you decide by \nreturning true or false if the value should be considered an \ninstance or not. \n\n\nWell-Known Symbols | 205 \n\n\n\n\n\n\n\nTo set @@haslnstance on a function, you must \nuse Object.defineProperty( ..), as the default \none on Function.prototype is writable: \nfalse. See the this & Object Prototypes title of \nthis series for more information. \n\n\nSymbol.species","metadata":{"loc":{"lines":{"from":228701,"to":228749}}}}],["1967",{"pageContent":"Symbol.species \n\nIn “Classes” on page 135 in Chapter 3, we introduced the @@species \nsymbol, which controls which constructor is used by built-in meth¬ \nods of a class that needs to spawn new instances. \n\nThe most common example is when subclassing Array and wanting \nto define which constructor (Array(..) or your subclass) inherited \nmethods like slice(..) should use. By default, slice(..) called on \nan instance of a subclass of Array would produce a new instance of \nthat subclass, which is frankly what you’ll likely often want. \n\nHowever, you can meta program by overriding a class’s default \n@@species definition: \n\nclass Cool { \n\n// defer '@(dspecies' to derived constructor \n\nstatic get [Symbol. speciesJQ { return this; } \n\nagainQ { \n\nreturn new this.constructor[Symbol.species](); \n\n} \n\n} \n\nclass Fun extends Cool {} \n\nclass Awesome extends Cool { \n\n// force '@@species' to be parent constructor \nstatic get [Symbol. speciesJQ { return Cool; } \n\n} \n\nvar a = new Fun(),","metadata":{"loc":{"lines":{"from":228749,"to":228787}}}}],["1968",{"pageContent":"} \n\n} \n\nclass Fun extends Cool {} \n\nclass Awesome extends Cool { \n\n// force '@@species' to be parent constructor \nstatic get [Symbol. speciesJQ { return Cool; } \n\n} \n\nvar a = new Fun(), \n\nb = new Awesome Q, \nc = a.again(), \nd = b. againQ; \n\nc instanceof Fun; // true \n\nd instanceof Awesome; // false \n\nd instanceof Cool; // true \n\nThe Symbol.species setting defaults on the built-in native con¬ \nstructors to the return this behavior as illustrated in the previous \n\n\n206 | Chapter 7: Meta Programming \n\n\n\n\n\n\nsnippet in the Cool definition. It has no default on user classes, but \nas shown that behavior is easy to emulate. \n\nIf you need to define methods that generate new instances, use the \nmeta programming of the new this, constructor [Symbol, spe \ncles] (..) pattern instead of the hard-wiring of new this. construe \ntor(..) or new XYZ(..). Derived classes will then be able to \ncustomize Symbol.species to control which constructor vends \nthose instances. \n\nSymbol.toPrimitive","metadata":{"loc":{"lines":{"from":228787,"to":228833}}}}],["1969",{"pageContent":"Symbol.toPrimitive \n\nIn the Types & Grammar title of this series, we discussed the ToPrl \nmltlve abstract coercion operation, which is used when an object \nmust be coerced to a primitive value for some operation (such as == \ncomparison or + addition). Prior to ES6, there was no way to control \nthis behavior. \n\nAs of ES6, the @@toPrimitive symbol as a property on any object \nvalue can customize that ToPrlmltlve coercion by specifying a \nmethod. \n\nConsider: \n\nvar arr = [1,2,3,4, 5]; \n\narr + 10; // 1,2,3,4,510 \n\narr[Symbol.toPrimitive] = function(hint) { \n\nif (hint == \"default\" || hint == \"number\") { \n\n// sun all numbers \n\nreturn this.reduce( function(acc,curr){ \nreturn acc + curr; \n\n}. 0 ); \n\n} \n\n}; \n\n\narr + 10; // 25","metadata":{"loc":{"lines":{"from":228833,"to":228867}}}}],["1970",{"pageContent":"if (hint == \"default\" || hint == \"number\") { \n\n// sun all numbers \n\nreturn this.reduce( function(acc,curr){ \nreturn acc + curr; \n\n}. 0 ); \n\n} \n\n}; \n\n\narr + 10; // 25 \n\nThe Symbol.toPrimitive method will be provided with a hint of \n\"string\", \"number\", or \"default\" (which should be interpreted as \n\"number\"), depending on what type the operation invoking ToPrimi \ntive is expecting. In the previous snippet, the additive + operation \nhas no hint (\"default\" is passed). A multiplicative * operation \nwould hint \"number\" and a String(arr) would hint \"string\". \n\n\nWell-Known Symbols | 207","metadata":{"loc":{"lines":{"from":228867,"to":228891}}}}],["1971",{"pageContent":"Well-Known Symbols | 207 \n\n\n\n\n\nThe == operator will invoke the ToPrimitive \noperation with no hint—the @@toPrimitive \nmethod, if any is called with hint \"default\" — \non an object if the other value being compared is \nnot an object. However, if both comparison val¬ \nues are objects, the behavior of == is identical to \n===, which is that the references themselves are \ndirectly compared. In this case, @@toPrimitive \nis not invoked at all. See the Types & Grammar \ntitle of this series for more information about \ncoercion and the abstract operations. \n\n\nRegular Expression Symbols \n\nThere are four well-known symbols that can be overridden for regu¬ \nlar expression objects, which control how those regular expressions \nare used by the four corresponding String. prototype functions of \nthe same name:","metadata":{"loc":{"lines":{"from":228891,"to":228915}}}}],["1972",{"pageContent":"• @@match: The Symbol.natch value of a regular expression is the \nmethod used to match all or part of a string value with the given \nregular expression. It’s used by String .prototype.match( ..) if \nyou pass it a regular expression for the pattern matching. \n\nThe default algorithm for matching is laid out in section 21.2.5.6 of \nthe ES6 specification. You could override this default algorithm and \nprovide extra regex features, such as look-behind assertions.","metadata":{"loc":{"lines":{"from":228917,"to":228924}}}}],["1973",{"pageContent":"Symbol.match is also used by the isRegExp abstract operation (see \nthe note in “String Inspection Functions” on page 196 in Chapter 6) \nto determine if an object is intended to be used as a regular expres¬ \nsion. To force this check to fail for an object so it’s not treated as a \nregular expression, set the Symbol. match value to false (or some¬ \nthing falsy). * @@replace: The Symbol.replace value of a regular \nexpression is the method used by String.prototype. replace(..) \nto replace within a string one or all occurrences of character sequen¬ \nces that match the given regular expression pattern. \n\nThe default algorithm for replacing is laid out in section 21.2.5.8 of \nthe ES6 specification. \n\nOne cool use for overriding the default algorithm is to provide addi¬ \ntional replacer argument options, such as supporting \n\"abaca\".replace(/a/g,[1,2,3] ) producing \"Ib2c3\" by consum- \n\n\n208 | Chapter 7: Meta Programming","metadata":{"loc":{"lines":{"from":228926,"to":228944}}}}],["1974",{"pageContent":"208 | Chapter 7: Meta Programming \n\n\n\n\ning the iterable for successive replacement values. * @@search: The \nSymbol.search value of a regular expression is the method used by \nString.prototype.search(..) to search for a substring within \nanother string as matched by the given regular expression. \n\nThe default algorithm for searching is laid out in section 21.2.5.9 of \nthe ES6 specification. * @@split: The Symbol. split value of a regu¬ \nlar expression is the method used by String .prototype. spllt(..) \nto split a string into substrings at the location(s) of the delimiter as \nmatched by the given regular expression. \n\nThe default algorithm for splitting is laid out in section 21.2.5.11 of \nthe ES6 specification.","metadata":{"loc":{"lines":{"from":228944,"to":228961}}}}],["1975",{"pageContent":"The default algorithm for splitting is laid out in section 21.2.5.11 of \nthe ES6 specification. \n\nOverriding the built-in regular expression algorithms is not for the \nfaint of heart! JS ships with a highly optimized regular expression \nengine, so your own user code will likely be a lot slower. This kind of \nmeta programming is neat and powerful, but it should only be used \nin cases where it’s really necessary or beneficial. \n\nSymbol.isConcatSpreadable \n\nThe @@lsConcatSpreadable symbol can be defined as a boolean \nproperty (Symbol.isConcatSpreadable) on any object (like an array \nor other iterable) to indicate if it should be spread out if passed to an \narray concat(..). \n\nConsider: \n\nvar a = [1,2,3], \nb = [4,5,6]; \n\nbfSymbol.isConcatSpreadable] = false; \n\n[ ]. concat( a, b ); // [1,2,3, [4,5,6]] \n\nSymbol.unscopables","metadata":{"loc":{"lines":{"from":228961,"to":228986}}}}],["1976",{"pageContent":"Consider: \n\nvar a = [1,2,3], \nb = [4,5,6]; \n\nbfSymbol.isConcatSpreadable] = false; \n\n[ ]. concat( a, b ); // [1,2,3, [4,5,6]] \n\nSymbol.unscopables \n\nThe @@unscopables symbol can be defined as an object property \n(Symbol.unscopables) on any object to indicate which properties \ncan and cannot be exposed as lexical variables in a with statement. \n\nConsider: \n\nvar o = { a: 1, b:2, c:3 }, \na = 10, b = 20, c = 30; \n\n\nWell-Known Symbols | 209 \n\n\n\n\n\no[Symbol.unscopables] = { \na: false, \nb: true, \nc: false \n\n}; \n\n\nwith (o) { \n\nconsole. log( a, b, c ); // 1 26 3 \n\n} \n\nA true in the @@unscopables object indicates the property should \nbe unscopable, and thus filtered out from the lexical scope variables, \nfalse means it’s OK to be included in the lexical scope variables.","metadata":{"loc":{"lines":{"from":228986,"to":229029}}}}],["1977",{"pageContent":"The with statement is disallowed entirely in \nstrict mode, and as such should be considered \ndeprecated from the language. Don’t use it. See \nthe Scope & Closures title of this series for more \ninformation. Because with should be avoided, \nthe @@unscopables symbol is also moot. \n\n\nProxies \n\nOne of the most obviously meta programming features added to \nES6 is the Proxy feature. \n\nA proxy is a special kind of object you create that “wraps”—or sits in \nfront of—another normal object. You can register special handlers \n(aka traps) on the proxy object, which are called when various oper¬ \nations are performed against the proxy. These handlers have the \nopportunity to perform extra logic in addition to forwarding the \noperations on to the original target/wrapped object. \n\nOne example of the kind of trap handler you can define on a proxy \nis get that intercepts the [ [Get] ] operation—performed when you \ntry to access a property on an object. Consider: \n\nvar obj = { a: 1 }, \nhandlers = {","metadata":{"loc":{"lines":{"from":229033,"to":229058}}}}],["1978",{"pageContent":"var obj = { a: 1 }, \nhandlers = { \n\nget(target,key,context) { \n\n// note: target ==- obj, \n\n// context === pobj \n\nconsole. log( \"accessing: \", key ); \n\nreturn Reflect. get( \n\ntarget, key, context \n\n); \n\n} \n\n\n210 | Chapter 7: Meta Programming \n\n\n\n\n\n}. \n\npobj = new Proxy( obj, handlers ); \n\n\nobj .a; \n\n// 1 \n\npobj .a; \n\n// accessing: a \n\n// 1 \n\nWe declare a get(..) handler as a named method on the handler \nobject (second argument to Proxy(..)), that receives a reference to \nthe target object (obj), the key property name (\"a\"), and the self/ \nreceive r/proxy (pobj). \n\nAfter the console.log(..) tracing statement, we “forward” the \noperation onto obj via Reflect.get(..We will cover the Reflect \nAPI in the next section, but note that each available proxy trap has a \ncorresponding Reflect function of the same name.","metadata":{"loc":{"lines":{"from":229058,"to":229107}}}}],["1979",{"pageContent":"These mappings are symmetric on purpose. The proxy handlers \neach intercept when a respective meta programming task is per¬ \nformed, and the Reflect utilities each perform the respective meta \nprogramming task on an object. Each proxy handler has a default \ndefinition that automatically calls the corresponding Reflect utility. \nYou will almost certainly use both Proxy and Reflect in tandem. \n\nHere’s a list of handlers you can define on a proxy for a target object/ \nfunction, and how/when they are triggered: \n\nget(..) \n\nVia [[Get]], a property is accessed on the proxy \n(Reflect.get(..), . property operator, or [ .. ] property \noperator) \n\nset(..) \n\nVia [[Set]], a property value is set on the proxy \n(Reflect.set(..), the = assignment operator, or destructuring \nassignment if it targets an object property) \n\ndeleteProperty(..) \n\nVia [[Delete]], a property is deleted from the proxy \n(Reflect.deleteProperty(..) or delete) \n\n\nProxies | 211 \n\n\n\n\n\napply (..) (if target is a function)","metadata":{"loc":{"lines":{"from":229109,"to":229143}}}}],["1980",{"pageContent":"deleteProperty(..) \n\nVia [[Delete]], a property is deleted from the proxy \n(Reflect.deleteProperty(..) or delete) \n\n\nProxies | 211 \n\n\n\n\n\napply (..) (if target is a function) \n\nVia [[Call]], the proxy is invoked as a normal function/ \nmethod (Reflect. apply(..), call(..), apply(..or the (..) \ncall operator) \n\nconstruct(..) (if target is a constructor function) \n\nVia [ [Construct] ], the proxy is invoked as a constructor func¬ \ntion (Reflect.construct(..) or new) \n\ngetOwnPropertyDescrlptor(..) \n\nVia [[GetOwnProperty]], a property descriptor is retrieved \nfrom the proxy (Object.getOwnPropertyDescriptor(..) or \nReflect.getOwnPropertyDescriptor(..)) \n\ndefineProperty(..) \n\nVia [ [DefineOwnProperty] ], a property descriptor is set on the \nproxy (Object.defineProperty(..) or Reflect.defineProp \nerty(..)) \n\ngetPrototypeOf(..) \n\nVia [[GetPrototypeOf]], the [[Prototype]] of the proxy is \nretrieved (Object.getPrototypeOf(..), Reflect.getPrototy","metadata":{"loc":{"lines":{"from":229143,"to":229181}}}}],["1981",{"pageContent":"getPrototypeOf(..) \n\nVia [[GetPrototypeOf]], the [[Prototype]] of the proxy is \nretrieved (Object.getPrototypeOf(..), Reflect.getPrototy \n\npeOf(..), _proto_, Object#isPrototypeOf(..), or Instan \n\nceof) \n\nsetPrototypeOf(..) \n\nVia [ [SetPrototypeOf ] ], the [ [Prototype] ] of the proxy is set \n(Object.setPrototypeOf(..), Reflect.setPrototypeOf(..), \nor_proto_) \n\npreventExtenslons(..) \n\nVia [ [PreventExtensions] ], the proxy is made non-extensible \n(Object.preventExtenslons(..) or Reflect.preventExten \nsions(..)) \n\nisExtensible(..) \n\nVia [ [IsExtensible] ], the extensibility of the proxy is probed \n(Object.isExtensible(..) or Reflect.isExtenslble(..)) \n\nownKeys(..) \n\nVia [ [OwnPropertyKeys] ], the set of owned properties and/or \nowned symbol properties of the proxy is retrieved \n(Object.keys(..), Object.getOwnPropertyNanes(..), \n\n\n212 | Chapter 7: Meta Programming \n\n\n\nObject.getOwnSymbolProperties(..), Reflect.ownKeys(..), \nor JSON.stringify(..)) \n\nenumerate(..)","metadata":{"loc":{"lines":{"from":229181,"to":229221}}}}],["1982",{"pageContent":"212 | Chapter 7: Meta Programming \n\n\n\nObject.getOwnSymbolProperties(..), Reflect.ownKeys(..), \nor JSON.stringify(..)) \n\nenumerate(..) \n\nVia [ [Enumerate] ], an iterator is requested for the proxy’s enu¬ \nmerable owned and “inherited” properties (Reflect.enumer \nate(..) or for..in) \n\n\nhas(..) \n\n\nVia [ [HasProperty] ], the proxy is probed to see if it has an \nowned or “inherited” property (Reflect.has(..), \nObject#hasOwnProperty( ..), or \"prop\" in obj) \n\n\n\nFor more information about each of these meta \nprogramming tasks, see “Reflect API” on page \n224 later in this chapter. \n\n\nIn addition to the notations in the preceding list about actions that \nwill trigger the various traps, some traps are triggered indirectly by \nthe default actions of another trap. For example: \n\nvar handlers = { \n\n\ngetOwnPropertyDescriptor(target.prop) { \nconsole. log( \n\n\"getownPropertyDescriptor\" \n\n); \n\nreturn Object .getOwnPropertyDescriptor( \ntarget, prop \n\n);","metadata":{"loc":{"lines":{"from":229221,"to":229266}}}}],["1983",{"pageContent":"var handlers = { \n\n\ngetOwnPropertyDescriptor(target.prop) { \nconsole. log( \n\n\"getownPropertyDescriptor\" \n\n); \n\nreturn Object .getOwnPropertyDescriptor( \ntarget, prop \n\n); \n\n\ndefineProperty(target.prop,desc){ \nconsole. log( \"defineProperty\" ); \nreturn Object .defineProperty( \ntarget, prop, desc \n\n); \n\n} \n\n}. \n\nproxy = new Proxy( {}, handlers ); \nproxy.a = 2; \n\n// getOwnPropertyDescriptor \n// defineProperty \n\nThe getOwnPropertyDescriptor( ..) and defineProperty(..) \nhandlers are triggered by the default set( ..) handlers steps when \n\n\nProxies | 213 \n\n\n\n\nsetting a property value (whether newly adding or updating). If you \nalso define your own set(..) handler, you may or may not make \nthe corresponding calls against context (not target!), which would \ntrigger these proxy traps. \n\nProxy Limitations","metadata":{"loc":{"lines":{"from":229266,"to":229313}}}}],["1984",{"pageContent":"Proxy Limitations \n\nThese meta programming handlers trap a wide array of fundamental \noperations you can perform against an object. However, there are \nsome operations that are not (yet, at least) available to intercept. \n\nFor example, none of these operations are trapped and forwarded \nfrom pob j proxy to ob j target: \n\nvar obj = { a:l, b : 2 }, \nhandlers = { .. }, \npobj = new Proxy( obj, handlers ); \n\ntypeof obj; \n\nString( obj ); \nobj + \n\nobj == pobj; \nobj === pobj \n\nPerhaps in the future, more of these underlying fundamental opera¬ \ntions in the language will be interceptable, giving us even more \npower to extend JavaScript from within itself.","metadata":{"loc":{"lines":{"from":229313,"to":229336}}}}],["1985",{"pageContent":"Perhaps in the future, more of these underlying fundamental opera¬ \ntions in the language will be interceptable, giving us even more \npower to extend JavaScript from within itself. \n\n\n\nThere are certain invariants —behaviors that \ncannot be overridden—that apply to the use of \nproxy handlers. For example, the result from the \nisExtensible( ..) handler is always coerced to \na boolean. These invariants restrict some of \nyour ability to customize behaviors with proxies, \nbut they do so only to prevent you from creating \nstrange and unusual (or inconsistent) behavior. \nThe conditions for these invariants are compli¬ \ncated so we won’t fully go into them here, but \nthis post does a great job of covering them. \n\n\nRevocable Proxies \n\nA regular proxy always traps for the target object, and cannot be \nmodified after creation—as long as a reference is kept to the proxy, \nproxying remains possible. However, there may be cases where you \n\n\n214 | Chapter 7: Meta Programming","metadata":{"loc":{"lines":{"from":229336,"to":229362}}}}],["1986",{"pageContent":"214 | Chapter 7: Meta Programming \n\n\n\n\nwant to create a proxy that can be disabled when you want to stop \nallowing it to proxy. The solution is to create a revocable proxy: \n\n\nvar obj = { a: 1 }, \nhandters = { \n\nget(target,key,context) { \n\n// note: target === obj, \n\n// context === pobj \n\nconsole. log( \"accessing: \", key ); \n\nreturn target[key]; \n\n} \n\n}, \n\n{ proxy: pobj, revoke: prevoke } = \n\nProxy. revocable( obj, handlers ); \n\n\npobj .a; \n\n// accessing: a \n// 1 \n\n// later: \nprevokeQ; \n\npobj .a; \n\n// TypeError \n\nA revocable proxy is created with Proxy. revocable( ..), which is a \nregular function, not a constructor like Proxy(..). Otherwise, it \ntakes the same two arguments: target and handlers.","metadata":{"loc":{"lines":{"from":229362,"to":229407}}}}],["1987",{"pageContent":"A revocable proxy is created with Proxy. revocable( ..), which is a \nregular function, not a constructor like Proxy(..). Otherwise, it \ntakes the same two arguments: target and handlers. \n\nThe return value of Proxy. revocable( ..) is not the proxy itself as \nwith new Proxy(..). Instead, it’s an object with two properties: \nproxy and revoke —we used object destructuring (see “Destructur¬ \ning” on page 23 in Chapter 2) to assign these properties to pobj and \nprevokeQ variables, respectively. \n\nOnce a revocable proxy is revoked, any attempts to access it (trigger \nany of its traps) will throw a TypeError.","metadata":{"loc":{"lines":{"from":229407,"to":229418}}}}],["1988",{"pageContent":"Once a revocable proxy is revoked, any attempts to access it (trigger \nany of its traps) will throw a TypeError. \n\nAn example of using a revocable proxy might be handing out a \nproxy to another party in your application that manages data in \nyour model, instead of giving them a reference to the real model \nobject itself. If your model object changes or is replaced, you want to \ninvalidate the proxy you handed out so the other party knows (via \nthe errors!) to request an updated reference to the model. \n\n\nProxies | 215 \n\n\n\n\n\nUsing Proxies \n\nThe meta programming benefits of these Proxy handlers should be \nobvious. We can almost fully intercept (and thus override) the \nbehavior of objects, meaning we can extend object behavior beyond \ncore JS in some very powerful ways. We’ll look at a few example pat¬ \nterns to explore the possibilities. \n\nProxy First, Proxy Last","metadata":{"loc":{"lines":{"from":229418,"to":229443}}}}],["1989",{"pageContent":"Proxy First, Proxy Last \n\nAs we mentioned earlier, you typically think of a proxy as “wrap¬ \nping” the target object. In that sense, the proxy becomes the primary \nobject the code interfaces with, and the actual target object remains \nhidden/protected. \n\nYou might do this because you want to pass the object somewhere \nthat can’t be fully “trusted,” and so you need to enforce special rules \naround its access rather than passing the object itself. \n\nConsider: \n\nvar messages = [], \nhandlers = { \n\nget(target,key) { \n\n// string value? \n\nif (typeof target[key] == \"string\") { \n\n// filter out punctuation \nreturn target[key] \n\n. replace( /[ A \\w]/g, ); \n\n} \n\n// pass everything else through \nreturn target[key]; \n\n}. \n\nset(target,key,val) { \n\n// only set unique strings, lowercased \nif (typeof vat == \"string\") { \nvat = val.toLowerCaseQ; \nif (target.indexOf( vat ) == -1) { \ntarget.push( \n\nval.toLowerCaseQ \n\n); \n\n} \n\n} \n\nreturn true; \n\n} \n\n}. \n\nmessages_proxy = \n\nnew Proxy( messages, handlers );","metadata":{"loc":{"lines":{"from":229443,"to":229501}}}}],["1990",{"pageContent":"val.toLowerCaseQ \n\n); \n\n} \n\n} \n\nreturn true; \n\n} \n\n}. \n\nmessages_proxy = \n\nnew Proxy( messages, handlers ); \n\n\n216 | Chapter 7: Meta Programming \n\n\n\n\n// elsewhere: \nmessages_proxy . push( \n\n\"heLLo...\", 42, \"wOrlD!!\" , \"WoRld!! \n\n); \n\n\nnessages_proxy.forEach ( function (val){ \nconsole. log(val); \n\n} ); \n\n// hello world \n\nmessages. forEach( functxon(val){ \nconsole. log(val); \n\n} ); \n\n// hello... world!! \n\nI call this proxy first design, as we interact first (primarily, entirely) \nwith the proxy. \n\nWe enforce some special rules on interacting with messages_proxy \nthat aren’t enforced for messages itself. We only add elements if the \nvalue is a string and is also unique; we also lowercase the value. \nWhen retrieving values from messages_proxy, we filter out any \npunctuation in the strings.","metadata":{"loc":{"lines":{"from":229501,"to":229554}}}}],["1991",{"pageContent":"Alternatively, we can completely invert this pattern, where the target \ninteracts with the proxy instead of the proxy interacting with the \ntarget. Thus, code really only interacts with the main object. The \neasiest way to accomplish this fallback is to have the proxy object in \nthe [ [Prototype] ] chain of the main object. \n\nConsider: \n\nvar handlers = { \n\nget(target,key,context) { \nreturn functionQ { \n\ncontext.speak(key + \n\n}; \n\n} \n\n}, \n\ncatchall = new Proxy( {}, handlers ), \ngreeter = { \n\nspeak(who = \"someone\") { \n\nconsole. log( \"hello\", who ); \n\n} \n\n}; \n\n\n// set up 'greeter' to fall back to 'catchall' \nObject.setPrototypeOf( greeter, catchall ); \n\n\nProxies | 217 \n\n\n\n\ngreeter . speak( ); // hello someone \n\ngreeter . speak( \"world\" ); // hello world \n\ngreeter.everyone(); // hello everyone!","metadata":{"loc":{"lines":{"from":229556,"to":229602}}}}],["1992",{"pageContent":"Proxies | 217 \n\n\n\n\ngreeter . speak( ); // hello someone \n\ngreeter . speak( \"world\" ); // hello world \n\ngreeter.everyone(); // hello everyone! \n\nWe interact directly with greeter instead of catchall. When we \ncall speak(. .), it’s found on greeter and used directly. But when \nwe try to access a method like everyone(), that function doesn’t \nexist on greeter. \n\nThe default object property behavior is to check up the [[Proto \ntype] ] chain (see the this & Object Prototypes title of this series), so \ncatchall is consulted for an everyone property. The proxy get() \nhandler then kicks in and returns a function that calls speak ( .. ) \nwith the name of the property being accessed (\"everyone\"). \n\nI call this pattern proxy last, as the proxy is used only as a last resort. \n\n\"No Such Property/Method\"","metadata":{"loc":{"lines":{"from":229602,"to":229626}}}}],["1993",{"pageContent":"I call this pattern proxy last, as the proxy is used only as a last resort. \n\n\"No Such Property/Method\" \n\nA common complaint about JS is that objects aren’t by default very \ndefensive in the situation where you try to access or set a property \nthat doesn’t already exist. You may wish to predefine all the proper¬ \nties/methods for an object, and have an error thrown if a nonexis¬ \ntent property name is subsequently used. \n\nWe can accomplish this with a proxy, either in proxy first or proxy \nlast design. Let’s consider both. \n\nvar obj = { \na: 1, \nfoo() { \n\nconsole. log( \"a:\", this. a ); \n\n} \n\n}, \n\nhandlers = { \n\nget(target,key,context) { \n\nIf (Reflect. has( target, key )) { \nreturn Reflect. get( \n\ntarget, key, context \n\n); \n\n} \n\nelse { \n\nthrow \"No such property/method!\" ; \n\n} \n\n}. \n\nset(target,key,val,context) { \n\nIf (Reflect. has( target, key )) { \nreturn Reflect. set( \n\n\n218 | Chapter 7: Meta Programming \n\n\n\n\ntarget, key, val, context \n\n\n); \n\n} \n\nelse {","metadata":{"loc":{"lines":{"from":229626,"to":229688}}}}],["1994",{"pageContent":"} \n\n}. \n\nset(target,key,val,context) { \n\nIf (Reflect. has( target, key )) { \nreturn Reflect. set( \n\n\n218 | Chapter 7: Meta Programming \n\n\n\n\ntarget, key, val, context \n\n\n); \n\n} \n\nelse { \n\nthrow \"No such property/method!\" ; \n\n} \n\n} \n\n}. \n\npobj = new Proxy( obj, handlers ); \npobj .a = 3; \n\npobj .foo(); // a: 3 \n\npobj.b = 4; // Error: No such property/nethod! \n\npobj.barQ; // Error: No such property/nethod! \n\nFor both get( ..) and set( ..we only forward the operation if the \ntarget object’s property already exists; an error is thrown otherwise. \nThe proxy object (pobj) is the main object code should interact \nwith, as it intercepts these actions to provide the protections. \n\nNow, let’s consider inverting with proxy last design: \n\nvar handlers = { \nget() { \n\nthrow \"No such property/nethod!\"; \n\n}. \n\nset( ) { \n\nthrow \"No such property/nethod!\"; \n\n} \n\n}. \n\npobj = new Proxy( {}, handlers ), \nobj = { \na: 1, \nfoo() { \n\nconsole. log( \"a:\", this. a ); \n\n} \n\n\n// set up 'obj' to fall back to 'pobj'","metadata":{"loc":{"lines":{"from":229688,"to":229761}}}}],["1995",{"pageContent":"set( ) { \n\nthrow \"No such property/nethod!\"; \n\n} \n\n}. \n\npobj = new Proxy( {}, handlers ), \nobj = { \na: 1, \nfoo() { \n\nconsole. log( \"a:\", this. a ); \n\n} \n\n\n// set up 'obj' to fall back to 'pobj' \n\nObject. setPrototypeOf( obj, pobj ); \n\nobj.a = 3; \n\nobj . foo( ); // a: 3 \n\nobj.b = 4; // Error: No such property/nethod! \n\nobj.barQ; // Error: No such property/nethod! \n\nThe proxy last design here is a fair bit simpler with respect to how \nthe handlers are defined. Instead of needing to intercept the [ [Get] ] \nand [[Set]] operations and only forward them if the target prop- \n\n\nProxies | 219 \n\n\n\nerty exists, we instead rely on the fact that if either [[Get]] or \n[[Set]] get to our pobj fallback, the action has already traversed \nthe whole [ [Prototype] ] chain and not found a matching property. \nWe are free at that point to unconditionally throw the error. Cool, \nhuh? \n\n\nProxy Hacking the [[Prototype]] Chain","metadata":{"loc":{"lines":{"from":229761,"to":229807}}}}],["1996",{"pageContent":"Proxy Hacking the [[Prototype]] Chain \n\nThe [ [Get] ] operation is the primary channel by which the [ [Proto \ntype] ] mechanism is invoked. When a property is not found on the \nimmediate object, [[Get]] automatically hands off the operation to \nthe [[Prototype]] object. \n\nThat means you can use the get( ..) trap of a proxy to emulate or \nextend the notion of this [ [Prototype] ] mechanism. \n\nThe first hack we’ll consider is creating two objects that are circu¬ \nlarly linked via [ [Prototype] ] (or, at least it appears that way!). You \ncannot actually create a real circular [[Prototype]] chain, as the \nengine will throw an error. But a proxy can fake it! \n\nConsider: \n\nvar handlers = { \n\nget(target,key,context) { \n\nIf (Reflect. has( target, key )) { \nreturn Reflect. get( \n\ntarget, key, context \n\n); \n\n} \n\n// fake circular '[[Prototype]]' \n\nelse { \n\nreturn Reflect. get( \ntarget] \n\nSymbol. for( \"[[Prototype]]\" ) \n\n]. \n\nkey, \n\ncontext \n\n); \n\n} \n\n} \n\n}. \n\nobjl = new Proxy( \n\n{","metadata":{"loc":{"lines":{"from":229807,"to":229862}}}}],["1997",{"pageContent":"); \n\n} \n\n// fake circular '[[Prototype]]' \n\nelse { \n\nreturn Reflect. get( \ntarget] \n\nSymbol. for( \"[[Prototype]]\" ) \n\n]. \n\nkey, \n\ncontext \n\n); \n\n} \n\n} \n\n}. \n\nobjl = new Proxy( \n\n{ \n\nname: \"obj-1\", \nfoo() { \n\nconsole. log( \"foo:\", this. name ); \n\n} \n\n\n220 | Chapter 7: Meta Programming \n\n\n\n\n}. \n\nhandlers \n\n\n), \n\nobj2 = Object. asstgn( \n\nObject. create( objl ), \n\n{ \n\nname: \"obj-2\", \nbar() { \n\nconsole. log( \"bar:\", this. name ); \nthis.fooQ; \n\n} \n\n} \n\n); \n\n\n// fake circular '[[Prototype]]' link \nobjl[ Symbol. for( \"[[Prototype]]\" ) ] = obj2; \n\nobjl.barQ; \n\n// bar: obj-1 <-- through proxy faking [[Prototype]] \n// foo: obj-1 <-- 'this' context still preserved \n\nobj2.foo(); \n\n// foo: obj-2 <-- through [[Prototype]]","metadata":{"loc":{"lines":{"from":229862,"to":229942}}}}],["1998",{"pageContent":"objl.barQ; \n\n// bar: obj-1 <-- through proxy faking [[Prototype]] \n// foo: obj-1 <-- 'this' context still preserved \n\nobj2.foo(); \n\n// foo: obj-2 <-- through [[Prototype]] \n\n\n\nWe didn’t need to proxy/forward [ [Set] ] in this \nexample, so we kept things simpler. To be fully \n[ [Prototype] ] emulation compliant, you’d want \nto implement a set(..) handler that searches \nthe [[Prototype]] chain for a matching prop¬ \nerty and respects its descriptor behavior (e.g., \nset, writable). See the this & Object Prototypes \ntitle of this series. \n\n\nIn the previous snippet, obj2 is [[Prototype]] linked to objl by \nvirtue of the Object. create( ..) statement. But to create the reverse \n(circular) linkage, we create property on objl at the symbol location \nSymbol.for( 11 [[Prototype]]\") (see “Symbols” on page 80 in Chap¬ \nter 2). This symbol may look sort of special/magical, but it isn’t. It \njust allows me a conveniently named hook that semantically appears \nrelated to the task I’m performing.","metadata":{"loc":{"lines":{"from":229942,"to":229969}}}}],["1999",{"pageContent":"Then, the proxy’s get( ..) handler looks first to see if a requested \nkey is on the proxy. If not, the operation is manually handed off to \nthe object reference stored in the Symbol.for(\"[[Prototype]]\") \nlocation of target. \n\n\nProxies | 221 \n\n\n\n\n\n\n\nOne important advantage of this pattern is that the definitions of \nobjl and obj2 are mostly not intruded by the setting up of this cir¬ \ncular relationship between them. Although the previous snippet has \nall the steps intertwined for brevity’s sake, if you look closely, the \nproxy handler logic is entirely generic (doesn’t know about objl or \nobj2 specifically). So, that logic could be pulled out into a simple \nhelper that wires them up, like a setCircularPrototypeOf( ..) for \nexample. We’ll leave that as an exercise for the reader.","metadata":{"loc":{"lines":{"from":229971,"to":229992}}}}],["2000",{"pageContent":"Now that we’ve seen how we can use get( ..) to emulate a [ [Proto \ntype] ] link, let’s push the hackery a bit further. Instead of a circular \n[[Prototype]], what about multiple [[Prototype]] linkages (aka \n“multiple inheritance”)? This turns out to be fairly straightforward: \n\n\nvar objl = { \n\nname: \"obj-1\", \nfoo() { \n\nconsole. tog( \"objl.foo:\", this. name ); \n\n}. \n\n}, \n\nobj2 = { \n\nname: \"obj-2\", \nfoo() { \n\nconsole. tog( \"obj2.foo:\", this. name ); \n\n}. \n\nbar( ) { \n\nconsole. tog( \"obj2.bar:\", this. name ); \n\n} \n\n}, \n\nhandlers = { \n\nget(target, key, context) { \n\nif (Reflect. has( target, key )) { \nreturn Reflect. get( \n\ntarget, key, context \n\n); \n\n} \n\n// fake multiple '[[Prototype]]' \n\nelse { \n\nfor (var P of target[ \n\nSymbol. for ( \"[[Prototype]]\" ) \n\n1 ) { \n\nif (Reflect. has( P, key )) { \nreturn Reflect. get( \n\nP, key, context \n\n); \n\n1 \n\n} \n\n} \n\n} \n\n\n222 | Chapter 7: Meta Programming \n\n\n\n\n}. \n\nobj3 = new Proxy( \n\n{ \n\nname: \"obj-3\", \nbaz() { \n\nthis.fooQ; \nthis . bar( ); \n\n} \n\n}.","metadata":{"loc":{"lines":{"from":229994,"to":230086}}}}],["2001",{"pageContent":"P, key, context \n\n); \n\n1 \n\n} \n\n} \n\n} \n\n\n222 | Chapter 7: Meta Programming \n\n\n\n\n}. \n\nobj3 = new Proxy( \n\n{ \n\nname: \"obj-3\", \nbaz() { \n\nthis.fooQ; \nthis . bar( ); \n\n} \n\n}. \n\nhandlers \n\n); \n\n\n// fake multiple '[[Prototype]]' links \nobj3[ Symbol. for( \"[[Prototype]]\" ) ] [ \n\nobjl, obj2 \n\n]; \n\n\nobj3.baz(); \n\n// objl.foo: obj-3 \n// obj2.bar: obj-3 \n\n\n\nAs mentioned in the note after the earlier circu¬ \nlar [[Prototype]] example, we didn’t imple¬ \nment the set(..) handler, but it would be \nnecessary for a complete solution that emulates \n[[Set]] actions as normal [ [Prototype] ]s \nbehave. \n\n\nobj3 is set up to multiple-delegate to both objl and obj2. In \nobj3.baz(), the this.foo() call ends up pulling foo() from objl \n(first-come, first-served, even though there’s also a foo() on obj2). \nIf we reordered the linkage as obj2, objl, the obj2.foo() would \nhave been found and used.","metadata":{"loc":{"lines":{"from":230086,"to":230152}}}}],["2002",{"pageContent":"But as is, the this. bar() call doesn’t find a bar() on objl, so it falls \nover to check obj2, where it finds a match. \n\nobjl and obj 2 represent two parallel [[Prototype]] chains ofobj3. \nobjl and/or obj2 could themselves have normal [[Prototype]] \ndelegation to other objects, or either could themself be a proxy (like \nobj 3 is) that can multiple-delegate. \n\nJust as with the circular [[Prototype]] example earlier, the defini¬ \ntions of objl, obj2, and obj3 are almost entirely separate from the \ngeneric proxy logic that handles the multiple-delegation. It would be \ntrivial to define a utility like setPrototypesOf (..) (notice the “s”!) \n\n\nProxies | 223 \n\n\n\n\n\n\nthat takes a main object and a list of objects to fake the multiple \n[[Prototype]] linkage to. Again, we’ll leave that as an exercise for \nthe reader. \n\nHopefully the power of proxies is now becoming clearer after these \nvarious examples. There are many other powerful meta program¬ \nming tasks that proxies enable. \n\nReflect API","metadata":{"loc":{"lines":{"from":230154,"to":230183}}}}],["2003",{"pageContent":"Hopefully the power of proxies is now becoming clearer after these \nvarious examples. There are many other powerful meta program¬ \nming tasks that proxies enable. \n\nReflect API \n\nThe Reflect object is a plain object (like Math), not a function/ \nconstructor like the other built-in natives. \n\nIt holds static functions that correspond to various meta program¬ \nming tasks you can control. These functions correspond one-to-one \nwith the handler methods (traps) that proxies can define. \n\nSome of the functions will look familiar as functions of the same \nnames on Object: \n\n• Reflect.getOwnPropertyDescriptor(..) \n\n• Reflect.deflneProperty(..) \n\n• Reflect.getPrototypeOf(..) \n\n• Reflect.setPrototypeOf(..) \n\n• Reflect.preventExtenslons(..) \n\n• Reflect.isExtensible(..)","metadata":{"loc":{"lines":{"from":230183,"to":230209}}}}],["2004",{"pageContent":"• Reflect.getOwnPropertyDescriptor(..) \n\n• Reflect.deflneProperty(..) \n\n• Reflect.getPrototypeOf(..) \n\n• Reflect.setPrototypeOf(..) \n\n• Reflect.preventExtenslons(..) \n\n• Reflect.isExtensible(..) \n\nThese utilities in general behave the same as their Object. * counter¬ \nparts. However, one difference is that the Object.* counterparts \nattempt to coerce their first argument (the target object) to an object \nif it’s not already one. The Reflect.* methods simply throw an \nerror in that case. \n\nAn object’s keys can be accessed/inspected using these utilities: \nReflect.ownKeys(..) \n\nReturns the list of all owned keys (not “inherited”), as returned \nby both Object.getOwnPropertyNames(..) and Object.getOwn \nPropertySymbols(..). See “Property Ordering” on page 226 \nfor information about the order of keys. \n\n\n224 | Chapter 7: Meta Programming \n\n\n\n\nReflect.enumerate(..)","metadata":{"loc":{"lines":{"from":230209,"to":230241}}}}],["2005",{"pageContent":"224 | Chapter 7: Meta Programming \n\n\n\n\nReflect.enumerate(..) \n\nReturns an iterator that produces the set of all nonsymbol keys \n(owned and “inherited”) that are enumerable (see the this & \nObject Prototypes title of this series). Essentially, this set of keys \nis the same as those processed by a for.. In loop. See “Property \nOrdering” on page 226 for information about the order of keys. \n\nReflect.has(..) \n\nEssentially the same as the In operator for checking if a prop¬ \nerty is on an object or its [[Prototype]] chain. For example, \nReflect.has(o,\"foo\") essentially performs \"foo\" in o. \n\nFunction calls and constructor invocations can be performed man¬ \nually, separate of the normal syntax (e.g., (..) and new) using these \nutilities: \n\nReflect.apply(..) \n\nFor example, Reflect.apply(foo,thls0bj,[42,\"bar\"]) calls \nthe foo(..) function with thisObj as its this, and passes in the \n42 and \"bar\" arguments. \n\nReflect.construct!•■)","metadata":{"loc":{"lines":{"from":230241,"to":230270}}}}],["2006",{"pageContent":"Reflect.apply(..) \n\nFor example, Reflect.apply(foo,thls0bj,[42,\"bar\"]) calls \nthe foo(..) function with thisObj as its this, and passes in the \n42 and \"bar\" arguments. \n\nReflect.construct!•■) \n\nFor example, Reflect.construct(foo,[42,\"bar\"]) essentially \ncalls new foo(42,\"bar\"). \n\nObject property access, setting, and deletion can be performed man¬ \nually using these utilities: \n\nReflect.get(..) \n\nFor example, Reflect.get(o,\"foo\") retrieves o.foo. \n\nReflect.set(..) \n\nFor example, Reflect.set(o,\"foo\",42) essentially performs \no.foo = 42. \n\nReflect.deleteProperty(..) \n\nFor example, Reflect.deleteProperty(o,\"foo\") essentially \nperforms delete o.foo. \n\nThe meta programming capabilities of Reflect give you program¬ \nmatic equivalents to emulate various syntactic features, exposing \npreviously hidden-only abstract operations. For example, you can \nuse these capabilities to extend features and APIs for domain specific \nlanguages (DSLs). \n\n\nReflect API | 225 \n\n\n\nProperty Ordering","metadata":{"loc":{"lines":{"from":230270,"to":230309}}}}],["2007",{"pageContent":"Reflect API | 225 \n\n\n\nProperty Ordering \n\nPrior to ES6, the order used to list an objects keys/properties was \nimplementation dependent and undefined by the specification. Gen¬ \nerally, most engines have enumerated them in creation order, \nthough developers have been strongly encouraged not to ever rely \non this ordering. \n\nAs of ES6, the order for listing owned properties is now defined \n(ES6 specification, section 9.1.12) by the [ [OwnPropertyKeys] ] \nalgorithm, which produces all owned properties (strings or sym¬ \nbols), regardless of enumerability. This ordering is only guaranteed \nfor Reflect.ownKeys(. .) (and by extension, Object.getOwnProper \ntyNames(.. ) and Object.getOwnPropertySymbols(..)). \n\nThe ordering is: \n\n1. First, enumerate any owned properties that are integer indexes, \nin ascending numeric order. \n\n2. Next, enumerate the rest of the owned string property names in \ncreation order. \n\n3. Finally, enumerate owned symbol properties in creation order. \n\nConsider:","metadata":{"loc":{"lines":{"from":230309,"to":230338}}}}],["2008",{"pageContent":"2. Next, enumerate the rest of the owned string property names in \ncreation order. \n\n3. Finally, enumerate owned symbol properties in creation order. \n\nConsider: \n\nvar o = {}; \n\no[Symbol(\"c\")] = \"yay\"; \no[2] = true; \no [1] = true; \no.b = \"awesome\"; \no.a = \"cool\"; \n\nReflect.ownKeys( o ); // [1, 2, \"b\" , \"a\" ,Synbol(c)] \n\nObject.getOwnPropertyNames( o ); // [1,2, \"b\", \"a\"] \n\nObject. getOwnPropertySymbols( o ); // [Symbol(c)] \n\nOn the other hand, the [ [Enumerate] ] algorithm (ES6 specification, \nsection 9.1.11) produces only enumerable properties, from the tar¬ \nget object as well as its [[Prototype]] chain. It is used by both \nReflect. enumerate( ..) and for..in. The observable ordering is \nimplementation dependent and not controlled by the specification. \n\nBy contrast, Object.keys(. .) invokes the [[OwnPropertyKeys]] \nalgorithm to get a list of all owned keys. However, it filters out non- \nenumerable properties and then reorders the list to match legacy","metadata":{"loc":{"lines":{"from":230338,"to":230367}}}}],["2009",{"pageContent":"226 | Chapter 7: Meta Programming \n\n\n\nimplementation-dependent behavior, specifically with JSON.string \nify(..) and for..in. So, by extension the ordering also matches \nthat of Reflect.enumeratef..). \n\nIn other words, all four mechanisms (Reflect.enumerate(..), \nObject.keys(..), for., in, and JSON. stringifyf..)) will match \nwith the same implementation-dependent ordering, though they \ntechnically get there in different ways. \n\nImplementations are allowed to match these four to the ordering of \n[[OwnPropertyKeys]], but are not required to. Nevertheless, you \nwill likely observe the following ordering behavior from them: \n\nvar o = { a: 1, b: 2 }; \nvar p = Object. create( o ); \np.c = 3; \np.d = 4; \n\nfor (var prop of Reflect.enunerate( p )) { \nconsole. log( prop ); \n\n} \n\n// c d a b \n\nfor (var prop in p) { \nconsole. log( prop ); \n\n} \n\n// c d a b \n\nJSON.stringlfy( p ); \n\n// {\"c\":3,\"d\":4} \n\nObject. keys( p ); \n\n// [\"c\", \"d\"]","metadata":{"loc":{"lines":{"from":230370,"to":230412}}}}],["2010",{"pageContent":"} \n\n// c d a b \n\nfor (var prop in p) { \nconsole. log( prop ); \n\n} \n\n// c d a b \n\nJSON.stringlfy( p ); \n\n// {\"c\":3,\"d\":4} \n\nObject. keys( p ); \n\n// [\"c\", \"d\"] \n\nBoiling this all down: as of ES6, Reflect. ownKeys(..), \nObject.getOwnPropertyNamesf..), and Object.getOwnProperty \nSymbols (..) all have predictable and reliable ordering guaranteed \nby the specification. So it’s safe to build code that relies on this \nordering. \n\nReflect .enumerate! • •), Object .keys(..), and for. .in (as well as \nJSON.stringificationf..) by extension) continue to share an \nobservable ordering with each other, as they always have. But that \nordering will not necessarily be the same as that of Reflect.own \nKeys(..). Care should still be taken in relying on their \nimplementation-dependent ordering. \n\n\nReflect API | 227 \n\n\n\nFeature Testing","metadata":{"loc":{"lines":{"from":230412,"to":230449}}}}],["2011",{"pageContent":"Reflect API | 227 \n\n\n\nFeature Testing \n\nWhat is a feature test? It’s a test you run to determine if a feature is \navailable or not. Sometimes, the test is not just for existence, but for \nconformance to specified behavior—features can exist but be buggy. \n\nThis is a meta programming technique, to test the environment \nyour program runs in to then determine how your program should \nbehave. \n\nThe most common use of feature tests in JS is checking for the exis¬ \ntence of an API and if it’s not present, defining a polyfill (see Chap¬ \nter 1). For example: \n\nif ( INumber.isNaN) { \n\nNumber. IsNaN = function(x) { \nreturn x !== x; \n\n}; \n\n} \n\nThe if statement in this snippet is meta programming: we’re prob¬ \ning our program and its runtime environment to determine if and \nhow we should proceed. \n\nBut what about testing for features that involve new syntax? \n\nYou might try something like: \ntry { \n\na = 0 => {}; \n\nARROW_FUNCS_ENABLED = true; \n\n} \n\ncatch (err) { \n\nARROW_FUNCS_ENABLED = false;","metadata":{"loc":{"lines":{"from":230449,"to":230493}}}}],["2012",{"pageContent":"But what about testing for features that involve new syntax? \n\nYou might try something like: \ntry { \n\na = 0 => {}; \n\nARROW_FUNCS_ENABLED = true; \n\n} \n\ncatch (err) { \n\nARROW_FUNCS_ENABLED = false; \n\n} \n\nUnfortunately, this doesn’t work, because our JS programs are com¬ \npiled. Thus, the engine will choke on the () => {} syntax if it is not \nalready supporting ES6 arrow functions. Having a syntax error in \nyour program prevents it from running, which prevents your pro¬ \ngram from subsequently responding differently if the feature is sup¬ \nported or not. \n\nTo meta program with feature tests around syntax-related features, \nwe need a way to insulate the test from the initial compile step our \nprogram runs through. For instance, if we could store the code for \nthe test in a string, then the JS engine wouldn’t by default try to \ncompile the contents of that string, until we asked it to. \n\n\n228 | Chapter 7: Meta Programming \n\n\n\n\nDid your mind just jump to using eval(..)?","metadata":{"loc":{"lines":{"from":230493,"to":230529}}}}],["2013",{"pageContent":"228 | Chapter 7: Meta Programming \n\n\n\n\nDid your mind just jump to using eval(..)? \n\nNot so fast. See the Scope & Closures title of this series for why \neval(..) is a bad idea. But there’s another option with less down¬ \nsides: the Function(..) constructor. \n\nConsider: \n\ntry { \n\nnew Function( \"( () => {} )\" ); \n\nARROW_FUNCS_ENABLED = true; \n\n} \n\ncatch (err) { \n\nARROW_FUNCS_ENABLED = false; \n\n} \n\nOK, so now we’re meta programming by determining if a feature \nlike arrow functions can compile in the current engine or not. You \nmight then wonder, what would we do with this information? \n\nWith existence checks for APIs, and defining fallback API polyfills, \nthere’s a clear path for what to do with either test success or failure. \nBut what can we do with the information we get from \nARROW_FUNCS_ENABLED being true or false?","metadata":{"loc":{"lines":{"from":230529,"to":230563}}}}],["2014",{"pageContent":"Because the syntax can’t appear in a file if the engine doesn’t support \nthat feature, you can’t just have different functions defined in the file \nwith and without the syntax in question. \n\nWhat you can do is use the test to determine which of a set of JS files \nyou should load. For example, if you had a set of these feature tests \nin a bootstrapper for your JS application, it could then test the envi¬ \nronment to determine if your ES6 code can be loaded and run \ndirectly, or if you need to load a transpiled version of your code (see \nChapter 1). \n\nThis technique is called split delivery. \n\nIt recognizes the reality that your ES6 authored JS programs will \nsometimes be able to entirely run “natively” in ES6+ browsers, but \nother times need transpilation to run in pre-ES6 browsers. If you \nalways load and use the transpiled code, even in the new ES6- \ncompliant environments, you’re running suboptimal code at least \nsome of the time. This is not ideal.","metadata":{"loc":{"lines":{"from":230565,"to":230583}}}}],["2015",{"pageContent":"Split delivery is more complicated and sophisticated, but it repre¬ \nsents a more mature and robust approach to bridging the gap \n\n\nFeature Testing | 229 \n\n\n\nbetween the code you write and the feature support in browsers \nyour programs must run in. \n\nFeatureTests.io \n\nDefining feature tests for all of the ES6+ syntax, as well as the \nsemantic behaviors, is a daunting task you probably don’t want to \ntackle yourself. Because these tests require dynamic compilation \n(new Function (..)), there’s some unfortunate performance cost. \n\nMoreover, running these tests every single time your app runs is \nprobably wasteful, as on average a user’s browser only updates once \nin a several week period at most, and even then, new features aren’t \nnecessarily showing up with every update. \n\nFinally, managing the list of feature tests that apply to your specific \ncode base—rarely will your programs use the entirety of ES6—is \nunruly and error-prone.","metadata":{"loc":{"lines":{"from":230585,"to":230610}}}}],["2016",{"pageContent":"Finally, managing the list of feature tests that apply to your specific \ncode base—rarely will your programs use the entirety of ES6—is \nunruly and error-prone. \n\nFeatureTests.io offers solutions to these frustrations. \n\nYou can load the service’s library into your page, and it loads the lat¬ \nest test definitions and runs all the feature tests. It does so using \nbackground processing with Web Workers, if possible, to reduce the \nperformance overhead. It also uses LocalStorage persistence to cache \nthe results in a way that can be shared across all sites you visit which \nuse the service, which drastically reduces how often the tests need to \nrun on each browser instance. \n\nYou get runtime feature tests in each of your users’ browsers, and \nyou can use those tests results dynamically to serve users the most \nappropriate code (no more, no less) for their environments.","metadata":{"loc":{"lines":{"from":230610,"to":230626}}}}],["2017",{"pageContent":"You get runtime feature tests in each of your users’ browsers, and \nyou can use those tests results dynamically to serve users the most \nappropriate code (no more, no less) for their environments. \n\nMoreover, the service provides tools and APIs to scan your files to \ndetermine what features you need, so you can fully automate your \nsplit delivery build processes. \n\nFeatureTests.io makes it practical to use feature tests for all parts of \nES6 and beyond to make sure that only the best code is ever loaded \nand run for any given environment. \n\nTail Call Optimization (TCO) \n\nNormally, when a function call is made from inside another func¬ \ntion, a second stack frame is allocated to separately manage the vari- \n\n\n230 | Chapter 7: Meta Programming \n\n\n\nabies/state of that other function invocation. Not only does this \nallocation cost some processing time, but it also takes up some extra \nmemory.","metadata":{"loc":{"lines":{"from":230626,"to":230650}}}}],["2018",{"pageContent":"230 | Chapter 7: Meta Programming \n\n\n\nabies/state of that other function invocation. Not only does this \nallocation cost some processing time, but it also takes up some extra \nmemory. \n\nA call stack chain typically has at most 10-15 jumps from one func¬ \ntion to another and another. In those scenarios, the memory usage is \nnot likely any kind of practical problem. \n\nHowever, when you consider recursive programming (a function \ncalling itself repeatedly)—or mutual recursion with two or more \nfunctions calling each other—the call stack could easily be hun¬ \ndreds, thousands, or more levels deep. You can probably see the \nproblems that could cause, if memory usage grows unbounded. \n\nJavaScript engines have to set an arbitrary limit to prevent such pro¬ \ngramming techniques from crashing by running the browser and \ndevice out of memory. That’s why we get the frustrating “RangeEr- \nror: Maximum call stack size exceeded” thrown if the limit is hit.","metadata":{"loc":{"lines":{"from":230650,"to":230671}}}}],["2019",{"pageContent":"The limit of call stack depth is not controlled by \nthe specification. It’s implementation dependent, \nand will vary between browsers and devices. You \nshould never code with strong assumptions of \nexact observable limits, as they may very well \nchange from release to release. \n\n\nCertain patterns of function calls, called tail calls, can be optimized \nin a way to avoid the extra allocation of stack frames. If the extra \nallocation can be avoided, there’s no reason to arbitrarily limit the \ncall stack depth, so the engines can let them run unbounded. \n\nA tail call is a return statement with a function call, where nothing \nhas to happen after the call except returning its value. \n\nThis optimization can only be applied in strict mode. Yet another \nreason to always write all your code as strict! \n\nHere’s a function call that is not in tail position: \n\n\"use strict\"; \n\nfunction foo(x) { \nreturn x * 2; \n\n} \n\nfunction bar(x) { \n\n\nTail Call Optimization (TCO) | 231","metadata":{"loc":{"lines":{"from":230675,"to":230706}}}}],["2020",{"pageContent":"Here’s a function call that is not in tail position: \n\n\"use strict\"; \n\nfunction foo(x) { \nreturn x * 2; \n\n} \n\nfunction bar(x) { \n\n\nTail Call Optimization (TCO) | 231 \n\n\n\n\n// not a tail call \nreturn 1 + foo( x ); \n\n\n} \n\n\nbar( 10 ); \n\n\n// 21 \n\n\n1 + .. has to be performed after the foo(x) call completes, so the \nstate of that bar(..) invocation needs to be preserved. \n\nBut the following snippet demonstrates calls to foo(..) and \nbar(..) where both are in tail position, as they’re the last thing to \nhappen in their code path (other than the return): \n\n\"use strict\"; \n\nfunction foo(x) { \nreturn x * 2; \n\n} \n\nfunction bar(x) { \nx = x + 1; \n\nIf (x > 10) { \n\nreturn foo( x ); \n\n} \n\nelse { \n\nreturn bar( x + 1 ); \n\n} \n\n\n} \n\n\n// 24 \n// 32 \n\n\nbar( 5 ); \nbar( 15 );","metadata":{"loc":{"lines":{"from":230706,"to":230774}}}}],["2021",{"pageContent":"function foo(x) { \nreturn x * 2; \n\n} \n\nfunction bar(x) { \nx = x + 1; \n\nIf (x > 10) { \n\nreturn foo( x ); \n\n} \n\nelse { \n\nreturn bar( x + 1 ); \n\n} \n\n\n} \n\n\n// 24 \n// 32 \n\n\nbar( 5 ); \nbar( 15 ); \n\n\nIn this program, bar( ..) is clearly recursive, but foo( ..) is just a \nregular function call. In both cases, the function calls are in proper \ntail position. The x + 1 is evaluated before the bar(. .) call, and \nwhenever that call finishes, all that happens is the return. \n\nProper Tail Calls (PTC) of these forms can be optimized—called Tail \nCall Optimization (TCO)—so that the extra stack frame allocation is \nunnecessary. Instead of creating a new stack frame for the next func¬ \ntion call, the engine just reuses the existing stack frame. That works \nbecause a function doesn’t need to preserve any of the current state, \nas nothing happens with that state after the PTC.","metadata":{"loc":{"lines":{"from":230774,"to":230816}}}}],["2022",{"pageContent":"TCO means there’s practically no limit to how deep the call stack \ncan be. That trick slightly improves regular function calls in normal \nprograms, but more importantly opens the door to using recursion \n\n\n232 | Chapter 7: Meta Programming \n\n\n\n\nfor program expression even if the call stack could be tens of thou¬ \nsands of calls deep. \n\nWe’re no longer relegated to simply theorizing about recursion for \nproblem solving, but can actually use it in real JavaScript programs! \n\nAs of ES6, all PTC should be optimizable in this way, recursion or \nnot. \n\nTail Call Rewrite \n\nThe hitch, however, is that only PTC can be optimized; non-PTC \nwill still work of course, but will cause stack frame allocation as they \nalways did. You’ll have to be careful about structuring your func¬ \ntions with PTC if you expect the optimizations to kick in. \n\nIf you have a function that’s not written with PTC, you may find the \nneed to manually rearrange your code to be eligible for TCO. \n\nConsider:","metadata":{"loc":{"lines":{"from":230818,"to":230847}}}}],["2023",{"pageContent":"If you have a function that’s not written with PTC, you may find the \nneed to manually rearrange your code to be eligible for TCO. \n\nConsider: \n\n\"use strict\"; \n\nfunction foo(x) { \n\nIf (x <= 1) return 1; \nreturn (x / 2) + foo( x - 1 ); \n\n} \n\nfoo( 123456 ); // RangeError \n\nThe call to foo(x-1) isn’t a PTC because its result has to be added to \n(x / 2) before returning. \n\nHowever, to make this code eligible for TCO in an ES6 engine, we \ncan rewrite it as follows: \n\n\"use strict\"; \n\nvar foo = (functlon(){ \n\nfunction _foo(acc,x) { \n\nIf (x <= 1) return acc; \n\nreturn _foo( (x / 2) + acc, x - 1 ); \n\n} \n\nreturn functlon(x) { \n\nreturn _foo( 1, x ); \n\n}; \n\nHO; \n\nfoo( 123456 ); // 3810376848.5 \n\n\nTail Call Optimization (TCO) | 233 \n\n\n\n\n\nIf you run the previous snippet in an ES6 engine that implements \nTCO, you’ll get the 3810376848.5 answer as shown. However, it’ll \nstill fail with a RangeError in non-TCO engines. \n\nNon-TCO Optimizations","metadata":{"loc":{"lines":{"from":230847,"to":230902}}}}],["2024",{"pageContent":"Non-TCO Optimizations \n\nThere are other techniques to rewrite the code so that the call stack \nisn’t growing with each call. \n\nOne such technique is called trampolining, which amounts to having \neach partial result represented as a function that either returns \nanother partial result function or the final result. Then you can sim¬ \nply loop until you stop getting a function, and you’ll have the result. \nConsider: \n\n\"use strict\"; \n\nfunction trampoline( res ) { \n\nwhile (typeof res == \"function\") { \nres = res(); \n\n} \n\nreturn res; \n\n} \n\nvar foo = (function(){ \n\nfunction _foo(acc,x) { \n\nif (x <= 1) return acc; \nreturn function partial(){ \n\nreturn _foo( (x / 2) + acc, x - 1 ); \n\n}; \n\n} \n\nreturn function(x) { \n\nreturn trampoline( _foo( 1, x ) ); \n\n}; \n\n})(); \n\nfoo( 123456 ); // 3810376848.5 \n\nThis reworking required minimal changes to factor out the recur¬ \nsion into the loop in trampoline(.. ):","metadata":{"loc":{"lines":{"from":230902,"to":230950}}}}],["2025",{"pageContent":"return trampoline( _foo( 1, x ) ); \n\n}; \n\n})(); \n\nfoo( 123456 ); // 3810376848.5 \n\nThis reworking required minimal changes to factor out the recur¬ \nsion into the loop in trampoline(.. ): \n\n1. First, we wrapped the return _foo . . line in the return par \ntialQ { .. function expression. \n\n2. Then we wrapped the _foo(l,x) call in the trampoline( .. ) \ncall. \n\n\n234 | Chapter 7: Meta Programming \n\n\n\n\nThe reason this technique doesn’t suffer the call stack limitation is \nthat each of those inner partial( ..) functions is just returned back \nto the while loop in trampoline( ..), which runs it and then loop \niterates again. In other words, partial(.. ) doesn’t recursively call \nitself, it just returns another function. The stack depth remains con¬ \nstant, so it can run as long as it needs to.","metadata":{"loc":{"lines":{"from":230950,"to":230978}}}}],["2026",{"pageContent":"Trampolining expressed in this way uses the closure that the inner \npartialQ function has over the x and acc variables to keep the \nstate from iteration to iteration. The advantage is that the looping \nlogic is pulled out into a reusable trampoline(.. ) utility function, \nwhich many libraries provide versions of. You can reuse trampo \nline(. .) multiple times in your program with different trampo- \nlined algorithms. \n\nOf course, if you really wanted to deeply optimize (and the reusabil¬ \nity wasn’t a concern), you could discard the closure state and inline \nthe state tracking of acc into just one function’s scope along with a \nloop. This technique is generally called recursion unrolling: \n\n\"use strict\"; \n\nfunction foo(x) { \nvar acc = 1; \nwhile (x > 1) { \n\nacc = (x / 2) + acc; \nx = x - 1; \n\n} \n\nreturn acc; \n\n1 \n\nfoo( 123456 ); // 3810376848.5","metadata":{"loc":{"lines":{"from":230980,"to":231008}}}}],["2027",{"pageContent":"\"use strict\"; \n\nfunction foo(x) { \nvar acc = 1; \nwhile (x > 1) { \n\nacc = (x / 2) + acc; \nx = x - 1; \n\n} \n\nreturn acc; \n\n1 \n\nfoo( 123456 ); // 3810376848.5 \n\nThis expression of the algorithm is simpler to read, and will likely \nperform the best (strictly speaking) of the various forms we’ve \nexplored. That may seem like a clear winner, and you may wonder \nwhy you would ever try the other approaches. \n\nThere are some reasons why you might not want to always manually \nunroll your recursions: \n\n• Instead of factoring out the trampolining (loop) logic for \nreusability, we’ve inlined it. This works great when there’s only \none example to consider, but as soon as you have a half dozen or \nmore of these in your program, there’s a good chance you’ll \n\n\nTail Call Optimization (TCO) | 235 \n\n\n\n\nwant some reusability to keep things shorter and more manage¬ \nable.","metadata":{"loc":{"lines":{"from":231008,"to":231045}}}}],["2028",{"pageContent":"Tail Call Optimization (TCO) | 235 \n\n\n\n\nwant some reusability to keep things shorter and more manage¬ \nable. \n\n• The example here is deliberately simple enough to illustrate the \ndifferent forms. In practice, there are many more complications \nin recursion algorithms, such as mutual recursion (more than \njust one function calling itself). \n\nThe farther you go down this rabbit hole, the more manual and \nintricate the unrolling optimizations are. You’ll quickly lose all the \nperceived value of readability. The primary advantage of recursion, \neven in the PTC form, is that it preserves the algorithm readability, \nand offloads the performance optimization to the engine. \n\nIf you write your algorithms with PTC, the ES6 engine will apply \nTCO to let your code run in constant stack depth (by reusing stack \nframes). You get the readability of recursion with most of the perfor¬ \nmance benefits and no limitations of run length. \n\nMeta? \n\nWhat does TCO have to do with meta programming?","metadata":{"loc":{"lines":{"from":231045,"to":231071}}}}],["2029",{"pageContent":"Meta? \n\nWhat does TCO have to do with meta programming? \n\nAs we covered in “Feature Testing” on page 228 earlier, you can \ndetermine at runtime what features an engine supports. This \nincludes TCO, though determining it is quite brute force. Consider: \n\n\"use strict\"; \n\ntry { \n\n(function foo(x){ \n\nif (x < 5E5) return foo( x + 1 ); \n\n})( i ); \n\nTCO_ENABLED = true; \n\n} \n\ncatch (err) { \n\nTCO_ENABLED = false; \n\n} \n\nIn a non-TCO engine, the recursive loop will fail out eventually, \nthrowing an exception caught by the try..catch. Otherwise, the \nloop completes easily thanks to TCO. \n\nYuck, right? \n\nBut how could meta programming around the TCO feature (or \nrather, the lack thereof) benefit our code? The simple answer is that \n\n\n236 | Chapter 7: Meta Programming \n\n\n\nyou could use such a feature test to decide to load a version of your \napplication’s code that uses recursion, or an alternative one that’s \nbeen converted/transpiled to not need recursion. \n\nSelf-Adjusting Code","metadata":{"loc":{"lines":{"from":231071,"to":231117}}}}],["2030",{"pageContent":"Self-Adjusting Code \n\nBut here’s another way of looking at the problem: \n\n\"use strict\"; \n\nfunction foo(x) { \n\nfunction _foo() { \nif (x > 1) { \n\nacc = acc + (x / 2); \nx = x - 1; \nreturn _foo(); \n\n} \n\n} \n\nvar acc = 1; \n\nwhile (x > 1) { \ntry { \n\n_foo(); \n\n} \n\ncatch (err) { } \n\n} \n\nreturn acc; \n\n} \n\nfoo( 123456 ); // 3810376848.5 \n\nThis algorithm works by attempting to do as much of the work with \nrecursion as possible, but keeping track of the progress via scoped \nvariables x and acc. If the entire problem can be solved with recur¬ \nsion without an error, great. If the engine kills the recursion at some \npoint, we simply catch that with the try.. catch and then try again, \npicking up where we left off. \n\nI consider this a form of meta programming in that you are probing \nduring runtime the ability of the engine to fully (recursively) finish \nthe task, and working around any (non-TCO) engine limitations \nthat may restrict you.","metadata":{"loc":{"lines":{"from":231117,"to":231165}}}}],["2031",{"pageContent":"At first (or even second!) glance, my bet is this code seems much \nuglier to you compared to some of the earlier versions. It also runs a \nfair bit slower (on larger runs in a non-TCO environment). \n\n\nTail Call Optimization (TCO) | 237 \n\n\n\nThe primary advantage, other than it being able to complete any size \ntask even in non-TCO engines, is that this “solution” to the recur¬ \nsion stack limitation is much more flexible than the trampolining or \nmanual unrolling techniques shown previously. \n\nEssentially, _foo() in this case is a sort of stand-in for practically \nany recursive task, even mutual recursion. The rest is the boilerplate \nthat should work for just about any algorithm.","metadata":{"loc":{"lines":{"from":231167,"to":231183}}}}],["2032",{"pageContent":"Essentially, _foo() in this case is a sort of stand-in for practically \nany recursive task, even mutual recursion. The rest is the boilerplate \nthat should work for just about any algorithm. \n\nThe only “catch” is that to be able to resume in the event of a recur¬ \nsion limit being hit, the state of the recursion must be in scoped \nvariables that exist outside the recursive function(s). We did that by \nleaving x and acc outside of the _foo() function, instead of passing \nthem as arguments to _foo( ) as earlier. \n\nAlmost any recursive algorithm can be adapted to work this way. \nThat means it’s the most widely applicable way of leveraging TCO \nwith recursion in your programs, with minimal rewriting. \n\nThis approach still uses a PTC, meaning this code will progressively \nenhance from running using the loop many times (recursion \nbatches) in an older browser to fully leveraging TCO’d recursion in \nan ES6+ environment. I think that’s pretty cool! \n\nReview","metadata":{"loc":{"lines":{"from":231183,"to":231202}}}}],["2033",{"pageContent":"Review \n\nMeta programming is when you turn the logic of your program to \nfocus on itself (or its runtime environment), either to inspect its \nown structure or to modify it. The primary value of meta program¬ \nming is to extend the normal mechanisms of the language to pro¬ \nvide additional capabilities. \n\nPrior to ES6, JavaScript already had quite a bit of meta program¬ \nming capability, but ES6 significantly ramps that up with several \nnew features. \n\nFrom function name inferences for anonymous functions to meta \nproperties that give you information about things like how a con¬ \nstructor was invoked, you can inspect the program structure while it \nruns more than ever before. Well-Known Symbols let you override \nintrinsic behaviors, such as coercion of an object to a primitive \nvalue. Proxies can intercept and customize various low-level opera¬ \ntions on objects, and Reflect provides utilities to emulate them. \n\n\n238 | Chapter 7: Meta Programming","metadata":{"loc":{"lines":{"from":231202,"to":231223}}}}],["2034",{"pageContent":"238 | Chapter 7: Meta Programming \n\n\n\n\nFeature testing, even for subtle semantic behaviors like Tail Call \nOptimization, shifts the meta programming focus from your pro¬ \ngram to the JS engine capabilities itself. By knowing more about \nwhat the environment can do, your programs can adjust themselves \nto the best fit as they run. \n\nShould you meta program? My advice is: first focus on learning how \nthe core mechanics of the language really work. But once you fully \nknow what JS itself can do, it’s time to start leveraging these power¬ \nful meta programming capabilities to push the language further! \n\n\nReview | 239 \n\n\n\nCHAPTER 8 \n\n\nBeyond ES6 \n\n\nAt the time of this writing, the final draft of ES6 (ECMAScript 2015) \nis shortly headed toward its final official vote of approval by ECMA. \nBut even as ES6 is being finalized, the TC39 committee is already \nhard at work at on features for ES7/2016 and beyond.","metadata":{"loc":{"lines":{"from":231223,"to":231253}}}}],["2035",{"pageContent":"As we discussed in Chapter 1, it’s expected that the cadence of pro¬ \ngress for JS is going to accelerate from updating once every several \nyears to having an official version update once per year (hence the \nyear-based naming). That alone is going to radically change how JS \ndevelopers learn about and keep up with the language. \n\nBut even more importantly, the committee is actually going to work \nfeature by feature. As soon as a feature is spec-complete and has its \nkinks worked out through implementation experiments in a few \nbrowsers, that feature will be considered stable enough to start \nusing. We’re all strongly encouraged to adopt features once they’re \nready instead of waiting for some official standards vote. If you \nhaven’t already learned ES6, the time is past due to get on board! \n\nAs the time of this writing, a list of future proposals and their status \ncan be seen here.","metadata":{"loc":{"lines":{"from":231255,"to":231270}}}}],["2036",{"pageContent":"As the time of this writing, a list of future proposals and their status \ncan be seen here. \n\nTranspilers and polyfills are how we’ll bridge to these new features \neven before all browsers we support have implemented them. Babel, \nTraceur, and several other major transpilers already have support for \nsome of the post-ES6 features that are most likely to stabilize. \n\nWith that in mind, it’s already time for us to look at some of them. \nLet’s jump in! \n\n\n241 \n\n\n\n\n\nThese features are all in various stages of devel¬ \nopment. While they’re likely to land, and proba¬ \nbly will look similar, take the contents of this \nchapter with more than a few grains of salt. This \nchapter will evolve in future editions of this title \nas these (and other!) features finalize. \n\n\nasync functions","metadata":{"loc":{"lines":{"from":231270,"to":231296}}}}],["2037",{"pageContent":"async functions \n\nIn “Generators + Promises” on page 155 in Chapter 4, we mentioned \nthat there’s a proposal for direct syntactic support for the pattern of \ngenerators yielding promises to a runner-like utility that will \nresume it on promise completion. Let’s take a brief look at that pro¬ \nposed feature, called async function. \n\nRecall this generator example from Chapter 4: \n\nrun( function *main() { \n\nvar ret = yield steplQ; \n\ntry { \n\nret = yield step2( ret ); \n\n} \n\ncatch (err) { \n\nret = yield step2Failed( err ); \n\n} \n\nret = yield Promise. ail ([ \nstep3a( ret ), \nstep3b( ret ), \nstep3c( ret ) \n\n]); \n\nyield step4( ret ); \n\n} ) \n\n. then( \n\nfunction fulfilled(){ \n\n// '*main()' completed successfully \n\n}, \n\nfunction rejected(reason){ \n\n// Oops, something went wrong \n\n} \n\n); \n\nThe proposed async function syntax can express this same flow \ncontrol logic without needing the run(..) utility, because JS will \nautomatically know how to look for promises to wait and resume. \nConsider:","metadata":{"loc":{"lines":{"from":231296,"to":231352}}}}],["2038",{"pageContent":"242 | Chapter 8: Beyond ES6 \n\n\n\n\nasync function main() { \n\nvar ret = await stepl(); \n\ntry { \n\nret = await step2( ret ); \n\n} \n\ncatch (err) { \n\nret = await step2Failed( err ); \n\n} \n\nret = await Promise. all( [ \nstep3a( ret ), \nstep3b( ret ), \nstep3c( ret ) \n\n] ); \n\nawait step4( ret ); \n\n} \n\nmain( ) \n\n. then( \n\nfunction fulfilled(){ \n\n// 'nain()' completed successfully \n\n}, \n\nfunction rejected(reason){ \n\n// Oops, something went wrong \n\n} \n\n); \n\nInstead of the function *main() { .. declaration, we declare with \nthe async function nain() { .. form. And instead of yielding a \npromise, we await the promise. The call to run the function main() \nactually returns a promise that we can directly observe. That’s the \nequivalent to the promise we get back from a run(nain) call. \n\nDo you see the symmetry? async function is essentially syntactic \nsugar for the generators + promises + run(..) pattern; under the \ncovers, it operates the same!","metadata":{"loc":{"lines":{"from":231355,"to":231413}}}}],["2039",{"pageContent":"Do you see the symmetry? async function is essentially syntactic \nsugar for the generators + promises + run(..) pattern; under the \ncovers, it operates the same! \n\nIf you’re a C# developer and this async/await looks familiar, it’s \nbecause this feature is directly inspired by C#’s feature. It’s nice to see \nlanguage precedence informing convergence! \n\nBabel, Traceur, and other transpilers already have early support for \nthe current status of async functions, so you can start using them \nalready. However, in the next section, we’ll see why you perhaps \nshouldn’t jump on that ship quite yet. \n\n\nasync functions | 243","metadata":{"loc":{"lines":{"from":231413,"to":231427}}}}],["2040",{"pageContent":"async functions | 243 \n\n\n\n\n\nThere’s also a proposal for async function*, \nwhich would be called an “async generator.” You \ncan both yield and await in the same code, and \neven combine those operations in the same \nstatement: x = await yield y. The “async gen¬ \nerator” proposal seems to be more in flux— \nnamely, its return value is not fully worked out \nyet. Some feel it should be an observable , which \nis kind of like the combination of an iterator and \na promise. For now, we won’t go further into \nthat topic, but stay tuned as it evolves. \n\n\nCaveats \n\nOne unresolved point of contention with async function is that \nbecause it only returns a promise, there’s no way from the outside to \ncancel an async function instance that’s currently running. This \ncan be a problem if the async operation is resource-intensive, and \nyou want to free up the resources as soon as you’re sure the result \nwon’t be needed. \n\nFor example: \n\nasync function request(url) { \nvar resp = await (","metadata":{"loc":{"lines":{"from":231427,"to":231458}}}}],["2041",{"pageContent":"For example: \n\nasync function request(url) { \nvar resp = await ( \n\nnew Pronise( function( resolve,reject){ \nvar xhr = new XMLHttpRequestQ; \nxhr.open( \"GET\", url ); \nxhr.onreadystatechange = function(){ \nif (xhr.readyState == 4) { \nif (xhr.status == 200) { \nresolve( xhr ); \n\n} \n\nelse { \n\nreject( xhr . statusText ); \n\n} \n\n} \n\n}; \n\nxhr . send( ); \n\n} ) \n\n); \n\n\nreturn resp.responseText; \n\n} \n\nvar pr = request( \"http://some.url.1\" ); \npr.then( \n\n\n244 | Chapter 8: Beyond ES6 \n\n\n\n\n\n\n\n\nfunction fulfilled(responseText){ \n\n// ajax success \n\n}, \n\nfunction rejected(reason){ \n\n// Oops, something went wrong \n\n} \n\n); \n\nThis request(..) that I’ve conceived is somewhat like the \nfetch (. .) utility that’s recently been proposed for inclusion into the \nweb platform. So the concern is, what happens if you want to use the \npr value to somehow indicate that you want to cancel a long- \nrunning Ajax request, for example?","metadata":{"loc":{"lines":{"from":231458,"to":231525}}}}],["2042",{"pageContent":"Promises are not cancelable (at the time of writing, anyway). In my \nopinion, as well as many others, they never should be (see the Async \n& Performance title of this series). And even if a promise did have a \ncancelQ method on it, does that necessarily mean that calling \npr. cancel () should actually propagate a cancelation signal all the \nway back up the promise chain to the async function? \n\nSeveral possible resolutions to this debate have surfaced: \n\n• async functions won’t be cancelable at all (status quo) \n\n• A “cancel token” can be passed to an async function at call time \n\n• Return value changes to a cancelable-promise type that’s added \n\n• Return value changes to something else nonpromise (e.g., \nobservable, or control token with promise and cancel capabili¬ \nties)","metadata":{"loc":{"lines":{"from":231527,"to":231544}}}}],["2043",{"pageContent":"• Return value changes to a cancelable-promise type that’s added \n\n• Return value changes to something else nonpromise (e.g., \nobservable, or control token with promise and cancel capabili¬ \nties) \n\nAt the time of this writing, async functions return regular prom¬ \nises, so it’s less likely that the return value will entirely change. But \nit’s too early to tell where things will land. Keep an eye on this \ndiscussion. \n\nObject.observe(..) \n\nOne of the holy grails of front-end web development is data binding \n—listening for updates to a data object and syncing the DOM repre¬ \nsentation of that data. Most JS frameworks provide some mecha¬ \nnism for these sorts of operations. \n\nIt appears likely that post-ES6, we’ll see support added directly to the \nlanguage, via a utility called Object.observe! • • )■ Essentially, the \n\n\nObject.observef.) | 245","metadata":{"loc":{"lines":{"from":231544,"to":231566}}}}],["2044",{"pageContent":"It appears likely that post-ES6, we’ll see support added directly to the \nlanguage, via a utility called Object.observe! • • )■ Essentially, the \n\n\nObject.observef.) | 245 \n\n\n\nidea is that you can set up a listener to observe an objects changes, \nand have a callback called any time a change occurs. You can then \nupdate the DOM accordingly, for instance. \n\nThere are six types of changes that you can observe: \n\n• add \n\n• update \n\n• delete \n\n• reconfigure \n\n• setPrototype \n\n• preventExtensions \n\nBy default, you’ll be notified of all these change types, but you can \nfilter down to only the ones you care about. \n\nConsider: \n\nvar obj = { a: 1, b: 2 }; \n\nObject. observe! \nobj, \n\nfunction (changes)f \n\nfor (var change of changes) { \nconsole. log( change ); \n\n} \n\n}. \n\n[ \"add\", \"update\", \"delete\" ] \n\n); \n\n\nobj.c = 3; \n\n// { nane: \"c\", object: obj, type: \"add\" } \nobj.a = 42; \n\n// { nane: \"a\", object: obj, type: \"update\", oldValue: 1 } \n\ndelete obj.b;","metadata":{"loc":{"lines":{"from":231566,"to":231623}}}}],["2045",{"pageContent":"} \n\n}. \n\n[ \"add\", \"update\", \"delete\" ] \n\n); \n\n\nobj.c = 3; \n\n// { nane: \"c\", object: obj, type: \"add\" } \nobj.a = 42; \n\n// { nane: \"a\", object: obj, type: \"update\", oldValue: 1 } \n\ndelete obj.b; \n\n// { nane: \"b\", object: obj, type: \"delete\", oldValue: 2 } \n\nIn addition to the main \"add\", \"update\", and \"delete\" change \ntypes: \n\n• The \"reconfigure\" change event is fired if one of the object’s \nproperties is reconfigured with Object.defineProperty(..), \nsuch as changing its writable attribute. See the this & Object \nPrototypes title of this series for more information. \n\n\n246 | Chapter 8: Beyond ES6 \n\n\n\n• The \"preventExtensions\" change event is fired if the object is \nmade non-extensible via Object. preventExtensions(.. )■","metadata":{"loc":{"lines":{"from":231623,"to":231657}}}}],["2046",{"pageContent":"246 | Chapter 8: Beyond ES6 \n\n\n\n• The \"preventExtensions\" change event is fired if the object is \nmade non-extensible via Object. preventExtensions(.. )■ \n\nBecause both Object. seal(..) and Object. f reeze(..) also imply \nObject.preventExtensions(. .), they’ll also fire its corresponding \nchange event. In addition, \"reconfigure\" change events will also be \nfired for each property on the object. * The \"setPrototype\" change \nevent is fired if the [ [Prototype] ] of an object is changed, either by \n\nsetting it with the_proto_setter, or using Object.setPrototy \n\npeOf (..). \n\nNotice that these change events are notified immediately after said \nchange. Don’t confuse this with proxies (see Chapter 7) where you \ncan intercept the actions before they occur. Object observation lets \nyou respond after a change (or set of changes) occurs. \n\nCustom Change Events \n\nIn addition to the six built-in change event types, you can also listen \nfor and fire custom change events. \n\nConsider:","metadata":{"loc":{"lines":{"from":231657,"to":231684}}}}],["2047",{"pageContent":"Custom Change Events \n\nIn addition to the six built-in change event types, you can also listen \nfor and fire custom change events. \n\nConsider: \n\nfunction observer(changes){ \n\nfor (var change of changes) { \n\nif (change.type == \"recalc\") { \nchange.object.c = \n\nchange.object.otdValue + \nchange.object.a + \nchange.object. b; \n\n} \n\n} \n\n} \n\nfunction changeObj(a,b) { \n\nvar notifier = Object. getNotifier( obj ); \n\nobj.a = a * 2; \nobj.b = b * 3; \n\n// queue up change events into a set \nnotifier.notify ( { \ntype: \"recalc\", \nname: \"c\", \noldValue: obj.c \n\n} ); \n\n} \n\n\nObject.observef.) | 247 \n\n\n\n\nvar obj = { a: 1, b: 2, c: 3 }; \n\n\nObject. observe( \nobj, \n\nobserver, \n\n[\" recalc\"] \n\n\nchangeObj( 3, 11 ); \n\nobj. a; // 12 \n\nobj.b; // 30 \n\nobj .c; // 3 \n\nThe change set (\"recalc\" custom event) has been queued for deliv¬ \nery to the observer, but not delivered yet, which is why ob j. c is still \n\n3.","metadata":{"loc":{"lines":{"from":231684,"to":231753}}}}],["2048",{"pageContent":"obj. a; // 12 \n\nobj.b; // 30 \n\nobj .c; // 3 \n\nThe change set (\"recalc\" custom event) has been queued for deliv¬ \nery to the observer, but not delivered yet, which is why ob j. c is still \n\n3. \n\nThe changes are by default delivered at the end of the current event \nloop (see the Async & Performance title of this series). If you want to \ndeliver them immediately, use Object.deliverChangeRe \ncords(observer). Once the change events are delivered, you can \nobserve obj. c updated as expected: \n\nobj .c; // 42 \n\nIn the previous example, we called notifler.notify (..) with the \ncomplete change event record. An alternative form for queuing \nchange records is to use perfomChange( ..), which separates speci¬ \nfying the type of the event from the rest of event records properties \n(via a function callback). Consider: \n\nnotifler . performChange( \"recalc\", function(){ \nreturn { \n\nname: \"c\", \n\n// 'this' is the object under observation \noldValue: this.c \n\n}; \n\n} );","metadata":{"loc":{"lines":{"from":231753,"to":231788}}}}],["2049",{"pageContent":"notifler . performChange( \"recalc\", function(){ \nreturn { \n\nname: \"c\", \n\n// 'this' is the object under observation \noldValue: this.c \n\n}; \n\n} ); \n\nIn certain circumstances, this separation of concerns may map more \ncleanly to your usage pattern. \n\nEnding Observation \n\nJust like with normal event listeners, you may wish to stop observing \nan objects change events. For that, you use Object. unobserve(.. ). \n\nFor example: \n\n\n248 | Chapter 8: Beyond ES6 \n\n\n\n\n\nvar obj = { a: 1, b: 2 }; \n\n\nObject. observe( obj, function observer(changes) { \nfor (var change of changes) { \n\nif (change.type == \"setPrototype\" ) { \n\nObject . unobserve( \n\nchange.object, observer \n\n); \n\nbreak; \n\n} \n\n} \n\n} ); \n\nIn this trivial example, we listen for change events until we see the \n\"setPrototype\" event come through, at which time we stop observ¬ \ning any more change events. \n\n\nExponentiation Operator","metadata":{"loc":{"lines":{"from":231788,"to":231844}}}}],["2050",{"pageContent":"In this trivial example, we listen for change events until we see the \n\"setPrototype\" event come through, at which time we stop observ¬ \ning any more change events. \n\n\nExponentiation Operator \n\nAn operator has been proposed for JavaScript to perform exponen¬ \ntiation in the same way that Math . pow( ..) does. Consider: \n\nvar a = 2; \n\n\na ** 4; // Math.pow( a, 4 ) == 16 \n\na **= 3; // a = Math.pow( a, 3 ) \n\na; // 8 \n\n\n\n** is essentially the same as it appears in Python, \nRuby, Perl, and others. \n\n\nObjects Properties and ... \n\nAs we saw in “Too Many, Too Few, Just Enough” on page 30 in \nChapter 2, the ... operator is pretty obvious in how it relates to \nspreading or gathering arrays. But what about objects? \n\nSuch a feature was considered for ES6, but was deferred to be con¬ \nsidered after ES6 (aka “ES7” or “ES2016” or ...). Here’s how it might \nwork in that “beyond ES6” timeframe: \n\nvar ol = { a: 1, b; 2 }, \no2 = { c: 3 }, \n\no3 = { . . .ol, . ..02, d: 4 };","metadata":{"loc":{"lines":{"from":231844,"to":231882}}}}],["2051",{"pageContent":"var ol = { a: 1, b; 2 }, \no2 = { c: 3 }, \n\no3 = { . . .ol, . ..02, d: 4 }; \n\n\nExponentiation Operator | 249 \n\n\n\n\nconsole. log( o3.a, o3.b, o3.c, o3.d ); \n\n// 1 2 3 4 \n\nThe ... operator might also be used to gather an object’s destruc- \ntured properties back into an object: \n\nvar ol={b:2, c: 3, d: 4 }; \nvar { b, ...o2 } = ol; \n\nconsole. log ( b, o2.c, o2.d ); // 2 3 4 \n\nHere, the .. .o2 re-gathers the destructured c and d properties back \ninto an o2 object (o2 does not have a b property like ol does). \n\nAgain, these are just proposals under consideration beyond ES6. But \nit’ll be cool if they do land. \n\nArray#indudes(..) \n\nOne extremely common task JS developers need to perform is \nsearching for a value inside an array of values. The way this has \nalways been done is: \n\nvar vals = [ \"foo\", \"bar\", 42, \"baz\" ]; \n\nif (vals.indexOf( 42 ) >= 0) { \n\n// found it! \n\n1","metadata":{"loc":{"lines":{"from":231882,"to":231923}}}}],["2052",{"pageContent":"var vals = [ \"foo\", \"bar\", 42, \"baz\" ]; \n\nif (vals.indexOf( 42 ) >= 0) { \n\n// found it! \n\n1 \n\nThe reason for the >= 0 check is because indexOf (..) returns a \nnumeric value of 0 or greater if found, or -1 if not found. In other \nwords, we’re using an index-returning function in a boolean context. \nBut because -1 is truthy instead of falsy, we have to be more manual \nwith our checks. \n\nIn the Types & Grammar title of this series, I explored another pat¬ \ntern that I slightly prefer: \n\nvar vals = [ \"foo\", \"bar\", 42, \"baz\" ]; \n\nif (-vals.indexOf ( 42 )) { \n\n// found it! \n\n} \n\nThe ~ operator here conforms the return value of indexOf (..) to a \nvalue range that is suitably boolean coercible. That is, -1 produces 0 \n(falsy), and anything else produces a nonzero (truthy) value, which \nis what we for deciding if we found the value or not. \n\n\n250 | Chapter 8: Beyond ES6","metadata":{"loc":{"lines":{"from":231923,"to":231954}}}}],["2053",{"pageContent":"250 | Chapter 8: Beyond ES6 \n\n\n\nWhile I think that’s an improvement, others strongly disagree. How¬ \never, no one can argue that indexOf (.. )’s searching logic is perfect. \nIt fails to find NaN values in the array, for example. \n\nSo a proposal has surfaced and gained a lot of support for adding a \nreal boolean-returning array search method, called includes(..): \n\nvar vats = [ \"foo\", \"bar\", 42, \"baz\" ]; \n\n\nif (vals.includes( 42 )) { \n// found it! \n\n} \n\n\n\nArray#includes( ..) uses matching logic that \nwill find NaN values, but will not distinguish \nbetween -0 and 0 (see the Types & Grammar \ntitle of this series). If you don’t care about -0 val¬ \nues in your programs, this will likely be exactly \nwhat you’re hoping for. If you do care about - 0, \nyou’ll need to do your own searching logic, \nlikely using the Object.is(. .) utility (see \nChapter 6). \n\n\nSIMD","metadata":{"loc":{"lines":{"from":231954,"to":231986}}}}],["2054",{"pageContent":"SIMD \n\nWe cover Single Instruction, Multiple Data (SIMD) in more detail in \nthe Async & Performance title of this series, but it bears a brief men¬ \ntion here, as it’s one of the next likely features to land in a future JS. \n\nThe SIMD API exposes various low-level (CPU) instructions that \ncan operate on more than a single number value at a time. For \nexample, you’ll be able to specify two vectors of 4 or 8 numbers each, \nand multiply the respective elements all at once (data parallelism!). \n\nConsider: \n\nvar vl = SIMD.float32x4( 3.14159, 21.0, 32.3, 55.55 ); \nvar v2 = SIMD.float32x4( 2.1, 3.2, 4.3, 5.4 ); \n\nSIMD.float32x4.mul( vl, v2 ); \n\n// [ 6.597339, 67.2, 138.89, 299.97 ] \n\nSIMD will include several other operations besides mul( ..) (multi¬ \nplication), such as sub(), div(), abs(), neg(), sqrtQ, and many \nmore. \n\n\nSIMD | 251 \n\n\n\n\n\nParallel math operations are critical for the next generations of high \nperformance JS applications. \n\nWebAssembly (WASM)","metadata":{"loc":{"lines":{"from":231986,"to":232020}}}}],["2055",{"pageContent":"SIMD | 251 \n\n\n\n\n\nParallel math operations are critical for the next generations of high \nperformance JS applications. \n\nWebAssembly (WASM) \n\nBrendan Eich made a late-breaking announcement near the comple¬ \ntion of the first edition of this title that has the potential to signifi¬ \ncantly impact the future path of JavaScript: WebAssembly (WASM). \nWe will not be able to cover WASM in detail here, as it’s extremely \nearly at the time of this writing. But this title would be incomplete \nwithout at least a brief mention of it. \n\nOne of the strongest pressures on the recent (and near future) \ndesign changes of the JS language has been the desire that it become \na more suitable target for transpilation/cross-compilation from \nother languages (like C/C++, ClojureScript, etc.). Obviously, perfor¬ \nmance of code running as JavaScript has been a primary concern.","metadata":{"loc":{"lines":{"from":232020,"to":232042}}}}],["2056",{"pageContent":"As discussed in the Async & Performance title of this series, a few \nyears ago a group of developers at Mozilla introduced an idea to \nJavaScript called ASM.js. ASM.js is a subset of valid JS that most sig¬ \nnificantly restricts certain actions that make code hard for the JS \nengine to optimize. The result is that ASM.js-compatible code run¬ \nning in an ASM-aware engine can run remarkably faster, nearly on \npar with native optimized C equivalents. Many viewed ASM.js as the \nmost likely backbone on which performance-hungry applications \nwould ride in JavaScript. \n\nIn other words, all roads to running code in the browser lead \nthrough JavaScript.","metadata":{"loc":{"lines":{"from":232044,"to":232055}}}}],["2057",{"pageContent":"In other words, all roads to running code in the browser lead \nthrough JavaScript. \n\nThat is, until the WASM announcement. WASM provides an alter¬ \nnate path for other languages to target the browser’s runtime envi¬ \nronment without having to first pass through JavaScript. Essentially, \nif WASM takes off, JS engines will gain an extra capability to execute \na binary format of code that can be seen as somewhat similar to a \nbytecode (like that which runs on the JVM). \n\nWASM proposes a format for a binary representation of a highly \ncompressed AST (syntax tree) of code, which can then give instruc¬ \ntions directly to the JS engine and its underpinnings, without having \nto be parsed by JS, or even behave by the rules of JS. Languages like \nC or C++ can be compiled directly to the WASM format instead of \n\n\n252 | Chapter 8: Beyond ES6 \n\n\n\nASM.js, and gain an extra speed advantage by skipping the JS pars¬ \ning.","metadata":{"loc":{"lines":{"from":232055,"to":232077}}}}],["2058",{"pageContent":"252 | Chapter 8: Beyond ES6 \n\n\n\nASM.js, and gain an extra speed advantage by skipping the JS pars¬ \ning. \n\nThe near term goal for WASM is to have parity with ASM.js and \nindeed JS. But eventually, it’s expected that WASM will grow new \ncapabilities that surpass anything JS could do. For example, the pres¬ \nsure for JS to evolve radical features like threads—a change that \nwould certainly send major shockwaves through the JS ecosystem— \nhas a more hopeful future as a future WASM extension, relieving the \npressure to change JS. \n\nIn fact, this new roadmap opens up many new roads for many lan¬ \nguages to target the web runtime. That’s an exciting new future path \nfor the web platform! \n\nWhat does it mean for JS? Will JS become irrelevant or “die”? Abso¬ \nlutely not. ASM.js will likely not see much of a future beyond the \nnext couple of years, but the majority of JS is quite safely anchored \nin the web platform story.","metadata":{"loc":{"lines":{"from":232077,"to":232099}}}}],["2059",{"pageContent":"Proponents of WASM suggest its success will mean that the design \nof JS will be protected from pressures that would have eventually \nstretched it beyond assumed breaking points of reasonability. It is \nprojected that WASM will become the preferred target for high- \nperformance parts of applications, as authored in any of a myriad of \ndifferent languages. \n\nInterestingly, JavaScript is one of the languages less likely to target \nWASM in the future. There may be future changes that carve out \nsubsets of JS that might be tenable for such targeting, but that path \ndoesn’t seem high on the priority list. \n\nWhile JS likely won’t be much of a WASM funnel, JS code and \nWASM code will be able to interoperate in the most significant ways, \njust as naturally as current module interactions. You can imagine \ncalling a JS function like foo() and having that actually invoke a \nWASM function of that name with the power to run well outside the \nconstraints of the rest of your JS.","metadata":{"loc":{"lines":{"from":232101,"to":232118}}}}],["2060",{"pageContent":"Things that are currently written in JS will probably continue to \nalways be written in JS, at least for the foreseeable future. Things \nthat are transpiled to JS will probably eventually at least consider \ntargeting WASM instead. For things that need the utmost in perfor¬ \nmance with minimal tolerance for layers of abstraction, the likely \n\n\nWebAssembly (WASM) | 253 \n\n\n\nchoice will be to find a suitable non-JS language to author in, and \nthen targeting WASM. \n\nThere’s a good chance that this shift will be slow, and will be years in \nthe making. WASM landing in all the major browser platforms is \nprobably a few years out at best. In the meantime, the WASM \nproject has an early polyfill to demonstrate proof-of-concept for its \nbasic tenets.","metadata":{"loc":{"lines":{"from":232120,"to":232138}}}}],["2061",{"pageContent":"But as time goes on, and as WASM learns new non-JS tricks, it’s not \ntoo much a stretch of imagination to see some currently-JS things \nbeing refactored to a WASM-targetable language. For example, the \nperformance-sensitive parts of frameworks, game engines, and \nother heavily used tools might very well benefit from such a shift. \nDevelopers using these tools in their web applications likely won’t \nnotice much difference in usage or integration, but will just auto¬ \nmatically take advantage of the performance and capabilities. \n\nWhat’s certain is that the more real WASM becomes over time, the \nmore it means to the trajectory and design of JavaScript. It’s perhaps \none of the most important “beyond ES6” topics that developers \nshould keep an eye on. \n\nReview","metadata":{"loc":{"lines":{"from":232140,"to":232154}}}}],["2062",{"pageContent":"Review \n\nIf all the other books in this series essentially propose this challenge, \n“you (may) not know JS (as much as you thought),” this book has \ninstead suggested, “you don’t know JS anymore.” The book has cov¬ \nered a ton of new stuff added to the language in ES6. It’s an exciting \ncollection of new language features and paradigms that will forever \nimprove our JS programs. \n\nBut JS is not done with ES6! Not even close. There’s already quite a \nfew features in various stages of development for the “beyond ES6” \ntimeframe. In this chapter, we briefly looked at some of the most \nlikely candidates to land in JS very soon.","metadata":{"loc":{"lines":{"from":232154,"to":232166}}}}],["2063",{"pageContent":"async functions are powerful syntactic sugar on top of the genera¬ \ntors + promises pattern (see Chapter 4). Object.observe( ..) adds \ndirect native support for observing object change events, which is \ncritical for implementing data binding. The ** exponentiation oper¬ \nator, ... for object properties, and Array#includes( ..) are all sim¬ \nple but helpful improvements to existing mechanisms. Finally, \nSIMD ushers in a new era in the evolution of high-performance JS. \n\n\n254 | Chapter 8: Beyond ES6 \n\n\n\nCliche as it sounds, the future of JS is really bright! The challenge of \nthis series, and indeed of this book, is incumbent on every reader \nnow. What are you waiting for? It’s time to get learning and explor¬ \ning! \n\n\nReview | 255 \n\n\n\nAPPENDIX A \n\n\nAcknowledgments \n\n\nI have many people to thank for making this book title and the over¬ \nall series happen.","metadata":{"loc":{"lines":{"from":232168,"to":232198}}}}],["2064",{"pageContent":"Review | 255 \n\n\n\nAPPENDIX A \n\n\nAcknowledgments \n\n\nI have many people to thank for making this book title and the over¬ \nall series happen. \n\nFirst, I must thank my wife Christen Simpson, and my two kids \nEthan and Emily, for putting up with Dad always pecking away at \nthe computer. Even when not writing books, my obsession with \nJavaScript glues my eyes to the screen far more than it should. That \ntime I borrow from my family is the reason these books can so \ndeeply and completely explain JavaScript to you, the reader. I owe \nmy family everything. \n\nI’d like to thank my editors at O’Reilly, namely Simon St.Laurent and \nBrian MacDonald, as well as the rest of the editorial and marketing \nstaff. They are fantastic to work with, and have been especially \naccommodating during this experiment into “open source” book \nwriting, editing, and production.","metadata":{"loc":{"lines":{"from":232198,"to":232223}}}}],["2065",{"pageContent":"Thank you to the many folks who have participated in making this \nbook series better by providing editorial suggestions and correc¬ \ntions, including Shelley Powers, Tim Ferro, Evan Borden, Forrest L. \nNorvell, Jennifer Davis, Jesse Harlin, and many others. A big thank \nyou to Rick Waldron for writing the Foreword for this title. \n\nThank you to the countless folks in the community, including mem¬ \nbers of the TC39 committee, who have shared so much knowledge \nwith the rest of us, and especially tolerated my incessant questions \nand explorations with patience and detail. John-David Dalton, Juriy \n“kangax” Zaytsev, Mathias Bynens, Axel Rauschmayer, Nicholas \n\n\n257","metadata":{"loc":{"lines":{"from":232225,"to":232238}}}}],["2066",{"pageContent":"257 \n\n\n\n\nZakas, Angus Croll, Reginald Braithwaite, Dave Herman, Brendan \nEich, Allen Wirfs-Brock, Bradley Meek, Domenic Denicola, David \nWalsh, Tim Disney, Peter van der Zee, Andrea Giammarchi, Kit \nCambridge, Eric Elliott, Andre Bargull, Caitlin Potter, Brian Terlson, \nIngvar Stepanyan, Chris Dickinson, Luke Hoban, and so many oth¬ \ners, I can’t even scratch the surface. \n\nThe You Don’t Know JS book series was born on Kickstarter, so I also \nwish to thank all my (nearly) 500 generous backers, without whom \nthis book series could not have happened:","metadata":{"loc":{"lines":{"from":232238,"to":232252}}}}],["2067",{"pageContent":"Jan Szpila, nokiko, Murali Krishnamoorthy, Ryan Joy, Craig Patch- \nett, pdqtrader, Dale Fukami, ray hatfield, ROdrigo Perez [Mx], Dan \nPetitt, Jack Franklin, Andrew Berry, Brian Grinstead, Rob Suther¬ \nland, Sergi Meseguer, Phillip Gourley, Mark Watson, Jeff Carouth, \nAlfredo Sumaran, Martin Sachse, Marcio Barrios, Dan, AimelyneM, \nMatt Sullivan, Delnatte Pierre-Antoine, Jake Smith, Eugen Tudoran- \ncea, Iris, David Trinh, simonstl, Ray Daly, Uros Gruber, Justin \nMyers, Shai Zonis, Mom & Dad, Devin Clark, Dennis Palmer, Brian \nPanahi Johnson, Josh Marshall, Marshall, Dennis Kerr, Matt Steele, \nErik Slagter, Sacah, Justin Rainbow, Christian Nilsson, Delapouite, \nD.Pereira, Nicolas Hoizey, George V. Reilly, Dan Reeves, Bruno \nLaturner, Chad Jennings, Shane King, Jeremiah Lee Cohick, od3n, \nStan Yamane, Marko Vucinic, Jim B, Stephen Collins, Higir \nhorsteinsson, Eric Pederson, Owain, Nathan Smith, Jeanetteurphy, \nAlexandre ELISE, Chris Peterson, Rik Watson, Luke Matthews, Jus¬","metadata":{"loc":{"lines":{"from":232254,"to":232268}}}}],["2068",{"pageContent":"Stan Yamane, Marko Vucinic, Jim B, Stephen Collins, Higir \nhorsteinsson, Eric Pederson, Owain, Nathan Smith, Jeanetteurphy, \nAlexandre ELISE, Chris Peterson, Rik Watson, Luke Matthews, Jus¬ \ntin Lowery, Morten Nielsen, Vernon Kesner, Chetan Shenoy, Paul \nTregoing, Marc Grabanski, Dion Almaer, Andrew Sullivan, Keith \nElsass, Tom Burke, Brian Ashenfelter, David Stuart, Karl Swedberg, \nGraeme, Brandon Hays, John Christopher, Gior, manoj reddy, Chad \nSmith, Jared Harbour, Minoru TODA, Chris Wigley, Daniel Mee, \nMike, Handyface, Alex Jahraus, Carl Furrow, Rob Foulkrod, Max \nShishkin, Leigh Penny Jr., Robert Ferguson, Mike van Hoenselaar, \nHasse Schougaard, rajan venkataguru, Jeff Adams, Trae Robbins, \nRolf Langenhuijzen, Jorge Antunes, Alex Koloskov, Hugh Greenish, \nTim Jones, Jose Ochoa, Michael Brennan-White, Naga Harish \nMuwa, Barkoczi David, Kitt Hodsden, Paul McGraw, Sascha Gold- \nhofer, Andrew Metcalf, Markus Krogh, Michael Mathews, Matt","metadata":{"loc":{"lines":{"from":232268,"to":232282}}}}],["2069",{"pageContent":"Tim Jones, Jose Ochoa, Michael Brennan-White, Naga Harish \nMuwa, Barkoczi David, Kitt Hodsden, Paul McGraw, Sascha Gold- \nhofer, Andrew Metcalf, Markus Krogh, Michael Mathews, Matt \nJared, Juanfran, Georgie Kirschner, Kenny Lee, Ted Zhang, Amit \nPahwa, Inbal Sinai, Dan Raine, Schabse Laks, Michael Tervoort, \nAlexandre Abreu, Alan Joseph Williams, NicolasD, Cindy Wong, \nReg Braithwaite, LocalPCGuy, Jon Friskics, Chris Merriman, John","metadata":{"loc":{"lines":{"from":232282,"to":232288}}}}],["2070",{"pageContent":"258 | Appendix A: Acknowledgments \n\n\n\nPena, Jacob Katz, Sue Lockwood, Magnus Johansson, Jeremy Crap- \nsey, Grzegorz PawJowski, nico nuzzaci, Christine Wilks, Hans Berg- \nren, charles montgomery, Ariel Fogel, Ivan Kolev, Daniel","metadata":{"loc":{"lines":{"from":232291,"to":232297}}}}],["2071",{"pageContent":"Campos, Hugh Wood, Christian Bradford, Frederic Harper, IonuJ \nDan Popa, Jeff Trimble, Rupert Wood, Trey Carrico, Pancho Lopez, \nJoel kuijten, Tom A Marra, Jeff Jewiss, Jacob Rios, Paolo Di Stefano, \nSoledad Penades, Chris Gerber, Andrey Dolganov, Wil Moore III, \nThomas Martineau, Kareem, Ben Thouret, Udi Nir, Morgan Lau- \npies, jory carson-burson, Nathan L Smith, Eric Damon Walters, \nDerry Lozano-Hoyland, Geoffrey Wiseman, mkeehner, KatieK, \nScott MacFarlane, Brian LaShomb, Adrien Mas, Christopher ross, \nIan Littman, Dan Atkinson, Elliot Jobe, Nick Dozier, Peter Wooley, \nJohn Hoover, dan, Martin A. Jackson, Hector Fernando Hurtado, \nandy ennamorato, Paul Seltmann, Melissa Gore, Dave Pollard, Jack \nSmith, Philip Da Silva, Guy Israeli, @megalithic, Damian Crawford, \nFelix Gliesche, April Carter Grant, Heidi, jim tierney, Andrea Giam- \nmarchi, Nico Vignola, Don Jones, Chris Hartjes, Alex Howes, john \ngibbon, David J. Groom, BBox, Yu Dilys Sun, Nate Steiner, Brandon","metadata":{"loc":{"lines":{"from":232299,"to":232313}}}}],["2072",{"pageContent":"marchi, Nico Vignola, Don Jones, Chris Hartjes, Alex Howes, john \ngibbon, David J. Groom, BBox, Yu Dilys Sun, Nate Steiner, Brandon \nSatrom, Brian Wyant, Wesley Hales, Ian Pouncey, Timothy Kevin \nOxley, George Terezakis, sanjay raj, Jordan Harband, Marko \nMcLion, Wolfgang Kaufmann, Pascal Peuckert, Dave Nugent, Mar¬ \nkus Liebelt, Welling Guzman, Nick Cooley, Daniel Mesquita, Robert \nSyvarth, Chris Coyier, Remy Bach, Adam Dougal, Alistair Duggin, \nDavid Loidolt, Ed Richer, Brian Chenault, GoldFire Studios, Carles \nAndres, Carlos Cabo, Yuya Saito, roberto ricardo, Barnett Klane, \nMike Moore, Kevin Marx, Justin Love, Joe Taylor, Paul Dijou, \nMichael Kohler, Rob Cassie, Mike Tierney, Cody Leroy Lindley, \ntofuji, Shimon Schwartz, Raymond, Luc De Brouwer, David Hayes, \nRhys Brett-Bowen, Dmitry, Aziz Khoury, Dean, Scott Tolinski - \nLevel Up, Clement Boirie, Djordje Lukic, Anton Kotenko, Rafael \nCorral, Philip Hurwitz, Jonathan Pidgeon, Jason Campbell, Joseph","metadata":{"loc":{"lines":{"from":232313,"to":232327}}}}],["2073",{"pageContent":"Rhys Brett-Bowen, Dmitry, Aziz Khoury, Dean, Scott Tolinski - \nLevel Up, Clement Boirie, Djordje Lukic, Anton Kotenko, Rafael \nCorral, Philip Hurwitz, Jonathan Pidgeon, Jason Campbell, Joseph \nC., SwiftOne, Jan Hohner, Derick Bailey, getify, Daniel Cousineau, \nChris Charlton, Eric Turner, David Turner, Joel Galeran, Dharma \nVagabond, adam, Dirk van Bergen, dave furf, Vedran Zakanj,","metadata":{"loc":{"lines":{"from":232327,"to":232332}}}}],["2074",{"pageContent":"Ryan McAllen, Natalie Patrice Tucker, Eric J. Bivona, Adam Spoo¬ \nner, Aaron Cavano, Kelly Packer, Eric J, Martin Drenovac, Emilis, \nMichael Pelikan, Scott F. Walter, Josh Freeman, Brandon Hudgeons, \nvijay chennupati, Bill Glennon, Robin R., Troy Forster, otaku_coder, \nBrad, Scott, Frederick Ostrander, Adam Brill, Seb Flippence, \nMichael Anderson, Jacob, Adam Randlett, Standard, Joshua Clan¬ \nton, Sebastian Kouba, Chris Deck, SwordFire, Hannes Papenberg, \n\n\nAcknowledgments | 259","metadata":{"loc":{"lines":{"from":232334,"to":232343}}}}],["2075",{"pageContent":"Richard Woeber, hnzz, Rob Crowther, Jedidiah Broadbent, Sergey \nChernyshev, Jay-Ar Jamon, Ben Combee, luciano bonachela, Mark \nTomlinson, Kit Cambridge, Michael Melgares, Jacob Adams, Adrian \nBruinhout, Bev Wieber, Scott Puleo, Thomas Herzog, April Leone, \nDaniel Mizielinski, Kees van Ginkel, Jon Abrams, Erwin Heiser, Avi \nLaviad, David newell, Jean-Francois Turcot, Niko Roberts, Erik \nDana, Charles Neill, Aaron Holmes, Grzegorz Ziolkowski, Nathan \nYoungman, Timothy, Jacob Mather, Michael Allan, Mohit Seth, Ryan \nEwing, Benjamin Van Treese, Marcelo Santos, Denis Wolf, Phil \nKeys, Chris Yung, Timo Tijhof, Martin Lekvall, Agendine, Greg \nWhitworth, Helen Humphrey, Dougal Campbell, Johannes Harth, \nBruno Girin, Brian Hough, Darren Newton, Craig McPheat, Olivier \nTille, Dennis Roethig, Mathias Bynens, Brendan Stromberger, sun- \ndeep, John Meyer, Ron Male, John F Croston III, gigante, Carl Ber- \ngenhem, B.J. May, Rebekah Tyler, Ted Foxberry, Jordan Reese, Terry","metadata":{"loc":{"lines":{"from":232347,"to":232361}}}}],["2076",{"pageContent":"deep, John Meyer, Ron Male, John F Croston III, gigante, Carl Ber- \ngenhem, B.J. May, Rebekah Tyler, Ted Foxberry, Jordan Reese, Terry \nSuitor, afeliz, Tom Kiefer, Darragh Duffy, Kevin Vanderbeken, Andy \nPearson, Simon Mac Donald, Abid Din, Chris Joel, Tomas Theunis- \nsen, David Dick, Paul Grock, Brandon Wood, John Weis, dgrebb, \nNick Jenkins, Chuck Lane, Johnny Megahan, marzsman, Tatu Tam- \nminen, Geoffrey Knauth, Alexander Tarmolov, Jeremy Tymes, Chad \nAuld, Sean Parmelee, Rob Staenke, Dan Bender, Yannick derwa, \nJoshua Jones, Geert Plaisier, Tom LeZotte, Christen Simpson, Stefan \nBruvik, Justin Falcone, Carlos Santana, Michael Weiss, Pablo Villos- \nlada, Peter deHaan, Dimitris Iliopoulos, seyDoggy, Adam Jordens, \nNoah Kantrowitz, Amol M, Matthew Winnard, Dirk Ginader, Phi- \nnam Bui, David Rapson, Andrew Baxter, Florian Bougel, Michael \nGeorge, Alban Escalier, Daniel Sellers, Sasha Rudan, John Green, \nRobert Kowalski, David I. Teixeira (@ditma, Charles Carpenter, Jus¬","metadata":{"loc":{"lines":{"from":232361,"to":232375}}}}],["2077",{"pageContent":"nam Bui, David Rapson, Andrew Baxter, Florian Bougel, Michael \nGeorge, Alban Escalier, Daniel Sellers, Sasha Rudan, John Green, \nRobert Kowalski, David I. Teixeira (@ditma, Charles Carpenter, Jus¬ \ntin Yost, Sam S, Denis Ciccale, Kevin Sheurs, Yannick Croissant, Pau \nFraces, Stephen McGowan, Shawn Searcy, Chris Ruppel, Kevin \nLamping, Jessica Campbell, Christopher Schmitt, Sablons, Jonathan \nReisdorf, Bunni Gek, Teddy Huff, Michael Mullany, Michael Fiir- \nstenberg, Carl Henderson, Rick Yoesting, Scott Nichols, Hernan \nCiudad, Andrew Maier, Mike Stapp, Jesse Shawl, Sergio Lopes, jsu- \nlak, Shawn Price, Joel Clermont, Chris Ridmann, Sean Timm, Jason \nFinch, Aiden Montgomery, Elijah Manor, Derek Gathright, Jesse \nHarlin, Dillon Curry, Courtney Myers, Diego Cadenas, Arne de \nBree, Joao Paulo Dubas, James Taylor, Philipp Kraeutli, Mihai Paun, \nSam Gharegozlou, joshjs, Matt Murchison, Eric Windham, Timo \nBehrmann, Andrew Hall, joshua price, Theophile Villard","metadata":{"loc":{"lines":{"from":232375,"to":232389}}}}],["2078",{"pageContent":"260 | Appendix A: Acknowledgments \n\n\n\n\nThis book series is being produced in an open source fashion, \nincluding editing and production. We owe GitHub a debt of grati¬ \ntude for making that sort of thing possible for the community! \n\nThank you again to all the countless folks I didn’t name but who I \nnonetheless owe thanks. May this book series be “owned” by all of us \nand serve to contribute to increasing awareness and understanding \nof the JavaScript language, to the benefit of all current and future \ncommunity contributors. \n\n\nAcknowledgments | 261 \n\n\n\nAbout the Author \n\n\nKyle Simpson is an Open Web Evangelist who’s passionate about all \nthings JavaScript. He’s an author, workshop trainer, tech speaker, \nand OSS contributor/leader.","metadata":{"loc":{"lines":{"from":232392,"to":232417}}}}]]